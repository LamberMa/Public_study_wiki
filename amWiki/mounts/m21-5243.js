if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m21']=[{"name":"01-运维工程师.md","path":"21-InterView/01-运维工程师.md","content":"# 运维工程师\n\n[TOC]\n\n\n\n\n\n## 协议\n\n**为什么TCP建立连接要三次握手，而不是两次，四次，描述一下三次握手的过程**\n\n\n\n## 基础应用\n\n### 计划任务\n\n- 每周一凌晨一点执行一次，查找/tmp/path下以A开头的所有文件并删除。\n\n- 添加后发现执行失败，但是当前用户直接执行是没有问题的，可能的原因是什么？\n\n  ```\n  环境变量\n  ```\n\n### 资源释放\n\n\n\n\n\n\n\n## Bash Script\n\n- 假设存在目录A，目录A下面有二级子目录若干，子目录中存在若干文件与目录。现在需要通过编程实现（Python或者Shell）生成目录B（结构目录同A），若二级子目录中叶子节点的数量大于2，那么随机复制两个文件到目标目录数。否则，直接复制文件到目标目录数。（目录A下面的子目录级别大于2，如：/A/B/C/D/E，B为二级子目录，C为三级子目录，D为四级子目录，E为五级子目录）\n\n## CI/CD\n\n### Jenkins比较常用的构建触发器有哪几种？\n\n```\n- Poll SCM Web hook\n- 周期性检查项⽬源码库，有更新即启动构建；\n- 通过 触发构建任务； 当指定的其他项⽬构建后进⾏构建；\n```\n\n- \n\n\n\n\n\n## 应用篇\n\n### Web \n\n#### 为什么说nginx比apache高效？高效在哪里？\n\n\n\n\n\n### Redis\n\n#### redis的缓存过期策略是什么？默认的是什么？\n\n```\n# 缓存过期策略，或者当达到设置的内存上限以后redis处理缓存的策略，有几个过期策略供你选择。生产环境中不要使用永不过期。\nnoeviction：永不过期，写不了就直接报错，但是可以读。\nvolatile-lru：使用LRU（最近最少使用）算法移除key，只对设置了过期时间的key，默认值\nallkeys-lru：使用LRU算法移除key\nvolatile-random：在过期集合中随机移除key，只对设置了过期时间的key\nallkeys-random：移除随机的key\nvolatile-ttl：移除那些ttl值最小的key，即那些最近要过期的key。\n\n# redis默认的策略就是永不过期，如果需要配置的话需要在配置文件中做如下修改。\nmaxmemory-policy volatile-lru\n```\n\n\n\n\n\n\n\n## Linux内核调优\n\n### 常见内核参数调优\n\n- net.ipv4.ip_forward=1：打开ip包转发的功能\n- net.ipv4.tcp_tw_recycle=1：回收TIME_WAIT连接的数量，但是一般不推荐在服务端开启，因为NAT环境会有问题。\n- net.ipv4.tcp_tw_reuse=1：重复使用TIME_WAIT状态的连接。\n- vm.swappiness=0：表示最大限度的使用武力内存，然后才是swap空间，swappiness=100表示几级的使用swap分区，并且把内存上的数据及时的搬运到swap空间的里面。\n\n\n\n","timestamp":1542254452231},{"name":"02-Python.md","path":"21-InterView/02-Python.md","content":"# Python开发\n\n[TOC]\n\n\n\n## Basis\n\n### Python递归的最大深度\n\n```python\npython有一个默认的最大递归深度，网上测的都说在970~980左右，我自己用ipython测试会到2800多。其实这个递归深度是可以设置的，python设置默认一个递归深度是为了避免python栈溢出引发一些异常，如果真的需要很大的递归深度可以自己引入sys模块进行设置：\n\nimport sys\nsys.setrecursionlimit(10000)\n```\n\n\n\n\n\n## OOP\n\n### python的自省有几种？\n\n```\n自省是一种自我检查的行为，在python中，自省是检查某种事物以确定它是什么，它知道什么，它能做什么。换言之就是在python中你可以通过自省知道运行时候的对象类型。\n常见的我们说的反射，getattr，hasattr。python内部提供的dir()，type()，isinstance()，id()，help()，callable()；\n```\n\n### \\_\\_new\\_\\_和\\_\\_init\\_\\_有什么区别？\n\n```python\n- __init__是实例方法，__new__是静态方法\n- __new__是真正返回创建好的实例的方法，而__init__不返回，只用来作为对象内容的构造。\n- 只有在__new__返回一个cls的实例时，后面的__init__才能被调用\n- 当创建一个新势力的时候调用__init__，初始化一个实例的时候使用__init__\n\nps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚.\n```\n\n\n\n\n\n\n\n## Cookie&Session\n\n**session和cookie的实现原理？**\n\n```\nsession: 是服务端应⽤程序在服务器上记录⽤⼾当前会话数据，有效时间⽐较短，会话结束就销毁了；因为数据保存在服务端，因此可以认为比起cookie，session更为可靠，而且session的实现要依赖于cookie\n\ncookie: 是通过 http 响应头发送到⽤⼾浏览器端保存的，通常会设置⼀段时间内都有效；cookie通常用来保存用户数据，session_id，标记用户，设备；一般认为cookie是不可靠的，session是可靠地。\n```\n\n\n\n## 网络编程\n\n\n\n## Web开发\n\n### Django\n\n\n\n### Flask\n\n#### Flask框架的优势在于哪些？\n\n\n\n#### Flask第三方插件\n\n\n\n#### Flask内置功能依赖\n\n\n\n#### Flask中上下文管理流程以及和Django的比较？\n\n\n\n\n\n#### Flask中上下文管理主要涉及到了哪些相关的类？并描述这些类的作用\n\n\n\n### Toronado\n\n\n\n\n\n\n\n## 项目\n\n### CMDB\n\n**CMDB应该包含哪些重要的实体，以及包含的主要的字段**\n\n```\n- 业务板块：名称，负责人，域名\n- 应用：仓库地址，负责人，节点，构建命令，启动命令，日志路径；\n- 服务器/云主机 ：供应商，地域，机房，ip，cpu，mem，disk，bandwidth，计费方式；\n```\n\n\n\n## 开发规范\n\n### Restful\n\n#### 谈谈你对restful规范的理解\n\n\n\n\n\n#### DRF视图你都用过哪些基类？\n\n\n\n\n\n## 算法\n\n\n\n\n\n## 设计\n\n","timestamp":1542254452231},{"name":"03-DataBase.md","path":"21-InterView/03-DataBase.md","content":"# Mysql\n\n**delete和truncate的区别是什么？**\n\n```\n1、truncate和delete只删除表数据不删除表的定义，但是drop会删除掉表的结构被依赖的约束，触发器，索引；依赖这个表的存储过程和函数将会被保留，但是会变为invalid的状态。\n2、delete语句是数据库操作语言(DML)，这个操作会翻到rollback segement中，事物提交之后才生效；如果有相应的trigger，执行的时候将被处罚。\n3、truncate和drop的操作是立即生效的，原数据不放到rollback segement中，不能回滚，操作不触发trigger。\n4、delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动；drop 语句将表所占用的空间全部释放。truncate 语句缺省情况下将空间释放到 minextents个extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。\n5、速度来讲，drop最快，其次是truncate，最后是delete。\n6、安全性上来讲，小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及；使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.想删除表,当然用 drop；想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。\n7、delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。\n8、TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同：二者均删除表中的全部行。但TRUNCATE TABLE   比DELETE速度快，且使用的系统和事务日志资源少。DELETE语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 这是truncate比delete速度快的原因。\n9、TRUNCATE TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用DROP TABLE语句。 \n10、对于由外键约束引用的表，不能使用TRUNCATE TABLE，而应使用不带WHERE子句的DELETE语句。由于   TRUNCATE TABLE不记录在日志中，所以它不能激活触发器。  \n11、TRUNCATE   TABLE   不能用于参与了索引视图的表。\n```\n\n**加索引的逻辑**\n\n```\n什么情况下需要家索引？是开发和你说加哪个字段就加哪个字段么？需要给所有用的字段加索引么？\n1、首先索引不是加的越多就越好的，首先索引是要占用空间的。\n2、一个表的主键一般要建立索引。\n3、where子句中经常会用到的筛选条件应该添加索引，适用的还有group by，order by等；\n4、更新频繁的字段不适合创建索引。不会出现在where子句中的字段也不适合创建索引。\n5、当表数据过大的时候就应该加索引了，比如超过300条后加索引。\n6、索引应该建立在小字段上，占用空间小，而不应该建立在text字段等超长文本字段，索引效率会大大降低。\n7、复合索引的建立需要进行仔细分析，尽量考虑使用单字段索引代替：\n   ① 正确选择复合索引中的主列字段，一般是选择性较好的字段\n   ② 复合索引的字段是否经常同时以AND方式出现在where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；\n   ③ 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；\n   ④ 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；\n   ⑤ 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；\n```\n\n","timestamp":1542254452231}]