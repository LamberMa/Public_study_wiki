if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m02']=[{"name":"01-01、专业mysql部署.md","path":"02-02、DBA运维/01-1、Mysql/01-Mysql的部署/01-01、专业mysql部署.md","content":"# 专家级Mysql部署\n\n> 工欲善其事必先利其器，因此在玩转mysql之前一定要进行合理的Mysql的部署和优化，了解其启动原理等，本文针对Mysql的部署做分步骤的阐述和整理。\n\n## 1、软件准备\n\n目前oracle的mysql的最新的版本是mysql5.7.20.我们可以选择这一个版本进行安装，较旧版来说新版本修复了很多的bug信息，下载网站我们可以去mysql的[官方网站](https://dev.mysql.com)去寻找最新的安装包下载。\n\nMysql的安装方式不唯一，可以使用编译好的二进制包，可以使用cmake进行手动编译，亦或是yum，rpm方式的安装都是可以的，这里使用编译好的二进制包的方式进行部署。yum方式不做过多的赘述，如果需要了解cmake安装方式的请到第二篇文章查看。\n\n首先需要做的就是下载一个最新版本的符合自身系统的安装包：\n\n```shell\n[root@maxiaoyu opt]# ls\nmysql-5.7.20-linux-glibc2.12-x86_64.tar.gz\n```\n\n## 2、硬件环境的优化\n\n虚拟机或者云端的就不赘述，如果是物理机的还要在硬件和系统层面进行一些优化，因为机器在默认出厂的时候cpu和内存默认的都是节能模式，因此首要应该做的就是改成高性能模式。\n\n- 关闭numa\n  - [numa的取舍](http://www.cnblogs.com/yjf512/archive/2012/12/10/2811823.html)，可以查看这一篇文章对numa有一个简单的理解，Mysql属于那种既占用CPU又吃内存的应用，因此建议是关闭掉numa\n  - [如何关闭掉numa](http://www.dataguru.cn/thread-462113-1-1.html)，[numa特性禁用](http://www.cnblogs.com/wjoyxt/p/4804081.html).\n    - 硬件层：在bios设置中关闭掉\n    - OS层：在启动的时候设置关闭掉numa\n    - 可以用numactl命令将内存分配策略修改为interleave（交叉）\n\n在OS层我们可以设置启动的时候关闭，直接修改grub.conf文件即可：\n\n```shell\nvim /boot/grub/grub.conf\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-6/63141757.jpg)\n\n- 网络优化&/etc/security/limits.conf \n\n```shell\n[root@maxiaoyu opt]# ulimit -a \ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 7285\nmax locked memory       (kbytes, -l) 64\nmax memory size         (kbytes, -m) unlimited\nopen files                      (-n) 65535\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 7285\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n修改ulimit\n\n```shell\necho -e \'* soft nproc 65535\\n* hard nproc 65535\\n* soft nofile 65535\\n* hard nofile 65535\\n\' >> /etc/security/limits.conf\n```\n\n修改一些内核参数：\n\n```shell\n# 在/etc/sysctl.conf后面添加如下内容\nnet.ipv4.tcp_max_syn_backlog = 819200\nnet.core.netdev_max_backlog = 400000\nnet.core.somaxconn = 4096\nnet.ipv4.tcp_tw_reuse=1\nnet.ipv4.tcp_tw_recycle=0\n# 添加完成以后手动生效\nsysctl -p\n```\n\n同时有一个需要注意的是，如果你的机器是开启的多实例的话建议修改一下`max user processes`这个参数，这个参数我们可以在刚才的ulimit -a中查看到，或者我们可以使用ulimit -u去单独查看这个参数的值，那么这个值代表什么意思呢？\n\n这个ulimit -u是用来限制每个用户的最大processes数量。如果ulimit -u进行了限制那么每个linux用户可以派生出来的process就会被限制再这个数值之内。在mysql多实例的时候就很可能会受到这个参数的影响而导致根本无法链接，具体设置可以参考：http://blog.csdn.net/bbaiggey/article/details/51004817\n\n- Swap优化：直接禁用，现在的数据库独立服务器的配置普遍已经很高了，按照之前的一些说法，swap要分内存的1.5~2倍，如果遇到64gb或者128gb内存的情况下，分1.5~2倍其实是很不理智的一个选择，现在内存大多数情况已经够用，因此swap是可以直接禁用掉的，如果要分的话建议分配不超过4g。\n\n- IO优化：针对不同的盘使用不同的策略可以带来不同的优化效果。\n\n  查看对应的磁盘的IO调度策略可以通过如下的方式查看：\n\n  ```shell\n  [root@DBServer1 ~]# cat /sys/block/sda/queue/scheduler \n  noop anticipatory deadline [cfq]\n  ```\n\n  被括号括起来的就是当前的IO调度策略。那么对于不同的磁盘建议的调度策略如下：\n\n  - SAS：deadline\n  - SSD：noop\n\n- 文件系统：关于数据目录毫不犹豫的使用xfs格式的。\n\n- selinux和iptables：selinux建议禁掉，如果你的mysql完全跑内网，那么iptables可以也不用开\n\n  ​\n\n## 3、Mysql的安装\n\n> 基础环境优化完毕以后，就可以进行Mysql数据库的安装了。当然这里使用的是二进制安装包的方式进行安装，如果你使用rpm安装的话这一切都会自动的为你搞定，因为默认的配置都给你设置好了，缺点就是你没办法进行自定义的调整配置。\n>\n> 当然你也可以把rpm解包，重新做相应的脚本以及再次做rpm包。\n\n### 创建账户\n\n```shell\ngroupadd mysql\nuseradd -g mysql -d /usr/local/mysql -s /sbin/nologin -M mysql\nid mysql\n```\n\n### 软件基本安装\n\n```shell\nmkdir /opt/mysql\ncd /opt/mysql\ntar xf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz \ncd /usr/local\nln -s /opt/mysql/mysql-5.7.20-linux-glibc2.12-x86_64/ /usr/local/mysql5.7.20\nchown -R mysql.mysql mysql5.7.20/\n```\n\n### 数据目录创建\n\n```shell\ncd /data\nmkdir -p 3330/{data,logs,tmp}\n```\n\n### 配置文件准备\n\n```shell\n# 准备配置文件，你默认的也好，自定义的也好\n[root@maxiaoyu 3330]# pwd\n/data/3330\n[root@maxiaoyu 3330]# ls -l my.cnf\n-rw-r--r-- 1 root root 4014 Nov  6 11:58 my.cnf\n```\n\n### 初始化Mysql\n\n```mysql\n# 5.7的初始化方式\ncd /usr/local/mysql5.7.20/\n./bin/mysqld --defaults-file=/etc/my.cnf --initialize\n\n# 5.6,5.5,5.1的初始化方式\n./script/mysql_db_install\n./bin/mysql_db_install\n```\n\n### 启动\n\n```shell\n# 数据库这里可以设置开启自启，但是一般不建议这么做，如果出问题了，应该先排查问题然后再手动重启。\ncp support-files/mysql.server /etc/init.d/mysql\n/etc/init.d/mysql start\n\n# 设置开机自启的方式（不建议）\nchkconfig add mysql\n\n# 手工启动\n/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf &\n/usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &\n```\n\n### 检查错误日志查看是否正常\n\n启动起来以后还要修改环境变量，是否启动正常从以下几个角度排查\n\n- 起来以后确认进程在不在\n- 确认加载的配置文件对不对？\n- 看错误日志。查看有没有error信息\n\n### 链接数据库\n\n```shell\n# 默认第一次会生成一个随机密码，我们可以在errorlog里看到\ncat /data/mysql/mysql3306/data/error.log | grep password 看密码\nmysql -S /tmp/mysql3306.sock -p\n# 修改密码，这是必要的\n>alter user user() identified by \'new_pass\';\n```\n\n### 关闭数据库\n\n```shell\n# 利用系统脚本关闭\n/etc/init.d/mysql stop\n\n# 利用mysqladmin关闭，加上-h参数甚至可以关闭掉远端的mysql\nmysqladmin -S /tmp/mysql.sock -p shutdown\n\n# 在mysql5.7.19以后多了一个可以在mysql命令行直接打shutdown关闭的命令。\nmysql>shutdown;\n```\n\n## 4、Mysql安装过程中遇到的问题小结\n\n### 4.1、手贱授权错目录咋整\n\n前面提到了要给mysql的目录授权为属主是mysql，用户组也是mysql，假如说授权错误，比如直接授权给了根目录改咋整，这个时候一定不要退出，否则很可能你就再也登不上来了。具体问题可以参考Linux系统权限修复：http://www.cnblogs.com/xdxhg/p/6139818.html\n\n### 4.2、依赖缺失\n\n```shell\n# 查看库的依赖\n[root@DBServer1 ~]# ldd /home/mysql/db9018/bin/mysqld \n        linux-vdso.so.1 =>  (0x00007fffdd7ff000)\n        libpthread.so.0 => /lib64/libpthread.so.0 (0x0000003c4c800000)\n        librt.so.1 => /lib64/librt.so.1 (0x0000003c4cc00000)\n        libcrypt.so.1 => /lib64/libcrypt.so.1 (0x0000003c5aa00000)\n        libdl.so.2 => /lib64/libdl.so.2 (0x0000003c4c000000)\n        libstdc++.so.6 => /usr/lib64/libstdc++.so.6 (0x0000003c53000000)\n        libm.so.6 => /lib64/libm.so.6 (0x0000003c4d000000)\n        libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x0000003c52400000)\n        libc.so.6 => /lib64/libc.so.6 (0x0000003c4c400000)\n        /lib64/ld-linux-x86-64.so.2 (0x0000003c4bc00000)\n        libfreebl3.so => /lib64/libfreebl3.so (0x0000003c5ae00000)\n```\n\n### 4.3、Selinux没有关闭\n\n```shell\n# 临时关闭\nsetenforce 0 \n# 修改配置文件永久关闭，需重启\n[root@innerManager1 ~]# cat /etc/sysconfig/selinux \n\n# This file controls the state of SELinux on the system.\n# SELINUX= can take one of these three values:\n#     enforcing - SELinux security policy is enforced.\n#     permissive - SELinux prints warnings instead of enforcing.\n#     disabled - No SELinux policy is loaded.\nSELINUX=enforcing\n# SELINUXTYPE= can take one of these two values:\n#     targeted - Targeted processes are protected,\n#     mls - Multi Level Security protection.\nSELINUXTYPE=targeted \n\n将SELINUX=enforcing改为disabled即可\n```\n\n### 4.4、文件目录权限不对\n\n```shell\n# 如果出现permission denied的相关错误日志就要考虑一下是不是你的权限分配错误了？\nchown -R mysql.mysql /data/mysql\n```\n\n### 4.5、datadir非空\n\n当datadir不是空的时候，初始化会出现错误，因此确保初始化的时候datadir是空目录。\n\n### 4.6 磁盘空间不够\n\n```shell\ndf -h\n```\n\n### 4.7 初始化参数不对！\n\n参数写错了这个问题其实看似简单但是有时候操作者会有意无意的忽略掉，所以说对待这种问题的时候最好还是看看错误日志，可以立即打醒你。\n\n```shell\ncat /data/mysql/data/error.log | grep ERR\n```\n\n## 5、遇到问题该怎么处理？\n\n- 查看error.log\n\n大部分的日志错误都是可以在error.log中查看到的，直接去监控错误日志即可。\n\n- 把日志打开\n- 启动不起来的话利用mysqld手工启动一下查看\n- 利用strace再现一下启动过程\n\n```shell\n# 我们使用mysqld的方式去手动启动mysql\nstrace /usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf\n# strace的结果是很长的，但是我们需要看的内容并不是很多，记住以下的几个用法即可阅读\n- execve相当于调用系统外部命令的一个命令\n- mmap相当于把数据读取到内存里面\n- access是访问一个文件\n- open是打开一个文件\n- fstat查看文件状态\n\nexecve(\"/usr/local/mysql/bin/mysqld\", [\"/usr/local/mysql/bin/mysqld\", \"--defaults-file=/etc/my.cnf\"], [/* 18 vars */]) = 0\nbrk(0)                                  = 0x37bc000\nmmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f45615b7000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=79083, ...}) = 0\nmmap(NULL, 79083, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f45615a3000\nclose(3)                                = 0\n# 简单的来看一段，可以发现系统的一开始调用了我们的命令，将对应的内容映射到内存中去，然后访问了对应的so库文件，查看文件状态，映射到内存中，接下来的操作基本都是读取各种库文件       \n```\n\n通过strace还可以看到加载配置文件的过程（如果指定了defaults-file这个参数，只会读取指定的这个配置文件）：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-6/57224031.jpg)\n\n默认的配置文件的读取顺序：\n\n```shell\n[root@maxiaoyu 15:29:19 /root]\n#mysqld --verbose --help | grep my.cnf\n/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf \n# 可以看到如果没有指定配置文件的位置的话默认会从上面的四个位置读取配置文件。\n```\n\n查看加载表结构的过程：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-6/77738193.jpg)\n\nmysql5.7的io模型是基于poll的，当看到如下的字样的时候就代表mysql已经启动成功了\n\n```\npoll[{fd=33,events=POLLIN},{fd=36,events=POLLIN}],2,-1\n```\n\n### 5.1、查看报错代码的意思\n\n如果查看ERROR里面的code代码不知道什么意思的时候该如何处理？\n\n```shell\n[root@maxiaoyu 15:35:34 /root]\n#/usr/local/mysql/bin/perror 11\nOS error code  11:  Resource temporarily unavailable\n\n[root@maxiaoyu 15:35:58 /root]\n#/usr/local/mysql/bin/perror 13\nOS error code  13:  Permission denied\n\n[root@maxiaoyu 15:36:05 /root]\n#/usr/local/mysql/bin/perror 24\nOS error code  24:  Too many open files\n\n[root@maxiaoyu 15:36:12 /root]\n#/usr/local/mysql/bin/perror 27\nOS error code  27:  File too large\n\n[root@maxiaoyu 15:36:14 /root]\n#/usr/local/mysql/bin/perror 28\nOS error code  28:  No space left on device\n```\n\n\n\n","timestamp":1518081382541},{"name":"00-Mysql基础应用.md","path":"02-02、DBA运维/01-1、Mysql/02-MYSQL基本维护/00-Mysql基础应用.md","content":"# MySQL基础\n\n[TOC]\n\n## 日志\n\n- 日志可能会占用大量的磁盘空间\n- 现在部分日志可以存储在表里（现在不提倡使用）\n- 以文本格式写入日志（二进制日志除外）\n\n### **日志类型**\n\n- 错误日志\n- 慢查询日志\n- 常规日志\n- 二进制日志\n- 审计日志\n\n### **日志文件**\n\n| 日志文件 | 选项                                   | 文件名或表名称                     | 程序                            |\n| ---- | ------------------------------------ | --------------------------- | ----------------------------- |\n| 错误   | --log-error                          | host_name.err               | N/A                           |\n| 常规   | --general_log                        | host_name.log/general.log   | N/A                           |\n| 慢查询  | --slow_query_log & --long_query_time | host_name-slow.log/slow_log | mysqldumpslow/pt-query-digest |\n| 二进制  | --log-bin & --expire-logs-days       | host_name-bin.000001        | mysqlbinlog & binlog2sql      |\n| 审计   | --audit_log等                         | audit.log                   | N/A                           |\n| 中继   |                                      | host_name-relay.log         |                               |\n\n- 常规日志既会记录正确日志也会记录错误日志\n- long_query_time默认是10s，建议改成1s或者以下。慢日志分析推荐pt-query-digest\n- 一定要设置二进制日志的expire-logs-days，否则会被日志占满\n- relay-log的日志名字是和hostname有关的，不止relaylog，假如说更改了主机名，而且relay-log未定义，按照默认的走，改了主机名以后可能找不到对应命名的relay-log。\n\n查看mysql中和日志有关的变量：\n\n```mysql\nmysql> show global variables like \'%log%\';\n```\n\n其中的`log_queries_not_using_indexes`是可以不用开启的，因为小于1s的你用没用其实我也不用关心，你大于1s的即使你用了我毕业要想办法优化。\n\n还有就是log是可以定义到syslog中的，比如说用elk进行收集等等：\n\n```mysql\nlog_syslog                              | OFF   \nlog_syslog_facility                     | daemon\nlog_syslog_include_pid                  | ON    \nlog_syslog_tag                          |       \n```\n\n- relay_log_purge：relay-log被sql thread消耗完毕以后清除掉\n- relay_log_space_limit：这个参数默认是开启的，允许我们设置接受的relay-log的最大的大小，当relay-log超过设置的大小了以后就不再从master那边取了。因此这个参数不建议去使用。一般可用于磁盘紧张而且主从复制出现了大量延迟的时候避免被relay-log撑满磁盘空间可以使用这个参数。\n- general_log：默认是不开启的，如果想要开启可以`set global general_log = 1`不过这个参数一般也不会进行开启。可以用来排查问题或者在比较严格的环境做审计使用。\n\n**修改日志记录的时间：**\n\n```mysql\ntime_zone                       | SYSTEM \nsystem_time_zone                | CST \n```\n\n### 二进制日志\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-18/17887452.jpg)\n\n**二进制日志什么时间会刷新（切换）？**\n\n- 达到了系统定义的max_binlog_size\n- 运行了flush logs\n- 服务器重启\n\n在重启这里有一个要进行说明的，重启过程中mysql会去读取这些bin-log的文件名，只是读取文件名，然后根据文件名进行排序，获取最大的，然后在这个最大的序号基础上+1生成一个新的文件（不是根据mysqlbin.index文件产生的，单纯的是根据排序后的序号最大的+1产生的新文件），加入说binlog过多的话，比如上万个，这种情况下不管是开启还是关闭相对来说就会很慢，因此binlog的size要合理的进行设置，太小的话就会造成binlog文件过多的问题。默认的是1个G。用这个默认的设置其实就可以，不要太大也不要太小。\n\n那么mysqlbin.index是干什么用的？\n\n```mysql\nmysql> show binary logs;\n+----------------------+-----------+\n| Log_name             | File_size |\n+----------------------+-----------+\n| ecs-mysql-bin.000001 |    814133 |\n| ecs-mysql-bin.000002 |      1909 |\n| ecs-mysql-bin.000003 |       177 |\n| ecs-mysql-bin.000004 |       205 |\n| ecs-mysql-bin.000005 |       650 |\n+----------------------+-----------+\n13 rows in set (0.01 sec)\n```\n\n上面这一条命令是从index文件中读取的。\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-18/80515399.jpg)\n\n关于binlog_format：推荐使用row格式。\n\n**查询二进制日志文件**\n\n```mysql\nshow binary logs;\n# 列出当前的日志文件以及大小\n\nshow master status;\n# 显示mysql当前的日志以及状态（需要super，replication，client权限）\n\nshow binlog events in \'mysql-bin.000010\';\n# mysql的二进制日志是以‘事件（event）’为单位存储到日志中的。一个insert，update……由多个事件组成，比如：\n- GTID event\n- query event\n- table_map event\n- write_rows event\n- xid event\n可以截取事件日志的其中一部分看一下：\n\n| ecs-mysql-bin.000013 | 1009189 | Query     | 1 | 1009263 | BEGIN                          |\n| ecs-mysql-bin.000013 | 1009263 | Table_map | 1 | 1009321 | table_id: 461 (zabbix.sessions)|\n| ecs-mysql-bin.000013 | 1009321 | Write_rows| 1 | 1009406 | table_id: 461 flags: STMT_END_F|\n| ecs-mysql-bin.000013 | 1009406 | Xid       | 1 | 1009437 | COMMIT /* xid=620202 */        |\n针对DDL语句，没有query（begin），xid（commit），table_map这样得event。\n\n# 专业名称：日志文件：mysqlbin.000010，字节偏移量（位置），position，单位是字节。\nmysql> show master status;\n+----------------------+----------+--------------+------------------+-------------------+\n| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\n+----------------------+----------+--------------+------------------+-------------------+\n| ecs-mysql-bin.000013 |  1012070 |              |                  |                   |\n+----------------------+----------+--------------+------------------+-------------------+\n1 row in set (0.00 sec)\n\n[root@maxiaoyu 21:09:53 /data/mysql]\n#ll /data/mysql/ecs-mysql-bin.000013\n-rw-r----- 1 mysql mysql 1012070 Nov 18 20:18 /data/mysql/ecs-mysql-bin.000013\n\n# 可以看到和上面的master status中的position是一致的。\n```\n\n**查看二进制日志：**\n\n二进制日志是无法用文本查看的，日志以紧凑的二进制格式存储，以事件组合，可以使用工具mysqlbinlog来进行查看：\n\n```mysql\nmysqlbinlog -v --base64-output=decode-rows ecs-mysql-bin.000013 | less\n```\n\n其中mysqlbinlog有几个比较重要的参数，比如：\n\n- --start-position\n- --stop-position\n- --start-datetime=name\n- --stop-datetime-name\n- --stop-never\n\n**二进制日志维护：**\n\n基于时间删除二进制日志\n\n```mysql\nset global expire_logs_days=7;\n\npurge binary logs before now() -interval 3 days;\nPURGE BINARY LOGS BEFORE \'2008-04-02 22:46:26\';\n# 如果忘了purge的使用方法，可以在mysql命令行中直接help purge;\n```\n\n根据文件名删除：\n\n```mysql\n# 把mysql-bin.000010之前的日志都干掉。\npurge binary logs to \'mysql-bin.000010\';\n```\n\n那么使用purge删除的话会保证主从复制所有数据都传递到从库？当然，这个是不能保证的。因此purge之前要确保日志都传递到从库了（确认方法可以在主库flush logs然后去从库看看有没有传递过去）。还有就是使用purge删除的话会把mysqlbin.index中的也删掉，这个是rm做不到的，因此不建议使用rm进行删除binlog，不过一定要使用rm删除的话，记得在数据库里使用purge调用一下。\n\n### 审计日志\n\n审计日志是官方的一个收费组件，需要购买企业版。\n\n- 基于策略的日志记录：\n  - 通过audit_log_policy选项设置\n  - 提供日志记录选项ALL、NONE、LOGINS或QUERIES，默认为ALL\n\n在日志文件中生成一个服务器活动审计的记录：\n\n- 内容取决于策略，可能包括：\n  - 在系统上发生的错误的记录\n  - 客户机链接和断开的链接的时间\n  - 客户机在连接期间执行的操作\n  - 客户机访问的数据库和表\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-18/45961731.jpg)\n\n## DBA运维常用命令总览\n\n### 认识information_schema数据库\n\n> 学习利用information_schema的字典信息生成语句，information_schema相当于Mysql的中央信息库。\n\n**模式和模式对象**\n\n服务器的统计信息（状态变量，设置，链接），该库不持久化，属于“虚拟数据库”，不可更改，即使是root也干不掉。我们在物理的datadir下是找不到这个数据库的，可以通过select访问。\n\n#### Information_schema重要对象\n\n比如当我们想统计哪些库中有哪些表的时候，我们就可以这样去访问：\n\n```mysql\nmysql> select table_name from information_schema.tables where table_schema=\'information_schema\' order by table_name;\n```\n\n查看库中的表和表引擎：\n\n```mysql\nmysql> select table_name,engine from information_schema.tables where table_schema=\'wordpress\';\n+----------------------------+--------+\n| table_name                 | engine |\n+----------------------------+--------+\n| mxyblog_commentmeta        | MyISAM |\n| mxyblog_comments           | MyISAM |\n| mxyblog_hermit             | MyISAM |\n| mxyblog_hermit_cat         | MyISAM |\n| mxyblog_links              | MyISAM |\n| mxyblog_ngg_album          | MyISAM |\n| mxyblog_ngg_gallery        | MyISAM |\n| mxyblog_ngg_pictures       | MyISAM |\n| mxyblog_options            | MyISAM |\n| mxyblog_postmeta           | MyISAM |\n| mxyblog_posts              | MyISAM |\n| mxyblog_term_relationships | MyISAM |\n| mxyblog_term_taxonomy      | MyISAM |\n| mxyblog_termmeta           | MyISAM |\n| mxyblog_terms              | MyISAM |\n| mxyblog_usermeta           | MyISAM |\n| mxyblog_users              | MyISAM |\n+----------------------------+--------+\n17 rows in set (0.00 sec)\n```\n\n查看mysql系统默认的字符集和校对集：\n\n```mysql\nmysql> select character_set_name,collation_name from information_schema.collations where is_default=\'Yes\';\n```\n\n查看每个库的表统计\n\n```mysql\nmysql> select table_schema,count(*) from information_schema.tables group by table_schema;\n+--------------------+----------+\n| table_schema       | count(*) |\n+--------------------+----------+\n| carbon             |       23 |\n| emlog              |       15 |\n| gogs               |       36 |\n| information_schema |       61 |\n| mysql              |       31 |\n| performance_schema |       87 |\n| sys                |      101 |\n| wordpress          |       17 |\n| zabbix             |      127 |\n+--------------------+----------+\n9 rows in set (0.00 sec)\n```\n\n常见用法-语句拼合生成(可以结合into outfile使用)：\n\n```mysql\nmysql> select concat(\"mysqldump -uroot -pxxxx\",\" \",table_schema,\" \",table_name,\">\",table_schema,\".\",table_name,\".bak.sql\") from information_schema.tables where table_name like \"mxyblog_%\"; \n```\n\n### show核心语句(help show)\n\n- show databases\n- show tables;/show tables from db_name;\n- show columns from db_name.tb_name;\n- show full columns from db_name.tb_name;\n- show processlist\n- show create table table_name\n- show index from table_name\n- show open tables;\n- show table status;\n\n####  show还支持like和where使用\n\n- show databases like \'mxyblog_%\';\n- show columns from zst where \'Default\' is null\n- show character set;\n- show collation;\n\n## Mysql的目录结构\n\n首先先来看一下data目录下都有什么内容：\n\n```shell\n[root@maxiaoyu 11:57:18 /data/mysql]\n#ls -lh\ntotal 186M\n-rw-r----- 1 mysql mysql    56 Jun 16 12:08 auto.cnf\n-rw------- 1 root  root   1.7K Jun 16 12:10 ca-key.pem\n-rw-r--r-- 1 root  root   1.1K Jun 16 12:10 ca.pem\n-rw-r--r-- 1 root  root   1.1K Jun 16 12:10 client-cert.pem\n-rw------- 1 root  root   1.7K Jun 16 12:10 client-key.pem\n-rw-r----- 1 mysql mysql 1005K Nov 19 11:22 ecs-mysql-bin.000013\n-rw-r----- 1 mysql mysql    23 Nov 18 21:36 ecs-mysql-bin.index\n-rw-r----- 1 mysql mysql   830 Nov  6 15:22 ib_buffer_pool\n-rw-r----- 1 mysql mysql   76M Nov 19 10:52 ibdata1\n-rw-r----- 1 mysql mysql   48M Nov 19 10:52 ib_logfile0\n-rw-r----- 1 mysql mysql   48M Aug 28 15:42 ib_logfile1\n-rw-r----- 1 mysql mysql   12M Nov 19 11:26 ibtmp1\n-rw-r----- 1 mysql mysql  113K Nov  6 14:41 maxiaoyu.err\n-rw-r----- 1 mysql mysql     6 Nov  6 15:23 maxiaoyu.pid\n-rw-r----- 1 mysql mysql  4.3K Nov  6 15:23 maxiaoyu-slow.log\ndrwxr-x--- 2 mysql mysql  4.0K Jun 16 12:08 mysql\ndrwxr-x--- 2 mysql mysql  4.0K Jun 16 12:08 performance_schema\n-rw------- 1 root  root   1.7K Jun 16 12:10 private_key.pem\n-rw-r--r-- 1 root  root    451 Jun 16 12:10 public_key.pem\n-rw-r--r-- 1 root  root   1.1K Jun 16 12:10 server-cert.pem\n-rw------- 1 root  root   1.7K Jun 16 12:10 server-key.pem\ndrwxr-x--- 2 mysql mysql   12K Jun 16 12:08 sys\n```\n\n- auto_cnf下存放的是server的uuid\n\n  ```mysql\n  [root@maxiaoyu 11:57:21 /data/mysql]\n  #cat auto.cnf \n  [auto]\n  server-uuid=7e40a68a-5249-11e7-94f1-00163e06bd3d\n  ```\n\n- ib_buffer_pool：insert buffer pool\n\n- ibdata1：整体的一个数据字典文件，Innodb表的元数据；变更缓冲区；双写缓冲区；撤销日志。ibdata1存储的内容可以参考[为什么mysql里的ibdata1文件不断的增长](https://linux.cn/article-5829-1.html)\n\n- ib_logfile0：redo文件，建议最少设置成3~5个。\n\n- ibtemp1：临时表文件\n\n**使用mysql_config查找对应的库位置：**\n\n```shell\n$sudo /usr/local/mysql/bin/mysql_config\nUsage: /usr/local/mysql/bin/mysql_config [OPTIONS]\nCompiler: GNU 4.4.4\nOptions:\n        --cflags         [-I/usr/local/mysql/include ]\n        --cxxflags       [-I/usr/local/mysql/include ]\n        --include        [-I/usr/local/mysql/include]\n        --libs           [-L/usr/local/mysql/lib -lmysqlclient -lpthread -lm -lrt -ldl]\n        --libs_r         [-L/usr/local/mysql/lib -lmysqlclient -lpthread -lm -lrt -ldl]\n        --plugindir      [/usr/local/mysql/lib/plugin]\n        --socket         [/tmp/mysql.sock]\n        --port           [0]\n        --version        [5.7.18]\n        --libmysqld-libs [-L/usr/local/mysql/lib -lmysqld -lpthread -lm -lrt -lcrypt -ldl -laio]\n        --variable=VAR   VAR is one of:\n                pkgincludedir [/usr/local/mysql/include]\n                pkglibdir     [/usr/local/mysql/lib]\n                plugindir     [/usr/local/mysql/lib/plugin]\n```\n\n**mysql对应的插件目录（比如半同步）**：\n\n```shell\n/usr/local/mysql/lib/plugin\n```\n\n**帮助手册：**\n\n如果说系统的帮助手册man不到mysql的话我们可以手动拷贝一下mysql安装目录中的man手册到系统下，这样就可以实现使用系统man查看帮助手册了：\n\n```shell\ncp /usr/local/mysql/man/man* /usr/local/share/man -r\n```\n\n**share目录**\n\nshare目录保存的是一些字符集，以及一些初始化用的sql。 \n\n**bin目录：**\n\n- mysqld\n- mysql\n- mysqldump\n- mysqlbinlog\n- mysqladmin\n- mysql_config_editor：配合--login-path使用\n- perror：展示错误代码\n- mysqlslap：做mysql的性能测试\n\n**性能测试工具：**\n\n- sysbench1.1\n- mysql-tpcc：使用percona版本\n- YCSB：雅虎的，可以适配多种数据库 & NOSQL\n- fio：磁盘性能监测\n\n***\n\n如果说遇到数据库整库打包迁移后域名解析错误该怎么办？\n\n```shell\n# 这种问题可以借助sql自带的resolveip来反解析一下看看对不对\n\n[lamber@maxiaoyu 12:59:52 /usr/local/mysql/bin]\n$./resolveip 47.94.132.15\nHost name of 47.94.132.15 is maxiaoyu, blog.dcgamer.top\n\n# 如果说不对的话可以使用strace来看一下\n$strace ./resolveip 47.94.132.15 \n```\n\n***\n\n安装percona-tools\n\n\n\nmysqlbinlog统计：\n\nhttps://github.com/wubx/mysql-binlog-statistic\n\n### Mysql的5.7的SYS库\n\n","timestamp":1518081382541},{"name":"01-Mysql用户账户维护.md","path":"02-02、DBA运维/01-1、Mysql/02-MYSQL基本维护/01-Mysql用户账户维护.md","content":"# Mysql用户维护\n\n账户管理的重要性\n\n- 在mysql中可以通过账户控制允许或者不允许用户执行操作\n- 可以精细分配不同的权限给不同职能的账户\n- 避免使用root账户\n  - 应用不能直接使用root\n  - 防止维护期间出错\n- 限定特定权限账户确保数据的完整性\n  - 允许特定授权账户完成期工作\n  - 阻止未经授权的用户访问超出其特权的数据\n\n在root上可以做一些限制的操作：\n\n```mysql\nupdate mysql.user set user=\'xroot\' where user=\'root\';\nflush privileges;\n```\n\n## 账户管理\n\n查看mysql账户\n\n```mysql\n# mysql 5.6及以前版本\nselect user,host,password from mysql.user;\n# 在初始化数据库以后要删除掉匿名账户(在5.7中会自动执行这条命令)\ndelete from mysql.user where user!=\'root\' or localhost!=\'localhost\';\n\n# mysql 5.7及以后\nmysql root@localhost:(none)> select user,host,authentication_string from mysql.user;\n```\n\nmysql的账户验证现在大多验证使用mysql_native_password这个plugin，在mysql验证的时候使用以下三个要素：\n\n- 用户名\n- 主机所属范围（主机来源）\n- 用户密码\n\n查看用户授权有两个函数，一个是user()另外一个是current_user()\n\n```mysql\nmysql maxiaoyu@localhost:(none)> select user(),current_user();\n+--------------------+----------------+\n| user()             | current_user() |\n+--------------------+----------------+\n| maxiaoyu@localhost | maxiaoyu@%     |\n+--------------------+----------------+\n1 row in set\nTime: 0.006s\n```\n\n从上面的结果可以看到user函数是指的当前登录进来的用户和它的主机范围，current_user这个函数指的是授权的信息。\n\n用户连接和查询流程\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-17/7497028.jpg)\n\n和用户权限把控相关的主要是mysql库中的四张表，user表，db表以及columns_priv表，table_priv表。\n\n创建用户\n\n```mysql\ncreate user 用户名@主机 identified by \'密码\'\n# 这样创建的账号的只有链接权限，其他的啥都做不了\n# %通配，_表示匹配一个。\n```\n\n用户名建议8~16个字符，密码一般是16-32个字符，mysql域名最好在60个字符以内。我们可以使用mkpasswd去生成随机密码，也可以使用其他的方式。linux可以生成随机密码的方式有很多，可以选择自己喜欢的方式做为常用方式去升级。\n\n创建用户要注意的几个风险：\n\n- 不要创建没有用户名的账号\n- 不要创建没有密码的账号\n- 在可能的情况下主机限制那里不要使用通配符，尽量缩小范围。\n\n关于主机名的匹配是走最精确的，比如‘root’@\'192.168.%\'和‘root’@‘192.168.1.%’，它会去优先匹配后面这个，不看排序只看精确程度，或者这里我们可以通过通配符结合/etc/hosts来进行域名的解析数据库的登录。\n\n那么如何针对一个大范围内的部分主机IP进行限制呢？\n\n```mysql\n# 比如授权一个\ncreate user \'lamber\'@\'192.168.1.%\' identified by \'password\'\n\n# 我现在唯独想把192.168.1.100这个ip的不让他进行访问，那么我们就可以单独处理\ncreate user \'lamber\'@\'192.168.1.100\' identified by \'otherpasswd\'\n\n# 由于最精确匹配的原则，这个1.100ip的人的密码就是这个otherpasswd而不是password因此就会限制这个ip的用户的登录\n```\n\n使用password函数查看加密处理的authentication_string是什么：\n\n```mysql\nmysql maxiaoyu@localhost:mysql> select password(\'maxiaoyuhahaha\');\n+-------------------------------------------+\n| password(\'maxiaoyuhahaha\')                |\n+-------------------------------------------+\n| *92A2BE17BB2A1064C25BAE92A1AAFCF8B961B8C2 |\n+-------------------------------------------+\n1 row in set\nTime: 0.006s\n```\n\n有时候忘了密码还能猜猜，当然你如果是随机密码那就别这么玩了。。不过密码忘了有一种暴力修改的方式就是：\n\n```mysql\nupdate mysql.user set authentication_string=password(\'new_pass\') where user=\'current_user\';\nflush privileges;\n```\n\n在使用这个暴力方法的时候务必要加where的条件，要不然不这个系统上的所有mysql账户全部gg，而且修改完以后要刷一下缓存。上面这一种方法并不是官方推荐的方法，当然你也尽可能的不要去使用，手抖一下问题还是挺多的。除了使用上面的暴力方法还可以使用下面这种方法为用户修改密码：\n\n```mysql\nset password for \'maxiaoyu\'@\'%\'=password(\'new_pass\');\n```\n\n更好地修改方法：\n\n```mysql\nset password for \'maxiaoyu\'@\'%\'=\'hahahaha\'\n\n# 因为使用password函数的方法将会在后期的版本被移除，这个信息可以通过show warnings查看\nmysql maxiaoyu@localhost:mysql> show warnings\\G;\n***************************[ 1. row ]***************************\nLevel   | Warning\nCode    | 1287\nMessage | \'SET PASSWORD FOR <user> = PASSWORD(\'<plaintext_password>\')\' is deprecated and will be removed in a future release. Please use SET PASSWORD FOR <user> = \'<plaintext_password>\' instead\n```\n\n使用alter的方法去修改用户的密码：\n\n```mysql\nmysql maxiaoyu@localhost:mysql> alter user \'maxiaoyu\'@\'%\' identified by \'new_pass\';\nQuery OK, 0 rows affected\nTime: 0.001s\n```\n\n确认没有密码的用户（把没有密码的用户干掉）：\n\n```mysql\nselect user,host from mysql.user where password=\'\';\nselect user,host from mysql.user where authentication_string=\'\';\n```\n\n让用户口令失效，登录后必须修改密码（5.7使用，如果是5.5或者以前的话登录直接会报错）：\n\n```mysql\nalter user \'maxiaoyu\'@\'%\' passwird expire;\n```\n\n删除用户：\n\n```mysql\n# 直接删除该用户，从授权表中删除该用户的记录\ndrop user \'maxiaoyu\'@\'%\'\n\n# 如果不加主机名的话默认会删除主机名为%的记录\ndrop user \'maxiaoyu\'(drop user \'maxiaoyu\'@\'%\')\n```\n\n重命名用户：\n\n```mysql\n# 更改账号的名称，保留权限，可以更改：用户名和主机名部分\nrename user \'maxiaoyu\'@\'%\' to \'lamber\'@\'%\'\n```\n\n如果忘记了语法的使用可以使用help\n\n```mysql\nhelp create user\n```\n\n## 权限管理\n\n使用create创建的用户其实是什么权限都没有的，只能看到一个information_schema这么一个库，如果你要创建一个和root一样的权限的账号，可以参考root的权限，很重要的一点就是`with grant option`。\n\n合理的控制授权也是dba的重要责任之一，权限可以划分的很细致，主要从以下几个方面：\n\n- 全局级别\n- 数据库级别\n- 表级别\n- 列级别\n- 存储过程级别\n\n**只读用户**\n\n全局，数据库或者表级别权限，只用select\n\n**开发用户**\n\n业务库权限：insert、update、delete、select，call\n\n**管理用户**\n\n全局级别，权限：insert、update、delete、create、alter、drop、file(现在基本不用给这个权限了)、process、shutdown、super\n\n### 以下权限需要注意\n\nFILE：允许用户指示mysql服务器在服务器主机文件系统中读写文件，在mysql5.7中需要打开配置文件中的一个参数来配合：\n\n```mysql\n# file\n# @secure-file-priv=/tmp\n```\n\n如果需要文件权限就需要打开这个注释，不过5.7还是默认把这个给干掉了，因为漏洞还是挺多的。\n\nPROCESS：允许用户使用show processlist语句，这个是管理中常用的语句（如果show processlist显示内容过多的话可以使用[pager more](http://wubx.net/mysql-client-tips/)这个功能）\n\nSUPER：运行用户终止其他客户机的链接，或者更改服务器的运行时的配置，执行kill set shutdown\n\nALL：授予所有权限（但是不能向其他用户授予权限）\n\nGRANT ALL … WITH GRANT OPTION：授予所有特权，相当于root\n\n### 权限的授予与去除（grant and revoke）\n\nGRANT命令可以给现有的用户添加权限，如果用户不存在的话还可以创建用户\n\n```mysql\ngrant select,insert,update,delete on *.* to \'maxiaoyu\'@\'%\' identified by \'password\'\n```\n\nTips:\n\n- 多个权限使用逗号隔开，不区分大小写\n- 授权的对象\n  - 全局级别：\\*.\\*\n  - 数据库级别：dbname.\\*\n  - 表级别：db_name.table_name\n- 要创建或是授权的用户：\'username\'@\'hostname(IP/network)\'\n- 密码：可选\n\n查看账户的权限：\n\n```mysql\nshow grants;\nshow grants for current_user();\nshow grants for \'root\'@\'localhost\';\n```\n\n我们可以通过`show privileges`来查看mysql支持的权限：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-19/55799788.jpg)\n\n### 权限控制表\n\n|     表（MyISAM）     |       用处       |\n| :---------------: | :------------: |\n|    mysql.user     | 每个创建的用户在这里都有记录 |\n|     mysql.db      |  限制用户做用户特定的db  |\n| mysql.tables_priv |   用于表级别的权限控制   |\n| mysql.procs_priv  | 用户存储过程和函数权限控制  |\n\nMysql启动的时候从mysql库中把权限读取加载到内存中，如果通过DML更新权限表需要借助于flush privilegesl才能生效。*<u>特别需要注意的是：不要对权限表进行DML操作</u>*。\n\n#### 权限的revoke\n\n使用revoke语句撤销对用户的授权：\n\n```mysql\nrevoke delete,insert,update on world_innodb.* from \'maxiaoyu\'@\'%\'\nrevoke all privileges,grant option from \'maxiaoyu\'@\'%\';\n\n# revoke语法：\n# revoke关键字：指定要撤掉的特权列表。\n# on子句：只是要撤销特权的级别（全局级别的时候可以不用带）。\n# from子句：指定账户名称。\n```\n\n批量对部分表进行授权：\n\n```mysql\nmysql root@localhost:(none)> use information_schema\nYou are now connected to database \"information_schema\" as user \"root\"\nTime: 0.001s\nmysql root@localhost:information_schema> select concat(\'grant select on \',table_schema,\'.\',table_name,\" to \'testuser2\'@\'%\';\") from tables where table_schema=\'wordpress\' and table_name like \"mxy%\";\n+-------------------------------------------------------------------------------+\n| concat(\'grant select on \',table_schema,\'.\',table_name,\" to \'testuser2\'@\'%\';\") |\n+-------------------------------------------------------------------------------+\n| grant select on wordpress.mxyblog_commentmeta to \'testuser2\'@\'%\';             |\n| grant select on wordpress.mxyblog_comments to \'testuser2\'@\'%\';                |\n| grant select on wordpress.mxyblog_hermit to \'testuser2\'@\'%\';                  |\n| grant select on wordpress.mxyblog_hermit_cat to \'testuser2\'@\'%\';              |\n| grant select on wordpress.mxyblog_links to \'testuser2\'@\'%\';                   |\n| grant select on wordpress.mxyblog_ngg_album to \'testuser2\'@\'%\';               |\n| grant select on wordpress.mxyblog_ngg_gallery to \'testuser2\'@\'%\';             |\n| grant select on wordpress.mxyblog_ngg_pictures to \'testuser2\'@\'%\';            |\n| grant select on wordpress.mxyblog_options to \'testuser2\'@\'%\';                 |\n| grant select on wordpress.mxyblog_postmeta to \'testuser2\'@\'%\';                |\n| grant select on wordpress.mxyblog_posts to \'testuser2\'@\'%\';                   |\n| grant select on wordpress.mxyblog_term_relationships to \'testuser2\'@\'%\';      |\n| grant select on wordpress.mxyblog_term_taxonomy to \'testuser2\'@\'%\';           |\n| grant select on wordpress.mxyblog_termmeta to \'testuser2\'@\'%\';                |\n| grant select on wordpress.mxyblog_terms to \'testuser2\'@\'%\';                   |\n| grant select on wordpress.mxyblog_usermeta to \'testuser2\'@\'%\';                |\n| grant select on wordpress.mxyblog_users to \'testuser2\'@\'%\';                   |\n+-------------------------------------------------------------------------------+\n17 rows in set\nTime: 0.008s\n```\n\n## 禁用验证控制\n\n视频点：第四课：1小时23分\n\n\n\n\n\n\n\n\n\n","timestamp":1518081382541},{"name":"01-01、Mysql主从.md","path":"02-02、DBA运维/01-1、Mysql/03-MYSQL数据安全/01-01、Mysql主从.md","content":"hexdump -C mysql-bin.010100\n\n","timestamp":1518081382541},{"name":"02-02、Mysql备份.md","path":"02-02、DBA运维/01-1、Mysql/03-MYSQL数据安全/02-02、Mysql备份.md","content":"","timestamp":1518081382541},{"name":"05-05、Mysql高可用.md","path":"02-02、DBA运维/01-1、Mysql/03-MYSQL数据安全/05-05、Mysql高可用.md","content":"# Mysql常见高可用架构\n\n> 常见Mysql高可用大纲\n>\n> - 基于主从的高可用\n> - 基于DRBD+Heartbeat的高可用\n> - 官方推荐的Mysql NDB Cluster\n> - 基于PXC模型的高可用\n> - 基于Proxy模型的高可用\n> - Mysql 5.7 Group Replication高可用\n> - 基于多源复制高可用\n> - 自主实现mysql高可用\n> - 业界DB四层架构设计\n\n## 1、基于复制的高可用\n\n**传统的复制模型：**\n\n- statement\n- mixed\n- row\n\n如果你的mysql版本是5.6以上的话毫不犹豫的建议使用GTID+ROW的形式\n\n### 1.1、基于Keepalived实现主从故障切换\n\n\n\n### 1.2、基于MHA的高可用\n\n> 作者已经放弃了对mha的维护了\n\n\n\n### 1.3、基于DNS或介入服务的高可用\n\n","timestamp":1518081382541},{"name":"02-02、mysql基础操作.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/02-02、mysql基础操作.md","content":"# Mysql基础操作\n\n## 1、库操作，DDL\n\n### 1.1 创建（create）\n\ncreate database 库名 [库选项]\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-25/45809924.jpg)\n\n注意的问题：\n\n库选项，只有字符集，校对集的概念！每个库，会对应一个数据目录\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-25/30978819.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-25/91773687.jpg)\n\n默认的只有字符集，校对集的概念：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-25/9094061.jpg)\n\n其他需要注意的问题：\n\n- 关于创建名称大小写的问题，这个是跟着系统走的，看你操作是否大小写敏感，比如windows是大小写不敏感的，但是linux是敏感的，因此为了保持一致性，使用的时候要保持大小写敏感，从而保证系统的稳定运行\n\n- 你创建的库或者是表不能是关键字敏感的，比如下面的：\n\n  ```\n  mysql> create database order;\n  ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'order\' at line 1\n  ```\n\n  但是这并不是绝对的，我们只要告诉数据库我要创建的这是一个表名称就可以了，需要将名称用反引号引起来，就是数组1左侧的那个按键：\n\n  ```\n  mysql> create database `order`;\n  Query OK, 1 row affected (0.00 sec)\n  ```\n\n- 中文等都可以作为标识符（库名），需要同样反引号！（多字节字符，还需要注意字符集的问题），需要设置字符集为gbk，因为当前是在windows上。不然无法创建的。\n\n  ```\n  mysql> set names gbk;\n  Query OK, 0 rows affected (0.00 sec)\n\n  mysql> create database `小雨`;\n  Query OK, 1 row affected (0.04 sec)\n\n  mysql> show databases;\n  +--------------------+\n  | Database           |\n  +--------------------+\n  | information_schema |\n  | 小雨               |\n  | mysql              |\n  | order              |\n  | performance_schema |\n  | sys                |\n  | test               |\n  +--------------------+\n  7 rows in set (0.00 sec)\n  ```\n\n### 1.2 查询库\n\n```mysql\nshow databases;\nshow databases likes \'%_scheme\';   # 使用like可以实现通配符匹配\n=========================================\n可以使用通配符（通用匹配符，可以匹配多个字符）\n% 匹配任意字符的任意次数（包括0次）的组合！\n_ 匹配任意字符的一次！\nlike ‘x_y’;\nx1y xby xxy（可以）\nxy(不可以)\n通配符是与 like 关键字一起使用！\n=========================================\n```\n\n注意如需要匹配特定的通配符，则需要对通配符转义，使用反斜杠\\完成转义！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-25/55760220.jpg)\n\n**查看某一个库的定义**\n\n```mysql\nmysql> show create database mysql\\G;\n*************************** 1. row ***************************\n       Database: mysql\nCreate Database: CREATE DATABASE `mysql` /*!40100 DEFAULT CHARACTER SET latin1 */\n1 row in set (0.00 sec)\n\nERROR:\nNo query specified\n```\n\n### 1.3 修改库\n\nalter database 数据库名\n\n```\nmysql> alter database `小雨` charset gbk;\nQuery OK, 1 row affected (0.00 sec)\n```\n\n### 1.4 删除库\n\ndrop database 名字\n\n### 1.5 if not exist,if exist\n\n```mysql\n在  create  与 drop 时，创建和删除时，有两个额外的操作：\n \ncreate database if not exists\n如果不存在则创建\n \ndrop database if exists\n如果存在，则删除\n```\n\n### 1.6 查看警告状态\n\nshow warnings;   \n\n此命令可以查看警告项\n\n## 2、表操作\n\n### 2.1 创建，create table\n\n```mysql\ncreate table 表名 (\n字段的定义\n) [表选项];\n\n其中表名，一定先要确定数据库！因此一个典型的表名是由两部分组成：\n所在库.表名（库与表之间用“.”连接）\ntest.itcast       test库内itcast表\nitcast.stu         itcast库内的stu表\n但是我们可以设置默认数据库，如果不指定则使用默认数据库（当前数据库）\nuse 数据库名。选择默认数据库！\n在使用表名但是没有指明其所在数据库时，默认数据库才会起作用！\n\n比如：\n在itcast库内创建：\nuse itcast ; create table stu;\n或者\ncreate table itcast.stu\n```\n\n**关于字段**\n\n字段才是最终的数据的载体（与变量的概念是类似的，都是基本保存数据的），mysql的是强类型，字段的类型是固定的，提前定义好的！因此，在定义字段时，至少要字段名和字段类型！两种最基本的mysql数据类型（int， varchar,varchar必须指定最大长度字符为单位）varchar单位为字符数，一般是255.比如大葱，这就是两个字符，在UTF-8中就是占用6个字节。具体多少字节和字符集有关系。\n\n创建一个表的示例：\n\n```mysql\nmysql> create table test2 (\n        id int auto_increment,\n        name varchar(255),\n        sex char(16)\n        ) engine=innodb charset=utf8;\n        \nAbout auto_increment:\nauto_increment指的是自增列，这个列可以实现数据id自增，常用与表的id列。\n我们可以指定auto_increment的起始位置\n\nalter table table_name AUTO_INCREMENT=20;\n或者在创建的时候在engine后面跟一个auto_increment=xx也可以\n\n当然现在自增是一个一个的，我们可以为它设置步长，可以跳着增加。\nmysql自增步长是基于会话级别的，什么叫会话级别的，就是你当前打开一个mysql终端\n这就是建立了一个会话，针对当前有一个设置有一个默认的步长：\nmysql> show session variables like \'auto_increment%\';\n+--------------------------+-------+\n| Variable_name            | Value |\n+--------------------------+-------+\n| auto_increment_increment | 1     |\n| auto_increment_offset    | 1     |\n+--------------------------+-------+\n2 rows in set, 1 warning (0.00 sec)\n大家默认的步长都是1，每个会话的步长可以不一样，我们可以通过set命令\n\nmysql> set session auto_increment_increment=2;\nQuery OK, 0 rows affected (0.00 sec)\n当然退出重新登录就相当于一个新的会话了，之前的设置就没了。\n\n如果要设置所有人都一样的话也不是不可以，设置全局变量即可：\nmysql> set global auto_increment_increment=200;\nQuery OK, 0 rows affected (0.00 sec)\n当然服务器重启以后还是会重置，如果需要永久修改还是放到配置文件去吧。\n\n当然还有基于表级别的设置步长，给一个表单独设置步长。这个和会话就没关系了。\n```\n\n- 当然字段可以创建的时候就指定好，也可以后续的添加：\n\n```\nalter table table_name add column 字段定义 [字段位置]\n\neg:\nmysql> alter table test2 add column age int;\nQuery OK, 0 rows affected (0.91 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> desc test2;\n+-------+--------------+------+-----+---------+-------+\n| Field | Type         | Null | Key | Default | Extra |\n+-------+--------------+------+-----+---------+-------+\n| id    | int(11)      | YES  |     | NULL    |       |\n| name  | varchar(255) | YES  |     | NULL    |       |\n| sex   | char(16)     | YES  |     | NULL    |       |\n| age   | int(11)      | YES  |     | NULL    |       |\n+-------+--------------+------+-----+---------+-------+\n4 rows in set (0.00 sec)\n\n指定添加字段的位置，加在某一个字段后可以使用after，加在第一行可以使用first关键字：\nmysql> alter table test2 add column comment varchar(255) after sex;\nQuery OK, 0 rows affected (0.68 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> desc test2;\n+---------+--------------+------+-----+---------+-------+\n| Field   | Type         | Null | Key | Default | Extra |\n+---------+--------------+------+-----+---------+-------+\n| id      | int(11)      | YES  |     | NULL    |       |\n| name    | varchar(255) | YES  |     | NULL    |       |\n| sex     | char(16)     | YES  |     | NULL    |       |\n| comment | varchar(255) | YES  |     | NULL    |       |\n| age     | int(11)      | YES  |     | NULL    |       |\n+---------+--------------+------+-----+---------+-------+\n5 rows in set (0.00 sec)\n```\n\n### 2.2 查\n\n查看所有的表：\n\n```mysql\nmysql> show tables;\n+----------------+\n| Tables_in_test |\n+----------------+\n| test1          |\n| test2          |\n+----------------+\n2 rows in set (0.00 sec)\n```\n\n使用like进行模糊匹配：\n\n```mysql\nmysql> show tables like \'%es%\';\n+-----------------------+\n| Tables_in_test (%es%) |\n+-----------------------+\n| test1                 |\n| test2                 |\n+-----------------------+\n2 rows in set (0.02 sec)\n```\n\n查看建表的时候相关信息：\n\n```python\nmysql> show create table test1\\G;\n*************************** 1. row ***************************\n       Table: test1\nCreate Table: CREATE TABLE `test1` (\n  `id` int(11) DEFAULT NULL,\n  `name` varchar(255) DEFAULT NULL,\n  `sex` char(16) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n1 row in set (0.00 sec)\n```\n\n查询表结构\n\n```mysql\nmysql> desc test1;\n+-------+--------------+------+-----+---------+-------+\n| Field | Type         | Null | Key | Default | Extra |\n+-------+--------------+------+-----+---------+-------+\n| id    | int(11)      | YES  |     | NULL    |       |\n| name  | varchar(255) | YES  |     | NULL    |       |\n| sex   | char(16)     | YES  |     | NULL    |       |\n+-------+--------------+------+-----+---------+-------+\n3 rows in set (0.00 sec)\n```\n\n### 2.3 改\n\nalter命令进行修改的操作，alter table table_name 设置对应的字段值：\n\n```mysql\nmysql> alter table test1 engine=myisam charset=gbk;\nQuery OK, 0 rows affected (0.64 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> show create table test1\\G;\n*************************** 1. row ***************************\n       Table: test1\nCreate Table: CREATE TABLE `test1` (\n  `id` int(11) DEFAULT NULL,\n  `name` varchar(255) CHARACTER SET latin1 DEFAULT NULL,\n  `sex` char(16) CHARACTER SET latin1 DEFAULT NULL\n) ENGINE=MyISAM DEFAULT CHARSET=gbk\n1 row in set (0.00 sec)\n```\n\n表名称的修改\n\n```mysql\nrename table test1 to hahahal\n\nmysql> show tables;\n+----------------+\n| Tables_in_test |\n+----------------+\n| hahahal        |\n| test2          |\n+----------------+\n2 rows in set (0.00 sec) \n\n注意，表名可以由库名.表名形式的！因此，可以跨库修改表名：只要在表名前增加库名即可\n```\n\n针对字段的定义的修改：\n\n```mysql\nalter table table_name modify column column_name 新的定义！\n\neg:\nmysql> desc test2;\n+---------+--------------+------+-----+---------+-------+\n| Field   | Type         | Null | Key | Default | Extra |\n+---------+--------------+------+-----+---------+-------+\n| id      | int(11)      | YES  |     | NULL    |       |\n| name    | varchar(255) | YES  |     | NULL    |       |\n| sex     | char(16)     | YES  |     | NULL    |       |\n| comment | varchar(255) | YES  |     | NULL    |       |\n| age     | int(11)      | YES  |     | NULL    |       |\n+---------+--------------+------+-----+---------+-------+\n5 rows in set (0.00 sec)\n\nmysql> alter table test2 modify column id char(4) after age;\nQuery OK, 0 rows affected (0.79 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> desc test2;\n+---------+--------------+------+-----+---------+-------+\n| Field   | Type         | Null | Key | Default | Extra |\n+---------+--------------+------+-----+---------+-------+\n| name    | varchar(255) | YES  |     | NULL    |       |\n| sex     | char(16)     | YES  |     | NULL    |       |\n| comment | varchar(255) | YES  |     | NULL    |       |\n| age     | int(11)      | YES  |     | NULL    |       |\n| id      | char(4)      | YES  |     | NULL    |       |\n+---------+--------------+------+-----+---------+-------+\n5 rows in set (0.00 sec)\n```\n\n修改字段名称：\n\n```mysql\nalter table table_name change column 原字段名 新字段名 新字段定义！【选项】\n注意，不是纯粹的改名，而是需要在修改定义的同时改名！\n\nmysql> desc test2;\n+---------+--------------+------+-----+---------+-------+\n| Field   | Type         | Null | Key | Default | Extra |\n+---------+--------------+------+-----+---------+-------+\n| name    | varchar(255) | YES  |     | NULL    |       |\n| sex     | char(16)     | YES  |     | NULL    |       |\n| comment | varchar(255) | YES  |     | NULL    |       |\n| age     | int(11)      | YES  |     | NULL    |       |\n| id      | char(4)      | YES  |     | NULL    |       |\n+---------+--------------+------+-----+---------+-------+\n5 rows in set (0.00 sec)\n\nmysql> alter table test2 change column name username char(128) after sex;\nQuery OK, 0 rows affected (0.77 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> desc test2;\n+----------+--------------+------+-----+---------+-------+\n| Field    | Type         | Null | Key | Default | Extra |\n+----------+--------------+------+-----+---------+-------+\n| sex      | char(16)     | YES  |     | NULL    |       |\n| username | char(128)    | YES  |     | NULL    |       |\n| comment  | varchar(255) | YES  |     | NULL    |       |\n| age      | int(11)      | YES  |     | NULL    |       |\n| id       | char(4)      | YES  |     | NULL    |       |\n+----------+--------------+------+-----+---------+-------+\n5 rows in set (0.00 sec)\n```\n\n### 2.4 删\n\n- 直接删除表\n\n```mysql\ndrop table table_name;\n```\n\n- 删除字段\n\n```mysql\nalter table table_name drop column column_name;\n```\n\n## 3、数据操作\n\n### 3.1 增\n\ninsert into 表名 (字段列表) values (与字段相对的值列表)。不一定要一次性插入所有字段，或者按照原始的字段顺序插入，但是字段要与值的数量匹配。\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/38995012.jpg)\n\n如果数量不匹配的话就会报错：\n\n```mysql\nmysql> insert into test2 (sex,username,comment) values(\'male\');\nERROR 1136 (21S01): Column count doesn\'t match value count at row 1\n```\n\n当然如果要向所有的字段插入数据的话那么就可以省略字段直接添加values，同样的，要一一对应。\n\n```mysql\nmysql> insert into test2 values(\'male\',\'lamber\',\'test\',26,2);\nQuery OK, 1 row affected (0.11 sec)\n\nmysql> select * from test2;\n+------+----------+---------+------+------+\n| sex  | username | comment | age  | id   |\n+------+----------+---------+------+------+\n| male | lamber   | test    |   26 | 2    |\n+------+----------+---------+------+------+\n1 row in set (0.00 sec)\n\n也可以一条命令添加多条数据：\ninsert into test2 values(\'male\',\'lamber\',\'test\',26,2),(\'female\',\'testuser1\',\'test2\',27,1)……;\n多个数据之间都接在values后面用逗号隔开。\n```\n\n将A表里的数据插入到B表：\n\n```mysql\ninsert into tableB(name,age) select name,age from tableA\n```\n\n也是支持上面这种写法的。\n\n### 3.2 删\n\n- 清空表数据\n\n```mysql\ndelete from table_name;\ntruncate table table_name;\n\n说下二者的区别，truncate是要比delete from清空数据快的多的，DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 简单来说delete比较慢的原因是它是一行一行删的。\n\nTRUNCATE,DELETE,DROP放在一起比较：\nTRUNCATE TABLE：删除内容、释放空间但不删除定义。\nDELETE TABLE:删除内容不删除定义，不释放空间。\nDROP TABLE：删除内容和定义，释放空间。\n```\n\n- 删除详细数据就要结合where条件语句\n\n```mysql\ndelete from 表名 where 条件;\n关于条件，可以省略。表示永远为真。注意，删除是不可逆的。要避免没有条件的删除！\n\ndelete from t_name where id > 2; [> < != = or and]\n```\n\n### 3.3 改\n\nupdate操作\n\n```mysql\nupdate 表名 set 字段=新值, 字段n=新值n where 条件\n\neg:\nmysql> update test2 set name=\'shiyue2\' where name=\'shiyue\';\nQuery OK, 1 row affected (0.30 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nmysql> select * from test2;\n+----+---------+------+---------+\n| id | name    | age  | comment |\n+----+---------+------+---------+\n|  1 | lamber  |   26 | test1   |\n|  2 | shiyue2 |   23 | test2   |\n+----+---------+------+---------+\n2 rows in set (0.00 sec)\n```\n\n### 3.4 查\n\n`select 字段列表 from 表名 [where 条件表达式]`\n\n其中字段列表可以使用 * 表示所有字段！\n\n```mysql\nmysql> select * from test2;\n+----+--------+------+---------+\n| id | name   | age  | comment |\n+----+--------+------+---------+\n|  1 | lamber |   26 | test1   |\n|  2 | shiyue |   23 | test2   |\n+----+--------+------+---------+\n2 rows in set (0.00 sec)\n```\n\n关于条件表达式，默认是没有，表示永远为真！但是，很少出现没有条件的情况！为了突出，应该所有的语句都有查询条件！即使没有条件，我也强制增加一个 where 1;（1表示true）\n\n```mysql\nmysql> select * from test2 where id=2;\n+----+--------+------+---------+\n| id | name   | age  | comment |\n+----+--------+------+---------+\n|  2 | shiyue |   23 | test2   |\n+----+--------+------+---------+\n1 row in set (0.00 sec)\n```\n\n## 4、数据类型\n\n```mysql\nbit[(M)]\n二进制位（101001），m表示二进制位的长度（1-64），默认m＝1\n\ntinyint[(m)] [unsigned] [zerofill]\n小整数，数据类型用于保存一些范围的整数数值范围：\n有符号：-128 ～ 127.\n无符号：～ 255\n\n特别的： MySQL中无布尔值，使用tinyint(1)构造。\n\nint[(m)][unsigned][zerofill]\n整数，数据类型用于保存一些范围的整数数值范围：\n有符号：-2147483648 ～ 2147483647\n无符号：～ 4294967295\n\n特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为： 00002\n\nbigint[(m)][unsigned][zerofill]\n大整数，数据类型用于保存一些范围的整数数值范围：\n有符号：-9223372036854775808 ～ 9223372036854775807\n无符号：～  18446744073709551615\n\ndecimal[(m[,d])] [unsigned] [zerofill]\n准确的小数值，m是数字总个数，算上小数点前+小数点后面支持的总位数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。\n用法：decimal(10,5)\n特别的：对于精确数值计算时需要用此类型.decaimal能够存储精确值的原因在于其内部按照字符串存储。\n\nFLOAT[(M,D)] [UNSIGNED] [ZEROFILL]\n单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。\n无符号：\n-3.402823466E+38 to -1.175494351E-38,\n1.175494351E-38 to 3.402823466E+38\n有符号：\n1.175494351E-38 to 3.402823466E+38\n**** 数值越大，越不准确 ****\n\nDOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]\n双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。\n无符号：\n-1.7976931348623157E+308 to -2.2250738585072014E-308\n2.2250738585072014E-308 to 1.7976931348623157E+308\n有符号：\n2.2250738585072014E-308 to 1.7976931348623157E+308\n**** 数值越大，越不准确 ****\n\n\nchar (m)\nchar数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。char一上来就会开辟你指定的空间的大小。如果没有占满会填充空\nPS: 即使数据小于m长度，也会占用m长度\nvarchar(m)【节省空间，但是速度没有char快】\nvarchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。\n\n注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡。因此定长的往前放，变长的往后放。\n\ntext\ntext数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。\n\nmediumtext\nA TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.\n\nlongtext\nA TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters.\n\nenum，枚举类型：\nAn ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)\n示例：\nCREATE TABLE shirts (\n    name VARCHAR(40),\n    size ENUM(\'x-small\', \'small\', \'medium\', \'large\', \'x-large\')\n);\nINSERT INTO shirts (name, size) VALUES (\'dress shirt\',\'large\'), (\'t-shirt\',\'medium\'),(\'polo shirt\',\'small\');\n\nset\n集合类型\nA SET column can have a maximum of 64 distinct members.\n示例：\n    CREATE TABLE myset (col SET(\'a\', \'b\', \'c\', \'d\'));\n    INSERT INTO myset (col) VALUES (\'a,d\'), (\'d,a\'), (\'a,d,a\'), (\'a,d,d\'), (\'d,a,d\');\n\nDATE\n    YYYY-MM-DD（1000-01-01/9999-12-31）\n\nTIME\n    HH:MM:SS（\'-838:59:59\'/\'838:59:59\'）\n\nYEAR\n    YYYY（1901/2155）\n\nDATETIME\n\n    YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00/9999-12-31 23:59:59    Y）\n\nTIMESTAMP\n\n    YYYYMMDD HHMMSS（1970-01-01 00:00:00/2037 年某时）\n    \n二进制数据类型：\n二进制数据：TinyBlob、Blob、MediumBlob、LongBlob\n```\n\n### 4.1 针对枚举和set单独拿出来说一下\n\n#### 枚举\n\n需要在定义枚举类型时，列出哪些是可能的！意义在于：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/28981298.jpg)\n\n1. 限制可以插入值的可能性，不让你随便插入值。\n2. 速度快，比普通的字符串速度快！原因是枚举型是利用整数进行管理的，能够2个字节进行管理！每个值，都是一个整数标识，从第一个选项开始为1，逐一递增！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/91520219.jpg)\n\n管理时整数的形式，速度比字符串快！2 个字节，0-65535，因此可以有 65535个选项可以使用！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/19664276.jpg)\n\nTip：注意enum(\'obj1\',\'obj2\')里面的条目要用单引号引起来。\n\n#### 集合\n\n类似于 enum枚举，在定义时，也需要指定其已有值！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/4899381.jpg)\n\n与字符串相比，优势是：\n\n1. 也是采用整数进行管理的！采用位运算，从第一位开始为1,逐一x2！\n2. 每个集合类型8个字节，64位，因此可以表示64个元素！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/80926930.jpg)\n\n```\n注意：\n站在 mysql的角度，尽量多用枚举和集合！\n但是站在python操作mysql的角度，尽量少用！（兼容性差）\n```\n\n## 5、键和约束\n\n### 5.1 主键\n\n主键的用处：保持数据的唯一性。主键不能为空\n\n一张表只能有一个主键，但是并不代表一个主键只能代表一列，我们可以指定多列联合为一个主键：\n\n```mysql\ncreate table test(\nid int unsigned not null auto_increment,\nname varchar(255) not null,\nsex char(8),\ncontent text,\nprimary key(id,name)\n) engine=innodb default charset=utf8;\n```\n\n### 5.2 外键约束\n\n约束的作用，是用于保证数据的完整性或者合理性的工具!\n\n外键：foreign key，当前表内，指向其他表的主键的字段，称之为外键！\n\n外键约束：用于限制相关联的记录在逻辑上保证合理性的约束称之为外键约束！\n\n**约束，不是字段。**\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/39334644.jpg)\n\n这样每一次写所属班级的时候不用写班级的名字，直接写班级的id，一定的程度上节省了空间。同时约束可以保证数据的一致性，导致不会让你随便写个班级id导致实际的班级找不到。\n\n首先创建两个表，添加约束。\n\n```mysql\nmysql> use test;\nDatabase changed\n\ncreate table userinfo(\nuid int unsigned auto_increment primary key,\nname varchar(32),\ndepartment_id int unsigned,\nconstraint fk_user_depart foreign key (`department_id`) references department(`id`)\n# 添加约束   约束名称        外键    （约束可以添加多个，多个约束名字不一样即可）      \n) engine=innodb default charset=utf8;\n\n\ncreate table department(\nid int unsigned auto_increment primary key,\ntitle char(15)\n) engine=innodb default charset=utf8;\nQuery OK, 0 rows affected (0.31 sec)\n\n如果建表的时候没有加的话可以后续手动加上：\nmysql> alter table userinfo add constraint fk_user_depart foreign key (`department_id`) references department(`id`);\nQuery OK, 0 rows affected (1.11 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> show create table userinfo\\G;\n*************************** 1. row ***************************\n       Table: userinfo\nCreate Table: CREATE TABLE `userinfo` (\n  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `name` varchar(32) DEFAULT NULL,\n  `department_id` int(10) unsigned DEFAULT NULL,\n  PRIMARY KEY (`uid`),\n  KEY `fk_user_depart` (`department_id`),\n  CONSTRAINT `fk_user_depart` FOREIGN KEY (`department_id`) REFERENCES `department` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\n```\n\nTip：字段，键（key）用反引号引起来。\n\n被约束关联的表是无法直接删除的，比如上面图中的学生表里所属的班级表里的班级id，如果有一个外键在学生表里还有引用，那么这个班级就无法删除，必须把这个学生和这个班级id的关联取消才可以进行删除。\n\n外键的名字是不允许重复的，如果约束引用的表的主键是联合的，那么在设置约束的时候也可以设置多列。如果约束引用的表的主键不是联合主键是单列的就不可以使用这种方式了。\n\n```mysql\nCONSTRAINT `test` FOREIGN KEY (`id1`,`id2`) REFERENCES `department`(`d_id`,`s_id`) \n```\n\n## 6、索引\n\n> 索引的目标就是加速查找，比如书的目录\n>\n> - 约束不能重复（但是可以为空，但是主键不能为空）\n> - 加速查找\n\n建立索引最直观的就是加快访问速度，但是建立索引是会占用空间的，因此索引虽然加快了查找的速度但不是完全没有代价的。如果对索引进行滥用的话，虽然大大提高了查询速度，但是会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。\n\n### 6.1 普通索引\n\n添加普通索引：\n\n```mysql\n# 修改表结构添加索引\nmysql> alter table test add index idx_id (`id`);\nQuery OK, 0 rows affected (0.34 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> show create table test\\G;\n*************************** 1. row ***************************\n       Table: test\nCreate Table: CREATE TABLE `test` (\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) NOT NULL,\n  `sex` char(8) DEFAULT NULL,\n  `content` text,\n  PRIMARY KEY (`id`,`name`),\n  KEY `idx_id` (`id`)   # 我们添加的索引\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\n\n\n# 添加索引\nCREATE INDEX indexName ON table_name(column(前缀长度length)); \n\n# 建表的时候添加索引\nindex index_name (column(length))\n```\n\n删除索引\n\n```mysql\ndrop index index_name on table_name;\n```\n\n### 6.2 唯一索引\n\n唯一索引可以在创建的时候添加也可以在创建以后补加，唯一索引的索引列的值可以为空，但是必须唯一，如果是组合索引，那么组合索引的值必须唯一。\n\n- 创建的时候添加\n\n```mysql\nunique 索引名称 (索引字段)\n```\n\n- 创建后补加\n\n```mysql\nALTER TABLE `table_name` ADD UNIQUE index_name (`column`(length))  # length可以不写\nCREATE UNIQUE INDEX indexName ON table_name(username(length)) \n```\n\n***\n\n上面说到的是单列索引，当然索引和是多列的，称为组合索引。如果where判定条件有一个的话那么单列索引就足够了。\n\n>有四种方式来添加数据表的索引：\n>\n>- ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):  该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。\n>- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。\n>- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。\n>- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。\n\n查看表索引信息：\n\n```mysql\nmysql> show index from test\\G;\n```\n\n","timestamp":1518081382541},{"name":"03-03、关于索引.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/03-03、关于索引.md","content":"http://www.cnblogs.com/aspnethot/articles/1504082.html\n\nhttp://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html\n\nhttp://www.open-open.com/lib/view/open1370089357102.html\n\nhttp://www.cnblogs.com/dreamhome/archive/2013/04/16/3025304.html\n\nhttp://blog.csdn.net/xluren/article/details/32746183\n\n# 索引\n\n- 普通索引：加速查找\n\n\n- 主键索引：加速查找，不能为空，不能重复。\n- 唯一索引：加速查找，不能重复\n- 联合索引（组合索引）：多列组合成一个索引\n  - 联合主键索引\n  - 联合唯一索引\n  - 联合普通索引\n\n```python\n### 使用pymysql创建测试数据，插入200w条数据：\n表结构：\nmysql> desc user;\n+--------+------------------+------+-----+---------+----------------+\n| Field  | Type             | Null | Key | Default | Extra          |\n+--------+------------------+------+-----+---------+----------------+\n| id     | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| gender | char(16)         | NO   |     | NULL    |                |\n| age    | int(10) unsigned | NO   |     | NULL    |                |\n| name   | varchar(32)      | NO   |     | NULL    |                |\n+--------+------------------+------+-----+---------+----------------+\n\n# 模拟数据的Python脚本\n#!/usr/bin/python3.6\n# -*- coding: utf-8 -*-\n# author:maxiaoyu\nimport pymysql\nimport random\n\n# make a generator\ncreate_user = (x for x in range(2000000))\n\n# connect to the mysqld\nconn = pymysql.connect(host=\'192.168.171.10\',user=\'maxiaoyu\',password=\'13082171785\',database=\'indextest\')\n\n# tools to get data\ncursor = conn.cursor()\nprint(cursor.__dict__)\nsql = \"insert into user(gender,age,name) values(%s,%s,%s)\"\n\n\nfor user in create_user:\n    user_name = \'testuser\'+str(user)\n    cursor.execute(sql,(random.choice([\'male\',\'female\']),random.randint(1,100),user_name))\n    conn.commit()\n\n\ncursor.close()\nconn.close()\n```\n\n速度测试：\n\n```mysql\nmysql> select * from user where name=\'testuser1111232\';  \n+---------+--------+-----+-----------------+\n| id      | gender | age | name            |\n+---------+--------+-----+-----------------+\n| 1111237 | male   |   2 | testuser1111232 |\n+---------+--------+-----+-----------------+\n1 row in set (1.31 sec)\n\n\nmysql> select * from user where id=\'1111232\'; \n+---------+--------+-----+-----------------+\n| id      | gender | age | name            |\n+---------+--------+-----+-----------------+\n| 1111232 | female |  18 | testuser1111227 |\n+---------+--------+-----+-----------------+\n1 row in set (0.04 sec)\n```\n\n观察这个可以发现通过id查询的效率是非常高的仅有0.04s，但是通过name查找则会发现有1.31s。因为我们为id添加了主键索引了。\n\n> ##### 如何去理解索引：\n>\n> 索引可以理解为字典或者书的目录，我们可以认为计算机很笨，在没有索引的情况下它去翻阅一本字典取找一个字只能一页一页一行一行的从头翻到尾，如果要找的字在前面还好，如果要找到的字在最后那真的就是从头翻到尾了。\n>\n> 为了能够更好的查找数据我们添加了索引（index），其实也就是目录的意思，添加一个目录，我们没有必要去知道所有的内容，只看针对某一个字段或者某一部分的关键字就可以知道我们要找的内容在哪里。就好比可以根据拼音首字母，或者根据笔画去查，可以很快的根据索引定位到多少页。索引可以帮我们定位数据在表中的位置。当然创建索引（做目录的时候）也是需要一定的时间的，当数据量够大的时候会发现创建索引也是挺慢的。\n>\n> 当然就如大家所知道的，一本字典很厚，索引页也占用好几十页的空间，也就是说索引不是凭空的，而是真实的占用空间的，如果不恰当的使用索引就会导致索引的内容非常大，想想一下一本书，目录就占了半本，我为什么不直接去翻正文呢？\n\n创建普通索引的方法：\n\n```mysql\ncreate index name_index on user (name); \ncreate index 索引名     on 表 (column(length)……)\n```\n\n### 索引种类\n\n#### hash索引：索引表\n\n会把对应的列的数据转换成hash值放到一个表里，同时把对应的hash值对应的数据的存储地址也记录上。当对应的hash值被匹配到了以后就会直接去找这个数据所在的地址，然后通过游标直接跳过去即可。\n\n当然索引表是有一个缺陷的，在找**单值**的时候速度很快，但是如果去匹配一个条件，比如id>102321这样的就会比较慢了，因为索引表存储的索引信息其实是无序的。对于这样非单值的查找比如连续性的范围就很耗费时间了。\n\n#### BTree索引（innodb引擎）\n\n二叉树，具体二叉树相关内容请参考：\n\n\n\n建立索引：\n\n- 额外的文件保存特殊的数据结构\n- ​","timestamp":1518081382541},{"name":"04-04、mysql进阶.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/04-04、mysql进阶.md","content":"#  \n\n## 1、实体之间的关系\n\n多个是体表应该如何设计！\n\n### 实体之间存在哪些关系？\n\n```\n班级，学生两类实体！(一个班级对应多个学生实体，多个学生实体对应一个班级实体)\n一对多，多对一，1:N, N:1\n \n班级，讲师两类实体！（一个讲师可以在多个班级任教，反过来也是一样的。）\n多对多，M：N\n \n学生常用信息，学生不常用信息（学生与自己个人信息的肯定是一一对应的）\n一对一，1：1\n```\n\n### 如何设计？\n\n#### 多对一，一对多\n\n在多的那端（那个表内），增加一个字段，用于保存于当前记录相关联的一端记录的主键！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-27/92928316.jpg)\n\n#### 多对多\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-27/74244288.jpg)\n\n增加一个专门管理关联的表，使班级与讲师都与关连表存在联系。从而是两个实体间有多对多的关系！\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-27/81487.jpg)\n\n因此，一个多对多，会拆分成两个多对一！这里的班级id和讲师id都应该是foreign key，同时应该还应该做一个联合唯一，因为这种关系对应有一个就够了。\n\n### 一对一\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-27/54806190.jpg)\n\n可见，两个表之间存在相同的主键ID即可！也可以做外键+唯一约束。外键保证这个用户真实存在，唯一约束保证不为空且不重复。\n\n## 2、mysql语句扩展\n\n- 在查询的时候给字段起别名：\n\n```mysql\nmysql> desc test;\n+---------+------------------+------+-----+---------+----------------+\n| Field   | Type             | Null | Key | Default | Extra          |\n+---------+------------------+------+-----+---------+----------------+\n| id      | int(10) unsigned | NO   | PRI | NULL    | auto_increment |\n| name    | varchar(255)     | NO   | PRI | NULL    |                |\n| sex     | char(8)          | YES  |     | NULL    |                |\n| content | text             | YES  |     | NULL    |                |\n+---------+------------------+------+-----+---------+----------------+\n4 rows in set (0.00 sec)\n\n\nmysql> select name as testname,sex from test;\n+----------+--------+\n| testname | sex    |\n+----------+--------+\n| user1    | male   |\n| user2    | female |\n+----------+--------+\n2 rows in set (0.00 sec)\n```\n\n也可以在查询后加额外的一列，比如：\n\n```mysql\nmysql> select name,sex,123 from test;\n+-------+--------+-----+\n| name  | sex    | 123 |\n+-------+--------+-----+\n| user1 | male   | 123 |\n| user2 | female | 123 |\n+-------+--------+-----+\n2 rows in set (0.00 sec)\n\n那么这玩意有什么用呢？\n```\n\n### 2.1 查询深入\n\n```mysql\nselect * from table where id > 2\nselect * from table where id < 2\nselect * from table where id = 2\nselect * from table where id != 2\nselect * from table where id <> 2\nselect * from table where id > 2 and name=\'xxx\'\nselect * from table where id > 100 or id=30 or id=20 or id=40;\nselect * from table where id in (20,30,40)\nselect * from table where id in (select nid from table_name) # 子查询\nselect * from table where id not in (20,30,40)\nselect * from table where id between 6 and 12; # 这个锁定的范围是闭区间\nselect * from table limit 10; # 查看前10条\nselect * from table limit 0,2; # 从第一条开始取（位置），往后取两条（数量）\nselect * from table limit 20 offset 10; # 取20条，从第11个位置开始\n\n如何取到后10条？那么就先顺序倒过来，然后再limit 10就可以了。\n```\n\n### 2.2 排序（order by）\n\n```mysql\nselect * from table order by id desc; # 倒序\nselect * from table order by id asc;  # 正序\n\n# 当按照一列的规则进行排序的时候有可能有重复的，针对相同的这一些按照列2的规则排\nselect * from 表 order by 列1 desc,列2 asc\n```\n\n### 2.3 分组\n\n```mysql\n首先说说分组能干啥，比如有很多学生，他们都有自己所属的班级id，那么我只要：\nselect class_id,max(stu_id) from stu group by class_id=\'xxx\'\n就可以以班级id为标准把id一样的人分组给分出来,返回的结果重复的去掉。取出来的id去重复内容条目中的最大的。\n\n- max:取最大值\n- min：去最小值\n- count：取总数\n- sum：求和\n- avg：取平均值\n\nselect num from 表 group by num\nselect num,nid from 表 group by num,nid\nselect num,nid from 表  where nid > 10 group by num,nid order nid desc\nselect num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nid\n \nselect num from 表 group by num having max(id) > 10\n\n特别的：group by 必须在where之后，order by之前\n```\n\n### 2.4 表链接\n\n```mysql\n无对应关系则不显示\nselect A.num, A.name, B.name\nfrom A,B\nWhere A.nid = B.nid\n\n无对应关系则不显示\nselect A.num, A.name, B.name\nfrom A inner join B\non A.nid = B.nid\n\nA表所有显示，如果B中无对应关系，则值为null\nselect A.num, A.name, B.name\nfrom A left join B\non A.nid = B.nid\n\nB表所有显示，如果B中无对应关系，则值为null\nselect A.num, A.name, B.name\nfrom A right join B\non A.nid = B.nid\n```\n\n#### 2.4.1 简单连接\n\n```mysql\nmysql> select * from student;\n+----+--------+\n| id | name   |\n+----+--------+\n|  1 | 张三   |\n|  2 | 李四   |\n|  3 | 王二   |\n+----+--------+\n3 rows in set (0.00 sec)\n\nmysql> select * from course;\n+----+--------+\n| id | cname  |\n+----+--------+\n|  1 | 足球   |\n|  2 | 音乐   |\n|  3 | 美术   |\n+----+--------+\n3 rows in set (0.00 sec)\n```\n\n简单的表连接\n\n```mysql\nmysql> select * from student,course;\n+----+--------+----+--------+\n| id | name   | id | cname  |\n+----+--------+----+--------+\n|  1 | 张三   |  1 | 足球   |\n|  2 | 李四   |  1 | 足球   |\n|  3 | 王二   |  1 | 足球   |\n|  1 | 张三   |  2 | 音乐   |\n|  2 | 李四   |  2 | 音乐   |\n|  3 | 王二   |  2 | 音乐   |\n|  1 | 张三   |  3 | 美术   |\n|  2 | 李四   |  3 | 美术   |\n|  3 | 王二   |  3 | 美术   |\n+----+--------+----+--------+\n9 rows in set (0.00 sec)\n```\n\n可以看到简单的表连接是对两个表做了笛卡尔积。\n\n> 笛卡尔积：\n>\n> ![](http://omk1n04i8.bkt.clouddn.com/17-9-28/87001516.jpg)\n>\n> 依次做匹配，比如樱木给一个前锋位置给一个后卫位置，其他人同理。\n\n不过当然平常的情况下我们并不会这样去做，而是建立在某种条件的约束下进行表连接\n\n```mysql\nmysql> select * from student,course where student.id=course.id;\n+----+--------+----+--------+\n| id | name   | id | cname  |\n+----+--------+----+--------+\n|  1 | 张三   |  1 | 足球   |\n|  2 | 李四   |  2 | 音乐   |\n|  3 | 王二   |  3 | 美术   |\n+----+--------+----+--------+\n3 rows in set (0.00 sec)\n```\n\n当然上面这个例子很不合适，但是代表了是建立在某种约束下查询出来的。\n\n#### 2.4.2 Join连接\n\n>http://www.blogjava.net/GavinMiao/archive/2011/10/20/361640.html\n>\n>http://blog.163.com/xueling1231989@126/blog/static/102640807201231493651609/\n>\n>http://www.cnblogs.com/stone-d/p/7258340.html\n>\n>http://www.cnblogs.com/qiuqiuqiu/p/6442791.html\n>\n>http://blog.163.com/li_hx/blog/static/18399141320141127102622383/\n>\n>\n\n\n\nJoin连接类型，可分为三种：\n\n- 内连接（inner）\n- 外连接（outer）\n- 交叉连接（cross）\n\n##### 内连接\n\n\n\n\n\n内连接(INNER JOIN)使用比\n\n较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用\n\n的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。\n\n外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)\n\n和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹\n\n配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的\n\n数据行。\n\n交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的\n\n数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。\n\n连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑\n\n运算符等构成。\n\n无论哪种连接都不能对text、ntext和image数据类型列进行直接连接，但可以对这三种列进行间接\n\n连接。\n\n","timestamp":1518081382541},{"name":"07-07、SQL优化.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/07-07、SQL优化.md","content":"http://blog.csdn.net/hguisu/article/details/5731629","timestamp":1518081382541},{"name":"08-08、数据库优化.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/08-08、数据库优化.md","content":"","timestamp":1518081382541},{"name":"22-22、Mysql练习.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/22-22、Mysql练习.md","content":"# Mysql Exercise\n\n> 请创建如下表，并创建相关约束\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-26/59526112.jpg)\n\n1、自行创建测试数据\n\n```mysql\n/*\n Navicat Premium Data Transfer\n\n Source Server         : localhost\n Source Server Type    : MySQL\n Source Server Version : 50624\n Source Host           : localhost\n Source Database       : sqlexam\n\n Target Server Type    : MySQL\n Target Server Version : 50624\n File Encoding         : utf-8\n\n Date: 10/21/2016 06:46:46 AM\n*/\n\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n--  Table structure for `class`\n-- ----------------------------\nDROP TABLE IF EXISTS `class`;\nCREATE TABLE `class` (\n  `cid` int(11) NOT NULL AUTO_INCREMENT,\n  `caption` varchar(32) NOT NULL,\n  PRIMARY KEY (`cid`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n--  Records of `class`\n-- ----------------------------\nBEGIN;\nINSERT INTO `class` VALUES (\'1\', \'三年二班\'), (\'2\', \'三年三班\'), (\'3\', \'一年二班\'), (\'4\', \'二年九班\');\nCOMMIT;\n\n-- ----------------------------\n--  Table structure for `course`\n-- ----------------------------\nDROP TABLE IF EXISTS `course`;\nCREATE TABLE `course` (\n  `cid` int(11) NOT NULL AUTO_INCREMENT,\n  `cname` varchar(32) NOT NULL,\n  `teacher_id` int(11) NOT NULL,\n  PRIMARY KEY (`cid`),\n  KEY `fk_course_teacher` (`teacher_id`),\n  CONSTRAINT `fk_course_teacher` FOREIGN KEY (`teacher_id`) REFERENCES `teacher` (`tid`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n--  Records of `course`\n-- ----------------------------\nBEGIN;\nINSERT INTO `course` VALUES (\'1\', \'生物\', \'1\'), (\'2\', \'物理\', \'2\'), (\'3\', \'体育\', \'3\'), (\'4\', \'美术\', \'2\');\nCOMMIT;\n\n-- ----------------------------\n--  Table structure for `score`\n-- ----------------------------\nDROP TABLE IF EXISTS `score`;\nCREATE TABLE `score` (\n  `sid` int(11) NOT NULL AUTO_INCREMENT,\n  `student_id` int(11) NOT NULL,\n  `course_id` int(11) NOT NULL,\n  `num` int(11) NOT NULL,\n  PRIMARY KEY (`sid`),\n  KEY `fk_score_student` (`student_id`),\n  KEY `fk_score_course` (`course_id`),\n  CONSTRAINT `fk_score_course` FOREIGN KEY (`course_id`) REFERENCES `course` (`cid`),\n  CONSTRAINT `fk_score_student` FOREIGN KEY (`student_id`) REFERENCES `student` (`sid`)\n) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n--  Records of `score`\n-- ----------------------------\nBEGIN;\nINSERT INTO `score` VALUES (\'1\', \'1\', \'1\', \'10\'), (\'2\', \'1\', \'2\', \'9\'), (\'5\', \'1\', \'4\', \'66\'), (\'6\', \'2\', \'1\', \'8\'), (\'8\', \'2\', \'3\', \'68\'), (\'9\', \'2\', \'4\', \'99\'), (\'10\', \'3\', \'1\', \'77\'), (\'11\', \'3\', \'2\', \'66\'), (\'12\', \'3\', \'3\', \'87\'), (\'13\', \'3\', \'4\', \'99\'), (\'14\', \'4\', \'1\', \'79\'), (\'15\', \'4\', \'2\', \'11\'), (\'16\', \'4\', \'3\', \'67\'), (\'17\', \'4\', \'4\', \'100\'), (\'18\', \'5\', \'1\', \'79\'), (\'19\', \'5\', \'2\', \'11\'), (\'20\', \'5\', \'3\', \'67\'), (\'21\', \'5\', \'4\', \'100\'), (\'22\', \'6\', \'1\', \'9\'), (\'23\', \'6\', \'2\', \'100\'), (\'24\', \'6\', \'3\', \'67\'), (\'25\', \'6\', \'4\', \'100\'), (\'26\', \'7\', \'1\', \'9\'), (\'27\', \'7\', \'2\', \'100\'), (\'28\', \'7\', \'3\', \'67\'), (\'29\', \'7\', \'4\', \'88\'), (\'30\', \'8\', \'1\', \'9\'), (\'31\', \'8\', \'2\', \'100\'), (\'32\', \'8\', \'3\', \'67\'), (\'33\', \'8\', \'4\', \'88\'), (\'34\', \'9\', \'1\', \'91\'), (\'35\', \'9\', \'2\', \'88\'), (\'36\', \'9\', \'3\', \'67\'), (\'37\', \'9\', \'4\', \'22\'), (\'38\', \'10\', \'1\', \'90\'), (\'39\', \'10\', \'2\', \'77\'), (\'40\', \'10\', \'3\', \'43\'), (\'41\', \'10\', \'4\', \'87\'), (\'42\', \'11\', \'1\', \'90\'), (\'43\', \'11\', \'2\', \'77\'), (\'44\', \'11\', \'3\', \'43\'), (\'45\', \'11\', \'4\', \'87\'), (\'46\', \'12\', \'1\', \'90\'), (\'47\', \'12\', \'2\', \'77\'), (\'48\', \'12\', \'3\', \'43\'), (\'49\', \'12\', \'4\', \'87\'), (\'52\', \'13\', \'3\', \'87\');\nCOMMIT;\n\n-- ----------------------------\n--  Table structure for `student`\n-- ----------------------------\nDROP TABLE IF EXISTS `student`;\nCREATE TABLE `student` (\n  `sid` int(11) NOT NULL AUTO_INCREMENT,\n  `gender` char(1) NOT NULL,\n  `class_id` int(11) NOT NULL,\n  `sname` varchar(32) NOT NULL,\n  PRIMARY KEY (`sid`),\n  KEY `fk_class` (`class_id`),\n  CONSTRAINT `fk_class` FOREIGN KEY (`class_id`) REFERENCES `class` (`cid`)\n) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n--  Records of `student`\n-- ----------------------------\nBEGIN;\nINSERT INTO `student` VALUES (\'1\', \'男\', \'1\', \'理解\'), (\'2\', \'女\', \'1\', \'钢蛋\'), (\'3\', \'男\', \'1\', \'张三\'), (\'4\', \'男\', \'1\', \'张一\'), (\'5\', \'女\', \'1\', \'张二\'), (\'6\', \'男\', \'1\', \'张四\'), (\'7\', \'女\', \'2\', \'铁锤\'), (\'8\', \'男\', \'2\', \'李三\'), (\'9\', \'男\', \'2\', \'李一\'), (\'10\', \'女\', \'2\', \'李二\'), (\'11\', \'男\', \'2\', \'李四\'), (\'12\', \'女\', \'3\', \'如花\'), (\'13\', \'男\', \'3\', \'刘三\'), (\'14\', \'男\', \'3\', \'刘一\'), (\'15\', \'女\', \'3\', \'刘二\'), (\'16\', \'男\', \'3\', \'刘四\');\nCOMMIT;\n\n-- ----------------------------\n--  Table structure for `teacher`\n-- ----------------------------\nDROP TABLE IF EXISTS `teacher`;\nCREATE TABLE `teacher` (\n  `tid` int(11) NOT NULL AUTO_INCREMENT,\n  `tname` varchar(32) NOT NULL,\n  PRIMARY KEY (`tid`)\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n--  Records of `teacher`\n-- ----------------------------\nBEGIN;\nINSERT INTO `teacher` VALUES (\'1\', \'张磊老师\'), (\'2\', \'李平老师\'), (\'3\', \'刘海燕老师\'), (\'4\', \'朱云海老师\'), (\'5\', \'李杰老师\');\nCOMMIT;\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n表结构和数据\n```\n\n2、查询“生物”课程比“物理”课程成绩高的所有学生的学号；\n\n```mysql\nselect A.student_id from \n(select score.sid,score.student_id,course.cname,score.num from score LEFT JOIN course on score.course_id=course.cid where course.cname=\'生物\' ) as A\nINNER JOIN \n(select score.sid,score.student_id,course.cname,score.num from score LEFT JOIN course on score.course_id=course.cid where course.cname=\'物理\' ) as B\non A.student_id=B.student_id where A.num>B.num\n```\n\n3、查询平均成绩大于60分的同学的学号和平均成绩； \n\n```mysql\nselect temp.student_id,student.sname,temp.number from (select student_id,avg(num) as number from score  GROUP BY student_id having number > 60) as temp LEFT JOIN student on temp.student_id=sid;\n```\n\n4、查询所有同学的学号、姓名、选课数、总成绩；\n\n```mysql\nselect score.student_id,student.sname,count(score.student_id),sum(score.num) from score LEFT JOIN\nstudent on score.student_id=student.sid\nGROUP BY score.student_id\n```\n\n5、查询姓“李”的老师的个数；\n\n```mysql\nselect * from teacher where t_name like \'李%\';\n```\n\n6、查询没学过“叶平”老师课的同学的学号、姓名；\n\n```mysql\nselect student.sid,student.sname from student where sid not in (\nselect student_id from score where score.course_id  in \n(select cid from course LEFT JOIN teacher on course.teacher_id=teacher.tid where tname=\'李平老师\')\nGROUP BY student_id\n)\n```\n\n7、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；\n\n```mysql\nselect student_id,student.sname as count from score \nLEFT JOIN student on score.student_id=student.sid\nwhere course_id=1 or course_id=2 GROUP BY student_id HAVING count(student_id) > 1\n```\n\n8、查询学过“叶平”老师所教的所有课的同学的学号、姓名；\n\n```mysql\nselect score.student_id,student.sname from score \nLEFT JOIN student on score.student_id=student.sid\nwhere course_id in \n(select cid from course \nLEFT JOIN teacher on \ncourse.teacher_id=teacher.tid WHERE teacher.tname=\'李平老师\')\nGROUP BY student_id having COUNT(course_id) = \n(select count(cid) from course \nLEFT JOIN teacher on \ncourse.teacher_id=teacher.tid WHERE teacher.tname=\'李平老师\')\n```\n\n9、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；\n\n```mysql\nselect A.student_id,student.sname from \n(select * from score LEFT JOIN course on score.course_id=course.cid where course.cid=1) as A\nINNER JOIN\n(select * from score LEFT JOIN course on score.course_id=course.cid where course.cid=2) as B\non A.student_id=B.student_id\nLEFT JOIN student on A.student_id=student.sid\nwhere A.num > B.num\n```\n\n10、查询有课程成绩小于60分的同学的学号、姓名；\n\n```mysql\nselect student.sid,student.sname from score\nLEFT JOIN student on student.sid=score.student_id\nwhere score.num < 60\nGROUP BY sid\n\n或者使用distinct\n\nselect DISTINCT student.sid,student.sname from score\nLEFT JOIN student on student.sid=score.student_id\nwhere score.num < 60\n\n但是distinct效率并不是很高，能少用就少用。\n```\n\n11、查询没有学全所有课的同学的学号、姓名；\n\n```mysql\n-- 以后要么count主键，要么就count1\nselect student_id,student.sname as count_num from score\nLEFT JOIN student on score.student_id=student.sid\nGROUP BY student_id\nHAVING count(1) < (select count(1) from course)\n```\n\n12、查询至少有一门课与学号为“001”的同学所学相同的同学的学号和姓名；\n\n```mysql\n-- 假如001学了3门课程，只要001学过的任何一门课程我学过，那么我就是符合条件的。\nselect student_id,sname from score \nLEFT JOIN student on score.student_id=student.sid\nwhere student.sid <> 1 and score.course_id in\n(select course.cid from score \nLEFT JOIN course on score.course_id=course.cid\nwhere student_id=1)\nGROUP BY student_id\n```\n\n13、查询至少学过学号为“001”同学所有课的**其他同学**学号和姓名；\n\n```mysql\nselect student_id,sname from score \nLEFT JOIN student on score.student_id=student.sid\nwhere student.sid <> 1 and score.course_id in\n(select course.cid from score \nLEFT JOIN course on score.course_id=course.cid\nwhere student_id=1)\nGROUP BY student_id \nhaving count(1)=(select count(score.course_id) from score where student_id = 1)\n```\n\n14、查询和“002”号的同学学习的课程完全相同的其他同学学号和姓名；\n\n```mysql\n-- 先把和002选择个数一样的，再把不在002选择课程内的剔除\nselect student_id,sname from score LEFT JOIN student on score.student_id=student.sid\nwhere student_id in \n(select student_id from score where student_id <> 1 GROUP BY student_id HAVING count(1) = (select count(1) from score where student_id=1))\nand course_id in (select course_id from score where student_id=1)\nGROUP BY student_id HAVING count(1) = (select count(1) from score where student_id=1)\n```\n\n15、删除学习“李平”老师课的SC表记录；\n\n```mysql\nDELETE from score where score.course_id in \n(select cid from course LEFT JOIN teacher on course.teacher_id=teacher.tid where tname=\'李平老师\')\n```\n\n16、向Score表中插入一些记录，这些记录要求符合以下条件：①没有上过编号“002”课程的同学学号；②插入“002”号课程的平均成绩； \n\n```mysql\ninsert into score(student_id,course_id,num)\nselect student_id,2,(select avg(num) from score where course_id=2) from score where course_id!=2\n```\n\n17、按平均成绩从低到高显示所有学生的“语文”、“数学”、“英语”三门的课程成绩，按如下形式显示： 学生ID,语文,数学,英语,有效课程数,有效平均分；\n\n```mysql\nselect \n   student_id as \'学生ID\',\n   (select num from score as s2 where s2.student_id=s1.student_id and course_id=1) as \'语文\',\n   (select num from score as s2 where s2.student_id=s1.student_id and course_id=2) as \'数学\',\n   (select num from score as s2 where s2.student_id=s1.student_id and course_id=3) as \'英语\'\nfrom score as s1;\n```\n\n18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分；\n\n```mysql\nselect course_id,max(num),min(num) from score GROUP BY course_id\n\n假如说要求最低分小于10的就显示0那么可以写成如下的：\nselect course_id,max(num),min(num),case when min(num)<10 then 0 else min(num) end from score GROUP BY course_id\n```\n\n19、按各科平均成绩从低到高和及格率的百分数从高到低顺序；\n\n```mysql\nselect course_id,AVG(num),sum(case when num<60 then 0 else 1 end),sum(1),sum(case when num<60 then 0 else 1 end)/sum(1) as jigelv from score GROUP BY course_id ORDER BY avg(num) asc,jigelv desc\n```\n\n20、课程平均分从高到低显示（显示任课老师）；\n\n```mysql\nselect score.course_id,course.cname,avg(IF(ISNULL(score.num),0,score.num)),teacher.tname from score \nLEFT JOIN course on score.course_id=course.cid \nLEFT JOIN teacher on teacher.tid=course.teacher_id\nGROUP BY score.course_id order by avg(num) desc\n\n# 三目运算符，如果score.num为null的话（也就是范围为true，那么给个默认值为0.否则为score.num）\n```\n\n21、查询各科成绩前三名的记录:(不考虑成绩并列情况) \n\n```mysql\n\n```\n\n22、查询每门课程被选修的学生数；\n\n```mysql\nselect course_id, count(1) from score group by course_id;\n```\n\n23、查询出只选修了一门课程的全部学生的学号和姓名；\n\n```mysql\nselect student_id,sname,count(1) as num from score \nLEFT JOIN student on score.student_id=student.sid\nGROUP BY student_id having num=1\n```\n\n24、查询男生、女生的人数；\n\n```mysql\nselect gender,count(1) from student group by gender\n```\n\n25、查询姓“张”的学生名单；\n\n```mysql\nselect sname from student where sname like \'张%\';\n```\n\n26、查询同名同姓学生名单，并统计同名人数；\n\n```mysql\nselect sname,count(1) as count from student group by sname;\n```\n\n27、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列；\n\n```mysql\nselect course_id,avg(if(isnull(num), 0 ,num)) as avg from score group by course_id order by avg asc,course_id desc;\n```\n\n28、查询平均成绩大于85的所有学生的学号、姓名和平均成绩；\n\n```mysql\nselect student_id,sname, avg(if(isnull(num), 0 ,num)) as avgnum from score left join student on score.student_id = student.sid group by student_id having avgnum > 85\n```\n\n29、查询课程名称为“数学”，且分数低于60的学生姓名和分数；\n\n```mysql\nselect student.sname,A.num from student join (\nselect student_id,num from score left join course on score.course_id = course.cid\nwhere cname=\'生物\' and num < 60\n) as A\non student.sid = A.student_id\n\n-- 或者\n\nselect student.sname,score.num from score\nleft join course on score.course_id = course.cid\nleft join student on score.student_id = student.sid\nwhere score.num < 60 and course.cname = \'生物\'\n```\n\n30、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名； \n\n```mysql\nselect * from score where score.student_id = 3 and score.num > 80\n```\n\n31、求选了课程的学生人数\n\n```mysql\n-- 1、\nselect count(c) from \n(\nselect count(student_id) as c from score group by student_id\n) as A\n\n-- 2、\nselect count(distinct student_id) from score\n```\n\n32、查询选修“张磊”老师所授课程的学生中，成绩最高的学生姓名及其成绩；\n\n```mysql\nselect sname,num from score\nleft join student on score.student_id = student.sid\nwhere score.course_id in \n(\nselect course.cid from course \nleft join teacher on course.teacher_id = teacher.tid \nwhere tname=\'张磊老师\'\n) order by num desc limit 1;\n```\n\n33、查询各个课程及相应的选修人数；\n\n```mysql\nselect course.cname,count(course_id) from score left join course\non score.course_id = course.cid\nGROUP BY course.cid\n```\n\n*34、查询不同课程但成绩相同的学生的学号、课程号、学生成绩；\n\n```mysql\nselect DISTINCT s1.course_id,s2.course_id,s1.num,s2.num from score as s1, score as s2 where s1.num = s2.num and s1.course_id != s2.course_id;\n```\n\n*35、查询每门课程成绩最好的前两名；\n\n```mysql\nselect score.sid,score.course_id,score.num,T.first_num,T.second_num from score left join\n(\nselect\n    sid,\n    (select num from score as s2 where s2.course_id = s1.course_id order by num desc limit 0,1) as first_num,\n    (select num from score as s2 where s2.course_id = s1.course_id order by num desc limit 1,1) as second_num\n    from\n        score as s1\n) as T\n    on score.sid =T.sid\n    where score.num <= T.first_num and score.num >= T.second_num\n```\n\n36、检索至少选修两门课程的学生学号；\n\n```mysql\nselect student_id from score group by student_id having count(student_id) > 1\n```\n\n37、查询全部学生都选修的课程的课程号和课程名；\n\n```mysql\n-- 找到学生的总数，哪一门课的成绩统计数=课程总数就证明，这门课所有人都学习了\nselect course_id,count(1) from score group by course_id having count(1) = (select count(1) from student);\n```\n\n38、查询没学过“叶平”老师讲授的任一门课程的学生姓名；\n\n```mysql\nselect student_id,student.sname from score\nleft join student on score.student_id = student.sid\nwhere score.course_id not in \n(\n-- 首先获取到\nselect cid from course left join teacher on course.teacher_id = teacher.tid where tname = \'张磊老师\'\n)\ngroup by student_id\n```\n\n39、查询两门以上不及格课程的同学的学号及其平均成绩；\n\n```mysql\nselect student_id,count(1) from score where num < 60 group by student_id having count(1) > 2\n```\n\n40、检索“004”课程分数小于60，按分数降序排列的同学学号；\n\n```mysql\nselect student_id from score where course_id = 4 and num < 60 order by num desc;\n```\n\n41、删除“002”同学的“001”课程的成绩；\n\n```mysql\ndelete from score where course_id = 1 and student_id = 2;\n```\n\n","timestamp":1518081382541},{"name":"24-24、视图.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/24-24、视图.md","content":"# 视图\n\n>视图是一个虚拟表（非真实存在），其本质是【根据SQL语句获取动态的数据集，并为其命名】，用户使用时只需使用【名称】即可获取结果集，并可以将其当作表来使用。\n\n临时表取一个别名，也是我们查询出来的，但是这个表并不是真实存在的。因此给某一个查询语句设置别名，日后方便使用，创建的这个别名的行为就是创建一个视图。别名也就是视图的名称。\n\n```mysql\n# 创建视图\ncreate view as v1 select * from student where sid>10;\n# 以后直接搜索视图就可以了\nselect * from v1\n```\n\n视图是虚拟的，动态的从真实表中读取出来放到内存中，因此视图不能增删改，这个是不允许的，而且如果数据源表进行了更改以后，视图结果也会跟着改变。\n\n修改视图：\n\n```mysql\n# 修改视图\nalter view view_name as new_sql\n# 删除视图\ndrop view view_name\n```\n\nTip：在开发中并不常用~开发中就直接写子查询，写在代码里","timestamp":1518081382541},{"name":"25-25、触发器.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/25-25、触发器.md","content":"# 触发器\n\n> 触发器在开发中也并不是很常用\n\n情境：用户注册，每注册一个插入用的同时要去日志表插入一条数据。针对这个问题，在程序级别上，可以分两步进行操作，用户注册的同时，分别向两个表里插入数据，当然这里也可以使用触发器。\n\n### 触发器创建基本语法\n\n```mysql\nBEFORE ：在xxx操作之前\nAFTER  ：在XXX操作之后\nFOR EACH ROW ：操作每一行的时候触发器就会执行一遍\n\n# 插入前\nCREATE TRIGGER tri_before_insert_tb1 BEFORE INSERT ON tb1 FOR EACH ROW\nBEGIN\n    ...\nEND\n\n# 插入后\nCREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROW\nBEGIN\n    ...\nEND\n\n# 删除前\nCREATE TRIGGER tri_before_delete_tb1 BEFORE DELETE ON tb1 FOR EACH ROW\nBEGIN\n    ...\nEND\n\n# 删除后\nCREATE TRIGGER tri_after_delete_tb1 AFTER DELETE ON tb1 FOR EACH ROW\nBEGIN\n    ...\nEND\n\n# 更新前\nCREATE TRIGGER tri_before_update_tb1 BEFORE UPDATE ON tb1 FOR EACH ROW\nBEGIN\n    ...\nEND\n\n# 更新后\nCREATE TRIGGER tri_after_update_tb1 AFTER UPDATE ON tb1 FOR EACH ROW\nBEGIN\n    ...\nEND\n```\n\n可以发现唯独查询的时候，没有触发操作。\n\n```mysql\ndelimiter //\ncreate trigger t1 before insert on student for each ROW\nBEGIN\n  INSERT into teacher(tname) values(\'hahaha\');\nEND //\ndelimiter ;\n\n# 语句中的触发语句用分号去分割，因此如果使用默认的分隔符，到END之前就会终止\n# 因此我们要使用delimiter先去指定其他的分隔符，比如指定//\n# 在执行完了以后还要将分隔符设置回来，不影响其他人使用\n```\n\n比如说触发器执行增删改操作的时候触发操作的数据要和用户增删改的数据关联，那么久需要用到如下的两个参数：\n\n- NEW：指的是新插入的数据，一整行\n- OLD：指的是即将删除的数据行\n\n针对insert和update操作的时候用到NEW，针对delete和update操作的时候用到OLD\n\n```mysql\ndelimiter //\nCREATE TRIGGER tri_after_insert_tb1 AFTER INSERT ON tb1 FOR EACH ROW\nBEGIN\n    IF NEW. num = 666 THEN\n        INSERT INTO tb2 (NAME)\n        VALUES\n            (\'666\'),\n            (\'666\') ;\n    ELSEIF NEW. num = 555 THEN\n        INSERT INTO tb2 (NAME)\n        VALUES\n            (\'555\'),\n            (\'555\') ;\n    END IF;\nEND//\ndelimiter ;\n\n# 可以直接讲NEW.column放到插入的values里作为插入的值。\n```\n\n删除触发器：\n\n```mysql\nDROP TRIGGER tri_after_insert_tb1;\n```\n\n使用触发器：\n\n```mysql\n# 触发器无法由用户直接调用，而知由于对表的【增/删/改】操作被动引发的。\ninsert into tb1(num) values(666)\n```\n\n\n\n","timestamp":1518081382541},{"name":"26-26、存储过程.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/26-26、存储过程.md","content":"","timestamp":1518081382541},{"name":"27-28、函数.md","path":"02-02、DBA运维/01-1、Mysql/05-SQL语法基础/27-28、函数.md","content":"# Mysql函数\n\n>\n\n如何使用内置函数？\n\n```mysql\n# select 函数名\nmysql> select CURDATE();\n+------------+\n| CURDATE()  |\n+------------+\n| 2017-10-13 |\n+------------+\n1 row in set (0.11 sec)\n```\n\n部分内置函数：\n\n```mysql\nCHAR_LENGTH(str)\n返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。\n对于一个包含五个二字节字符集, LENGTH()返回值为 10, 而CHAR_LENGTH()的返回值为5。\n\nCONCAT(str1,str2,...)\n字符串拼接\n如有任何一个参数为NULL ，则返回值为 NULL。\n\nCONCAT_WS(separator,str1,str2,...)\n字符串拼接（自定义连接符）\nCONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。\n\nCONV(N,from_base,to_base)\n进制转换\n例如：\n    SELECT CONV(\'a\',16,2); 表示将 a 由16进制转换为2进制字符串表示\n\nFORMAT(X,D)\n将数字X的格式写为\'#,###,###.##\',以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若D为0, 则返回结果不带有小数点，或不含小数部分。\n例如：\nSELECT FORMAT(12332.1,4); 结果为： \'12,332.1000\'\nINSERT(str,pos,len,newstr)\n        在str的指定位置插入字符串\n            pos：要替换位置起始位置\n            len：替换的长度\n            newstr：新字符串\n        特别的：\n            如果pos超过原字符串长度，则返回原字符串\n            如果len超过原字符串长度，则由新字符串完全替换\nINSTR(str,substr)\n        返回字符串 str 中子字符串的第一个出现位置。\n\n    LEFT(str,len)\n        返回字符串str 从开始的len位置的子序列字符。\n\n    LOWER(str)\n        变小写\n\n    UPPER(str)\n        变大写\n\n    LTRIM(str)\n        返回字符串 str ，其引导空格字符被删除。\n    RTRIM(str)\n        返回字符串 str ，结尾空格字符被删去。\n    SUBSTRING(str,pos,len)\n        获取字符串子序列\n\n    LOCATE(substr,str,pos)\n        获取子序列索引位置\n\n    REPEAT(str,count)\n        返回一个由重复的字符串str 组成的字符串，字符串str的数目等于count 。\n        若 count <= 0,则返回一个空字符串。\n        若str 或 count 为 NULL，则返回 NULL 。\n    REPLACE(str,from_str,to_str)\n        返回字符串str 以及所有被字符串to_str替代的字符串from_str 。\n    REVERSE(str)\n        返回字符串 str ，顺序和字符顺序相反。\n    RIGHT(str,len)\n        从字符串str 开始，返回从后边开始len个字符组成的子序列\n\n    SPACE(N)\n        返回一个由N空格组成的字符串。\n\n    SUBSTRING(str,pos) , SUBSTRING(str FROM pos) SUBSTRING(str,pos,len) , SUBSTRING(str FROM pos FOR len)\n        不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。\n\n        mysql> SELECT SUBSTRING(\'Quadratically\',5);\n            -> \'ratically\'\n\n        mysql> SELECT SUBSTRING(\'foobarbar\' FROM 4);\n            -> \'barbar\'\n\n        mysql> SELECT SUBSTRING(\'Quadratically\',5,6);\n            -> \'ratica\'\n\n        mysql> SELECT SUBSTRING(\'Sakila\', -3);\n            -> \'ila\'\n\n        mysql> SELECT SUBSTRING(\'Sakila\', -5, 3);\n            -> \'aki\'\n\n        mysql> SELECT SUBSTRING(\'Sakila\' FROM -4 FOR 2);\n            -> \'ki\'\n\n    TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str) TRIM(remstr FROM] str)\n        返回字符串 str ， 其中所有remstr 前缀和/或后缀都已被删除。若分类符BOTH、LEADIN或TRAILING中没有一个是给定的,则假设为BOTH 。 remstr 为可选项，在未指定情况下，可删除空格。\n\n        mysql> SELECT TRIM(\'  bar   \');\n                -> \'bar\'\n\n        mysql> SELECT TRIM(LEADING \'x\' FROM \'xxxbarxxx\');\n                -> \'barxxx\'\n\n        mysql> SELECT TRIM(BOTH \'x\' FROM \'xxxbarxxx\');\n                -> \'bar\'\n\n        mysql> SELECT TRIM(TRAILING \'xyz\' FROM \'barxxyz\');\n                -> \'barx\'\n\n部分内置函数\n```\n\n","timestamp":1518081382541},{"name":"09-01、数据库安装.md","path":"02-02、DBA运维/01-1、Mysql/09-01、数据库安装.md","content":"# Mysql的安装\n\n> 现在安装mysql有很多的方式，接下来分不同的平台进行说明。\n>\n> 安装包下载地址：\n>\n> https://dev.mysql.com/downloads/mysql/\n\n## 1-Windows\n\n### 1.1-Mysql Installer\n\n使用Mysql安装包的形式进行安装\n\n### 1.2-ZIP Archive\n\n使用已经打包好的内容进行安装。\n\n- 首先我把mysql的zip程序解压到了d:/mysql/下，在这个目录下创建一个data目录，当然现在这个data目录肯定是空的，啥都没有的。\n\n- 然后再命令行初始化数据库\n\n  ```mysql\n  D:\\mysql\\bin>mysqld -install                # 添加到windows系统服务\n  D:\\mysql\\bin>mysqld --initialise-insecure\n  ```\n\n  如果说你遇到下面这个报错的话说明你运行程序的权限是有问题的。这个时候我们只要以windows的administrator的权限去运行就可以了。这个其实和linux给一个道理，一般我们linux编译安装的时候都是用root，就算是不用root你也得用个sudo不~\n\n  ```\n  mysqld: Could not create or access the registry key needed for the MySQL application\n  to log to the Windows EventLog. Run the application with sufficient\n  privileges once to create the key, add the key manually, or turn off\n  logging for that application.\n  ```\n\n  解决方法很简单：打开cmd，右键使用管理员身份运行。然后再运行如上的这条初始化命令就好了。\n\n- 查看一下data目录下多了什么？\n\n  ```python\n  D:\\mysql\\data>dir\n   驱动器 D 中的卷是 workspace\n   卷的序列号是 F466-9ADB\n\n   D:\\mysql\\data 的目录\n\n  2017/09/25 周一  10:55    <DIR>          .\n  2017/09/25 周一  10:55    <DIR>          ..\n  2017/09/25 周一  10:55             7,552 DESKTOP-CH3QMNF.err\n  2017/09/25 周一  10:55        12,582,912 ibdata1\n  2017/09/25 周一  10:55               253 ib_buffer_pool\n  2017/09/25 周一  10:55        50,331,648 ib_logfile0\n  2017/09/25 周一  10:55        50,331,648 ib_logfile1\n                 5 个文件    113,254,013 字节\n                 2 个目录 138,721,185,792 可用字节\n  ```\n\n- 默认初始化以后密码为空的，mysql肯定是需要配置文件的，不过5.7.18版本后的配置文件就需要自己手动创建了。创建的内容文本如下，创建好了后保存为my.ini文件，移动到bin目录下：\n\n  ```\n  [client]\n  port=3306\n  default-character-set=utf8\n  [mysqld]\n  port=3306\n  character_set_server=utf8\n  basedir=D:\\mysql\n  datadir=D:\\mysql\\data\n  [WinMySQLAdmin]\n  D:\\mysql\\bin\\mysqld.exe\n  ```\n\n- 启动mysql服务，启动完成以后就可以链接了：\n\n  ```mysql\n  net start mysql       # 只有添加到windows的启动服务列表里才可以使用这条命令\n  关闭：\n  net stop mysql\n\n  # 链接mysql\n  mysql -uroot -p\n  ```\n\n新建用户：\n\n```\nmysql> create user \'lamber\'@\'localhost\' identified by \'13082171785\';\nQuery OK, 0 rows affected (0.00 sec)\n\n使用通配符的：\nmysql> create user \'testuser1\'@\'%\' identified by \'13082171785\';\nQuery OK, 0 rows affected (0.00 sec)\n\n授权：\ngrant select,insert on db_name.table_name to \'testuser1\'@\'%\'\n\n或者可以使用grant语句授权，省去创建用户的步骤而且直接把密码也给了：\nmysql> grant all privileges on *.* to \'lamber\'@\'%\' identified by \'13082171785\';\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n```\n\n## 2-Linux\n\n在Linux平台下可以使用cmake进行编译安装。\n\n### 2.1-编译安装\n\n- 准备包和环境依赖\n\n  ```mysql\n  # 首先安装初始环境所需要的包：\n  [root@db02 ~]# yum -y install ncurses-devel libaio-devel  \n  [root@db02 ~]# rpm -qa ncurses-devel libaio-devel       \n  ncurses-devel-5.7-4.20090207.el6.x86_64\n  libaio-devel-0.3.107-10.el6.x86_64\n  [root@db02 ~]# yum -y install cmake \n  [root@db02 log]# useradd mysql -s /sbin/nologin -M\n  [root@db02 log]# id mysql\n  uid=502(mysql) gid=502(mysql) groups=502(mysql)\n  # 切换到下载目录中去：\n  [root@db02 tools]# tar xf mysql-5.5.32.tar.gz \n  ```\n\n- 使用cmake进行编译，然后进行安装\n\n  ```shell\n  预编译：\n  [root@db02 mysql-5.5.32]# cmake . -DCMAKE_INSTALL_PREFIX=/application/mysql-5.5.32 \\\n  -DMYSQL_DATADIR=/application/mysql-5.5.32/data \\\n  -DMYSQL_UNIX_ADDR=/application/mysql-5.5.32/tmp/mysql.sock \\\n  -DDEFAULT_CHARSET=utf8 \\\n  -DDEFAULT_COLLATION=utf8_general_ci \\\n  -DEXTRA_CHARSETS=gbk,gb2312,utf8,ascii \\\n  -DENABLED_LOCAL_INFILE=ON \\\n  -DWITH_INNOBASE_STORAGE_ENGINE=1 \\\n  -DWITH_FEDERATED_STORAGE_ENGINE=1 \\\n  -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\n  -DWITHOUT_EXAMPLE_STORAGE_ENGINE=1 \\\n  -DWITHOUT_PARTITION_STORAGE_ENGINE=1 \\\n  -DWITH_FAST_MUTEXES=1 \\\n  -DWITH_ZLIB=bundled \\\n  -DENABLED_LOCAL_INFILE=1 \\\n  -DWITH_READLINE=1 \\\n  -DWITH_EMBEDDED_SERVER=1 \\\n  -DWITH_DEBUG=0\n  编译和安装：\n  make && make install & cd ..\n  ```\n\n- 创建数据目录进行初始化操作\n\n  ```shell\n  mkdir /data/3306/data        # 这个目录你自己按照自己的规划和需求整\n  find /data -type f -name mysql | xargs chmod +x    # 修改权限\n  ./scripts/mysql_install_db --basedir=/application/mysql/ --datadir=/data/3306/data/ --user=mysql                   # 初始化操作,加载mysql自身的库和表\n  ```\n\n- mysql启动，然后就可以进行连接了\n\n  ```shell\n   /data/3306/mysql start\n  ```\n\n#### =====编译安装过程中遇到的一些问题=====\n\n- 编译安装的过程中，cmake可能会报下面的错误\n\n  ```shell\n  -- Could NOT find Curses (missing:  CURSES_LIBRARY CURSES_INCLUDE_PATH)\n  CMake Error at cmake/readline.cmake:82 (MESSAGE):\n    Curses library not found.  Please install appropriate package,\n        remove CMakeCache.txt and rerun cmake.On Debian/Ubuntu, package name is libncurses5-dev, on Redhat and derivates it is ncurses-devel.\n  Call Stack (most recent call first):\n    cmake/readline.cmake:126 (FIND_CURSES)\n    cmake/readline.cmake:216 (MYSQL_USE_BUNDLED_LIBEDIT)\n    CMakeLists.txt:250 (MYSQL_CHECK_READLINE)\n  ```\n\n  解决办法：\n\n  ```shell\n  [root@localhost mysql-5.6.1]# rm CMakeCache.txt\n  [root@localhost mysql-5.6.1]# yum install ncurses-devel\n  [root@localhost mysql-5.5.11]# yum install bison\n  ```\n\n### 2.2-二进制tar.gz包解压直接使用\n\n二进制包的方式，都是已经编译好的，现成的东西，解压初始化以后就可以进行使用，多bb两句。\n\n>mysql5.7和之前的二进制包的部署方式有点小小的不一样。接下来呈现安装过程。\n\n\n1. 下载5.7的mysql安装包，这个破安装包竟然有600多m大，吓死人了。。\n```\nwget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-5.7.16-linux-glibc2.5-x86_64.tar.gz\n```\n2. 解压缩，移动到/application目录中\n```\ntar xf mysql-5.7.16-linux-glibc2.5-x86_64.tar.gz \nmkdir /application\n[root@nfs01 tools]# mv mysql-5.7.16-linux-glibc2.5-x86_64 /application/mysql-5.7.16\n[root@nfs01 tools]# cd /application/\n[root@nfs01 application]# ln -s /application/mysql-5.7.16/ /application/mysql\n[root@nfs01 application]# ll\ntotal 728\nlrwxrwxrwx. 1 root root     26 Feb  8 15:30 mysql -> /application/mysql-5.7.16/\ndrwxr-xr-x. 9 root root   4096 Feb  8 15:28 mysql-5.7.16\n```\n3. 数据库初始化\n\n\n```\nuseradd mysql -M -s /sbin/nologin \nmkdir /data/mysql\ncd /data/\nchown -R mysql.mysql mysql/\n./bin/mysqld --initialize --user=mysql --datadir=/data/mysql\n#在初始化的最后我们能看到这样一条日志信息\n2017-02-08T07:42:24.827356Z 1 [Note] A temporary password is generated for root@localhost: _p-2Abg:dqiU\n#这条日志信息的意思就是告诉你说，我们已经为root@localhost账户生成了一个临时的密码。这个密码就是_p-2Abg:dqiU，这个密码要先记下来，后面我们会用到\n[root@nfs01 mysql]# ./bin/mysql_ssl_rsa_setup --datadir=/data/mysql\nGenerating a 2048 bit RSA private key\n...+++\n....................................+++\nwriting new private key to \'ca-key.pem\'\n-----\nGenerating a 2048 bit RSA private key\n....................+++\n  ............+++\nwriting new private key to \'server-key.pem\'\n-----\nGenerating a 2048 bit RSA private key\n.........................................................+++\n........+++\nwriting new private key to \'client-key.pem\'\n-----\ncp support-files/my-default.cnf /etc/my.cnf\n[root@nfs01 mysql]# cp support-files/my-default.cnf /etc/my.cnf\n#修改我们的配置文件\n[root@nfs01 mysql]# vim /etc/my.cnf\nbasedir = /application/mysql\ndatadir = /data/mysql\nport = 3306\n# server_id = .....\nsocket = /tmp/mysql.sock\n#复制启动脚本\n[root@nfs01 mysql]# cp support-files/mysql.server /etc/init.d/mysqld\n[root@nfs01 mysql]# vim /etc/init.d/mysqld\nbasedir=/application/mysql\ndatadir=/data/mysql\n#启动mysql\n[root@nfs01 mysql]# /etc/init.d/mysqld start\nStarting MySQL. SUCCESS! \n#用我们刚才生成的临时密码登录进行修改密码的操作\n[root@nfs01 mysql]# /application/mysql/bin/mysql -uroot -p_p-2Abg:dqiU\nmysql> set password = password(\'redhat\');\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n#还有一种情况，就是不知道初始化密码\nvim /etc/my.cnf\n#在[mysqld]下面增加一行\nskip-grant-tables\n#重启  \n/etc/init.d/mysqld restart\n/usr/local/mysql/bin/mysql -uroot \nmysql> update mysql.user set authentication_string=password(\'123333\') where user=\'root\';\n#退出来后，更改my.cnf，去掉刚加的 skip-grant-tables\n#重启 \n/etc/init.d/mysqld restart\n\n此时就可以使用新的密码了。\n```\n4. 排错\n  如果说在启动过程中遇到了如下的报错的话：\n```\n[root@nfs01 mysql]# /etc/init.d/mysqld start\nStarting MySQL.... ERROR! The server quit without updating PID file (/data/mysql/nfs01.pid).\n```\n一般来讲，出现这个报错的原因大多是权限问题，去看一下你的目录权限吧，很可能你的sock文件无权限在你设定的文件夹中生成。\n\n### 2.3- Yum安装\n\nPass\n\n## Mac\n\n太穷，买不起mac，不做了\n\n![](http://omk1n04i8.bkt.clouddn.com/17-9-25/78130839.jpg)\n\n\n\n","timestamp":1518081382541},{"name":"23-23、innodb和myisam.md","path":"02-02、DBA运维/01-1、Mysql/23-23、innodb和myisam.md","content":"","timestamp":1518081382541},{"name":"24-24、mysql监控.md","path":"02-02、DBA运维/01-1、Mysql/24-24、mysql监控.md","content":"# Mysql的监控\n\n## 1、监控的意义\n\n- 监控更偏重于趋势分析\n  - 通过监控的数据展现了了解趋势增长情况\n  - 监控程序采集的数据指标也可以用当前DB的性能分析\n- 监控分为：\n  - 趋势分析类：zabbix，其他等\n  - 当前指标分析类：top，iostat，dstat，pt-ioprofile，mysqladmin\n    - dstat：一款由Python编写的脚本工具，可以去好好读读dstat的脚本，从中会有所收获的，下载地址如下：http://dstat.sourcearchive.com/\n    - pt-ioprofile：这是一个percona提供的工具，属于percona-tools中的一个工具。可以定义mysqld进程进行分析，分析哪个io调用比较高，它可以进行排序并显示出来。pt-ioprofile依赖strace，因此需要安装strace。percona-tools安装如下：\n\n\n\ngoogle也开源出来一个监控插件叫[cadvisor](https://github.com/google/cadvisor)，这个是用Go语言写的。\n\n## 2、常用监控工具\n\n### 2.1、top\n\n- user的cpu占用高，常常是因为索引不合理或者是大量的order by，group by的处理\n- io_wait高，通常是因为系统io不给力，造成CPU等待，或者随机IO过重，可以使用pt-ioprofile去查看一下到底是谁占用比较高。直接在命令行输入pt-ioprofile就可以。\n- sys占用高，一般是因为numa没有关闭；如果不敢确定的话可以使用`pref top`去看一下，\n- st占用高，多出现于虚拟化环境，通常是虚拟化环境资源竞争过于严重。如果用的云厂商的话直接投诉云厂商就可以了。\n\n### 2.2、vmstat\n\nsi：swap-in、so：swap-out，vmstat中的r和b，r是正在运行的，b是等待io的。如果b比较大的话就需要pt-ioprofile去查一下了。\n\n\n\niops是什么？IO吞吐量是什么？\n\niops：每秒钟的io处理能力。其中包含了读和写。\n\niostat：yum -y install sysstat","timestamp":1518081382541}]