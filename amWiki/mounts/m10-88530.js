if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m10']=[{"name":"01-01、HTML简单介绍.md","path":"10-前端/01-HTML/01-01、HTML简单介绍.md","content":"\n\n\n\n\n\n### Form表单\n\n#### input标签\n\n\n\n\n\n","timestamp":1526030685669},{"name":"01-01-开发环境介绍.md","path":"10-前端/01-HTML/02-02、开发环境介绍/01-01-开发环境介绍.md","content":"# 开发环境介绍\n\n> 其实前端的开发不用什么太多的软件，一个浏览器，一个记事本足矣。不过一个好的编写代码的软件可以让我们的编程效率提高。编程软件很多，最简单的有记事本，较为常用的有notepad++，sublime。较为经典的有Dreamweaver，以及后起之秀的vscode，atom这些都可以，pycharm，Hbuilder这种软件同样是可以支持的，其实最重要的还是看哪个软件用着顺手。\n>\n> 参考资料：\n>\n> - https://segmentfault.com/a/1190000004204640\n> - http://www.w3cplus.com/tools/emmet-cheat-sheet.html\n> - http://www.cnblogs.com/SourceKing/p/5470428.html\n\n\n\n## 1、使用Sublime搭建前端开发环境\n\n下载sublime3的安装包不多说什么了，直接下载安装即可，如果想要将sublime用的更顺手，就需要安装其他的一些插件才可以。\n\n### 1.1、包管理器（Package Control）\n\n点击菜单→Show Console调出命令终端，或者使用快捷键`ctrl+反引号`也可以在底部呼出快捷菜单，将如下命令输入到控制台中，回车，等待即可安装成功。或者参考如下的安装代码和[指导地址](https://packagecontrol.io/installation)：\n\n```python\nimport urllib.request,os,hashlib; h = \'2915d1851351e5ee549c20394736b442\' + \'8bc59f460fa1548d1514676163dafc88\'; pf = \'Package Control.sublime-package\'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( \'http://packagecontrol.io/\' + pf.replace(\' \', \'%20\')).read(); dh = hashlib.sha256(by).hexdigest(); print(\'Error validating download (got %s instead of %s), please try manual install\' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), \'wb\' ).write(by)\n```\n\n### 1.2、安装插件\n\n通过快捷键`ctrl+shift+p`调出命令面板，找到包安装，就会跳转到各种包的界面：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/49383936.jpg)\n\n选中按回车，稍作等待即可以；\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/94138252.jpg)\n\n接下来就可以安装前端开发可能会用到的插件了。\n\n#### Emmet（代码快速生成软件）\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/21969652.jpg)\n\n可以看到可以用上面的方式快速生成我们想要的代码，它使用仿css选择器的方式去生成代码，大大的提高了我们生成代码的速度。简单了解详见：\n\n#### ConvertToUTF8\n\nConvertToUTF8：直接在菜单栏中可以转了，专为中文设计，妈妈再也不通担心中文乱码问题了\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/95674636.jpg)\n\n#### BracketHighlighter\n\n显示用户所在的括号到底是哪一个\n\n#### JSFormat\n\nJavaScript代码格式化软件\n\n#### AutoFileName\n\n自动完成文件名的输入，如图片选取\n\n#### Sublime CodeIntel\n\n代码自动提示\n\n#### ColorHighlighter\n\n[ColorHighlighter](https://github.com/Monnoroch/ColorHighlighter/)是一个显示选中颜色代码的视觉颜色的插件。如果您选择“# fff“，它将向您展示白色。ColorHighlighter支持所有CSS颜色格式，如Hex,RGB,HSL,HSV,同时包括颜色关键词,如“red”“green”,等等。它还为你显示包含颜色值的LESS,Sass,和Stylus变量。它是一个帮助您更直观处理颜色的插件","timestamp":1526030685669},{"name":"02-02-Emmet简单实用介绍.md","path":"10-前端/01-HTML/02-02、开发环境介绍/02-02-Emmet简单实用介绍.md","content":"# Emmet插件使用\n\n## 1-针对html的操作\n\n#### 初始化（输入下面代码按tab生效）\n\n- html:5或!：初始化html5文档类型\n- html:xt：用户xhtml过渡文档类型\n- html:4s：用于html4严格文档类型\n\n#### 轻松添加类、id、文本和属性\n\n- 元素.class_name的形式/元素#id的形式\n\n  ![](http://omk1n04i8.bkt.clouddn.com/17-10-29/90435545.jpg)\n\n  比如输入p.bar#foo则会生成如下的代码\n\n  ```html\n  <p class=\"bar\" id=\"foo\"></p>\n  ```\n\n- 属性可以通过h1{foo}和a[href=#]类似这种格式的代码来进行添加\n\n  ![](http://omk1n04i8.bkt.clouddn.com/17-10-29/44004558.jpg)\n\n#### 嵌套\n\n现在你只需要1行代码就可以实现标签的嵌套。 \n\n- \\>：子元素符号，表示嵌套的元素\n- +：同级标签符号\n- ^：可以使该符号前的标签提升一行\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/79982974.jpg)\n\n#### 分组\n\n使用\".\"默认就是生成div，通过嵌套和括号可以快速生成一些小的代码块。比如输入(.foo>h1)+(.bar>h2)的话那么就会生成如下的html代码：\n\n```html\n<div class=\"foo\">  \n  <h1></h1>  \n</div>  \n<div class=\"bar\">  \n  <h2></h2>  \n</div> \n```\n\n#### 隐式标签\n\n声明一个带类的标签，只需输入div.item，就会生成<div class=\"item\"></div>。 \n\n在过去版本中，可以省略掉div，即输入.item即可生成<div class=\"item\"></div>。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在<ul>中输入.item，就会生成<li class=\"item\"></li>。 \n\n下面是所有的隐式标签名称： \n\n- li：用于ul和ol中\n- tr：用于table、tbody、thead和tfoot中\n- td：用于tr中\n- option：用于select和optgroup中\n\n#### 定义多个元素\n\n使用`*`符号即可以定义多个同样的元素，比如ul>li*3就会生成如下的代码：\n\n```html\n<ul>  \n  <li></li>  \n  <li></li>  \n  <li></li>  \n</ul> \n```\n\n如果元素需要带属性怎么办呢？这个也很简单，比如输入 ul>li.item$*3会生成如下的html代码。\n\n```html\n<ul>  \n  <li class=\"item1\"></li>  \n  <li class=\"item2\"></li>  \n  <li class=\"item3\"></li>  \n</ul>  \n```\n\n## 2-针对CSS的操作\n\n#### css缩写(必须为对应的css格式的文件才可以生效)\n\n- w100：width:100px\n- m5e：margin: 5em\n- h10p：height: 10%;\n\n单位别名列表： \n\n- p 表示%\n- e 表示 em\n- x 表示 ex\n\n#### 附加属性\n\n可能你之前已经了解了一些缩写，比如 @f，可以生成： \n\n```css\n@font-face {  \n  font-family:;  \n  src:url();  \n} \n```\n\n一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成： \n\n```css\n@font-face {  \n  font-family: \'FontName\';  \n  src: url(\'FileName.eot\');  \n  src: url(\'FileName.eot?#iefix\') format(\'embedded-opentype\'),  \n     url(\'FileName.woff\') format(\'woff\'),  \n     url(\'FileName.ttf\') format(\'truetype\'),  \n     url(\'FileName.svg#FontName\') format(\'svg\');  \n  font-style: normal;  \n  font-weight: normal;  \n}  \n```\n\n#### 模糊匹配\n\n如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：\n\n```css\noverflow: hidden; \n```\n\n#### 供应商前缀\n\n如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成： \n\n```css\n-webkit-transform: ;  \n-moz-transform: ;  \n-ms-transform: ;  \n-o-transform: ;  \ntransform: ; \n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/8248386.jpg)\n\n你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo： \n\n```css\n-webkit-super-foo: ;  \n-moz-super-foo: ;  \n-ms-super-foo: ;  \n-o-super-foo: ;  \nsuper-foo: ;  \n```\n\n如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀： \n\n```css\n-webkit-transform: ;  \n-moz-transform: ;  \ntransform: ; \n```\n\n前缀缩写如下： \n\n- w 表示 -webkit-\n- m 表示 -moz-\n- s 表示 -ms-\n- o 表示 -o-\n\n#### 渐变\n\n输入lg(left, #fff 50%, #000)，会生成如下代码： \n\n```css\nbackground-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));  \nbackground-image: -webkit-linear-gradient(left, #fff 50%, #000);  \nbackground-image: -moz-linear-gradient(left, #fff 50%, #000);  \nbackground-image: -o-linear-gradient(left, #fff 50%, #000);  \nbackground-image: linear-gradient(left, #fff 50%, #000);  \n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/59307770.jpg)\n\n## 3-附加功能\n\n**生成Lorem ipsum文本** \n\nLorem ipsum指一篇常用于排版设计领域的拉丁文文章，主要目的是测试文章或文字在不同字型、版型下看起来的效果。通过Emmet，你只需输入lorem 或 lipsum即可生成这些文字。还可以指定文字的个数，比如lorem10，将生成： \n\n```\nLorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus.\n```\n\n## 4-定制\n\n你还可以定制Emmet插件： \n\n- 添加新缩写或更新现有缩写，可修改[snippets.json](http://docs.emmet.io/customization/snippets/)文件\n- 更改Emmet过滤器和操作的行为，可修改[preferences.json](http://docs.emmet.io/customization/preferences/)文件\n- 定义如何生成HTML或XML代码，可修改[syntaxProfiles.json](http://docs.emmet.io/customization/syntax-profiles/)文件\n\n## 5-针对不同编辑器的插件\n\nEmmet支持的编辑器如下（链接为针对该编辑器的Emmet插件）： \n\n- [Sublime Text 2](https://github.com/sergeche/emmet-sublime)\n- [TextMate 1.x](https://github.com/emmetio/Emmet.tmplugin)\n- [Eclipse/Aptana](https://github.com/emmetio/emmet-eclipse)\n- [Coda 1.6 and 2.x](https://github.com/emmetio/Emmet.codaplugin)\n- [Espresso](https://github.com/emmetio/Emmet.sugar)\n- [Chocolat](https://github.com/sergeche/emmet.chocmixin) （通过“Install Mixin”对话框添加)\n- [Komodo Edit/IDE](https://github.com/emmetio/emmet/downloads) （通过Tools → Add-ons菜单添加)\n- [Notepad++](https://github.com/emmetio/emmet/downloads)\n- [PSPad](https://github.com/emmetio/emmet/downloads)\n- [CodeMirror2/3](https://github.com/emmetio/codemirror)\n- [Brackets](https://github.com/emmetio/brackets-emmet)\n\n","timestamp":1526030685669},{"name":"03-03、HTML快速入门.md","path":"10-前端/01-HTML/03-03、HTML快速入门.md","content":"# HTML快速入门\n\n> 参考资料：http://www.cnblogs.com/yuanchenqi/articles/6835654.html\n\n## 1-HTML基础\n\n### 1.1 html是什么？\n\n- 超文本标记语言（Hypertext Markup Language，HTML）通过**标签语言**来标记要显示的网页中的各个部分。一套规则，浏览器认识的规则\n- 浏览器按顺序渲染网页文件，然后根据标记符解释和显示内容。但需要注意的是，对于不同的浏览器，对同一标签可能会有不完全相同的解释（兼容性）\n- 静态网页文件扩展名：.html 或 .htm\n\n### 1.2 html不是什么\n\nHTML 不是一种编程语言，而是一种标记语言 (markup language)\n\nHTML 使用标记标签来描述网页\n\n### 1.3 html的结构\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/37492664.jpg)\n\n- <!DOCTYPE html> 告诉浏览器使用什么样的html或者xhtml来解析html文档\n- <html></html>是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部<head>和主体<body>。 \n- <head></head>元素出现在文档的开头部分。<head>与</head>之间的内容不会在浏览器的文档窗口显示，但是其间的元素有特殊重要的意义。\n- <title></title>定义网页标题，在浏览器标题栏显示。  \n- <body></body>之间的文本是可见的网页主体内容\n\n到了html5以后结构变得更加的细化：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/10107051.jpg)\n\n### 1.4 html标签格式\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/23230425.jpg)\n\n标签的语法：\n\n<标签名 属性1=“属性值1” 属性2=“属性值2”……>内容部分</标签名>\n<标签名 属性1=“属性值1” 属性2=“属性值2”…… />\n\n### 1.5 常用标签\n\n#### 1.5.1 <!DOCTYPE>标签\n\n<!DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n\n作用：声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。\ndocument.compatMode：\n\n1. BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。\n2. CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。\n\n这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat\n\n#### 1.5.2 \\<head\\>内常用标签\n\n##### \\<meta\\>标签\n\nmeta介绍\n<meta>元素可提供有关页面的元信息（meta-information），针对搜索引擎和更新频度的描述和关键词。\n<meta>标签位于文档的头部，不包含任何内容。\n<meta>提供的信息是用户不可见的\n\nmeta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 \n\n- name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。    \n\n  ```html\n  <meta name=\"keywords\" content=\"meta总结,html meta,meta属性,meta跳转\">\n  <meta name=\"description\" content=\"哈哈哈哈哈\">\n  ```\n\n- http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。\n\n  ```html\n  <meta http-equiv=\"Refresh\" content=\"2;URL=https://www.oldboy.com\"> \n  //(注意后面的引号，分别在秒数的前面和网址的后面，表示2s后跳转到后面的网址)\n  <meta http-equiv=\"content-Type\" charset=UTF8\">\n  <meta http-equiv = \"X-UA-Compatible\" content = \"IE=EmulateIE7\" /> \n  ```\n\n##### 非meta标签\n\n```html\n<title>lamber</title>   # 网页文档的标题\n<link rel=\"icon\" href=\"http://www.jd.com/favicon.ico\">  # 网页的icon\n<link rel=\"stylesheet\" href=\"css.css\">  # 外部引入css\n<script src=\"hello.js\"></script>　# 引入js\n<style type=\"text/css\"></style>  # 引入css\n```\n\n#### 1.5.3 body内常用标签\n\n##### 基本标签\n\n```html\n<hn>: n的取值范围是1~6; 从大到小. 用来表示标题。一般h1在文档中只会有一个，和搜索引擎有关。\n<p>: 段落标签. 包裹的内容被换行.并且也上下内容之间有一行空白.\n<b> <strong>: 加粗标签.\n<strike>: 为文字加上一条中线。\n<em>: 文字变成斜体.\n<sup>和<sub>: 上角标 和 下角表.\n<br>:换行.\n<hr>:水平线\n\n特殊字符：\n      &lt; &gt；&quot；&copy;&reg;（小于，大于，引号，版权，注册商标）\n```\n\n##### div和span\n\n- <div></div> ： <div>只是一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现. 块级元素独占一行。\n- <span></span>：  <span>表示了内联行(行内元素),并无实际的意义,主要通过CSS样式为其赋予不同的表现. 非独占一行。\n\n块级元素与行内元素的区别\n所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。\n这两个元素是专门为定义CSS样式而生的。那么html的块级元素和行内元素都有哪些？以下内容仅供参考，实际上有用的没几个，看看就得了。\n\n```\n块元素(block element)\n\n　　 * address - 地址\n 　　* blockquote - 块引用\n 　　* center - 举中对齐块\n 　　* dir - 目录列表\n 　　* div - 常用块级容易，也是css layout的主要标签\n 　　* dl - 定义列表\n 　　* fieldset - form控制组\n 　　* form - 交互表单\n 　　* h1 - 大标题\n 　　* h2 - 副标题\n 　　* h3 - 3级标题\n 　　* h4 - 4级标题\n 　　* h5 - 5级标题\n 　　* h6 - 6级标题\n 　　* hr - 水平分隔线\n 　　* isindex - input prompt\n　　 * menu - 菜单列表\n 　　* noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容\n 　　* noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）\n 　　* ol - 排序表单\n 　　* p - 段落\n 　　* pre - 格式化文本\n 　　* table - 表格\n 　　* ul - 非排序列表\n\n内联元素(inline element)\n\n　　 * a - 锚点\n 　　* abbr - 缩写\n 　　* acronym - 首字\n 　　* b - 粗体(不推荐)\n　　 * bdo - bidi override\n　　 * big - 大字体\n 　　* br - 换行\n 　　* cite - 引用\n 　　* code - 计算机代码(在引用源码的时候需要)\n　　 * dfn - 定义字段\n 　　* em - 强调\n 　　* font - 字体设定(不推荐)\n　　 * i - 斜体\n 　　* img - 图片\n 　　* input - 输入框\n 　　* kbd - 定义键盘文本\n 　　* label - 表格标签\n 　　* q - 短引用\n 　　* s - 中划线(不推荐)\n　　 * samp - 定义范例计算机代码\n 　　* select - 项目选择\n 　　* small - 小字体文本\n 　　* span - 常用内联容器，定义文本内区块\n 　　* strike - 中划线\n 　　* strong - 粗体强调\n 　　* sub - 下标\n 　　* sup - 上标\n 　　* textarea - 多行文本输入框\n 　　* tt - 电传文本\n 　　* u - 下划线\n 　　* var - 定义变量\n\n可变元素\n\n　　可变元素为根据上下文语境决定该元素为块元素或者内联元素。\n 　　* applet - java applet\n　　 * button - 按钮\n 　　* del - 删除文本\n 　　* iframe - inline frame\n　　 * ins - 插入的文本\n 　　* map - 图片区块(map)\n　　 * object - object对象\n 　　* script - 客户端脚本\n```\n\n##### img标签\n\n```\nsrc: 要显示图片的路径.\nalt: 图片没有加载成功时的提示.\ntitle: 鼠标悬浮时的提示信息.\nwidth: 图片的宽\nheight:图片的高 (宽高两个属性只用一个会自动等比缩放.)\n```\n\n##### 超链接\n什么是超级链接？\n所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。\n\n```\n# 小知识点\n什么是URL：\nURL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。\nURL举例\nhttp://www.sohu.com/stu/intro.html\nhttp://222.172.123.33/stu/intro.html\n\nURL地址由4部分组成\n第1部分：为协议：http://、ftp://等 \n第2部分：为站点地址：可以是域名或IP地址\n第3部分：为页面在站点中的目录：stu\n第4部分：为页面名称，例如 index.html\n各部分之间用“/”符号隔开。\n```\n\n超链接的使用：\n\n```html\n<a href=\"\" target=\"_blank\" >click</a>\n\nhref属性指定目标网页地址。该地址可以有几种类型：\n\n    绝对 URL - 指向另一个站点（比如 href=\"http://www.jd.com）\n    相对 URL - 指当前站点中确切的路径（href=\"index.htm\"）\n    锚 URL - 指向页面中的锚（href=\"#top\"）\n```\n\n##### 列表\n\n```html\n<ul>: 无序列表 [type属性：disc(实心圆点)(默认)、circle(空心圆圈)、square(实心方块)]\n<ol>: 有序列表\n         <li>:列表中的每一项.\n<dl>  定义列表\n         <dt> 列表标题\n         <dd> 列表项\n```\n\n##### 表格\n\n\n\n\n\n\n\n\n\n","timestamp":1526030685669},{"name":"01-CSS简单了解.md","path":"10-前端/02-CSS/01-CSS简单了解.md","content":"## CSS简单使用\n\n[TOC]\n\n## 1、选择器\n\n```css\nselector {\n          property: value;\n          property: value;\n     ...  property: value\n \n  }\n```\n\n比如：\n\n```css\nh1 {color:red; font-size:14px;}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-8/77825534.jpg)\n\n### 1.1、基本选择器\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-8/79864028.jpg)\n\n### 1.2、组合选择器\n\n```css\nE,F   多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔      :div,p { color:#f00; }\n \nE F   后代(儿子，孙子都算后代)元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 :\n      li a { font-weight:bold;｝，会把li下的所有的a都给设置上。\n \nE > F   子元素选择器，匹配所有E元素的子元素F            :div > p { color:#f00; }\n        只是父级元素的二级元素才会被选择上。三级以后就不会被选择上了\n  \nE + F   毗邻元素选择器，匹配所有紧随E元素之后的同级元素F  :div + p { color:#f00; } \n        什么叫毗邻，就是紧挨着，中间插个第三者这就不叫紧挨着了。放到它上面还不行，只能在下面紧挨着。\n \nE ~ F   普通兄弟选择器（以破折号分隔）                 :.div1 ~ p{font-size: 30px; }\n        也是向下找，但是不管你挨着不挨着，反正就是同一级别的就行。\n```\n\n注意，关于标签嵌套：\n\n一般，块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。需要注意的是，p标签不能包含块级标签。\n\n### 1.3、属性选择器\n\n```css\nE[att]          匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略。\n                比如“[cheacked]”。以下同。）   p[title] { color:#f00; }\n \n \nE[att=val]      匹配所有att属性等于“val”的E元素   div[class=”error”] { color:#f00; }\n \n \nE[att~=val]     匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素\n                td[class~=”name”] { color:#f00; }\n \nE[attr^=val]    匹配属性值以指定值开头的每个元素                    \n                div[class^=\"test\"]{background:#ffff00;}\n \nE[attr$=val]    匹配属性值以指定值结尾的每个元素    div[class$=\"test\"]{background:#ffff00;}\n \nE[attr*=val]    匹配属性值中包含指定值的每个元素    div[class*=\"test\"]{background:#ffff00;}\n```\n\n##2、CSS的引用\n\n### 2.1、CSS的四种引用方式\n\n**行间样式**  （很少用）\n\n```html\n<!--行间样式很直观，但是只针对当前的标签生效，不具备统一修改的特效-->\n<body>\n\t<div style=\"width: 100px;height: 100px;background: red;\">\n\t\taaa\n\t</div>\t\n</body>\n```\n\n**内联样式表** （仍然是在文件内部）\n\n```html\n<!--不写在行间，而是写在head的style标签内部，便于分别去管理-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t#div1{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground: green;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div id=\"div1\">\n\t\ttest\n\t</div>\n</body>\n</html>\n```\n\n**外联样式表** （用在外部，实际应用的方式）\n\n```html\n<!--从外部引用，将网页和样式进行分离-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"day1.css\">\n</head>\n<body>\n\t<div id=\"div1\">\n\t\ttest\n\t</div>\n</body>\n</html>\n\n<!--day1.css文件-->\n#div1{\n\twidth: 100px;\n\theight: 100px;\n\tbackground: yellow;\n}\n```\n\n**导入式的方法**：\n\n将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，style标记也是写在head标记中，使用的语法如下：    \n\n```css\n<style type=\"text/css\">\n \n          @import\"mystyle.css\"; 此处要注意.css文件的路径\n \n</style>　\n```\n\n注意：\n\n​      导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。\n\n### 2.2、CSS的优先级\n\n> 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\n\n首先说CSS的属性是可以继承的，继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个BODY定义了的颜色值也会应用到段落的文本中。\n\n```css\nbody{color:red;}       <p>helloyuan</p>\n```\n\n这段文字都继承了由body {color:red;}样式定义的颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。\n\n```css\np{color:green}\n```\n\n发现只需要给加个颜色值就能覆盖掉它继承的样式颜色。由此可见：任何显示申明的规则都可以覆盖其继承样式。此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。\n\n在聊CSS优先级之前，先聊一下元素的class，元素的class是允许存在多个的，比如：\n\n```css\n<div class=\"aaa bbb\">\n    lalala\n</div>\n```\n\n在这种情况下属于同级调用，class之间的优先级是一样的，那么这个时候如果两个class之间有属性冲突的话，那么就会以css中下面的为准（css的读取从上往下读），简单来说就是同级的调用之间的是收到顺序的影响的。\n\n不同级的属性调用之间，是存在不同的优先级的，优先级可以用数字来表示。\n\n所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。\n\n样式表中的特殊性描述了不同规则的相对权重，它的基本规则是：\n\n- 内联样式表的权值最高                       style=\"\"－－－－－－－－－－－－1000；\n- 统计选择符中的ID属性个数。           #id －－－－－－－－－－－－－－100\n- 统计选择符中的CLASS属性个数。    .class －－－－－－－－－－－－－10\n- 统计选择符中的HTML标签名个数。 p －－－－－－－－－－－－－-－1\n\n按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。\n\n>\n>1、文内的样式优先级为1,0,0,0，所以始终高于外部定义。\n>\n>2、有!important声明的规则高于一切。\n>\n>```css\n>.p2 {color:red!important;}\n>```\n>\n>3、如果!important声明冲突，则比较优先权。\n>\n>4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。\n>\n>5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。\n>\n>6、关于经由@import载入的外部样式，由于@import必须出现在所有其他规则定义之前(如不是，则浏览器应该忽略之)，所以按照后来居上原则，一般优先权冲突时是占下风的。\n\n### 2.3、CSS的文本属性\n\n#### 水平对齐方式&文本属性\n\ntext-align 属性规定元素中的文本的水平对齐方式。\n\n- left      把文本排列到左边。默认值：由浏览器决定。\n- right    把文本排列到右边。\n- center 把文本排列到中间。\n- justify 实现两端对齐文本效果。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>css</title>\n<style>\n        h1 {text-align:center;}\n        p.publish_time {text-align:right;}\n        p.content {text-align:justify;}\n</style>\n</head>\n\n<body>\n<h1>CSS text-align 水平居中</h1>\n<p class=\"publish_time\">2017 年 5 月 17 号</p>\n<p class=\"content\">\n    有个落拓不得志的中年人每隔三两天就到教堂祈祷，而且他的祷告词几乎每次都相同。第一次他到教堂时，\n    跪在圣坛前，虔诚地低语：“上帝啊，请念在我多年来敬畏您的份上。让我中一次彩票吧！阿门。”\n    几天后，他又垂头丧气回到教堂，同样跪着祈祷：“上帝啊，为何不让我中彩票？我愿意更谦卑地来\n    服侍你，求您让我中一次彩票吧！阿门。”又过了几天，他再次出现在教堂，同样重复他的祈祷。如此周而\n    复始，不间断地祈求着。到了最后一次，他跪着：“我的上帝，为何您不垂听我的祈求？让我中一次彩票吧！\n    只要一次，让我解决所有困难，我愿终身奉献，专心侍奉您……”就在这时，圣坛上发出一阵宏伟庄严的声\n    音：“我一直垂听你的祷告。可是最起码？你也该先去买一张彩票吧!”</p>\n<p><b>注意：</b> 重置浏览器窗口大小查看 &quot;justify&quot; 是如何工作的。</p>\n</body>\n\n</html>\n```\n\n其他的文字属性：\n\n```css\nfont-size: 10px;\nline-height: 200px;   文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比\nvertical-align:－4px  设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效\ntext-decoration:none  text-decoration 属性用来设置或删除文本的装饰。主要是用来删除链接的下划线\nfont-family: \'Lucida Bright\'\nfont-weight: lighter/bold/border/\nfont-style: oblique\ntext-indent: 150px;      首行缩进150px\nletter-spacing: 10px;  字母间距\nword-spacing: 20px;  单词间距\ntext-transform: capitalize/uppercase/lowercase ; 文本转换，用于所有字句变成大写或小写字母，或每个单词的首字母大写\n```\n\n### 2.4、CSS的样式了解\n\n#### 颜色值：\n\n- 十六进制表示法，比如：background: #3CC; //#33CCCC，这种的就可以进行缩写\n\n- RGB模式，比如：rgb(100,255,233) //[RBG颜色对照表](http://tool.oschina.net/commons?type=3)\n\n- RGBA模式，在RBG的基础上调整透明度，比如：background: rgba(255,0,0,0.5);或者使用opacity这个来调整透明度。范围是0~1,1表示颜色的纯色。\n\n  ![](http://omk1n04i8.bkt.clouddn.com/17-10-30/37912135.jpg)\n\n- 颜色的单词，比如：red，green等\n\n#### 注释\n\n```css\n/*  我是被注释的内容  */\n```\n\n#### 背景图片\n\n```css\nbackground-image: url(img/b.png);\n```\n\n默认的情况下是平铺：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/69719727.jpg)\n\n如果不想平铺的话我们可以进行设置（背景图片层级要高于背景颜色）\n\n```css\nbackground-repeat: no-repeat;\n```\n\n还可以设置为横向重复：\n\n```css\nbackground-repeat: repeat-x;\n```\n\n\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/34906123.jpg)\n\n设置垂直平铺：\n\n```css\nbackground-repeat: repeat-y;\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/62538269.jpg)\n\n#### 设置背景定位\n\n调整图片的定位可以使用background-position这个设置参数。\n\n```css\nbackground-position: 50px 30px;   # 使用像素值，第一个值最好写x轴，第二个值最好写y\nbackground-position: -50px -30px; # 同样也支持负值\nbackground-position: 50% 30px;    # 使用百分比\nbackground-position: left bottom;   # 使用位置单词\n/*x轴有left center right三种位置。默认居中*/\n/*y轴有top，center，bottom，默认居中*/\n\n如果写成：\nbackground-position: center;   # 默认全放在中间 \n```\n\n如果你在设置定位的时候同时还使用了水平平铺或者垂直平铺，没被覆盖到的位置会被图片的其他部分补齐，比如：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/38561136.jpg)\n\n如果设置的div容器的大小小于图片的话，那么就是能看到多少就是看到多少。\n\n**设置图片不随着滚动条滚动**\n\n```css\nbackground-attachment: fixed;\n```\n\n**复合样式**\n\n```css\n/*这个顺序是可以任意调整的，没有的就不写，但是position定位xy轴是放到一块写的*/\nbackground: red url(img/maka.jpg) no-repeat center fixed;\n```\n\n#### 边框\n\n```css\n/*设置元素的border属性*/\n#div1{\n\twidth: 100px;\n\theight: 100px\n\tborder: 2px solid red;\n}\n- solid：实线\n- dashed：虚线\n- dotted：点线\n```\n\n边框肯定是四条边，我们可以针对这四条边进行拆分的：\n\n```css\nborder-top: 3px solid red;\nborder-left: 3px dotted green;\nborder-right: 3px dashed blue;\nborder-bottom: 3px solid yellow;\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/18069121.jpg)\n\n#### 列表属性\n\n```css\nlist-style-type         设置列表项标志的类型。（一般设置为None）\nlist-style-image    将图象设置为列表项标志。\nlist-style-position 设置列表中列表项标志的位置。\nlist-style          简写属性。用于把所有用于列表的属性设置于一个声明中（一般设置为None）\n```\n\nlist-style-type属性指定列表项标记的类型：\n\n```css\nul { list-style-type: square; }\n```\n\n使用图像来替换列表项的标记:\n\n```css\nul {\n     list-style-image: url(\'\');\n}\n```\n\n#### display属性\n\n- none\n\n  ```css\n  p{display:none;}\n\n  注意与visibility:hidden的区别：\n  visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。\n  display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。\n  ```\n\n- block（内联标签设置为块级标签）\n\n  ```css\n  span {display:block;}\n  注意：一个内联元素设置为display:block是不允许有它内部的嵌套块元素。　\n  ```\n\n- inline\n\n  ```css\n  # 块级别标签设置为内联级别的标签\n  li {display:inline;}\n  # 比如上面的把li设置一行显示，而不是独占一行。内容撑开宽高。\n  # 内联标签不能设置长宽，不支持上下的margin，代码换行被解析\n  ```\n\n- inline-block(设置成内联形式的块元素，可以设置长宽了；没有宽度的时候内容撑开宽度)\n\n  ```css\n  display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决：\n  #outer{\n              border: 3px dashed;\n              word-spacing: -5px;\n          }\n  ```\n\n#### 浮动Float\n\nfloat：left|right|none|inherit\n\n文档流：是文档中可以显示对象在排列时所占用的位置。\n\n浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停下来\n\n浮动的顺序是按照元素在页面从上到下的顺序加载的。\n\n浮动的基本特征：\n\n- 块在一排显示\n- 内联支持宽高\n- 默认文档撑开宽度\n- 脱离文档流\n- 提升层级半层\n\n清除浮动的方法：\n\n- 加高度（扩展性不好）\n- 父级也浮动（页面中所有的元素都浮动，margin左右自动失效，因此也不是很好的方法）\n- inline-block方法清除浮动：会导致margin左右的auto失效\n- 空标签清除浮动：但是只要用到浮动的地方就要去放一个空标签也是不合适的。\n- br清除浮动：br有一个属性叫`clear=\"all\"`，不符合工作中的结构，行为，样式的三者分离的要求\n- after伪类：清除浮动的方法\n\n下边的元素会判断你上级的元素是否是浮动的。\n\nclear：left|right|both|none|inherit\n\n元素在某个方向上不能有浮动元素，clear both指的是两侧均不予许有浮动元素。\n\n\n\n## 3、简单的PS抠图\n\n\n\n## 4、网易新闻小结构案例\n\n","timestamp":1526030685669},{"name":"02-CSS盒模型.md","path":"10-前端/02-CSS/02-CSS盒模型.md","content":"# CSS盒模型\n\n## 伪类\n伪类专用于控制链接的显示效果\n```css\na:link（没有接触过的链接）,用于定义了链接的常规状态。\na:hover（鼠标放在链接上的状态）,用于产生视觉效果。\na:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。\na:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。\n\n伪类选择器 : 伪类指的是标签的不同状态:\na ==> 点过状态 没有点过的状态 鼠标悬浮状态 激活状态\na:link {color: #FF0000} /* 未访问的链接 */\na:visited {color: #00FF00} /* 已访问的链接 */\na:hover {color: #FF00FF} /* 鼠标移动到链接上 */\na:active {color: #0000FF} /* 选定的链接 */ 格式: 标签:伪类名称{ css代码; }\n\n# 动态的添加内容\np:after{\n    content:\'hello world\'\n    color:red\n}\n\np:before\n```\n\n示例：\n\n```css\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <style>\n\n       .top{\n           background-color: rebeccapurple;\n           width: 100px;\n           height: 100px;\n       }\n        .bottom{\n            background-color: green;\n            width: 100px;\n            height: 100px;\n        }\n\n        .outer:hover .bottom{\n            background-color: yellow;\n        }\n\n        注意:一定是outer:hover  控制outer里某一个标签,否则无效\n\n        .top:hover .bottom{\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n\n\n<div class=\"outer\">\n    <div class=\"top\">top</div>\n    <div class=\"bottom\">bottom</div>\n</div>\n</body>\n</html>\n```\n\n\n\n\n\n如果想要一个简单的居中可以使用line-height=容器的高，然后text-align的值是center\n\n\n\noverflow-hidden\n\n当内容的高度超过容器设置的高度以后会溢出，因此有时候我们会去设置这个overflow-hidden这个参数，让它隐藏，被隐藏的部分可以以滚动条的形式查看。但是拥有overflow:hidden样式的块元素内部的元素溢出并不总是被隐藏，具体来说，需要同时满足以下条件：\n\n- 有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；\n- 内部溢出的元素是通过position:absolute绝对定位；\n\n## 盒模型\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-9/55577387.jpg)\n\n- **margin**:            用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。注意两个元素的margin是会重叠的，按照两者之间大的算，比如两个div一个margin是20，一个是30，\n- **padding**:           用于控制内容与边框之间的距离；   \n- **Border**(边框):     围绕在内边距和内容外的边框。\n- **Content**(内容):   盒子的内容，显示文本和图像。\n\n### margin\n\n**单边外边距属性：**\n\n```css\nmargin-top:100px;\nmargin-bottom:100px;\nmargin-right:50px;\nmargin-left:50px;\n```\n\n当然margin也是一个复合属性，我可以直接用一个margin来写四条边的：\n\n```css\nmargin:10px 20px 20px 10px；\n\n        上边距为10px\n        右边距为20px\n        下边距为20px\n        左边距为10px\n\nmargin:10px 20px 10px;\n\n        上边距为10px\n        左右边距为20px\n        下边距为10px\n\nmargin:10px 20px;\n\n        上下边距为10px\n        左右边距为20px\n\nmargin:25px;\n\n        所有的4个边距都是25px\n```\n\n居中的用法\n\n```css\nmargin: 0 auto;\n```\n\n### padding（内填充）\n\n单独使用填充属性可以改变上下左右的填充。缩写填充属性也可以使用，一旦改变一切都改变。\n\n设置同margine；(padding会影响盒子大小，简单来说可以用padding给撑起来)\n\n**思考1: ** body的外边距\n\n​       边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下，   body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上：\n\n```css\nbody{\n    border: 1px solid;\n    background-color: cadetblue;\n}\n```\n\n解决方法：\n\n```css\nbody{\n    margin: 0;\n}\n```\n\n**思考2：**margin collapse（边界塌陷或者说边界重叠）\n\n1、兄弟div：\n上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值（塌陷的重叠只会针对上下，不针对左右。）\n\n2、父子div：\nif 父级div中没有border，padding，inlinecontent，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content中的其中一个，然后按此div 进行margin；\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" style=\"padding: 0px\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n\n        body{\n            margin: 0px;\n        }\n\n        .div1{\n            background-color: rebeccapurple;\n            width: 300px;\n            height: 300px;\n            overflow: hidden;\n\n        }\n        .div2{\n            background-color: green;\n            width: 100px;\n            height: 100px;\n            margin-bottom: 40px;\n            margin-top: 20px;\n        }\n        .div3{\n            background-color:teal;\n            width: 100px;\n            height: 100px;\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n<div style=\"background-color: bisque;width: 300px;height: 300px\"></div>\n\n<div class=\"div1\">\n\n   <div class=\"div2\"></div>\n   <div class=\"div3\"></div>\n</div>\n\n</body>\n\n</html>\n```\n\n解决方案：\n\n```css\noverflow: hidden;　　\n```\n\n\n\n\n\n\n\nfloat会覆盖div但是不会影响文字\n\n## CSS中的定位（position）\n\n```css\nposition:relative; 相对定位\n- 不影响元素本身的特性\n- 不使元素脱离文档流，元素移动之后原始位置会被保留\n- 如果没有定位偏移量，对元素本身没有任何影响\n- 提升层级\n\n定位元素位置控制： top/right/bottom/left 定位元素偏移量\n```\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n        #div1{width: 200px;height: 200px;background: red}\n        #div2{width: 200px;height: 200px;background: green;position: relative;left: 200px;top: 200px}\n        #div3{width: 200px;height: 200px;background: blue}\n    </style>\n</head>\n<body>\n    <div id=\'div1\'></div>\n    <div id=\'div2\'></div>\n    <div id=\'div3\'></div>\n</body>\n</html>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-12-6/16357681.jpg)\n\n```css\nposition:absolute; 绝对定位\n- 使元素脱离文档流\n- 是内嵌元素支持宽高\n- 块属性标签内容撑开宽度\n- 如果有定位父级相对于定位父级发生偏移，没有定位父级相对于document发生偏移\n- 相对定位一般都是配合绝对定位元素使用\n- 提升层级\n\nz-index：[number]；  定位层级\n- 定位元素默认后者层级高于前者\n- 建议在兄弟标签之间比较层级\n```\n\n示例参考：\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style>\n\t\t\tbody{\n\t\t\t\tposition: relative;\n\t\t\t}\n\t\t\tdiv{\n\t\t\t\twidth: 200px;\n\t\t\t\theight: 200px;\n\t\t\t}\n\t\t\t.div1{\n\t\t\t\tbackground-color: red;\n\t\t\t}\n\t\t\t.div2{\n\t\t\t\tposition: absolute;\n\t\t\t\tleft:200px;\n\t\t\t\ttop:400px; # 距离body的。\n\t\t\t\tbackground-color: blue;\n\t\t\t}\n\t\t\t.div3{\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 400px;\n\t\t\t\tbackground-color: green;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"div1\">div1</div>\n\t\t<div class=\"div2\">div2</div>\n\t\t<div class=\"div3\">div3</div>\n\t</body>\n</html>\n\n```\n\n\n\n```css\nposition:fixed; 固定定位\n与绝对定位的特性基本一致，差别是始终相对于整个文档进行定位；\n问题：IE6不支持固定定位\n\n\n示例：\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style>\n\t\t\tbody{\n\t\t\t\theight: 3000px;\n\t\t\t}\n\t\t\tdiv{\n\t\t\t\twidth: 100px;\n\t\t\t\theight: 100px;\n\t\t\t\tbackground-color: red;\n\t\t\t\tposition: fixed;\n\t\t\t\tright: 0;\n\t\t\t\tbottom: 0;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div>返回顶部</div>\n\t</body>\n</html>\n\n\n其他不常用定位：\nposition：static；默认值\nposition：inherit；从父级元素继承定位属性的值\n\nposition：relative|absolute|fixed|static|inherit\n```\n\n### 透明度\n\n```css\nopacity:0~1; 1表示不透明，0表示完全透明。这个内容是默认继承父级的透明度的。\n```\n\n广告弹层示例：\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv{\n\t\t\t\twidth: 300px;\n\t\t\t\theight: 300px;\n\t\t\t}\n\t\t\t.box{\n\t\t\t\tmargin: 100px auto;\n\t\t\t\tposition: relative;\n\t\t\t}\n\t\t\t.content{\n\t\t\t\tposition: absolute;\n\t\t\t\tbackground-color: blue;\n\t\t\t\tleft: -6px;\n\t\t\t\ttop: -6px;\n\t\t\t\tz-index: 2;\n\t\t\t}\n\t\t\t.mark{\n\t\t\t\tposition: absolute;\n\t\t\t\tbackground-color: black;\n\t\t\t\tright: -6px;\n\t\t\t\tbottom: -6px;\n\t\t\t\tz-index: 1;\n\t\t\t\topacity: 0.5;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"box\">\n\t\t\t<div class=\"content\"></div>\n\t\t\t<div class=\"mark\"></div>\n\t\t</div>\n\t</body>\n</html>\n```\n\n","timestamp":1526030685669},{"name":"03-浮动和定位.md","path":"10-前端/02-CSS/03-浮动和定位.md","content":"> 参考文章\n>\n> - http://www.cnblogs.com/Zigzag/archive/2009/02/19/position.html\n> - http://www.cnblogs.com/coffeedeveloper/p/3145790.html\n> - https://segmentfault.com/a/1190000004237437\n> - http://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html\n> - http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/\n> - http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%BA%8C/\n\n## Float\n\n关于浮动，其实浮动的本意即让文字可以像流水一样环绕自己，学习浮动可以从以下几个方面去学习查看。\n\n#### 平级的浮动\n\n- 首先说浮动会破坏对象本身的display属性，比如把一个块级别的div设置为浮动以后，默认的display: block的属性就会被破坏。比如下面的3个div，我设置为第二个div为浮动以后，那么它就会脱离正常的文档流，第三个div会跑到它下面被它覆盖。首先说什么是文档流，在英文原版里文档流不是document flow，而是normal flow。意即html文档从上到下读取各个元素本来应该显示在的位置\n- 浮动元素会查看上一个元素是不是浮动的，如果不是浮动的按照正常文档流，如果是浮动的那么就紧贴着上一个元素。顺序按照文档顺序从上到下。\n\n<iframe height=\'265\' scrolling=\'no\' title=\'Study Float1\' src=\'https://codepen.io/lamber/embed/ypxoPP/?height=265&theme-id=0&default-tab=css,result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/lamber/pen/ypxoPP/\'>Study Float1</a> by lamber (<a href=\'https://codepen.io/lamber\'>@lamber</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n\n#### 父级浮动\n\n父级浮动会呈现出元素的包裹性。针对块级元素来讲，默认内部内容撑起高度，块级别元素如果不指定宽度的话那么就会100%撑满，但是即使设置了宽度由于块属性元素的特征，依然会占满这一行，不允许其他的元素。但是元素一旦设置了float属性以后就会“浮起来”，像inline元素一样，产生包裹性，比如：\n\n```html\n<div style=\"border: 2px solid black;float: left\">\n    <div style=\"width: 100px;height: 100px;background: greenyellow\"></div>\n</div>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-12-20/65943745.jpg)\n\n#### 子级浮动\n\n子级浮动会产生高度欺骗，让外层包裹层的高度塌陷了。内部内容的浮动使得包裹层认为内部元素的高度为0，因此出现了高度塌陷的问题。因此浮动并不是让元素的高度塌陷了，而是让元素具有高度塌陷的欺骗性。\n\n<iframe height=\'265\' scrolling=\'no\' title=\'Study Float2\' src=\'https://codepen.io/lamber/embed/opPePK/?height=265&theme-id=0&default-tab=css,result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/lamber/pen/opPePK/\'>Study Float2</a> by lamber (<a href=\'https://codepen.io/lamber\'>@lamber</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n\n### 浮动的清除\n\n首先要说明的一点是clear影响的对象是自己，比如一个对象设置了`clear: left;`那么我是要不允许我自己的左侧不允许有浮动的对象，但是我不改变别人，而是改变我自己。\n\n\n\n\n\n\n\n## Position\n\n","timestamp":1526030685669},{"name":"20-CSS3.md","path":"10-前端/02-CSS/20-CSS3.md","content":"# CSS3入门\n\n## Selector\n\n### 属性选择器\n\n- p[miaov]：只选择属性名\n\n- p[miaov=leo]：带属性名而且要求属性值\n\n- p[attr~=\"value\"]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格分开，其中词列表中包含了一个value词，而且等号前面的“~”是不能省略的。\n\n  ```css\n  /*表示对应的属性词列表里有old就能匹配上*/\n  p[miaov~=old]\n  ```\n\n- p[attr^=\"value\"]：指定属性名，并且具有属性值，属性值是以value开头的。\n\n  ```css\n  p[miaov^=g]\n  ```\n\n- E[attr$=\"value\"]：指定属性名，有属性值，而且属性值是以value结束的，区分大小写\n\n- E[attr*=\"value\"]：指定属性名，有属性值，而且属性值中包含了value\n\n- E[attr|=\"value\"]：指定属性名，并且属性值是value或者以value-开头的值，如zh-cn\n\n### 结构选择器\n\n- E:nth-child(n) 标识E父元素中的第n个节点 （CSS3中是从1开始计数，而不是0）\n  - p:nth-child(odd){background:red} 匹配奇数行，并且这个元素是p标签\n  - p:nth-child(even){background:red} 匹配偶数行，并且这个元素是p标签。\n  - p:nth-child(2n){background:red} 匹配偶数行，n表示自然数，这里可以计算，比如说（2n-1）\n- E:nth-last-child(n) 表示E父元素中的第n个子节点，从后往前计算\n- E:nth-of-type(n) 表示E父元素中的第n个子节点，类型为E\n- E:nth-last-of-type(n) 表示E父级元素中的第n个子节点，类型为E，从后往前计算\n- E:empty 表示匹配E元素中没有子节点的，并且里面没有内容的。其实就是找一个空标签，有文字不行，在这里文字也算一个节点。\n- E:first-child  表示E元素中的第一个子节点，相当于nth-child(1)\n- E:last-child 表示E元素中的最后一个子节点，相当于nth-last-child(1)\n- E:first-of-type 表示E父元素中的第一个子节点且节点类型为E的，等价于nth-of-type(1)\n- E:last-of-type 表示E父元素中的最后一个子节点且节点类型为E的，等价于nth-last-of-type(1)\n- E:only-child 表示E元素中只有一个子节点，注意：子节点不包含文本节点\n- E:only-of-type：表示E的父元素只有一个子节点，且这个唯一的子节点类型必须是E，注意子节点不包含文本节点\n\n```html\n<!----实例示例：新浪导航------>\n样式：\n.list {list-style: none;margin: 0;padding:0;}\n.list li {width: 150px;float: left;border-right: 1px solid #000;}\n.list li:nth-last-child(1){border: none}\n.list li a{text-decoration: none;width: 40px;float: left;text-align: center;margin: 0 4px;font: 12px/30px 宋体 ;color:#000}\n.list a:nth-child(3n+1){font-weight: bold;}\n.list li:nth-child(3) a:nth-child(2){color: orange}\n\nhtml：\n<ul class=\"list\">\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n\n</ul>\n```\n\n### 伪类\n\n- E:target  匹配相关URL指向的E元素。\n\n  ```css\n  /*URL后面跟锚点#，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)，:target选择器用于选取当前活动的目标元素。*/\n  #demo:target{color:#f00;}\n\n  <div id=\"demo\">\n  \t<p>E:target伪类使用方法</p>\n  </div>\n  当访问连接为：www.example.com/#demo的时候，我们会发现字体变成了红色\n  ```\n\n- E:disabled  表示不可点击的表单控件 `input:enabled{background:red}`\n\n- E:enabled  表示可点击的表单控件\n\n- E:checked  表示已选中的checkbox或者radio，其实复选框也没有太多可以设置的。这个主要是配合使用的，配合选择后面的兄弟标签。\n\n  ```html\n  <!--点击对应的方块都会变红-->\n  <label>\n      <input type=\"radio\" name=\"tab\">\n      <span></span>\n  </label>\n  <label>\n      <input type=\"radio\" name=\"tab\">\n      <span></span>\n  </label>\n  <label>\n      <input type=\"radio\" name=\"tab\">\n      <span></span>\n  </label>\n\n  label{\n      float: left;\n      position: relative;\n      margin: 0 5px;\n      overflow: hidden;\n  }\n  label input{\n      position: absolute;\n      top: -50px;\n      left: -50px;\n  }\n  span{\n      float: left;\n      width: 50px;\n      height: 50px;\n      border: 3px solid #000;\n  }\n  ```\n\n- E:first-line  表示E元素中的第一行\n\n- E:first-letter 表示E元素中的第一个字符，设置了以后第一个字符不会被选中。\n\n- E::selection  表示E元素在用户选中文字时，触发的一个样式。比如设置选中以后背景色和文字颜色\n\n- E::before 生成内容在E元素前\n\n- E::after 生成内容在E元素后\n\n- E:not(s) 表示E元素不被匹配，帮我们排除掉一些元素\n\n  ```html\n  # 除了class=“h2”的就都被排除掉了。\n  h1:not(.h2){xxx}\n  ```\n\n- E~F表示E元素毗邻的F元素，往下找不往上找\n\n- Content属性\n\n  ```css\n  p::before{content: \"hahahaha\";display:block;}\n  ```\n\n## 文本新增属性\n\n### 新增颜色模式\n\n- rgba：rgba(0,0,0,0.5)；加给背景，背景透明，文字不透明。加给color可以使文字透明。给边框加，边框也可以变成透明的。\n\n  | r    | red   | 红   | 0~255 |\n  | ---- | ----- | ---- | ----- |\n  | g    | green | 绿   | 0~255 |\n  | b    | Blue  | 蓝色 | 0~255 |\n  | a    | Alpha | 透明 | 0~1   |\n\n### 文字阴影\n\n- text-shadow: x y blur color, …（文字可以有多层阴影，写多个就行了，不同的层之间用逗号隔开）\n- 参数：\n  - x：横向偏移，正数往右偏移\n  - y：纵向偏移，正数是从上往下偏移\n  - blur：模糊距离\n  - color：阴影颜色\n- 文本阴影如果加很多层，会很卡很卡很卡\n\n```css\n# 对阴影的一种巧妙的利用，会产生一种浮雕的感觉\n<h1>longfor</h1>\n\nh1{text-align:center; color:#ffffff;text-shadow: 2px 2px 4px #000000;}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-2/33669204.jpg)\n\n```css\n/*光晕的效果*/\nh1{\n    color: white;\n    text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px #ffffff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de,0 0 100px #ff00de,0 0 150px #ff00de;\n}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-2/42382960.jpg)\n\n```css\n/*火焰的效果*/\nh1{\n    color: white;\n    text-align: center;\n    text-shadow: 0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,-20px -60px 60px #cd4606,0 -80px 70px #973716,10px -90px 80px #451b0e;\n    font-family: Verdana,Geneva,sans-serif;\n    font-weight: bold;\n}\n```\n\n### 文字模糊效果\n\n```css\nh1{text-align: center;color:#000;text-shadow:0 0 0 rgba(0,0,0,1);\n    transition: 1s;}\nh1:hover{color:rgba(0,0,0,0);text-shadow: 0 0 20px rgba(0,0,0,0.2);}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-2/95067259.jpg)\n\n### 文字的描边：\n\n```css\n/*描边只适用于webkit内核的浏览器，而且写的时候要带上webkit的前缀*/\n/*两个参数，一个描边宽度，一个描边颜色*/\nh1{\n    text-align: center;\n    color:#000;\n    -webkit-text-stroke: 3px red;\n}\n```\n\n### Direction文字排列方式（全兼容）\n\n- Rtl从右向左排列\n- Ltr从左向右排列\n- 注意要配合unicode-bidi一块使用\n\n```css\n# 如果不使用unicode-bidi的话那么文字顺序不变，只是文字从右侧开始打印\n# 如果使用上unicode-bidi的话那么文字顺序也会随着改变\nh1{text-align: center;direction: rtl;unicode-bidi: bidi-override;}\n```\n\n### Text-overflow定义省略文本的处理方式（全兼容）\n\n- clip 无省略号\n- Ellipsis 省略号（注意配合overflow:hidden和white-space:nowrap一起使用）\n  - white-space:nowrap可以使文字超出以后不换行\n  - overflow:hidden 使得超出部分隐藏\n\n```css\ntext-overflow:ellpsis\n```\n\n### 自定义字体\n\n```css\n略\n```\n\n## 盒模型\n\n### 弹性盒模型\n\n> 注意在使用弹性盒模型的时候，父元素必须要加display:box或者display:inline-box，同时要加上浏览器的内核比如：`display:-webkit-box`。加上box属性了会看上去像左浮动一样。因为默认的box-orient就是Horizontal横向显示的。\n\n- box-orient 定义盒模型的布局方向：`-webkit-box-orient:vertical;`\n\n  - Horizontal 水平显示\n  - vertical 垂直方向\n\n- box-direction 元素排列顺序：`-webkit-box-direction:reverse;`\n\n  - Normal 正序\n  - Reverse 逆序，即使是逆序显示但是还是靠左的，富裕空间在右侧，可以通过box-pack调整\n\n- box-ordinal-group 设置元素的具体位置\n\n  ```css\n  # 找到正常顺序中的第一个，让它显示在第二个\n  .box div:nth-of-type(1){-webkit-box-ordinal-group:2;}\n  ```\n\n- box-flex 定义盒子的弹性空间\n\n  - 子元素的尺寸=盒子的尺寸*子元素的box-flex属性值/所有子元素的box-flex属性值的和（其实就是这有一排盒子你在这排盒子里占了多少的百分比，乘以盒子的尺寸那么就是你的，尺寸，这个尺寸是自适应的，比如说有一部分已经固定了，那么其他部分会自适应）\n\n    $\\frac{子元素box-flex属性值}{所有子元素box-flex属性值之和}$\\times$盒子尺寸\n\n    ```css\n    # example\n    <div class=\"box\">\n        <div>1</div>\n        <div>2</div>\n        <div>3</div>\n    </div>\n\n    .box{height:100px;border:3px solid #000;padding:3px;display: -webkit-box;}\n    .box div{height: 100px;background: pink;border:1px solid brown; }\n    .box div:nth-of-type(1){width: 300px;}\n    .box div:nth-of-type(2){-webkit-box-flex:1}\n    .box div:nth-of-type(3){-webkit-box-flex:9}\n    ```\n\n- box-pack对盒子富裕空间进行管理（水平方向）\n\n  - Star 所有子元素在盒子左侧显示，富裕空间在右侧\n\n  - End 所有子元素在盒子右侧显示，富裕空间在左侧（可以产生一个右浮动的效果）\n\n    ![](http://omk1n04i8.bkt.clouddn.com/18-4-3/91875351.jpg)\n\n  - Center 所有子元素居中\n\n  - Justify 富裕空间在子元素中平均分布\n\n    ![](http://omk1n04i8.bkt.clouddn.com/18-4-3/57241073.jpg)\n\n- box-align 在垂直方向上对元素的位置进行管理(-webkit-box-align)\n\n  - Star 所有子元素在据顶\n  - End 所有子元素在据底\n  - Center 所有子元素居中\n\n### 盒模型的阴影\n\n- box-shadow:[inset] x y blur [spread] color （这个也是可以多层叠加的，层之间用逗号隔开）\n  - inset：投影方式\n    - inset：内投影\n    - 不给：外投影\n  - x,y：x轴和y轴的偏移距离\n  - blur：模糊半径\n  - spread：扩展阴影半径\n    - 先扩展原有形状，再开始画阴影\n  - color：阴影颜色\n\n### 其他盒模型属性\n\n- box-reflect 倒影，目前只在webkit内核下的浏览器实现了，是以使用的时候要加上webkit的前缀\n\n  - direction 方向   above | below | right | left；  （镜像显示）\n  - 距离，可选参数，是倒影和元素之间的距离。\n  - 渐变（可选）：`-webkit-linear-gradient(right,rgba(0,0,0,1) 0,rgba(0,0,0,0) 100%)`\n\n- resize自由缩放\n\n  - Both 水平垂直都可以缩放\n  - Horizontal 只有水平方向可以缩放\n  - Vertical 只有垂直方向可以缩放\n  - none 不能缩放\n  - 注意：一定要配合overflow：auto 一块使用\n\n- box-sizing 盒模型解析模式（比较鸡肋）\n\n  - Content-box 标准盒模型（width/height=border+padding+content）\n  - Border-box 怪异盒模型 width/height=content\n\n  ```css\n  # 针对如下这一个示例\n  <div class=\"box\">\n      <div>1</div>\n  </div>\n\n  .box{width:200px;height:200px;border:10px solid red;padding:10px;}\n  .box div{background: greenyellow}\n\n  在标准盒模型中，box内部的div会继承外部box的宽度也就是200px，200加上两边的border和两边的padding，那么总宽度应该是200+20+20=240；\n\n  # 但是当设置为怪异盒模型的时候\n  .box{width:200px;height:200px;border:10px solid red;padding:10px;box-sizing: border-box}\n  .box div{background: greenyellow}\n\n  整体的父级宽度就被卡死了，就是200px，那么content的内容就等于200-10*2-10*2=160px,可以发现整体变小了。\n  ```\n\n## 响应式布局\n\n### CSS3分栏布局\n\n> 目前只有webkit内核实现了这个功能，因此记得加上webkit的前缀\n\n- column-width 栏目宽度：只限制栏目的宽度的时候，列数浏览器会去为我们进行计算\n- column-count 栏目列数：只设置列数的时候，浏览器会自动为我们计算每一栏的宽度\n- column-gap 栏目距离：设置每一栏的间隔\n- column-rule 栏目间隔线，栏目分割线的写法和border是一样的，比如1px solid #000\n\n**响应式布局的设置**\n\n```html\n# 其实是通过media来进行实现的，不兼容ie6，7，8，在这几种情况下只能通过js判断浏览器宽度，根据不同的宽度引入不同的样式表。\n\n# 800px以上引用\n<link rel=\"stylesheet\" type=\"text/css\" href=\"A.css\" media=\"screen and (min-width:800px)\">\n\n# 400~800之间\n<link rel=\"stylesheet\" type=\"text/css\" href=\"B.css\" media=\"screen and (min-width:400px) and (max-width:800px)\">\n\n# 小于400的时候引入的样式表\n<link rel=\"stylesheet\" type=\"text/css\" href=\"C.css\" media=\"screen and  (max-width:400px)\">\n\n## 直接使用style的方式进行响应式的控制而不是使用引用样式表\n@media screen and (min-width:400px) and (max-width:500px) {.box{margin:0 auto;}}\n```\n\n**横屏竖屏**\n\n```html\n# 竖屏，当屏幕的宽度小于高度的时候。\n<link rel=\"stylesheet\" type=\"text/css\" href=\"portrait.css\" media=\"all and (orientation:portrait)\">\n# 横屏\n<link rel=\"stylesheet\" type=\"text/css\" href=\"landscape.css\" media=\"all and (orientation:landscape)\">\n```\n\n## 新的UI样式\n\n### 圆角\n\n- border-radius:1-4个数字/1-4个数字\n  - 前面是水平，后面是垂直\n  - 不给“/”则水平和垂直一样\n    - border-radius：10px/5px;\n- 参数\n  - 各种长度单位都可以：px，% ……\n  - %有时候很方便\n    - 但是宽度不一致时不太好\n\n```css\n# 第一个值左上角+右下角，第二个值右上角+左下角\nborder-radius: 20px 40px\n# 左上角，右上角+左下角，右下角\nborder-radius: 20px 30px 40px;\n# 从左上角开始顺时针旋转\nborder-radius: 10px 20px 30px 40px;\n# 画一个椭圆，x轴和y轴的半径就不一样了，这种情况下可以分别制定xy二轴的半径\nborder-radius: 100px/150px  (分别对应x轴半径和y轴半径)\n# x和y轴的半径还可以整体加，比如\nborder-radius: 20px 40px 60px 80px/10px 20px 30px 40px;\n# 使用百分比\nborder-radius: 50%\n```\n\n使用圆角的功能去做一个风车的效果：\n\n```html\n<style>\n.box{width:200px;height:200px;margin:50px auto; transition:5s linear;}\n.box div{width:80px;height:80px;margin:10px;border:1px solid #000; box-sizing:border-box;float:left;background:orange;}\n.box div:nth-child(1),.box div:nth-child(4){ border-radius:0 70%;}\n.box div:nth-child(2),.box div:nth-child(3){ border-radius:70% 0;}\n/*这里用到了一个旋转，rotate，后面的720deg指的是720°*/\n.box:hover{ -webkit-transform:rotate(720deg);}\n</style>\n</head>\n<body>\n<div class=\"box\">\n\t<div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n</div>\n```\n\n### 边框背景\n\n> 内容参考：\n>\n> - https://www.cnblogs.com/rain-null/p/6677913.html\n> - http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/\n> - https://blog.csdn.net/foreverling_ling/article/details/52247649\n\n- border-image\n  - border-image-source 引入图片\n  - border-image-slice 切割图片; 0 10，第一个值是上下切，第二个值是左右切，不带px\n  - border-image-width 边框宽度\n  - border-image-repeat 图片的排列方式\n    - round 平铺，repeat 重复，stretch 拉伸（默认）\n\nborder-image工作原理就是把图片切割成九块（九宫格），然后对应到边和角。\n\n```css\n# border-image是一个复合样式\n\n# 只设置一张图片的话会把完整的图片填充到四个角\nborder-image: url(\"/static/imgs/border/border.png\")\n\n# 关于图片的切割，接收大小默认单位就是px，不用手写，否则就无法识别。\nborder-image-slice: 10;   /*距离上下左右均为10px;*/\nborder-image-slice: 10 30;   /*距离上下10px,左右30px;*/\nborder-image-slice: 10 30 20;   /*距离上10px,下20px,左右30px;*/\nborder-image-slice: 10 30 20 40;   /*距离上10px,右30px,下20px,左40px;*/\n```\n\n- border-colors 边框颜色\n\n###渐变\n\n#### 线性渐变\n\n \n\n","timestamp":1526030685669},{"name":"98-常见样式布局.md","path":"10-前端/02-CSS/98-常见样式布局.md","content":"\n\n\n\n- 渐变\n\n```css\n.gradient{    \n\t/*top指的是从上到下，left指的是从左到右，top left指的是从左上角到右下角*/\n    /*firefox*/\n    background: -moz-linear-gradient(top,#FFFFFF,#f8f8f8);\n    /*chrome core*/\n    background: -webkit-linear-gradient(top,#FFFFFF,#f8f8f8);\n    /*common*/\n    background: linear-gradient(top,#FFFFFF,#f8f8f8);\n}\n```\n\n| **渐变模式**                                 | 渐变效果                                     |\n| ---------------------------------------- | ---------------------------------------- |\n| 纵向渐变：background: linear-gradient(to bottom, blue, white); | <img src=\"http://omk1n04i8.bkt.clouddn.com/18-1-25/42803622.jpg\" style=\"width:100px;height:100px\" /> |\n| 横向渐变：background: linear-gradient(to right, blue, white); | <img src=\"http://omk1n04i8.bkt.clouddn.com/18-1-25/24963190.jpg\" style=\'width:100px;height:100px;\'> |\n| 对角线方向的渐变：background: linear-gradient(to bottom right, blue, white); | <img src=\"http://omk1n04i8.bkt.clouddn.com/18-1-25/79186286.jpg\" style=\'width:100px;height:100px;\'> |\n\n","timestamp":1526030685669},{"name":"07-07、BootStrap.md","path":"10-前端/02-CSS/99-CSS框架/07-07、BootStrap.md","content":"# BootStrap\n\n> https://github.com/twbs\n>\n> bootstrap是移动优先的。\n>\n> bootstrap的JS是基于Jquery的，因此自己下载一个Jquery放到js文件夹\n\n## 栅格系统\n\n把整个页面分成12列，同时支持响应式。表示一行的class就是row，表示一列的class就是col。\n\n- 容器\n\n  - container-fluid\n\n    - 流体（平铺整体百分百），这个流体平铺的布局并不会顶格，他有一个padding值。\n\n  - container\n\n    - 固定（居中）\n    - 1170（默认是1170，根据不同的分辨率会显示为不同的width）\n    - 970\n    - 750\n    - auto\n\n    ```html\n    不同分辨率其实是存在一个阈值\n    - 1200>= 较大的分辨率的设备  col-lg-xx，低于1200就会纵向排列\n    - 992>=  中等屏幕的设备      col-md，低于992会纵向排列\n    - 768>=  相当于pad的尺寸      col-sm-xx，小于768会纵向排列\n    - 768<   小于768就是手机的尺寸    col-xs-xx，永远都是水平的\n    ```\n\n不要把container和container-flued嵌套使用。可以作为兄弟存在，比如header用流体的，body用container。\n\n如果一列多了12个格子就会被挤到第二行。\n\n### 栅格的组合模式\n\n```html\n<div class=\'row\'>\n  <!--依此根据class进行匹配-->\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n</div>\n在大屏幕分辨率的时候，一个是占用3个格子，也就是四个，当达到了md的阈值的时候就是12/4=3，一行3个，然后当到了sm阈值的时候就是一行两个。再小就是一行一个了。\n```\n\n#### 栅格系统中的列偏移\n\n```html\n#  向右偏移四个网格的距离，假如偏移10个就会出去，做多可以写12，整个都偏移出去，超过12或者小于1都是不起作用的。当达到了lg的阈值的时候就会进行纵向排列，不受偏移的影响了。\n<div class=\'col-lg-4 col-lg-offset-4\'></div>\n# 当没有设置栅格的网格大小，而只设置了偏移那么可以根据偏移去自动设置栅格大小哦，比如偏移为4，那么栅格大小就为12-4=8。列偏移同样适用于多种栅格混合适合用。\n```\n\n#### 列排序\n\n```html\n# 比如有两个，我想让这俩互换顺序。\n<div class=\"col-lg-2\"></div>\n<div class=\"col-lg-10\"></div>\n# push是向后，pull是往前拉，第一个往后推10个格子，第二个往前拉两个格子\n<div class=\"col-lg-2 col-lg-push-10\"></div>\n<div class=\"col-lg-10 col-lg-pull-2\"></div>\n```\n\n那么列排序和偏移和什么区别呢？\n\n- offset只能往右偏，但是排序可以使用pull和push向前向后。\n- offset还存在一个问题就是当有多个元素存在的情况下如果这一行撑满了，那么就会跳转到下一行进行偏移。比如一行有两个div都是col-lg-4，右侧的div的offset设置为5的时候可想而知，4+5+4=13，一行撑满了，因此右侧的div会直接跳转到第二行，然后offset出来5个格子。那么如果有这种需求的时候就可以使用排序来做了。\n\n#### 栅格系统的嵌套\n\nrow和row之间是可以互相嵌套的，宽度会按照父级的宽度进行12个网格的分配。\n\n如果一行有三个div分别为6,3,3的网格占位，如果6中的内容很多会单独把这个网格撑开，比如：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-4/17459743.jpg)\n\n那么假如我再加一个col，会变成如下的情况，因为本身这些内容更都是基于浮动的。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-4/55780879.jpg)\n\n如果想要另起一行显示需要清除浮动。\n\n```html\n<div class=\"row\">\n            <div class=\"col-lg-6 \" id=\"box1\">很多的文字</div>\n            <div class=\"box2 col-lg-3 \">col-lg-3</div>\n            <div class=\"box2 col-lg-3 \">col-lg-3</div>\n            <div class=\"clearfix\"></div>\n            <div class=\"box2 col-lg-3 \">col-lg-3</div>\n</div>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-4/46976091.jpg)\n\n当然如果你另起一个row的话就是另起一行了。\n\n\n\n","timestamp":1526030685669},{"name":"01-ECMA对象.md","path":"10-前端/03-原生JS/01-ECMA对象.md","content":"# ECMA对象\n## 目录\n\n[TOC]\n\n>从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。\n>\n>var o = new Object();\n\n## 对象的概念和分类\n\n- 由ECMAScript定义的本地对象.独立于宿主环境的 ECMAScript 实现提供的对象.(native object)\n- ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现.这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。（built-in object）\n- 所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象。\n\n**object对象**：ECMAScript 中的所有对象都由这个对象继承而来；Object 对象中的所有属性和方法都会出现在其他对象中\n\n```\nToString() :  返回对象的原始字符串表示。\nValueOf()  : 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。\n```\n\n### **11**种内置对象\n\n**包括：**\n\n**Array ,String , Date, Math, Boolean, Number Function, Global, Error, RegExp , Object**\n\n**简介：**\n\n在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，String、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是通过对象实现的，比如：\n\n```javascript\n<script language=\"javascript\">\nvar aa=Number.MAX_VALUE; \n//利用数字对象获取可表示最大数\nvar bb=new String(\"hello JavaScript\"); \n//创建字符串对象\nvar cc=new Date();\n//创建日期对象\nvar dd=new Array(\"星期一\",\"星期二\",\"星期三\",\"星期四\"); \n//数组对象\n</script>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/98355586.jpg)\n\n## 字符串对象\n\n```javascript\n# 调用字符串的对象属性或方法时自动创建对象，用完就丢弃\nvar s = \'hello\'                 # type:string\n# 手工创建字符串对象，采用new创建字符串对象str1，全局有效。\nvar s = new String(\'Hello\')     # type:object\n```\n\n### 字符串常用方法\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/17422823.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/63109260.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/95793116.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/47610132.jpg)\n\n```javascript\n# 获取字符串的长度\nvar s = \'hello world\'\ns.length                 # 结果：11\n\n# 获取指定位置的字符\ns.charAt(3)              # 结果：l\n\n# 书写格式:\nString对象提供了一组针对HTML格式的方法，如x.anchor()返回锚定义字符串<a>x</a>，\nx.bold()返回粗体表示字符串<b>x</b>，x.sup()返回上标格式字符串<sup>x</sup>。\n-----------------------------------------\n\nvar x=\"yuan\";\nvar y=\"x.italics():\"+x.italics();\ndocument.write(y.fontsize(10));//<font size=\"10\">x.italics():<i>yuan</i></font>\n\n# 字符串的正则表达式\n//使用注解\n//\n//x代表字符串对象\n//\n//regexp代表正则表达式或字符串\n//\n//match返回匹配字符串的数组，如果没有匹配则返回null\n//\n//search返回匹配字符串的首字符位置索引\n//-------------------------------------\nvar str1=\"welcome to the world of JS!\";\nvar str2=str1.match(\"world\"); \n# str2 -> [\"world\", index: 15, input: \"welcome to the world of JS!\"]\nvar str3=str1.search(\"world\");\nalert(str2[0]);\n//结果为\"world\"，因为str2的结果是一个列表。\nalert(str3);\n//结果为15，返回的是索引的位置\n\n# 顾头不顾尾\nvar s = \'hello world\'\nalert(s.substring(3,5))  # 结果为：\"lo\"，只打印3~4\nalert(s.substr(3,5))    # 结果为：\"lo wo\" 从索引为3的位置开始，打印长度为5\nalert(s.slice(1,4))     # 这个就和python的列表的切片很相似了。\nalert(s.slice(2)))      # 从索引为2的位置到最后\nalert(s.slice(-4,-1))   # 结果为：\"orl\"\n```\n\n字符串的替换\n\n```javascript\n//x.replace(findstr,tostr)\n\nvar str1=\"abcdefgh\";\nvar str2=str1.replace(\"cd\",\"aaa\");\nalert(str2);\n//结果为\"abaaaefgh\"\n```\n\n字符串的分割\n\n```javascript\nvar str1=\"一,二,三,四,五,六,日\"; \n\nvar strArray=str1.split(\",\");\n\nalert(strArray[1]);\n//结果为\"二\"\n```\n\n字符串的拼接\n\n```javascript\n//y=x.concat(addstr)\n//\n//使用注解\n//\n//x代表字符串对象\n//addstr为添加字符串\n//返回x+addstr字符串\n    \nvar str1=\"abcd\"; \nvar str2=str1.concat(\"efgh\");\n\nalert(str2);\n//结果为\"abcdefgh\" \n```\n\n## 数组对象\n\n创建数组对象：\n\n```javascript\nArray 对象用于在单个的变量中存储多个值。\n语法:\n\n创建方式1:\nvar a=[1,2,3];\n\n创建方式2:\nnew Array();     //  创建数组时允许指定元素个数也可以不指定元素个数。\nnew Array(size);//if 1个参数且为数字,即代表size,not content\n    初始化数组对象:\n    var cnweek=new Array(7);\n        cnweek[0]=\"星期日\";\n        cnweek[1]=\"星期一\";\n        ...\n        cnweek[6]=\"星期六\";\n\nnew Array(element0, element1, ..., elementn)//也可以直接在建立对象时初始化数组元素，元素类型允许不同\n\nvar test=new Array(100,\"a\",true);\n```\n\n创建二维数组\n\n```javascript\nvar cnweek=new Array(7);\nfor (var i=0;i<=6;i++){\n    cnweek[i]=new Array(2);\n}\ncnweek[0][0]=\"星期日\";\ncnweek[0][1]=\"Sunday\";\ncnweek[1][0]=\"星期一\";\ncnweek[1][1]=\"Monday\";\n...\ncnweek[6][0]=\"星期六\";\ncnweek[6][1]=\"Saturday\";\n```\n\nArray对象的属性：\n\n```javascript\n# 获取数组元素的个数：length\nvar cnweek=new Array(7);\ncnweek[0]=\"星期日\";\ncnweek[1]=\"星期一\";\ncnweek[2]=\"星期二\";\ncnweek[3]=\"星期三\";\ncnweek[4]=\"星期四\";\ncnweek[5]=\"星期五\";\ncnweek[6]=\"星期六\";\nfor (var i=0;i<cnweek.length;i++){\n  document.write(cnweek[i]+\" | \");\n}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/88028889.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/80226406.jpg)\n\nJoin方法\n\n```javascript\n//书写格式\n//x.join(bystr)\n//使用注解\n//\n//x代表数组对象\n//bystr作为连接数组中元素的字符串\n//返回连接后的字符串\n//与字符串的split功能刚好相反\n    \nvar arr1=[1, 2, 3, 4, 5, 6, 7];\n\nvar str1=arr1.join(\"-\");\n\nalert(str1);\n//结果为\"1-2-3-4-5-6-7\" \n```\n\nconcat链接方法：\n\n```javascript\n//连接数组-concat方法\n//\n//x.concat(value,...)\n\n\nvar a = [1,2,3];\nvar a = new Array(1,2,3);\nvar b=a.concat(4,5) ; # 等价于var b = a.concat([4,5])\n\n\nalert(a.toString());\n//返回结果为1,2,3\nalert(b.toString());\n//返回结果为1,2,3,4,5\n```\n\n数组逆序：\n\n```javascript\n//x.reverse()\n\nvar arr1=[32, 12, 111, 444];\n//var arr1=[\"a\",\"d\",\"f\",\"c\"];\n\narr1.reverse(); //颠倒数组元素，单纯的颠倒不排序\nalert(arr1.toString());\n//结果为444,111,12,32\n```\n\n数组的排序是按照最高位的默认形式去排的，比如112和25,112会排在前面。其实实际上排的是ascii表的数字，看一下下面这个例子：\n\n```javascript\n>> var s = [11,23,112,87,\'abc\',\'%\',\'@\']\n>> s.sort()\n<< (7) [\"%\", 11, 112, 23, 87, \"@\", \"abc\"]\n# 如上的记录，对比的都是第一个字符在ascii表中对应的数字：\n- % : 37\n- 1 : 49 \n- 2 : 50\n- 8 : 56\n- @ : 64\n- a : 97\n按照上面的标准得到如上的排序结果\n\n# 那么其实按照上面的结果并不符合我们实际理想中的要求，因此要达到我们想要的结果那就只能自己写函数拉。\n# 两个参数比较来返回对应的值\nfunction intSort(a,b){\n    if (a>b){\n        return 1;//-1\n    }\n    else if(a<b){\n        return -1;//1\n    }\n    else {\n        return 0\n    }\n}\n# 等价于\n\nfunction IntSort(a,b){\n    return a-b;\n}\n\n# 将我们定义的函数作为参数传递给sort，sort就会按照咱们的依据进行排序。其实相当于重写sort\narr.sort(intSort);\nalert(arr);\n```\n\n数组的切片：\n\n```javascript\n//x.slice(start, end)\n//\n//使用注解\n//\n//x代表数组对象\n//start表示开始位置索引\n//end是结束位置下一数组元素索引编号\n//第一个数组元素索引为0\n//start、end可为负数，-1代表最后一个数组元素\n//end省略则相当于从start位置截取以后所有数组元素\n\nvar arr1=[\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\',\'h\'];\nvar arr2=arr1.slice(2,4);\nvar arr3=arr1.slice(4);\nvar arr4=arr1.slice(2,-1);\n\nalert(arr2.toString());\n//结果为\"c,d\" \nalert(arr3.toString());\n//结果为\"e,f,g,h\"\nalert(arr4.toString());\n//结果为\"c,d,e,f,g\"\n```\n\n删除子数组\n\n```javascript\n//x. splice(start, deleteCount, value, ...)\n//\n//使用注解\n//\n//x代表数组对象\n//splice的主要用途是对数组指定位置进行删除和插入\n//start表示开始位置索引\n//deleteCount删除数组元素的个数\n//value表示在删除位置插入的数组元素\n//value参数可以省略\n\n\nvar a = [1,2,3,4,5,6,7,8];\na.splice(1,2);            //a变为 [1,4,5,6,7,8]\nalert(a.toString());\na.splice(1,1);            //a变为[1,5,6,7,8]\nalert(a.toString());\na.splice(1,0,2,3);        //a变为[1,2,3,5,6,7,8]\nalert(a.toString());\n\n# 那么其实就可以达到一个效果是先删除再添加，比如\n>> var a = [1,2,3,4,5]\n>> a.splice(2,2,\'lamber\',\'mxy\')\n<< (2) [3, 4]\n>> a\n<< (5) [1, 2, \"lamber\", \"mxy\", 5]\n\n# 那么我们其实可以利用这个特点完成一个简单的替换，但是实际也可以不这么使用\n>> var a = [1,2,3,\'lamber\']\nundefined\n>> a.splice(3,1,\'maxiaoyu\')\n[\"lamber\"]\n>> a\n(4) [1, 2, 3, \"maxiaoyu\"]\n```\n\n数组的进出栈操作\n\n```javascript\n//push pop这两个方法模拟的是一个栈操作\n\n//x.push(value, ...)  压栈，压到数组的队尾\n//x.pop()             弹栈，弹出也是弹出的最后一个     \n//使用注解\n//\n//x代表数组对象\n//value可以为字符串、数字、数组等任何值\n//push是将value值添加到数组x的结尾\n//pop是将数组x的最后一个元素删除\n\n\nvar arr1=[1,2,3];\narr1.push(4,5);\nalert(arr1);\n//结果为\"1,2,3,4,5\"\narr1.push([6,7]);\nalert(arr1)\n//结果为\"1,2,3,4,5,6,7\"\narr1.pop();\nalert(arr1);\n//结果为\"1,2,3,4,5\"\n```\n\nshift和unshift\n\n```javascript\n// unshift shift \n//x.unshift(value,...)\n//x.shift()\n//使用注解\n//\n//x代表数组对象\n//value可以为字符串、数字、数组等任何值\n//unshift是将value值插入到数组x的开始，压入到数组头部\n//shift是将数组x的第一个元素删除，把首位的删除\n其实就是一个后进先出的过程\n\nvar arr1=[1,2,3];\narr1.unshift(4,5);\nalert(arr1);\n//结果为\"4,5,1,2,3\"\narr1. unshift([6,7]);\nalert(arr1);\n//结果为\"6,7,4,5,1,2,3\"\narr1.shift();\nalert(arr1);\n//结果为\"4,5,1,2,3\"\n```\n\n小结：\n\n```javascript\n//  js中数组的特性\n         //java中数组的特性,  规定是什么类型的数组,就只能装什么类型.只有一种类型.\n         //js中的数组特性1: js中的数组可以装任意类型,没有任何限制.\n         //js中的数组特性2: js中的数组,长度是随着下标变化的.用到多长就有多长.\n         var arr5 = [\'abc\',123,1.14,true,null,undefined,new String(\'1213\'),new Function(\'a\',\'b\',\'alert(a+b)\')];\n        /*  alert(arr5.length);//8\n         arr5[10] = \"hahaha\";\n         alert(arr5.length); //11\n         alert(arr5[9]);// undefined */\n```\n\n## Date对象\n\nDate对象的创建\n\n```javascript\n//方法1：不指定参数\nvar date1=new Date();\nalert(date1.toLocaleString( ));   # 只有date对象有toLocaleString这个方法\n# date1返回的结果为：Wed Nov 22 2017 10:43:41 GMT+0800 (中国标准时间)\n# date1.toLocaleString的返回结果为：\"2017/11/22 上午10:43:41\"\n\n//方法2：参数为日期字符串，获取指定日期的。\nvar nowd2=new Date(\"2004/3/20 11:12\");\n>> nowd2.toLocaleString( )\n<< \"2004/3/20 上午11:12:00\"\nvar nowd3=new Date(\"04/03/20 11:12\");\n>> nowd3.toLocaleString( )\n<< \"2020/4/3 上午11:12:00\"\n\n//方法3：传一个时间戳进去，只不过参数单位为毫秒数\nvar nowd3=new Date(5000);\nalert(nowd3.toLocaleString( ));\nalert(nowd3.toUTCString());\n\n//方法4：参数为年月日小时分钟秒毫秒\nvar nowd4=new Date(2004,2,20,11,12,0,300);\n>> nowd4.toLocaleString( );\n<< \"2004/3/20 上午11:12:00\"\n//毫秒并不直接显示，注意这里这个月份，0表示1月份，1表示2月份，是从0开始的，而不是1，因此上面的结果就是3月20号，而不是2月20号。\n```\n\nDate对象获取时间的一些方法：\n\n```javascript\n获取日期和时间\ngetDate()                 获取日\ngetDay ()                 获取星期\ngetMonth ()               获取月（0-11）\ngetFullYear ()            获取完整年份\ngetYear ()                获取年\ngetHours ()               获取小时\ngetMinutes ()             获取分钟\ngetSeconds ()             获取秒\ngetMilliseconds ()        获取毫秒\ngetTime ()                返回累计毫秒数(从1970/1/1午夜)\n```\n\n小练习：拼一个完整的日期：\n\n```javascript\nfunction getCurrentDate(){\n        //1. 创建Date对象\n        var date = new Date(); //没有填入任何参数那么就是当前时间\n        //2. 获得当前年份\n        var year = date.getFullYear();\n        //3. 获得当前月份 js中月份是从0到11.\n        var month = date.getMonth()+1;\n        //4. 获得当前日\n        var day = date.getDate();\n        //5. 获得当前小时\n        var hour = date.getHours();\n        //6. 获得当前分钟\n        var min = date.getMinutes();\n        //7. 获得当前秒\n        var sec = date.getSeconds();\n        //8. 获得当前星期\n        var week = date.getDay(); //没有getWeek\n        // 2014年06月18日 15:40:30 星期三\n        return year+\"年\"+changeNum(month)+\"月\"+day+\"日 \"+hour+\":\"+min+\":\"+sec+\" \"+parseWeek(week);\n    }\n\nalert(getCurrentDate());\n\n//解决 自动补齐成两位数字的方法\n    function changeNum(num){\n    if(num < 10){\n        return \"0\"+num;\n    }else{\n        return num;\n    }\n\n}\n//将数字 0~6 转换成 星期日到星期六，因为获取兴趣返回的只是0~6的数值。我们要返回我们想要的内容可以自己定义个函数去映射\n    function parseWeek(week){\n    var arr = [\"星期日\",\"星期一\",\"星期二\",\"星期三\",\"星期四\",\"星期五\",\"星期六\"];\n    //             0      1      2      3 .............\n    return arr[week];\n}\n```\n\nDate对象设置时间的一些方法：\n\n```javascript\n//设置日期和时间\n//setDate(day_of_month)       设置日\n//setMonth (month)                 设置月\n//setFullYear (year)               设置年\n//setHours (hour)         设置小时\n//setMinutes (minute)     设置分钟\n//setSeconds (second)     设置秒\n//setMillliseconds (ms)       设置毫秒(0-999)\n//setTime (allms)     设置累计毫秒(从1970/1/1午夜)\n    \nvar x=new Date();\nx.setFullYear (1997);    //设置年1997\nx.setMonth(7);        //设置月7，实际是8月，写JavaScript的人脑子有坑，这块没法改了，记住\nx.setDate(1);        //设置日1\nx.setHours(5);        //设置小时5\nx.setMinutes(12);    //设置分钟12\nx.setSeconds(54);    //设置秒54\nx.setMilliseconds(230);        //设置毫秒230\ndocument.write(x.toLocaleString( )+\"<br>\");\n//返回1997年8月1日5点12分54秒\n\nx.setTime(870409430000); //设置累计毫秒数\ndocument.write(x.toLocaleString( )+\"<br>\");\n//返回1997年8月1日12点23分50秒  \n```\n\nDate对象方法：日期和时间的转换\n\n```javascript\n日期和时间的转换:\n\ngetTimezoneOffset():8个时区×15度×4分/度=480;\n返回本地时间与GMT的时间差，以分钟为单位\ntoUTCString()\n返回国际标准时间字符串\ntoLocaleString()\n返回本地格式时间字符串\nDate.parse(x)\n返回累计毫秒数(从1970/1/1午夜到本地时间)，比如：Date.parse(\'2014/04/20\')\nDate.UTC(x)\n返回累计毫秒数(从1970/1/1午夜到国际时间)\n```\n\n## Math对象\n\n```javascript\n    //Math对象\n    //该对象中的属性方法 和数学有关.\n    //Math是内置对象 , 与Global的不同之处是, 在调用时 需要打出 \"Math.\"前缀.\n    //属性学习:\n    //alert(Math.PI);\n    //方法学习:\n        //alert(Math.random()); // 获得随机数 0~1 不包括1.\n        //alert(Math.round(1.5)); // 四舍五入\n        //练习：获取1-100的随机整数，包括1和100\n             //var num=Math.random();\n            //num=num*10;\n            //num=Math.round(num);\n            // alert(num)\n        //============max  min=========================\n        /* alert(Math.max(1,2));// 2\n        alert(Math.min(1,2));// 1 */\n        //-------------pow--------------------------------\n        alert(Math.pow(2,4));// pow 计算参数1 的参数2 次方.\n        \n\n\n\nabs(x)    返回数的绝对值。\nexp(x)    返回 e 的指数。\nfloor(x)  直接取整。\nlog(x)    返回数的自然对数（底为e）。\nmax(x,y)  返回 x 和 y 中的最高值。\nmin(x,y)  返回 x 和 y 中的最低值。\npow(x,y)  返回 x 的 y 次幂。\nrandom()  返回 0 ~ 1 之间的随机数。\nround(x)  把数四舍五入为最接近的整数。\nsin(x)    返回数的正弦。\nsqrt(x)   返回数的平方根。\ntan(x)    返回角的正切。\n\n# 生成一个0~100的随机整数\nMath.round(Math.random()*100)\n```\n\n## RegExp对象\n\n```javascript\n//RegExp对象\n    // 在表单验证时使用该对象验证用户填入的字符串是否符合规则.\n    //创建正则对象方式1  参数1 正则表达式  参数2 验证模式  g global / i 忽略大小写. //参数2一般填写g就可以，也有“gi”.\n    // 用户名 首字母必须是英文, 除了第一位其他只能是英文数字和_ . 长度最短不能少于6位 最长不能超过12位\n    //----------------------------创建方式1\n    /* var reg1 = new RegExp(\"^[a-zA-Z][a-zA-Z0-9_]{5,11}$\",\"g\");\n    //\n    //验证字符串\n    var str = \"bc123\";\n    alert(reg1.test(str));// true\n    \n    //----------------------------创建方式2  /填写正则表达式/匹配模式;\n    var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/g;\n    \n    alert(reg2.test(str));// true\n     */\n    //-------------------------------正则对象的方法-------------------\n        //test方法  ==>  测试一个字符串是否复合 正则规则. 返回值是true 和false.\n    \n    //-------------------------String 中与正则结合的4个方法------------------.\n    // macth search split replace\n    var str = \"hello world\";\n    \n    //alert(str.match(/o/g)); //查找字符串中 复合正则的 内容.\n    //alert(str.search(/h/g));// 0  查找字符串中符合正则表达式的内容位置\n    //alert(str.split(/o/g)); // 按照正则表达式对字符串进行切割. 返回数组;\n    alert(str.replace(/o/g, \"s\")); // hells wsrld  对字符串按照正则进行替换.\n```\n\n## 函数对象(Important)\n\n函数的定义：\n\n```javascript\nfunction 函数名 (参数){\n    函数体;\n    return 返回值;\n}\n```\n\n**功能说明：**\n\n- 可以使用变量、常量或表达式作为函数调用的参数\n- 函数由关键字function定义\n- 函数名的定义规则与标识符一致，大小写是敏感的\n- 返回值必须使用return\n\n函数如果没有设置返回值的时候，默认会返回undefined.\n\nFunction 类可以表示开发者定义的任何函数。用 Function 类直接创建函数的语法如下：\n\n```javascript\nvar 函数名 = new Function(\"参数1\",\"参数n\",\"function_body\"); # 基本不用这种用法\n```\n\n虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。示例如下：\n\n```javascript\nalert(1);\nfunction func1(){\n    alert(\'hello yuan!\');\n    return 8\n}\n \n    ret=func1();\n    alert(ret)\n－－－－－－－－－－－－－－－－\n \nvar func1=new Function(\"name\",\"alert(\\\"hello\\\"+name);\")\nfunc1(\"yuan\")\n```\n\n**注意：js的函数加载执行与python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以：**\n\n**Function 对象的 length 属性**\n\n如前所述，函数属于引用类型，所以它们也有属性和方法。\n\n比如，ECMAScript 定义的属性 length 声明了函数期望的参数个数。\n\n```javascript\nalert(func1.length)\n```\n\n**Function 对象的方法**\n\nFunction 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。\n\n```javascript\nalert(void(fun1(1,2)))\n# 运算符void()作用：拦截方法的返回值　\n```\n\n**函数的调用**：\n\n```javascript\nfunction func1(a,b){\n\n    alert(a+b);\n}\n\n    func1(1,2);  //3\n    func1(1,2,3);//3\n    func1(1);    //NaN，相当于1+undifined，一个数字加一个undefined。\n    func1();     //NaN\n\n    //只要函数名写对即可,参数怎么填都不报错.\n\n-------------------面试题-----------\n function a(a,b){\n    alert(a+b);\n}\n\n   var a=1;\n   var b=2;\n   a(a,b)\n\n# 结论：会直接进行报错，因为a被重新赋值以后a就不是一个函数了，直接就报错了。\n```\n\n**函数的内置对象arguments**\n\n```javascript\n# 用作不定长参数，相当于python里面的*args\nfunction add(a,b){\n\n        console.log(a+b);//3\n        console.log(arguments.length);//2\n        console.log(arguments);//[1,2]\n\n    }\n    add(1,2)\n\n    ------------------arguments的用处1 ------------------\n    function nxAdd(){\n        var result=0;\n        for (var num in arguments){\n            result+=arguments[num]\n        }\n        alert(result)\n\n    }\n\n    nxAdd(1,2,3,4,5)\n\n//     ------------------arguments的用处2 ------------------\n\n    function f(a,b,c){\n        if (arguments.length!=3){\n            throw new Error(\"function f called with \"+arguments.length+\" arguments,but it just need 3 arguments\")\n        }\n        else {\n            alert(\"success!\")\n        }\n    }\n\n    f(1,2,3,4,5)\n```\n\n**匿名函数**\n\n```javascript\n// 匿名函数的应用\n    (function(){\n        alert(\"tony\");\n    } )()\n\n    (function(arg){\n        console.log(arg);\n    })(\'123\')\n```\n\n**函数的作用域和闭包**\n\n<u>作用域</u>\n\njs的作用域和py相似，if while等控制语句并没有自己作用域；而函数是有自己的作用域的；\n\n```javascript\nif(1==1){\n\n        var s=12;\n    }\n    console.log(s);//12\n\n   // ----------------------\n    function f(){\n        var temp=666;\n    }\n    f();\n    console.log(temp);//Uncaught ReferenceError: temp is not defined\n```\n\n嵌套函数的作用域：\n\n```javascript\n# example 1\nvar city = \'beijing\';\n\n    function func(){\n        var city = \'shanghai\';\n        function inner(){\n            var city = \'shenzhen\';\n            console.log(city);\n        }\n        inner();\n    }\n    func();   # shenzhen\n\n# example 2\nvar city = \'beijing\';\nfunction Bar(){\n    console.log(city);\n}\nfunction func(){\n\n    var city = \'shanghai\';\n    return Bar;  # 这里的bar会去先找Bar函数内部，如果内部没有会去找全局的\n}\nvar ret = func();\nret();    //beijing\n```\n\n闭包\n\n```javascript\nvar city = \'beijing\';\n\nfunction func(){\n    var city = \"shanghai\";\n    function inner(){\n        // var city = \"langfang\";\n        console.log(city);\n    }\n    return inner;\n}\nvar ret = func();\nret();  # shanghai\n```\n\n**作用域链(Scope Chain)：**\n\n​      在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。\n\n```javascript\nvar x=1;\nfunction foo() {\n    var y = 2;\n    \n    function bar() {\n        var z = 3;\n    }\n}\n\n#bar的作用域链： barScopeChain=[bar.AO, foo.AO, global.VO];\n\n#foo的作用域链： fooScopeChain=[foo.Ao, global.VO];\n\n########################################################\n什么是AO,VO?\n       在函数创建时，每个函数都会创建一个活动对象Active Object(AO)，全局对象为Global Object(VO)，创建函数的过程也就是为这个对象添加属性的过程，作用域链就是由这些绑定了属性的活动对象构成的。\n        例如：找x变量；bar函数在搜寻变量x的过程中，先从自身AO对象上找，如果bar.AO存在这个属性，那么会直接使用这个属性的值，如果不存在，则会转到父级函数的AO对象，也就是foo.AO\n        如果找到x属性则使用，找不到继续 在global.VO对象查找，找到x的属性，返回属性值。如果在global.VO中没有找到，则会抛出异常ReferenceError\n\n### 执行上下文。\n       函数在执行时会创建一个称为“执行上下文（execution context）”的内部对象，执行上下文定义了函数\n       执行时的环境。每个执行上下文都有自己的作用域链，用于标识符解析，当执行上下文被创建时，而它的作用\n       域链初始化为当前运行函数的[[Scope]]所包含的对象。\n### 函数执行\n       在函数执行过程中，每遇到一个变量，都会检索从哪里获取和存储数据，该过程从作用域链头部，也就是从活\n       动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没有则继续搜索作用域\n       链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义，函数执行过程中，每个标识符都\n       要经历这样的搜索过程。\n```\n\n创建作用域链的过程\n\n```javascript\n函数进入全局，创建VO对象，绑定x属性<入栈>\nglobal.VO={x=underfind; foo:reference of function}\n(这里只是预解析，为AO对象绑定声明的属性，函数执行时才会执行赋值语句，所以值是underfind)\n\n遇到foo函数，创建foo.AO，绑定y属性<入栈>\nfoo.AO={y=underfind, bar:reference of function}\n\n遇到bar函数，创建bar.AO，绑定z属性<入栈>\nbar.AO={z:underfind}\n\n作用域链和执行上下文都会保存在堆栈中，所以：\nbar函数的scope chain为：[0]bar.AO-->[1]foo.AO-->[2]global.VO\n\nfoo函数的scope chain为：[0]foo.AO-->[1]global.Vo\n//建议：少定义全局变量\n//理由：因为作用域链是栈的结构，全局变量在栈底，每次访问全局变量都会遍历一次栈，//这样会影响效率\n```\n\n函数的scope等于自身的AO对象加上父级的scope，也可以理解为一个函数的作用域等于自身活动对象加上父级作用域.\n\n函数执行前后的作用域链：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-22/30024822.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-22/30016708.jpg)\n\n**注意：作用域链的非自己部分在函数对象被建立（函数声明、函数表达式）的时候建立，而不需要等到执行**\n\n思考示例：\n\n```javascript\n for (var i=1; i<=9; i++) {\n     setTimeout( function timer(){\n     console.log( i );\n     },1000 );\n }\n\n//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝\n\nfor (var i=1; i<=9; i++) {\n    (function(){\n      var j = i;\n      setTimeout( function timer(){\n           console.log( j );\n      }, 1000 );\n     })();\n```\n\n## Json对象\n\n在Js中，也是支持和python字典类似的一种格式\n\n```javascript\n>> d = {\"name\":\"maxiaoyu\",\'age\':12}\n<< {name: \"maxiaoyu\", age: 12}\n```\n\n在JS里面的key的引号是可有可无的，但是再python中必须是有的否则会报错，针对值的话是必须要有引号的。如果针对这种内容进行遍历的话遍历的也是key。他的type是object。\n\n\n\n\n\n","timestamp":1526030685669},{"name":"01-Ajax入门.md","path":"10-前端/05-Ajax/01-Ajax入门.md","content":"# Ajax全套\n\n> http://www.cnblogs.com/wupeiqi/articles/5703697.html\n>\n> 什么是Ajax？(Asynchronous Javascript and XML)，异步JavaScript和XML\n>\n> - 节省用户操作，时间，提高用户体验，减少护具请求\n> - 传输获取数据\n>\n> Ajax最直接的作用就是数据交互。Ajax其实是可以通过不刷新页面的情况去请求和发送数据。\n\n## 原生Ajax\n\nJQuery的Ajax内部是基于原生的ajax，其实就是jquery就是封装了ajax\n\n### Ajax流程\n\n```javascript\n# HTML\n<form action=\"\" method=\"post\">\n    <input type=\"button\" value=\"button\" id=\"btn\">\n</form>\n\n\n# JS\nwindow.onload = function () {\n    var oBtn = document.getElementById(\'btn\');\n    oBtn.onclick = function () {\n        // 1-相当于打开浏览器\n        var xhr = new XMLHttpRequest();\n        // 2-在地址栏输入地址\n        xhr.open(\'get\', \'/login/\',true);\n        // 3-提交\n        xhr.send();\n        // 4-等待服务器返回内容\n        xhr.onreadystatechange = function () {\n            if( xhr.readyState == 4 ){\n                if ( xhr.status == 200 ){\n                    alert(xhr.responseText)\n                } else {\n                    alert(\'出错了！,Err\' + xhr.status);\n                }\n            }\n        }\n    }\n};\n```\n\n1. 新建一个ajax的对象\n2. 相当于在地址栏中输入地址，open方法需要三个参数，第一个参数是打开方式，第二个是打开的地址，第三个是是否异步。\n3. 发送请求给服务端\n4. 数据的获取，responseText存放ajax请求返回的内容。readyState代表ajax的工作状态，4表示接受完成可以直接调用了。并且我们可以通过responseText\n\n### XMLHttpRequest\n\n**1、XmlHttpRequest对象介绍**\n\nXmlHttpRequest对象的主要方法：\n\n```\na. void open(String method,String url,Boolen async)\n   用于创建请求\n   \n参数：\n- method： 请求方式（字符串类型），如：POST、GET、DELETE...\n- url：    要请求的地址（字符串类型）\n- async：  是否异步（布尔类型），体现在回调。默认就是异步的\n如果是异步，那么偷偷的给后台发数据，然后期间你该干嘛干嘛。前面的代码不会影响后面的代码的执行。\n如果是非异步，那么后台处理期间，整个页面就被卡主了。当后面的代码用到了前面的内容的时候就应该使用同步的。\n\nb. void send(String body)\n    用于发送请求，向请求体里塞内容\n\n    参数：\n        body： 要发送的数据（字符串类型）\n\nc. void setRequestHeader(String header,String value)\n    用于设置请求头\n\n    参数：\n        header： 请求头的key（字符串类型）\n        vlaue：  请求头的value（字符串类型）\n\nd. String getAllResponseHeaders()\n    获取所有响应头\n\n    返回值：\n        响应头数据（字符串类型）\n\ne. String getResponseHeader(String header)\n    获取响应头中指定header的值\n\n    参数：\n        header： 响应头的key（字符串类型）\n\n    返回值：\n        响应头中指定的header对应的值\n\nf. void abort()\n\n    终止请求\n```\n\nXmlHttpRequest对象的主要属性：\n\n```\na. Number readyState\n   状态值（整数）\n\n   详细：\n      0-初始化，尚未调用open()方法；\n      1-启动，调用了open()方法；\n      2-发送，已经调用了send()方法，未接收到响应；\n      3-接收，已经接收到部分响应数据；\n      4-完成，已经接收到全部响应数据，并解析完成，可以在客户端进行调用了；\n\nb. Function onreadystatechange\n   当readyState的值改变时自动触发执行其对应的函数（回调函数）\n\nc. String responseText\n   服务器返回的数据（字符串类型）\n\nd. XmlDocument responseXML\n   服务器返回的数据（Xml对象）\n\ne. Number states\n   状态码（整数），如：200、404...等，可以通过状态码做容错处理，来规避一些错误，比如我们的请求输错了，或者服务器挂了，数据库down了返回来的一些错误信息等。\n\nf. String statesText\n   状态文本（字符串），如：OK、NotFound...\n```\n\n### 举例应用：\n\n```javascript\n### GET请求\nfunction add2(){\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystateChange = function(){\n    # 当状态码为4的时候触发执行回调函数。\n    if (xhr.readyState == 4){\n      alert(xhr.responsetext)\n    }\n  };\n  # 打开一个连接，是否异步不写默认就是异步的\n  xhr.open(\'GET\',\'/add2/?i1=1&i2=2\');\n  //encodeURI解决编码问题，解决缓存问题就在请求的路径后面接一个时间戳\n  //为避免和后台要获取的key产生冲突，因此直接在请求的连接后面加一个&然后直接接时间戳，不指定key\n  //注意千万不要忘了“&”，不然就直接接到30后面了。\n  //xhr.open(\'get\',\'2.get.php?username=\'+encodeURI(\'刘伟\')+\'&age=30&\' + new Date().getTime(),true);\n  # 用于发送请求，\n  xhr.send();\n}\n\n### POST请求\nfunction add2(){\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystateChange = function(){\n    # 当状态码为4的时候执行回调函数。\n    if (xhr.readyState == 4){\n      alert(xhr.responsetext)\n    }\n  }\n  # 打开一个连接，是否异步不写默认就是异步的\n  xhr.open(\'POST\',\'/add2/\');\n  # POST请求的时候要记得设置Content-Type请求头，申明发送的数据类型。告诉后端我提交的数据是二进制编码的数据。并且post不存在get方法提交时候的缓存问题。所以也无需关系，而且编码问题也无需关心。\n  # 不设置请求头的话会返回一个空字典\n  xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded\');\n  # 把数据放到send的参数中，用于发送请求，无需编码\n  xhr.send(\'i1=12&i2=23\');\n}\n```\n\n### Ajax获取数据的处理\n\n> - JSON.stringify()：可以把一个对象转换成对应的字符串\n> - JSON.parse：可以把字符串转换成对应的对象\n>\n> Tip：Json的key值必须是双引号引起来的，json针对这格式是异常严格的，单引号也不行，注意。\n\n### 封装Ajax的方法\n\n```javascript\nfunction ajax(method, url, data, success){\n    xhr = new XMLHttpRequest();\n    if (method == \'get\' && data){\n        // 把url和参数数据分开\n        url += \'?\' + data;\n    }\n    \n    xhr.open(method,url,true);\n    if (method == \'get\'){\n        xhr.send();\n    } else {\n        xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded\');\n        xhr.send(data)\n    }\n    \n    xhr.onreadystateChange = function(){\n    \tif (xhr.readyState == 4){\n            if (xhr.status == 200){\n                // 判断有没有success这个函数，如果有就调用\n                // success函数的作用就是把获取到的数据进行处理，比如格式化，放到哪个标签下等\n                // xhr.responseText作为success的参数回调给调用端。\n                success && success( xhr.responseText );\n            }else{\n                alert(\'Error\' + xhr.status);\n            }\n    \t}\n  \t}\n}\n```\n\n## Ajax上传文件\n\n上面的这些都是发送的文字，接下来来看如何使用ajax在后台上传文件。\n\n```javascript\nfunction upload(){\n  # 创建一个FormData对象，这个对象能传字符串能传文件\n  var formData = new FormData();\n  # 字符串\n  formData.append(\'k1\',\'v1\')\n  # 拿到文件对象，i1为input的type为file的标签的id，它下面有一个files属性值，拿到的是\n  # 一个文件对象的列表，因为有可能上传多个文件，我们取第一个就是索引0的位置\n  formData.append(\'fafafa\',document.getElementById(\'i1\').files[0])\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystateChange = function(){\n    if (xhr.readyState == 4){\n      # 定一个变量用来获取后端传递过来的file_path\n      var file_path = xhr.responsetext;\n      var tag = document.createElement(\'img\');\n      # 返回的路径是相对的，我们要加一个斜杠，要这个路径是针对根显示的。\n      tag.src = \"/\" + file_path;\n      # container是页面中的一个容器，我们往这个容器里添加内容\n      document.getElementById(\'container1\').appendChild(tag);\n    }\n  }\n  xhr.open(\'POST\',\'/add2/\');\n  # 当使用formdata这个特殊对象的时候就不用指定这个content-type头了，直接把整个form-data对象传递到后台，后台会做统一处理。因此这个设置请求头的操作要省略。\n  # xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded\');\n  # 用于发送请求，将formData对象放到这里，formData里既有普通的文本又有文件\n  xhr.send(formData);\n}\n\n\ndef upload(request):\n  if request.method == \"GET\":\n    return render(xxx)\n  else:\n    # request.POST拿传递过来的文本数据\n    file_obj = request.FILES.get(\'fafafa\')\n    # 将上传过来的文件一点一点的写到本地\n    file_path = os.path.join(\"static\",file_obj.name)\n    with open(file_path, \'wb\') as f:\n      for chunk in file_obj.chunks():\n        f.write(chunk)\n    \n    return HttpResponse(file_path)\n```\n\n使用jquery封装的ajax提交\n\n```javascript\nfunction upload2(){\n  var formData = new FormData();\n  formData.append(\'k1\',\'v1\');\n  formData.append(\'fafafa\',$(\'#i2\')[0].files[0]);\n  # jquery对象和Dom对象的互换，直接把dom对象加个$(dom对象)就变成jquery对象\n  # 把jquery对象加个0的索引就能转换成dom对象，比如$(\'#i2\')[0]\n  $.ajax({\n    url:\'/upload/\',\n    type:\'POST\',\n    data:formData,\n    # 在原生ajax中我们知道不需要指定content-type，在这里同样也要告诉jquery不要添加Content-Type，让jquery不做处理。需要设置如下的两个参数。\n    contentType:false,\n    processData:false\n    success:function(arg){\n      var tag = document.createElement(\'img\');\n      tag.src = \"/\" + arg;\n      $(\'#container2\').append(tag);\n    }\n  })\n}\n```\n\n### Ajax上传的兼容性处理\n\n> 通过伪造的Ajax来实现，也就是iframe的实现方案。\n\nFormData对象是html5以后提出来的这么一个对象，主流的浏览器和ie10以上都是可以使用的，但是针对以前的浏览器就会有问题。因此兼容性存在一定的问题，如果想要兼容性更好一些，可以使用伪造的Ajax。\n\n```javascript\n# html:务必要指定enctype为multipart/form-data\n<form id=\"f1\" method=\"POST\" action=\"/upload/\" target=\'ifr\' enctype=\"multipart/form-data\">\n  <iframe id=\'ifr\' name=\'ifr\' style=\'display:none\'></iframe>\n  <input type=\"file\" name=\"fafafa\" />\n  <a onclick=\"upload3;\">上传</a>\n</form>\n\n\nfunction upload3(){\n  document.getElementById(\'f1\').submit();\n  document.getElementById(\'ifr\').onload=loadIframe();\n}\nfunction loadIframe(){\n  var content = document.getElementById(\'ifr\').contentWindow.document.body.innerText;\n  # 这个拿到的content就是上传文件的地址。\n  alert(\'content\');\n}\n```\n\n总结：\n\n1. 上传文件，推荐使用伪造的。\n2. 上传数据，推荐有限使用jQuery，而且可以打包整体发送过去。如果不允许使用jQuery可以使用XMLHttpRequest。\n3. 不要被好看的上传按钮所迷惑，好看的上传按钮就是一个定位，然后把input框透明度设置为0而已。这样点击好看的上传按钮其实就是点击这个input框上传。","timestamp":1526030685669},{"name":"02-伪造ajax.md","path":"10-前端/05-Ajax/02-伪造ajax.md","content":"# 伪造的ajax\n\n> 从iframe标签说起：iframe标签可以伪造出局部刷新的效果。可以开辟一个类似向后台提交的通道。不刷新，发送HTTP请求。`<form>`标签可以把input的数据打包，因此这俩结合起来也可以实现不刷新向后台提交数据的功能。iframe相当于又嵌套了一个页面。\n\n```html\n# 这样就可以在后台通过request.POST拿到用户在不刷新的条件下拿到的数据\n<body>\n  <!--用于检测页面是否刷新，实际检测，伪ajax下，页面并不会刷新-->\n  <input type=\'text\' />\n  <!--使用target可以指定提交的方式，不用form原来的提交方式了。-->\n  <form method=\'post\' action=\'/fake_ajax/\' target=\"ifr\">\n    <!--这个iframe放哪其实无碍-->\n    <iframe name=\"ifr\" style=\'display:none\'></iframe>\n    <input type=\"text\" name=\"user\" />\n    <input type=\"submit\" value=\"提交\" />\n  </form>\n</body>\n```\n\n这种情况下是无法使用回调函数的，当然也没法写回调。后台返回的值会放到iframe中去。那么其实可以这样，只要iframe中有内容的时候，证明后台的值就返回来了。如果里面有内容了，是可以执行一个onload函数的。这个onload也适用于其他的标签，只要加载的时候就会执行这个onload，后台返回一次数据就会加载一次。\n\n```html\n<body>\n  <!--使用target可以指定提交的方式，不用form原来的提交方式了。-->\n  <form method=\'post\' action=\'/fake_ajax/\' target=\"ifr\">\n    <!--这个iframe放哪其实无碍-->\n    <iframe name=\"ifr\" onload=\"loadIframe();\"></iframe>\n    <input type=\"text\" name=\"user\" />\n    <input type=\"submit\" value=\"提交\" />\n  </form>\n  <script>\n    function loadIframe(){\n      alert(123);\n    }\n  </script>\n</body>\n```\n\n但是这个会出现一个问题，console会报错，html从上往下加载第一次执行到iframe的时候回进行加载，但是此时js脚本还没有读到呢，因此会报错，说loadIframe找不到。为了避免这个问题：\n\n```html\n<body>\n  <input type=\'text\' />\n  <!--使用target可以指定提交的方式，不用form原来的提交方式了。-->\n  <form id=\"f1\" method=\'post\' action=\'/fake_ajax/\' target=\"ifr\">\n    <!--这个iframe放哪其实无碍-->\n    <iframe name=\"ifr\"  id=\'ifr\' style=\'display:none\'></iframe>\n    <input type=\"text\" name=\"user\" />\n    <a onclick=\"submitForm();\">提交</a>\n  </form>\n  <script>\n    # 通过js代码提交表单，可以在提交的时候再绑定事件。\n    function submitForm(){\n      # 我直接用js进行提交。\n      document.getElementById(\'f1\').submit();\n      # 在点的时候才绑定事件，第一遍读取的时候并不绑定事件。\n      document.getElementById(\'ifr\').onload=loadIframe();\n    }\n    function loadIframe(){\n      # 取iframe中的数据要用contentWindow取内容。因为iframe相当于又嵌套一个页面\n      var content = document.getElementById(\'ifr\').contentWindow.document.body.innerText;\n      alert(\'content\')\n    }\n  </script>\n</body>\n```","timestamp":1526030685669},{"name":"03-跨域Ajax.md","path":"10-前端/05-Ajax/03-跨域Ajax.md","content":"# 跨域的Ajax JSONP\n\n>JSONP（json with padding）是一种技巧和一种技术，或者叫一种访问方式。\n>\n>同源策略参考：http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\n>\n>https://www.cnblogs.com/rockmadman/p/6836834.html\n\n## 跨域的问题\n\n- 域：域名\n- 跨域请求（访问）：一个域名下的文件请求另外一个域名下的资源就产生了跨域。\n\nAjax存在：访问自己域名下的内容是没问题的，但是访问别的域名的请求就会存在被阻止的问题。浏览器会阻挡下来，ajax的回调函数不会执行的。如果去调用的话会出现如下的一个报错：\n\n```javascript\nNo \'Access-Control-Allow-Origin\' header is present on the requested resource.\n```\n\n应该如何去理解这个问题呢，相当于服务器设置的一个访问白名单，如果不在这个白名单的话是不允许访问的。\n\n浏览器：同源策略，浏览器遵循同源策略。从浏览器向别的网址发请求会被浏览器组织掉。请求会发过去，数据也会回来，但是被浏览器阻挡，数据拿不到的。相当于数据能发出去但是回不来。\n\n解决跨域问题的方案：\n\n- 服务端代理：服务端的一个文件去请求资源获得结果保存，然后再去访问当前域名下这个结果。\n- Flash：服务端存在一个跨域xml文件保存了能够去访问它的域名，如果这个域名存在，允许访问，如果不存在，那就拒绝。比如qq要去访问百度，那么在百度下面会有一个xml文件保存了qq域名。\n- JSONP\n\nJSONP可以解决上面的问题：\n\n> 核心：\n>\n> 1. script标签\n> 2. 用script标签加载资源是没有跨域问题的\n> 3. ​\n\nJSONP可以绕过同源策略，去把数据拿回来。浏览器不是针对所有都有同源策略的限制，允许带有src属性的标签是允许跨域的。比如js，jquery我们可以用网络的资源，jquery cdn。针对这种请求是没有做同源策略限制的。因此就可以钻这个空子。\n\n在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数利用这个参数做一些事情，然后需要的时候通过script标签加载对应远程文件资源，当远程文件资源被加载进来的时候就会去执行我们前面定义好的函数，并且把数据当做这个函数的参数传入进去。\n\n```javascript\n# JSON with padding 把json内容填充进来使用\n```\n\n\n\n\n\n```html\n# 在页面上创建一个标签，这样就不会有同源策略的限制而且能发送请求。\n# 1、发送端：把数据拼接成一个srcipt代码，把script代码放到html代码中。\n<script src=\'http://www.baidu.com\'>\n</script>\n\n# 2、如果返回的内容恰巧是：\"func(123123)\"\n\n<a onclick=\"SendMSg();\">发送</a>\n<script>\n  function SendMsg(){\n    # 动态的创建标签进行加载，而不是预先加载。控制执行的过程，实现按需加载。\n    var tag = document.createElement(\'script\')\n    tag.src = \'http://www.baidu.com\';\n    # 在头部加一个script代码，访问网站的返回值就被读到内存了。\n    document.head.appendChild(\'tag\');\n  }\n</script>\n```\n\n双方有约定，和远程约定好共同遵循规则。一个约定好的测试地址如下：\n\n`http://www.jxntv.cn/data/jmd-jxtv2.html?callback=list&_=1454376870403`\n\n\n\n开发需求：向其他网站发送http请求\n\n- 浏览器直接发送请求，需要考虑同源策略。\n\n\n- 把请求发给服务端，让本地服务端去请求然后再返给本地服务器，此时就不会有同源策略，因为不是浏览器。\n\n```javascript\nfunction getUser(){\n  var tag = document.createElement(\'script\');\n  # 传递参数传递一个funcname\n  tag.src = \"http://xxx:8881/users/?funcname=bbb\"\n  document.head.appendChild(tag);\n}\n\n#\nfunction bbb(arg){\n  console.log(arg)\n}\n\n# 后端数据\ndef users(request):\n    v = request.GET.get(\'funcname\')\n    user_list = [\'aaa\',\'vvv\',\'bbb\']\n    user_list_str = json.dumps(user_list)\n    temp = \"%s(%s)\" % (v,user_list_str,)\n    return HttpResponse(temp)\n```\n\njs中尽量少用全局变量，因此为了避免这个问题使用callback回调函数，而不是使用返回全局变量。\n\nJSONP的要求：\n\n- 客户端和服务端要达成一致。或者对返回的数据进行数据分析然后采取相应的方式进行处理\n- 在客户端的URL中要加一个?funcname=xxxx\n- 在客户端要有一个和funcname同名的函数\n- 服务端要获取funcname\n- 返回funcname(args)\n\n一般情况下funcname叫callback，其实就是回调函数。\n\n不过上面这些东西Jquery有现成的。\n\n```javascript\nfunctiuon getUsers(){\n  # 默认使用XMLHttpRequest，如果指定dataType为JSONP那么内部就会\n  # 使用JSONP来进行发送\n  # jquery内部会在触发以后添加一个script标签，然后又给你删掉了\n  $.ajax({\n    url: \'xxxxxx\',\n    type:\'GET\',\n    dataType: \'JSONP\',\n    # 下面这俩参数相当于  xxxx/?callback=list，一个对应前面的一个对应后面的。\n    jsonp: \'callback\',\n    jsonpCallback: \'list\'\n  })\n}\n\nfunction bbb(arg){\n  console.log(arg)\n}\n```\n\nJSONP只能发get请求，因此jquery中的ajax不写type也是可以的。\n\n使用：\n\n- 动态创建script标签然后删除\n- Jquery去做\n\n使用JSONP的时候：\n\n- 只能发get请求，不能发POST，即使写了POST，内部JSONP还是通过get传递。\n- 客户端和服务端相互约定好。\n\nJSONP在哪一种语言都有\n\n额外的在响应头中加点值就可以让浏览器忽略同源策略：cors\n\n```javascript\nfunction getUsers(){\n  $.ajax({\n    url:\'xxxxx/new_users\',\n    type:\'GET\',\n    success:function(arg){\n      console.log(arg);\n    }\n  })\n}\n\ndef new_users(request):\n  user_list = [1,2,3]\n  user_list_str = json.dumps(user_list)\n  obj = HttpResponse(user_list_str)\n  # 跨站资源共享\n  # 允许所有人访问：\n  # obj[\'Access-Control-Allow-Origin\'] = \"*\"\n  obj[\'Access-Control-Allow-Origin\'] = \"访问源地址，表示允许来源拿数据\"\n  return obj\n```\n\n简单请求就是发过来加个响应头，如果是内部（复杂）请求，会发两次请求，有一个预检的过程。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-27/24003776.jpg)\n\n如何区分复杂请求和简单请求，见博客。\n\n\n\n\n\n\n\n\n\n伪造Ajax：\n\n- iframe+form(target=\'xx\')\n- JS:document.getElementById(\'f1\').submit()\n\n原生Ajax:\n\n- XMLHttpRequest对象\n  - POST请求时注意请求头：Content-type，如果不加的话Request.POST没有，在Request.Body里，POST请求会根据content-type去判断是否从request.body中取值并解析。\n- Jquery Ajax\n\n\n\nInterview\n\n- python基础\n- 数据库一类的，根据需求做数据库设计，数据库性能\n- 前端，作用域，词法分析，this，面向对象，JSONP\n\n\n\n**2、跨浏览器支持**\n\n- XmlHttpRequest\n  IE7+, Firefox, Chrome, Opera, etc.\n- ActiveXObject(\"Microsoft.XMLHTTP\")\n  IE6, IE5\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n\n    <h1>XMLHttpRequest - Ajax请求</h1>\n    <input type=\"button\" onclick=\"XmlGetRequest();\" value=\"Get发送请求\" />\n    <input type=\"button\" onclick=\"XmlPostRequest();\" value=\"Post发送请求\" />\n\n    <script src=\"/statics/jquery-1.12.4.js\"></script>\n    <script type=\"text/javascript\">\n\n        function GetXHR(){\n            var xhr = null;\n            if(XMLHttpRequest){\n                xhr = new XMLHttpRequest();\n            }else{\n                xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n            return xhr;\n\n        }\n\n        function XhrPostRequest(){\n            var xhr = GetXHR();\n            // 定义回调函数\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    // 已经接收到全部响应数据，执行以下操作\n                    var data = xhr.responseText;\n                    console.log(data);\n                }\n            };\n            // 指定连接方式和地址----文件方式\n            xhr.open(\'POST\', \"/test/\", true);\n            // 设置请求头\n            xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded; charset-UTF-8\');\n            // 发送请求\n            xhr.send(\'n1=1;n2=2;\');\n        }\n\n        function XhrGetRequest(){\n            var xhr = GetXHR();\n            // 定义回调函数\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    // 已经接收到全部响应数据，执行以下操作\n                    var data = xhr.responseText;\n                    console.log(data);\n                }\n            };\n            // 指定连接方式和地址----文件方式\n            xhr.open(\'get\', \"/test/\", true);\n            // 发送请求\n            xhr.send();\n        }\n\n    </script>\n\n</body>\n</html>\n```\n\n\n\n\n\n使用原生的ajax：\n\n```javascript\n\n```\n\n\n\n\n\n不同的数据接口返回的数据使用不同的方式去处理。\n\n\n\n豆瓣Ajax请求\n\n```\napi.douban.com/book/subjects?q=javascript&alt=xd&cb=fn1\n```\n\nJSONP豆瓣实例\n\n```javascript\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>无标题文档</title>\n<style>\n#q {width: 300px; height: 30px; padding: 5px; border:1px solid #f90; font-size: 16px;}\ndl {border-bottom: 1px dotted #000;}\ndt {font-weight: bold;}\n</style>\n<script>\nfunction fn1(data) {\n\n\tvar oMsg = document.getElementById(\'msg\');\n\tvar oList = document.getElementById(\'list\');\n\t\n\tconsole.log(data);\n\t\n\toMsg.innerHTML = data.title.$t + \' : \' + data[\'opensearch:totalResults\'].$t;\n\t\n\tvar aEntry = data.entry;\n\tvar html = \'\';\n\tfor (var i=0; i<aEntry.length; i++) {\n\t\t\n\t\thtml += \'<dl><dt>\'+ aEntry[i].title.$t +\'</dt><dd><img src=\"\'+ aEntry[i].link[2][\'@href\'] +\'\" /></dd></dl>\';\n\t\t\n\t}\n\t\n\toList.innerHTML = html;\n\t\n}\nwindow.onload = function() {\n\t\n\tvar oQ = document.getElementById(\'q\');\n\tvar oBtn = document.getElementById(\'btn\');\n\tvar oMsg = document.getElementById(\'msg\');\n\tvar oList = document.getElementById(\'list\');\n\t\n\toBtn.onclick = function() {\n\n\t\tif ( oQ.value != \'\' ) {\n\t\t\tvar oScript = document.createElement(\'script\');\n\t\t\toScript.src = \'http://api.douban.com/book/subjects?q=\'+oQ.value+\'&alt=xd&callback=fn1\';\n\t\t\tdocument.body.appendChild(oScript);\n\t\t}\n\t\t\n\t\t//http://api.douban.com/book/subjects?q=\'+oQ.value+\'&alt=xd&callback=fn1&start-index=(当前页*每页显示的条数)&max-results=10(每页显示的条数)\n\t\t\n\t}\n\t\n}\n</script>\n</head>\n\n<body>\n\thttp://www.douban.com/service/apidoc/reference/\n\t<input type=\"text\" id=\"q\" /><input type=\"button\" id=\"btn\" value=\"搜索\" />\n    <p id=\"msg\"></p>\n    <hr />\n\t<div id=\"list\"></div>\n</body>\n</html>\n```\n\n\n\n","timestamp":1526030685669}]