if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m05']=[{"name":"01-01-开发环境介绍.md","path":"05-Frontend/01-HTML/00-开发环境介绍/01-01-开发环境介绍.md","content":"# 开发环境介绍\n\n> 其实前端的开发不用什么太多的软件，一个浏览器，一个记事本足矣。不过一个好的编写代码的软件可以让我们的编程效率提高。编程软件很多，最简单的有记事本，较为常用的有notepad++，sublime。较为经典的有Dreamweaver，以及后起之秀的vscode，atom这些都可以，pycharm，Hbuilder这种软件同样是可以支持的，其实最重要的还是看哪个软件用着顺手。\n>\n> 参考资料：\n>\n> - https://segmentfault.com/a/1190000004204640\n> - http://www.w3cplus.com/tools/emmet-cheat-sheet.html\n> - http://www.cnblogs.com/SourceKing/p/5470428.html\n\n\n\n## 1、使用Sublime搭建前端开发环境\n\n下载sublime3的安装包不多说什么了，直接下载安装即可，如果想要将sublime用的更顺手，就需要安装其他的一些插件才可以。\n\n### 1.1、包管理器（Package Control）\n\n点击菜单→Show Console调出命令终端，或者使用快捷键`ctrl+反引号`也可以在底部呼出快捷菜单，将如下命令输入到控制台中，回车，等待即可安装成功。或者参考如下的安装代码和[指导地址](https://packagecontrol.io/installation)：\n\n```python\nimport urllib.request,os,hashlib; h = \'2915d1851351e5ee549c20394736b442\' + \'8bc59f460fa1548d1514676163dafc88\'; pf = \'Package Control.sublime-package\'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( \'http://packagecontrol.io/\' + pf.replace(\' \', \'%20\')).read(); dh = hashlib.sha256(by).hexdigest(); print(\'Error validating download (got %s instead of %s), please try manual install\' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), \'wb\' ).write(by)\n```\n\n### 1.2、安装插件\n\n通过快捷键`ctrl+shift+p`调出命令面板，找到包安装，就会跳转到各种包的界面：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/49383936.jpg)\n\n选中按回车，稍作等待即可以；\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/94138252.jpg)\n\n接下来就可以安装前端开发可能会用到的插件了。\n\n#### Emmet（代码快速生成软件）\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/21969652.jpg)\n\n可以看到可以用上面的方式快速生成我们想要的代码，它使用仿css选择器的方式去生成代码，大大的提高了我们生成代码的速度。简单了解详见：\n\n#### ConvertToUTF8\n\nConvertToUTF8：直接在菜单栏中可以转了，专为中文设计，妈妈再也不通担心中文乱码问题了\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/95674636.jpg)\n\n#### BracketHighlighter\n\n显示用户所在的括号到底是哪一个\n\n#### JSFormat\n\nJavaScript代码格式化软件\n\n#### AutoFileName\n\n自动完成文件名的输入，如图片选取\n\n#### Sublime CodeIntel\n\n代码自动提示\n\n#### ColorHighlighter\n\n[ColorHighlighter](https://github.com/Monnoroch/ColorHighlighter/)是一个显示选中颜色代码的视觉颜色的插件。如果您选择“# fff“，它将向您展示白色。ColorHighlighter支持所有CSS颜色格式，如Hex,RGB,HSL,HSV,同时包括颜色关键词,如“red”“green”,等等。它还为你显示包含颜色值的LESS,Sass,和Stylus变量。它是一个帮助您更直观处理颜色的插件","timestamp":1540005876713},{"name":"02-02-Emmet简单实用介绍.md","path":"05-Frontend/01-HTML/00-开发环境介绍/02-02-Emmet简单实用介绍.md","content":"# Emmet插件使用\n\n## 1-针对html的操作\n\n#### 初始化（输入下面代码按tab生效）\n\n- html:5或!：初始化html5文档类型\n- html:xt：用户xhtml过渡文档类型\n- html:4s：用于html4严格文档类型\n\n#### 轻松添加类、id、文本和属性\n\n- 元素.class_name的形式/元素#id的形式\n\n  ![](http://omk1n04i8.bkt.clouddn.com/17-10-29/90435545.jpg)\n\n  比如输入p.bar#foo则会生成如下的代码\n\n  ```html\n  <p class=\"bar\" id=\"foo\"></p>\n  ```\n\n- 属性可以通过h1{foo}和a[href=#]类似这种格式的代码来进行添加\n\n  ![](http://omk1n04i8.bkt.clouddn.com/17-10-29/44004558.jpg)\n\n#### 嵌套\n\n现在你只需要1行代码就可以实现标签的嵌套。 \n\n- \\>：子元素符号，表示嵌套的元素\n- +：同级标签符号\n- ^：可以使该符号前的标签提升一行\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/79982974.jpg)\n\n#### 分组\n\n使用\".\"默认就是生成div，通过嵌套和括号可以快速生成一些小的代码块。比如输入(.foo>h1)+(.bar>h2)的话那么就会生成如下的html代码：\n\n```html\n<div class=\"foo\">  \n  <h1></h1>  \n</div>  \n<div class=\"bar\">  \n  <h2></h2>  \n</div> \n```\n\n#### 隐式标签\n\n声明一个带类的标签，只需输入div.item，就会生成<div class=\"item\"></div>。 \n\n在过去版本中，可以省略掉div，即输入.item即可生成<div class=\"item\"></div>。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在<ul>中输入.item，就会生成<li class=\"item\"></li>。 \n\n下面是所有的隐式标签名称： \n\n- li：用于ul和ol中\n- tr：用于table、tbody、thead和tfoot中\n- td：用于tr中\n- option：用于select和optgroup中\n\n#### 定义多个元素\n\n使用`*`符号即可以定义多个同样的元素，比如ul>li*3就会生成如下的代码：\n\n```html\n<ul>  \n  <li></li>  \n  <li></li>  \n  <li></li>  \n</ul> \n```\n\n如果元素需要带属性怎么办呢？这个也很简单，比如输入 ul>li.item$*3会生成如下的html代码。\n\n```html\n<ul>  \n  <li class=\"item1\"></li>  \n  <li class=\"item2\"></li>  \n  <li class=\"item3\"></li>  \n</ul>  \n```\n\n## 2-针对CSS的操作\n\n#### css缩写(必须为对应的css格式的文件才可以生效)\n\n- w100：width:100px\n- m5e：margin: 5em\n- h10p：height: 10%;\n\n单位别名列表： \n\n- p 表示%\n- e 表示 em\n- x 表示 ex\n\n#### 附加属性\n\n可能你之前已经了解了一些缩写，比如 @f，可以生成： \n\n```css\n@font-face {  \n  font-family:;  \n  src:url();  \n} \n```\n\n一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成： \n\n```css\n@font-face {  \n  font-family: \'FontName\';  \n  src: url(\'FileName.eot\');  \n  src: url(\'FileName.eot?#iefix\') format(\'embedded-opentype\'),  \n     url(\'FileName.woff\') format(\'woff\'),  \n     url(\'FileName.ttf\') format(\'truetype\'),  \n     url(\'FileName.svg#FontName\') format(\'svg\');  \n  font-style: normal;  \n  font-weight: normal;  \n}  \n```\n\n#### 模糊匹配\n\n如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：\n\n```css\noverflow: hidden; \n```\n\n#### 供应商前缀\n\n如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成： \n\n```css\n-webkit-transform: ;  \n-moz-transform: ;  \n-ms-transform: ;  \n-o-transform: ;  \ntransform: ; \n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/8248386.jpg)\n\n你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo： \n\n```css\n-webkit-super-foo: ;  \n-moz-super-foo: ;  \n-ms-super-foo: ;  \n-o-super-foo: ;  \nsuper-foo: ;  \n```\n\n如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀： \n\n```css\n-webkit-transform: ;  \n-moz-transform: ;  \ntransform: ; \n```\n\n前缀缩写如下： \n\n- w 表示 -webkit-\n- m 表示 -moz-\n- s 表示 -ms-\n- o 表示 -o-\n\n#### 渐变\n\n输入lg(left, #fff 50%, #000)，会生成如下代码： \n\n```css\nbackground-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));  \nbackground-image: -webkit-linear-gradient(left, #fff 50%, #000);  \nbackground-image: -moz-linear-gradient(left, #fff 50%, #000);  \nbackground-image: -o-linear-gradient(left, #fff 50%, #000);  \nbackground-image: linear-gradient(left, #fff 50%, #000);  \n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/59307770.jpg)\n\n## 3-附加功能\n\n**生成Lorem ipsum文本** \n\nLorem ipsum指一篇常用于排版设计领域的拉丁文文章，主要目的是测试文章或文字在不同字型、版型下看起来的效果。通过Emmet，你只需输入lorem 或 lipsum即可生成这些文字。还可以指定文字的个数，比如lorem10，将生成： \n\n```\nLorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus.\n```\n\n## 4-定制\n\n你还可以定制Emmet插件： \n\n- 添加新缩写或更新现有缩写，可修改[snippets.json](http://docs.emmet.io/customization/snippets/)文件\n- 更改Emmet过滤器和操作的行为，可修改[preferences.json](http://docs.emmet.io/customization/preferences/)文件\n- 定义如何生成HTML或XML代码，可修改[syntaxProfiles.json](http://docs.emmet.io/customization/syntax-profiles/)文件\n\n## 5-针对不同编辑器的插件\n\nEmmet支持的编辑器如下（链接为针对该编辑器的Emmet插件）： \n\n- [Sublime Text 2](https://github.com/sergeche/emmet-sublime)\n- [TextMate 1.x](https://github.com/emmetio/Emmet.tmplugin)\n- [Eclipse/Aptana](https://github.com/emmetio/emmet-eclipse)\n- [Coda 1.6 and 2.x](https://github.com/emmetio/Emmet.codaplugin)\n- [Espresso](https://github.com/emmetio/Emmet.sugar)\n- [Chocolat](https://github.com/sergeche/emmet.chocmixin) （通过“Install Mixin”对话框添加)\n- [Komodo Edit/IDE](https://github.com/emmetio/emmet/downloads) （通过Tools → Add-ons菜单添加)\n- [Notepad++](https://github.com/emmetio/emmet/downloads)\n- [PSPad](https://github.com/emmetio/emmet/downloads)\n- [CodeMirror2/3](https://github.com/emmetio/codemirror)\n- [Brackets](https://github.com/emmetio/brackets-emmet)\n\n","timestamp":1540005876713},{"name":"01-HTML快速入门.md","path":"05-Frontend/01-HTML/01-HTML快速入门.md","content":"# HTML快速入门\n\n> 参考资料：\n>\n> http://www.cnblogs.com/yuanchenqi/articles/6835654.html\n>\n> <http://www.cnblogs.com/liwenzhou/p/7988087.html> \n\n## 1-HTML基础\n\n### 1.0 Web服务的本质\n\n```python\nimport socket\n\n\nsk = socket.socket()\n\nsk.bind((\"127.0.0.1\", 8080))\nsk.listen(5)\n\n\nwhile True:\n    conn, addr = sk.accept()\n    data = conn.recv(8096)\n    conn.send(b\"HTTP/1.1 200 OK\\r\\n\\r\\n\")\n    conn.secd(b\"<h1>Hello world!</h1>\")\n    conn.close()\n```\n\n浏览器发请求 --> HTTP协议 --> 服务端接收请求 --> 服务端返回响应 --> 服务端把HTML文件内容发给浏览器 --> 浏览器渲染页面\n\n### 1.1 html是什么？\n\n- 超文本标记语言（Hypertext Markup Language，HTML）通过**标签语言**来标记要显示的网页中的各个部分。一套规则，浏览器认识的规则\n- 浏览器按顺序渲染网页文件，然后根据标记符解释和显示内容。但需要注意的是，对于不同的浏览器，对同一标签可能会有不完全相同的解释（兼容性）\n- 静态网页文件扩展名：.html 或 .htm\n\n### 1.2 html不是什么\n\nHTML 不是一种编程语言，而是一种标记语言 (markup language)\n\nHTML 使用标记标签来描述网页\n\n### 1.3 html的结构\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/37492664.jpg)\n\n- `<!DOCTYPE html> `告诉浏览器使用什么样的html或者xhtml来解析html文档\n- `<html></html>`是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部<head>和主体<body>。 \n- `<head></head>`元素出现在文档的开头部分。<head>与</head>之间的内容不会在浏览器的文档窗口显示，但是其间的元素有特殊重要的意义。\n- `<title></title>`定义网页标题，在浏览器标题栏显示。  \n- `<body></body>`之间的文本是可见的网页主体内容\n\n到了html5以后结构变得更加的细化：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/10107051.jpg)\n\n### 1.4 html标签格式\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-29/23230425.jpg)\n\n标签的语法：\n\n```html\n<标签名 属性1=“属性值1” 属性2=“属性值2”……>内容部分</标签名>\n<标签名 属性1=“属性值1” 属性2=“属性值2”…… />\n```\n\n### 1.5 常用标签\n\n#### 1.5.1 <!DOCTYPE>标签\n\n<!DOCTYPE> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n\n作用：声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。\ndocument.compatMode：\n\n1. BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。\n2. CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。\n\n这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat\n\n#### 1.5.2 \\<head\\>内常用标签\n\n##### \\<meta\\>标签\n\nmeta介绍\n`<meta>`元素可提供有关页面的元信息（meta-information），针对搜索引擎和更新频度的描述和关键词。\n`<meta>`标签位于文档的头部，不包含任何内容。\n`<meta>`提供的信息是用户不可见的\n\nmeta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。\n\n- 设置字符集：\n\n  ```html\n  <!--设置字符集-->\n  <meta charset=\"UTF-8\" />\n  ```\n\n- name属性: 主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。    \n\n  ```html\n  <meta name=\"keywords\" content=\"meta总结,html meta,meta属性,meta跳转\">\n  <meta name=\"description\" content=\"哈哈哈哈哈\">\n  ```\n\n- http-equiv属性：相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。\n\n  ```html\n  <!--设置自动刷新，每两秒刷新一次-->\n  <meta http-equiv=\"Refresh\" Content=\"2\" />\n  <meta http-equiv=\"Refresh\" content=\"2;URL=https://www.oldboy.com\"> \n  //(注意后面的引号，分别在秒数的前面和网址的后面，表示2s后跳转到后面的网址)\n  <meta http-equiv=\"content-Type\" charset=\"UTF8\">\n  <meta http-equiv = \"X-UA-Compatible\" content = \"IE=EmulateIE7\" /> \n  <!--兼容IE，告诉IE内部启用最新的引擎-->\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">                                                           \n  ```\n\n##### 非meta标签\n\n```html\n<title>lamber</title>   # 网页文档的标题\n<link rel=\"icon\" href=\"http://www.jd.com/favicon.ico\">  # 网页的icon\n<link rel=\"stylesheet\" href=\"css.css\">  # 外部引入css\n<script src=\"hello.js\"></script>　# 引入js\n<style type=\"text/css\"></style>  # 引入css\n```\n\n#### 1.5.3 body内常用标签\n\n##### 基本标签\n\n```html\n<hn>: n的取值范围是1~6; 从大到小. 用来表示标题。一般h1在文档中只会有一个，和搜索引擎有关。\n<p>: 段落标签. 包裹的内容被换行.并且也上下内容之间有一行空白.\n<b> <strong>: 加粗标签.\n<strike>: 为文字加上一条中线。\n<em>: 文字变成斜体.\n<sup>和<sub>: 上角标 和 下角表.\n<br>:换行.\n<hr>:水平线\n\n特殊字符：\n      &lt; &gt；&quot；&copy;&reg;（小于，大于，引号，版权，注册商标）\n<!--html中的特殊符号大全-->\nhttp://www.cnblogs.com/web-d/archive/2010/04/16/1713298.html\n```\n\n##### div和span\n\n- `<div></div>` ：` <div>`只是一个块级元素，并无实际的意义。主要通过CSS样式为其赋予不同的表现. 块级元素独占一行。\n- `<span></span>`：  `<span>`表示了内联行(行内元素),并无实际的意义,主要通过CSS样式为其赋予不同的表现. 非独占一行。\n\n**块级元素与行内元素的区别**\n所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行。如果单独在网页中插入这两个元素，不会对页面产生任何的影响。\n这两个元素是专门为定义CSS样式而生的。那么html的块级元素和行内元素都有哪些？以下内容仅供参考，实际上有用的没几个，看看就得了。\n\n```\n块元素(block element)\n\n　　 * address - 地址\n 　　* blockquote - 块引用\n 　　* center - 举中对齐块\n 　　* dir - 目录列表\n 　　* div - 常用块级容易，也是css layout的主要标签\n 　　* dl - 定义列表\n 　　* fieldset - form控制组\n 　　* form - 交互表单\n 　　* h1 - 大标题\n 　　* h2 - 副标题\n 　　* h3 - 3级标题\n 　　* h4 - 4级标题\n 　　* h5 - 5级标题\n 　　* h6 - 6级标题\n 　　* hr - 水平分隔线\n 　　* isindex - input prompt\n　　 * menu - 菜单列表\n 　　* noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容\n 　　* noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）\n 　　* ol - 排序表单\n 　　* p - 段落\n 　　* pre - 格式化文本\n 　　* table - 表格\n 　　* ul - 非排序列表\n\n内联元素(inline element)\n\n　　 * a - 锚点\n 　　* abbr - 缩写\n 　　* acronym - 首字\n 　　* b - 粗体(不推荐)\n　　 * bdo - bidi override\n　　 * big - 大字体\n 　　* br - 换行\n 　　* cite - 引用\n 　　* code - 计算机代码(在引用源码的时候需要)\n　　 * dfn - 定义字段\n 　　* em - 强调\n 　　* font - 字体设定(不推荐)\n　　 * i - 斜体\n 　　* img - 图片\n 　　* input - 输入框\n 　　* kbd - 定义键盘文本\n 　　* label - 表格标签\n 　　* q - 短引用\n 　　* s - 中划线(不推荐)\n　　 * samp - 定义范例计算机代码\n 　　* select - 项目选择\n 　　* small - 小字体文本\n 　　* span - 常用内联容器，定义文本内区块\n 　　* strike - 中划线\n 　　* strong - 粗体强调\n 　　* sub - 下标\n 　　* sup - 上标\n 　　* textarea - 多行文本输入框\n 　　* tt - 电传文本\n 　　* u - 下划线\n 　　* var - 定义变量\n\n可变元素\n\n　　可变元素为根据上下文语境决定该元素为块元素或者内联元素。\n 　　* applet - java applet\n　　 * button - 按钮\n 　　* del - 删除文本\n 　　* iframe - inline frame\n　　 * ins - 插入的文本\n 　　* map - 图片区块(map)\n　　 * object - object对象\n 　　* script - 客户端脚本\n```\n\n**关于标签的嵌套**\n\n- 通常块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。\n\n- p标签不能包含块级标签。如果你包含了会被隔开，它会把你p标签的开头和结尾给你自动闭合，中间的内容给你单独拿出来。比如：\n\n  ```html\n  # 比如你在代码中是这么写的。\n  <p><div></div></p>\n  \n  # 实际在网页中的显示会变为\n  <p></p>\n  <div>哈哈哈哈</div>\n  <p></p>\n  ```\n\n##### img标签\n\n```\nsrc: 要显示图片的路径.\nalt: 图片没有加载成功时的提示.就算是图片加载失败是个×，你也能根据alt知道这是个什么图片。\ntitle: 鼠标悬浮时的提示信息.\nwidth: 图片的宽\nheight:图片的高 (宽高两个属性只用一个会自动等比缩放.)\n```\n\n##### 超链接\n什么是超级链接？\n所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。\n\n```\n# 小知识点\n什么是URL：\nURL是统一资源定位器(Uniform Resource Locator)的缩写，也被称为网页地址，是因特网上标准的资源的地址。\nURL举例\nhttp://www.sohu.com/stu/intro.html\nhttp://222.172.123.33/stu/intro.html\n\nURL地址由4部分组成\n第1部分：为协议：http://、ftp://等 \n第2部分：为站点地址：可以是域名或IP地址\n第3部分：为页面在站点中的目录：stu\n第4部分：为页面名称，例如 index.html\n各部分之间用“/”符号隔开。\n```\n\n超链接的使用：\n\n```html\n<a href=\"\" target=\"_blank\" >click</a>\n\nhref属性指定目标网页地址。该地址可以有几种类型：\n\n    绝对 URL - 指向另一个站点（比如 href=\"http://www.jd.com）\n    相对 URL - 指当前站点中确切的路径（href=\"index.htm\"）\n    锚点 URL - 指向页面中的锚（href=\"#top\"）就会跳转到对应的id为top的位置去。\n\n# 关于target\n_blank: 表示在新标签页中打开目标网页\n_self: 表示在当前标签页打开目标网页\n_parent: 在父框架集中打开被链接文档。\n_top: 在整个窗口中打开被链接文档。\nframename: 在指定的框架中打开被连接的文档\n```\n\n##### 列表\n\n```html\n<ul>: 无序列表 [type属性：disc(实心圆点)(默认)、circle(空心圆圈)、square(实心方块)]\n<ol>: 有序列表\n         <li>:列表中的每一项.\n<dl>  定义列表\n         <dt> 列表标题\n         <dd> 列表项\n             \n# 这个值得注意的就是这个有序列表的序标，比如是数字的，还是罗马的还是字母的？有这样一个标识\ntype属性：\n\n1 数字列表，默认值\nA 大写字母\na 小写字母\nⅠ 大写罗马\nⅰ 小写罗马\n\n# Example\n<ol type=\"1\" start=\"2\">\n  <li>第一项</li>\n  <li>第二项</li>\n</ol>\n```\n\n##### 表格\n\n表格概念 表格是一个二维数据空间，一个表格由若干行组成，一个行又有若干单元格组成，单元格里可以包含文字、列表、图案、表单、数字符号、预置文本和其它的表格等内容。 表格最重要的目的是显示表格类数据。表格类数据是指最适合组织为表格格式（即按行和列组织）的数据。 表格的基本结构：\n\n```html\n<table>\n         <tr>\n                <td>标题</td>\n                <td>标题</td>\n         </tr>\n         \n         <tr>\n                <td>内容</td>\n                <td>内容</td>\n         </tr>\n</table>\n```\n\ntable的属性\n\n```\n<tr>: table row\n<th>: table head cell\n<td>: table data cell\n\n\n属性: 注意，这里的是属性，而不是放在style里面的样式。\n    border: 表格边框.\n    cellpadding: 内边距\n    cellspacing: 外边距.\n    width: 像素 百分比.（最好通过css来设置长宽）\n    rowspan:  单元格竖跨多少行，设置在td上。\n    colspan:  单元格横跨多少列（即合并单元格）\n```\n\n##### form表单\n\n功能：表单用于向服务器传输数据，从而实现用户与Web服务器的交互。表单能够包含input系列标签，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含textarea、select、fieldset和 label标签。\n\n**表单属性**\n\n- action: 表单提交到哪.一般指向服务器端一个程序,程序接收到表单提交过来的数据（即表单元素值）作相应处理，比如https://www.sogou.com/web\n- method: 表单的提交方式 post/get默认取值就是get\n- target：规定action属性中地址的目标（默认：_self）\n- novalidate：标识不适用浏览器的验证功能。\n- name：规定识别表单的名称（对于DOM使用：document.forms.name）\n- enctype：规定被提交数据的编码默认为：url-encoded\n- autocomplete：规定浏览器开启自动补全（完成）表单，默认为on，可以手动修改为off\n- accept-charset：规定在被提交表单中使用的字符集（默认：页面字符集）\n\n**表单元素**\n\n> HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。 表单一般用来收集用户的输入信息 表单工作原理： 访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交。这些信息通过Internet传送到服务器上。  服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误。当数据完整无误后，服务器反馈一个输入完成的信息\n\n**input标签**\n\n| type属性值 | 表现形式     | 对应代码                                                     |\n| ---------- | ------------ | ------------------------------------------------------------ |\n| text       | 单行输入文本 | `<input type=text\" />`                                       |\n| password   | 密码输入框   | `<input type=\"password\"  />`                                 |\n| date       | 日期输入框   | `<input type=\"date\" />`                                      |\n| checkbox   | 复选框       | `<input type=\"checkbox\" checked=\"checked\"  />`               |\n| radio      | 单选框       | `<input type=\"radio\"  />`;记得不同的单选选项记得要让他们的name一致，否则会造成都能选的情况。 |\n| submit     | 提交按钮     | `<input type=\"submit\" value=\"提交\" />`                       |\n| reset      | 重置按钮     | `<input type=\"reset\" value=\"重置\"  />`                       |\n| button     | 普通按钮     | `<input type=\"button\" value=\"普通按钮\"  />`                  |\n| hidden     | 隐藏输入框   | `<input type=\"hidden\"  />`                                   |\n| file       | 文件选择框   | `<input type=\"file\"  />`；form表单需要加上属性enctype=\"multipart/form-data\" |\n\n```\nbutton 按钮(需要配合js使用.) button和submit的区别？\n\n# Tip\n\n1 请求方式必须是post\n2 enctype=\"multipart/form-data\"\n\n表单属性\n\nname:    表单提交项的键.\n\n           注意和id属性的区别：name属性是和服务器通信时使用的名称；\n           而id属性是浏览器端使用的名称，该属性主要是为了方便客户端编程，而在css和javascript中使用的\n\nvalue:    表单提交项的值.对于不同的输入类型，value 属性的用法也不同：\n\n                type=\"button\", \"reset\", \"submit\" - 定义按钮上的显示的文本\n                 \n                type=\"text\", \"password\", \"hidden\" - 定义输入字段的初始值\n                 \n                type=\"checkbox\", \"radio\", \"image\" - 定义与输入相关联的值\n\n\nchecked:  radio 和 checkbox 默认被选中\n\nreadonly: 只读. text 和 password\n\ndisabled: 对所用input都好使.\n```\n\n**select标签**\n\n```html\n<select> 下拉选标签属性\n\n\n          name:表单提交项的键.\n\n          size：选项个数\n\n          multiple：multiple \n                 <optgroup>为每一项加上分组\n\n                 <option> 下拉选中的每一项 属性：\n\n                       value:表单提交项的值.   \n                       selected: selected下拉选默认被选中\n                     \n                     \n# 示例\n<form action=\"\" method=\"post\">\n  <select name=\"city\" id=\"city\">\n    <option value=\"1\">北京</option>\n    <option selected=\"selected\" value=\"2\">上海</option>\n    <option value=\"3\">广州</option>\n    <option value=\"4\">深圳</option>\n  </select>\n</form>\n```\n\n**`<textarea>` 多行文本框**\n\n```\n<form id=\"form1\" name=\"form1\" method=\"post\" action=\"\">\n        <textarea cols=“宽度” rows=“高度” name=“名称”>\n                   默认内容\n        </textarea>\n</form>\n- name：名称\n- rows：行数\n- cols：列数\n- disabled：禁用\n```\n\n**`<label>`标签**\n\n定义：`<label>` 标签为 input 元素定义标注（标记）。 \n\n说明： \n\n1. label 元素不会向用户呈现任何特殊效果。\n2.  `<label>` 标签的 for 属性值应当与相关元素的 id 属性值相同。此时点击lable，同时input也会被聚焦。\n\n```html\n<form method=\"post\" action=\"\">\n\n        <label for=“username”>用户名</label>\n        <input type=“text” name=“username” id=“username” size=“20” />\n</form>\n```\n\n**`<fieldset>`标签**\n\n```html\n<!--这个基本上是不怎么用的，我们都是自己布局加样式的，所以这个了解就好，就是一种把input框包起来的效果-->\n<fieldset>\n    <legend>登录吧</legend>\n    <input type=\"text\">\n</fieldset>\n```\n\n\n\n\n\n","timestamp":1540005876713},{"name":"02-HTML5新特性.md","path":"05-Frontend/01-HTML/02-HTML5新特性.md","content":"","timestamp":1540005876713},{"name":"01-CSS简单了解.md","path":"05-Frontend/02-CSS/01-CSS简单了解.md","content":"## CSS简单使用\n\n>http://www.cnblogs.com/yuanchenqi/articles/6856399.html\n>\n>http://www.cnblogs.com/liwenzhou/p/7999532.html\n\n[TOC]\n\n## 0、CSS介绍\n\nCSS（**C**ascading **S**tyle **S**heet，层叠样式表)定义**如何显示**HTML元素。\n\n当浏览器读到一个样式表，它就会按照这个样式表来对文档进行格式化（渲染）。\n\n## 1、选择器\n\n```css\nselector {\n          property: value;\n          property: value;\n     ...  property: value\n \n  }\n```\n\n比如：\n\n```css\nh1 {color:red; font-size:14px;}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-8/77825534.jpg)\n\n### 1.1、基本选择器\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-8/79864028.jpg)\n\n### 1.2、组合选择器\n\n```css\nE,F   多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔      :div,p { color:#f00; }\n \nE F   后代(儿子，孙子都算后代)元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔 :\n      li a { font-weight:bold;｝，会把li下的所有的a都给设置上。\n \nE > F   子元素选择器，匹配所有E元素的子元素F            :div > p { color:#f00; }\n        只是父级元素的二级元素才会被选择上。三级以后就不会被选择上了\n  \nE + F   毗邻元素选择器，匹配所有紧随E元素之后的同级元素F  :div + p { color:#f00; } \n        什么叫毗邻，就是紧挨着，中间插个第三者这就不叫紧挨着了。放到它上面还不行，只能在下面紧挨着。\n \nE ~ F   普通兄弟选择器（以破折号分隔）                 :.div1 ~ p{font-size: 30px; }\n        也是向下找，但是不管你挨着不挨着，反正就是同一级别的就行。\n```\n\n注意，关于标签嵌套：\n\n一般，块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。需要注意的是，p标签不能包含块级标签。\n\n### 1.3、属性选择器\n\n```css\nE[att]          匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略。\n                比如“[cheacked]”。以下同。）   p[title] { color:#f00; }\n \n \nE[att=val]      匹配所有att属性等于“val”的E元素   div[class=”error”] { color:#f00; }\n \n \nE[att~=val]     匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素\n                td[class~=”name”] { color:#f00; }\n \nE[attr^=val]    匹配属性值以指定值开头的每个元素                    \n                div[class^=\"test\"]{background:#ffff00;}\n \nE[attr$=val]    匹配属性值以指定值结尾的每个元素    div[class$=\"test\"]{background:#ffff00;}\n \nE[attr*=val]    匹配属性值中包含指定值的每个元素    div[class*=\"test\"]{background:#ffff00;}\n```\n\n##2、CSS的引用\n\n### 2.1、CSS的四种引用方式\n\n**行间样式**  （很少用）\n\n```html\n<!--行间样式很直观，但是只针对当前的标签生效，不具备统一修改的特效-->\n<body>\n\t<div style=\"width: 100px;height: 100px;background: red;\">\n\t\taaa\n\t</div>\t\n</body>\n```\n\n**内联样式表** （仍然是在文件内部）\n\n```html\n<!--不写在行间，而是写在head的style标签内部，便于分别去管理-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t#div1{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground: green;\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div id=\"div1\">\n\t\ttest\n\t</div>\n</body>\n</html>\n```\n\n**外联样式表** （用在外部，实际应用的方式）\n\n```html\n<!--从外部引用，将网页和样式进行分离-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"day1.css\">\n</head>\n<body>\n\t<div id=\"div1\">\n\t\ttest\n\t</div>\n</body>\n</html>\n\n<!--day1.css文件-->\n#div1{\n\twidth: 100px;\n\theight: 100px;\n\tbackground: yellow;\n}\n```\n\n**导入式的方法**：\n\n将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，style标记也是写在head标记中，使用的语法如下：    \n\n```css\n<style type=\"text/css\">\n \n          @import\"mystyle.css\"; 此处要注意.css文件的路径\n \n</style>　\n```\n\n注意：\n\n​      导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。\n\n### 2.2、CSS的优先级\n\n> 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity\n\n首先说CSS的属性是可以继承的，继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如一个BODY定义了的颜色值也会应用到段落的文本中。\n\n```css\nbody{color:red;}       <p>helloyuan</p>\n```\n\n这段文字都继承了由body {color:red;}样式定义的颜色。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。\n\n```css\np{color:green}\n```\n\n发现只需要给加个颜色值就能覆盖掉它继承的样式颜色。由此可见：任何显示申明的规则都可以覆盖其继承样式。此外，继承是CSS重要的一部分，我们甚至不用去考虑它为什么能够这样，但CSS继承也是有限制的。有一些属性不能被继承，如：border, margin, padding, background等。\n\n在聊CSS优先级之前，先聊一下元素的class，元素的class是允许存在多个的，比如：\n\n```css\n<div class=\"aaa bbb\">\n    lalala\n</div>\n```\n\n在这种情况下属于同级调用，class之间的优先级是一样的，那么这个时候如果两个class之间有属性冲突的话，那么就会以css中下面的为准（css的读取从上往下读），简单来说就是同级的调用之间的是收到顺序的影响的。\n\n不同级的属性调用之间，是存在不同的优先级的，优先级可以用数字来表示。\n\n所谓CSS优先级，即是指CSS样式在浏览器中被解析的先后顺序。\n\n样式表中的特殊性描述了不同规则的相对权重，它的基本规则是：\n\n```\n# 选择器的特殊性分为四个等级，分别为a,b,c,d\n- 如果样式是行内样式那么a=1，对应的权重为1000(a=1,b=0,c=0,c=0)\n- b表示ID选择器的个数，有一个id选择器那么b=1,有两个就是2，那么对应的权重就是0100或0200\n- c等于类，伪类和属性选择器的数量。比如有一个对应的权重就是0010\n- d等于类型选择器（其实就是标签选择器）和伪元素选择器的数量。比如有一个就是0001\n```\n\n- 内联样式表的权值最高                       style=\"\"－－－－－－－－－－－－1000；\n- 统计选择符中的ID属性个数。           #id －－－－－－－－－－－－－－100\n- 统计选择符中的CLASS属性个数。    .class －－－－－－－－－－－－－10\n- 统计选择符中的HTML标签名个数。 p －－－－－－－－－－－－－-－1\n\n```html\n1、#content div#main-content h2{}  \n2、#content #main-content>h2{}     \n3、body #content div[id=\"main-content\"] h2{}\n4、#main-content div.new-story h2{}\n5、#main-content [class=\"new-story\"] h2{}\n6、div#main-content div.new-story h2.first{}\n\n<!--对应的html代码-->\n<div id=\"content\">\n    <div id=\"main-content\">\n        <h2>Strange Times</h2>\n        <p>balabalabala</p>\n        <div class=\"new-story\">\n            <h2 class=\"first\">Bog Snorkeling Champion………………</h2>\n            <p>balabalabala</p>\n        </div>\n    </div>\n</div>\n\n# 问题为两个标题都会按照序号几的样式去设置？答案是1\n```\n\n按这些规则将数字符串逐位相加，就得到最终的权重，然后在比较取舍时按照从左到右的顺序逐位比较。\n\n>\n>1、文内的样式优先级为1,0,0,0，所以始终高于外部定义。\n>\n>2、有!important声明的规则高于一切。\n>\n>```css\n>.p2 {color:red!important;}\n>```\n>\n>3、如果!important声明冲突，则比较优先权。\n>\n>4、如果优先权一样，则按照在源码中出现的顺序决定，后来者居上。\n>\n>5、由继承而得到的样式没有specificity的计算，它低于一切其它规则(比如全局选择符*定义的规则)。\n>\n>6、关于经由@import载入的外部样式，由于@import必须出现在所有其他规则定义之前(如不是，则浏览器应该忽略之)，所以按照后来居上原则，一般优先权冲突时是占下风的。\n\n### 2.3、CSS的文本属性\n\n#### 水平对齐方式&文本属性\n\ntext-align 属性规定元素中的文本的水平对齐方式。\n\n- left      把文本排列到左边。默认值：由浏览器决定。\n- right    把文本排列到右边。\n- center 把文本排列到中间。\n- justify 实现两端对齐文本效果。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>css</title>\n<style>\n        h1 {text-align:center;}\n        p.publish_time {text-align:right;}\n        p.content {text-align:justify;}\n</style>\n</head>\n\n<body>\n<h1>CSS text-align 水平居中</h1>\n<p class=\"publish_time\">2017 年 5 月 17 号</p>\n<p class=\"content\">\n    有个落拓不得志的中年人每隔三两天就到教堂祈祷，而且他的祷告词几乎每次都相同。第一次他到教堂时，\n    跪在圣坛前，虔诚地低语：“上帝啊，请念在我多年来敬畏您的份上。让我中一次彩票吧！阿门。”\n    几天后，他又垂头丧气回到教堂，同样跪着祈祷：“上帝啊，为何不让我中彩票？我愿意更谦卑地来\n    服侍你，求您让我中一次彩票吧！阿门。”又过了几天，他再次出现在教堂，同样重复他的祈祷。如此周而\n    复始，不间断地祈求着。到了最后一次，他跪着：“我的上帝，为何您不垂听我的祈求？让我中一次彩票吧！\n    只要一次，让我解决所有困难，我愿终身奉献，专心侍奉您……”就在这时，圣坛上发出一阵宏伟庄严的声\n    音：“我一直垂听你的祷告。可是最起码？你也该先去买一张彩票吧!”</p>\n<p><b>注意：</b> 重置浏览器窗口大小查看 &quot;justify&quot; 是如何工作的。</p>\n</body>\n\n</html>\n```\n\n其他的文字属性：\n\n```css\nfont-size: 10px;\nline-height: 200px;   文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比\nvertical-align:－4px  设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效\ntext-decoration:none  text-decoration 属性用来设置或删除文本的装饰。主要是用来删除链接的下划线\nfont-family: \'Lucida Bright\'\nfont-weight: lighter/bold/border/\nfont-style: oblique\ntext-indent: 150px;      首行缩进150px\nletter-spacing: 10px;  字母间距\nword-spacing: 20px;  单词间距\ntext-transform: capitalize/uppercase/lowercase ; 文本转换，用于所有字句变成大写或小写字母，或每个单词的首字母大写\n```\n\n如果想要一个简单的居中可以使用line-height=容器的高，这样是上下垂直居中。然后text-align的值是center可以让你的文本左右水平居中。\n\n### 2.4、CSS的样式了解\n\n#### 颜色值：\n\n- 十六进制表示法，比如：background: #3CC; //#33CCCC，这种的就可以进行缩写\n\n- RGB模式，比如：rgb(100,255,233) //[RBG颜色对照表](http://tool.oschina.net/commons?type=3)\n\n- RGBA模式，在RBG的基础上调整透明度，比如：background: rgba(255,0,0,0.5);或者使用opacity这个来调整透明度。范围是0~1,1表示颜色的纯色。\n\n  ![](http://omk1n04i8.bkt.clouddn.com/17-10-30/37912135.jpg)\n\n- 颜色的单词，比如：red，green等\n\n#### 注释\n\n```css\n/*  我是被注释的内容  */\n```\n\n#### 背景图片\n\n```css\nbackground-image: url(img/b.png);\n```\n\n默认的情况下是平铺：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/69719727.jpg)\n\n如果不想平铺的话我们可以进行设置（背景图片层级要高于背景颜色）\n\n```css\nbackground-repeat: no-repeat;\n```\n\n还可以设置为横向重复：\n\n```css\nbackground-repeat: repeat-x;\n```\n\n\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/34906123.jpg)\n\n设置垂直平铺：\n\n```css\nbackground-repeat: repeat-y;\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/62538269.jpg)\n\n#### 设置背景定位\n\n调整图片的定位可以使用background-position这个设置参数。\n\n```css\nbackground-position: 50px 30px;   # 使用像素值，第一个值最好写x轴，第二个值最好写y\nbackground-position: -50px -30px; # 同样也支持负值\nbackground-position: 50% 30px;    # 使用百分比\nbackground-position: left bottom;   # 使用位置单词\n/*x轴有left center right三种位置。默认居中*/\n/*y轴有top，center，bottom，默认居中*/\n\n如果写成：\nbackground-position: center;   # 默认全放在中间 \n```\n\n如果你在设置定位的时候同时还使用了水平平铺或者垂直平铺，没被覆盖到的位置会被图片的其他部分补齐，比如：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/38561136.jpg)\n\n如果设置的div容器的大小小于图片的话，那么就是能看到多少就是看到多少。\n\n**设置图片不随着滚动条滚动**\n\n```css\nbackground-attachment: fixed;\n```\n\n**复合样式**\n\n```css\n/*这个顺序是可以任意调整的，没有的就不写，但是position定位xy轴是放到一块写的*/\nbackground: red url(img/maka.jpg) no-repeat center fixed;\n```\n\n#### 边框\n\n```css\n/*设置元素的border属性*/\n#div1{\n\twidth: 100px;\n\theight: 100px\n\tborder: 2px solid red;\n}\n- solid：实线\n- dashed：虚线\n- dotted：点线\n```\n\n边框肯定是四条边，我们可以针对这四条边进行拆分的：\n\n```css\nborder-top: 3px solid red;\nborder-left: 3px dotted green;\nborder-right: 3px dashed blue;\nborder-bottom: 3px solid yellow;\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-10-30/18069121.jpg)\n\n#### 列表属性\n\n```css\nlist-style-type         设置列表项标志的类型。（一般设置为None）\nlist-style-image        将图象设置为列表项标志。取代默认的样式\nlist-style-position     设置列表中列表项标志的位置。\nlist-style              简写属性。用于把所有用于列表的属性设置于一个声明中（一般设置为None）\n```\n\nlist-style-type属性指定列表项标记的类型：\n\n```css\nul { list-style-type: square; }\n```\n\n使用图像来替换列表项的标记:\n\n```css\n# 基本上用的非常少\nul {\n     list-style-image: url(\'\');\n}\n```\n\n#### display属性\n\n- none\n\n  ```css\n  p{display:none;}\n\n  注意与visibility:hidden的区别：\n  visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。相当于虽然不显示了，但是仍然会占一个坑。\n  display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。\n  ```\n\n- block（内联标签设置为块级标签）\n\n  ```css\n  span {display:block;}\n  注意：一个内联元素设置为display:block是不允许有它内部的嵌套块元素。　\n  ```\n\n- inline\n\n  ```css\n  # 块级别标签设置为内联级别的标签\n  li {display:inline;}\n  # 比如上面的把li设置一行显示，而不是独占一行。内容撑开宽高。\n  # 内联标签不能设置长宽，不支持上下的margin，代码换行被解析\n  ```\n\n- inline-block(设置成内联形式的块元素，可以设置长宽了；没有宽度的时候内容撑开宽度)\n\n  ```css\n  display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决：\n  #outer{\n              border: 3px dashed;\n              word-spacing: -5px;\n          }\n  ```\n\n#### 浮动Float\n\nfloat：left|right|none|inherit\n\n文档流：是文档中可以显示对象在排列时所占用的位置。\n\n浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停下来\n\n浮动的顺序是按照元素在页面从上到下的顺序加载的。浮动元素会去判断上一个元素是否是浮动的，如果是浮动的那么我就紧贴着你，如果不是浮动的块级元素那我就垂直顶着你，如果不是浮动的内联元素比如span这种会被挤到一边去。\n\n浮动的基本特征：\n\n- 块在一排显示\n- 内联支持宽高\n- 默认文档撑开宽度\n- 脱离文档流\n- 提升层级半层\n\n清除浮动的方法：\n\n- 加高度（扩展性不好）\n- 父级也浮动（页面中所有的元素都浮动，margin左右自动失效，因此也不是很好的方法）\n- inline-block方法清除浮动：会导致margin左右的auto失效\n- 空标签清除浮动：但是只要用到浮动的地方就要去放一个空标签也是不合适的。\n- br清除浮动：br有一个属性叫`clear=\"all\"`，不符合工作中的结构，行为，样式的三者分离的要求\n- after伪类：清除浮动的方法\n\n下边的元素会判断你上级的元素是否是浮动的。\n\nclear：left|right|both|none|inherit\n\n元素在某个方向上不能有浮动元素，clear both指的是两侧均不予许有浮动元素。注意clear影响的是元素自己本身，比如我不允许我的左侧有浮动，那么肯定是影响的我自己，而不是把别人给挪走。比如我左边有浮动元素，我clear left，那么肯定是我走，我不能影响其他人的。\n\nfloat会覆盖div但是不会影响文字\n\n#### overflow\n\n- overflow: hidden\n\n  ```\n  当内容的高度超过容器设置的高度以后会溢出，因此有时候我们会去设置这个overflow-hidden这个参数，让它隐藏，被隐藏的部分可以以滚动条的形式查看。但是拥有overflow:hidden样式的块元素内部的元素溢出并不总是被隐藏，具体来说，需要同时满足以下条件：\n  \n  - 有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；\n  - 内部溢出的元素是通过position:absolute绝对定位；\n  \n  overflow：hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。\n  ```\n\n| 值      | 描述                                                     |\n| ------- | -------------------------------------------------------- |\n| visible | 默认值。内容不会被修剪，会呈现在元素框之外。             |\n| hidden  | 内容会被修剪，并且其余内容是不可见的。                   |\n| scroll  | 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 |\n| auto    | 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 |\n| inherit | 规定应该从父元素继承 overflow 属性的值。                 |\n\n","timestamp":1540005876713},{"name":"02-CSS盒模型.md","path":"05-Frontend/02-CSS/02-CSS盒模型.md","content":"# CSS盒模型\n\n[TOC]\n\n## 伪类&伪元素\n\n> 参考内容:\n>\n> https://blog.csdn.net/ansenamerson/article/details/71250093\n>\n> 伪元素特效应用：\n>\n> https://www.jb51.net/css/461830.html\n>\n> https://blog.csdn.net/natalie86/article/details/44656247\n\n### 伪类\n\n伪类包含两种，状态伪类和结构性伪类，状态伪类专用于控制链接的显示效果。\n\n```css\na:link（没有接触过的链接）,用于定义了链接的常规状态。\na:hover（鼠标放在链接上的状态）,用于产生视觉效果。\na:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。\na:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。\na:focus 应用于用于键盘输入焦点的元素\n\n伪类选择器 : 伪类指的是标签的不同状态:\na ==> 点过状态 没有点过的状态 鼠标悬浮状态 激活状态\na:link {color: #FF0000} /* 未访问的链接 */\na:visited {color: #00FF00} /* 已访问的链接 */\na:hover {color: #FF00FF} /* 鼠标移动到链接上 */\na:active {color: #0000FF} /* 选定的链接 */ 格式: 标签:伪类名称{ css代码; }\n```\n\n结构性伪类是CSS3新增的选择器，比如，具体内容可以移步到css3章节查看：\n\n```css\nE:nth-last-child(n) 表示E父元素中的第n个子节点，从后往前计算\nE:nth-of-type(n) 表示E父元素中的第n个子节点，类型为E\nE:nth-last-of-type(n) 表示E父级元素中的第n个子节点，类型为E，从后往前计算\nE:empty 表示匹配E元素中没有子节点的，并且里面没有内容的。其实就是找一个空标签，有文字不行，在这里文字也算一个节点。\nE:first-child 表示E元素中的第一个子节点，相当于nth-child(1)\nE:last-child 表示E元素中的最后一个子节点，相当于nth-last-child(1)\nE:first-of-type 表示E父元素中的第一个子节点且节点类型为E的，等价于nth-of-type(1)\nE:last-of-type 表示E父元素中的最后一个子节点且节点类型为E的，等价于nth-last-of-type(1)\nE:only-child 表示E元素中只有一个子节点，注意：子节点不包含文本节点\nE:only-of-type：表示E的父元素只有一个子节点，且这个唯一的子节点类型必须是E，注意子节点不包含文本节点\n```\n\n### 伪元素\n\n**伪元素**是对元素中的特定内容进行操作，而不是描述状态。它的操作层次比伪类更深一层，因此动态性比伪类低很多。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中！常见的伪元素选择器包括：\n\n```\n:first-letter 选择元素文本的第一个字（母）。\n:first-line 选择元素文本的第一行。\n:before 在元素内容的最前面添加新内容。\n:after 在元素内容的最后面添加新内容。\n\n# 动态的添加内容\np:after{\n    content:\'hello world\'\n    color:red\n}\n\np:before\n```\n\n单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。对于 CSS2 中已经有的伪元素，例如 :before，单冒号和双冒号的写法 ::before 作用是一样的。目的其实是为了区分伪类和伪元素，而且大部分的浏览器都是识别这种标识方法的。\n\n示例：\n\n```css\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <style>\n\n       .top{\n           background-color: rebeccapurple;\n           width: 100px;\n           height: 100px;\n       }\n        .bottom{\n            background-color: green;\n            width: 100px;\n            height: 100px;\n        }\n\n        .outer:hover .bottom{\n            background-color: yellow;\n        }\n\n        注意:一定是outer:hover  控制outer里某一个标签,否则无效\n\n        .top:hover .bottom{\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n\n\n<div class=\"outer\">\n    <div class=\"top\">top</div>\n    <div class=\"bottom\">bottom</div>\n</div>\n</body>\n</html>\n```\n\n### 伪元素的应用\n\n#### 给首字母设置特殊样式\n\n```css\np:first-letter {\n  font-size: 48px;\n  color: red;\n}\n```\n\n#### 清浮动\n\n```css\n.clear:after {\n    content: \'\';\n    display: block;\n    clear: both;\n}\n```\n\n#### 画分割线\n\n```html\n<style>\n    * {\n      padding: 0;\n      margin: 0;\n    }\n    .spliter::before, .spliter::after {\n      content: \'\';\n      display: inline-block;\n      border-top: 1px solid black;\n      width: 200px;\n      margin: 5px;\n    }\n  </style>\n</head>\n<body>\n  <p class=\"spliter\">分割线</p>\n</body>\n```\n\n#### 做一个消息气泡\n\n```html\n<head>\n    <style>\n        #bubble{\n            position: relative;\n            width:300px;\n            height:150px;\n            background-color: #5bc0de;\n            margin: 200px auto;\n            border-radius: 10px;\n        }\n        #bubble:before{\n            position: absolute;\n            content: \'\';\n            width: 0;\n            height: 0;\n            right: 100%;\n            top: 60px;\n            border-top: 15px solid transparent;\n            border-right: 30px solid #000;\n            border-bottom: 15px solid transparent;\n        }\n    </style>\n</head>\n<body>\n\n<div id=\"bubble\"></div>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-30/35449268.jpg)\n\n伪元素的本质是在不增加dom结构的基础上添加的一个元素，在用法上跟真正的dom无本质区别。普通元素能实现的效果，伪元素都可以。有些用伪元素效果更好，代码更精简。\n\n## 盒模型\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-9/55577387.jpg)\n\n- **margin**:            用于控制元素与元素之间的距离；margin的最基本用途就是控制元素周围空间的间隔，从视觉角度上达到相互隔开的目的。注意两个元素的margin是会重叠的，按照两者之间大的算，比如两个div一个margin是20，一个是30，\n- **padding**:           用于控制内容与边框之间的距离；   \n- **Border**(边框):     围绕在内边距和内容外的边框。\n- **Content**(内容):   盒子的内容，显示文本和图像。\n\n### margin\n\n**单边外边距属性：**\n\n```css\nmargin-top:100px;\nmargin-bottom:100px;\nmargin-right:50px;\nmargin-left:50px;\n```\n\n当然margin也是一个复合属性，我可以直接用一个margin来写四条边的：\n\n```css\nmargin:10px 20px 20px 10px；\n\n        上边距为10px\n        右边距为20px\n        下边距为20px\n        左边距为10px\n\nmargin:10px 20px 10px;\n\n        上边距为10px\n        左右边距为20px\n        下边距为10px\n\nmargin:10px 20px;\n\n        上下边距为10px\n        左右边距为20px\n\nmargin:25px;\n\n        所有的4个边距都是25px\n```\n\n居中的用法\n\n```css\nmargin: 0 auto;\n```\n\n### padding（内填充）\n\n单独使用填充属性可以改变上下左右的填充。缩写填充属性也可以使用，一旦改变一切都改变。\n\n设置同margine；(padding会影响盒子大小，简单来说可以用padding给撑起来)\n\n**思考1: ** body的外边距\n\n​       边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下，   body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上：\n\n```css\nbody{\n    border: 1px solid;\n    background-color: cadetblue;\n}\n```\n\n解决方法：\n\n```css\nbody{\n    margin: 0;\n}\n```\n\n**思考2：**margin collapse（边界塌陷或者说边界重叠）\n\n1、兄弟div：\n上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值（塌陷的重叠只会针对上下，不针对左右。）\n\n2、父子div：\n\n如果父级div中没有border，padding，inlinecontent，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content中的其中一个，然后按此div 进行margin；\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" style=\"padding: 0px\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n\n        body{\n            margin: 0px;\n        }\n\n        .div1{\n            background-color: rebeccapurple;\n            width: 300px;\n            height: 300px;\n            overflow: hidden;\n\n        }\n        .div2{\n            background-color: green;\n            width: 100px;\n            height: 100px;\n            margin-bottom: 40px;\n            margin-top: 20px;\n        }\n        .div3{\n            background-color:teal;\n            width: 100px;\n            height: 100px;\n            margin-top: 20px;\n        }\n    </style>\n</head>\n<body>\n<div style=\"background-color: bisque;width: 300px;height: 300px\"></div>\n\n<div class=\"div1\">\n\n   <div class=\"div2\"></div>\n   <div class=\"div3\"></div>\n</div>\n\n</body>\n\n</html>\n```\n\n解决方案：\n\n```css\noverflow: hidden;　　\n```\n\n## CSS中的定位（position）\n\n```css\nposition:relative; 相对定位\n- 不影响元素本身的特性\n- 不使元素脱离文档流，元素移动之后原始位置会被保留\n- 如果没有定位偏移量，对元素本身没有任何影响\n- 提升层级\n\n定位元素位置控制： top/right/bottom/left 定位元素偏移量\n```\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n        #div1{width: 200px;height: 200px;background: red}\n        #div2{width: 200px;height: 200px;background: green;position: relative;left: 200px;top: 200px}\n        #div3{width: 200px;height: 200px;background: blue}\n    </style>\n</head>\n<body>\n    <div id=\'div1\'></div>\n    <div id=\'div2\'></div>\n    <div id=\'div3\'></div>\n</body>\n</html>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-12-6/16357681.jpg)\n\n```css\nposition:absolute; 绝对定位\n- 使元素脱离文档流\n- 是内嵌元素支持宽高\n- 块属性标签内容撑开宽度\n- 如果有定位父级相对于定位父级发生偏移，没有定位父级相对于document发生偏移\n- 相对定位一般都是配合绝对定位元素使用\n- 提升层级\n\nz-index：[number]；  定位层级\n- 定位元素默认后者层级高于前者\n- 建议在兄弟标签之间比较层级\n```\n\n示例参考：\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style>\n\t\t\tbody{\n\t\t\t\tposition: relative;\n\t\t\t}\n\t\t\tdiv{\n\t\t\t\twidth: 200px;\n\t\t\t\theight: 200px;\n\t\t\t}\n\t\t\t.div1{\n\t\t\t\tbackground-color: red;\n\t\t\t}\n\t\t\t.div2{\n\t\t\t\tposition: absolute;\n\t\t\t\tleft:200px;\n\t\t\t\ttop:400px; # 距离body的。\n\t\t\t\tbackground-color: blue;\n\t\t\t}\n\t\t\t.div3{\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 400px;\n\t\t\t\tbackground-color: green;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"div1\">div1</div>\n\t\t<div class=\"div2\">div2</div>\n\t\t<div class=\"div3\">div3</div>\n\t</body>\n</html>\n\n```\n\n\n\n```css\nposition:fixed; 固定定位\n与绝对定位的特性基本一致，差别是始终相对于整个文档进行定位；\n问题：IE6不支持固定定位\n\n\n示例：\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style>\n\t\t\tbody{\n\t\t\t\theight: 3000px;\n\t\t\t}\n\t\t\tdiv{\n\t\t\t\twidth: 100px;\n\t\t\t\theight: 100px;\n\t\t\t\tbackground-color: red;\n\t\t\t\tposition: fixed;\n\t\t\t\tright: 0;\n\t\t\t\tbottom: 0;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div>返回顶部</div>\n\t</body>\n</html>\n\n\n其他不常用定位：\nposition：static；默认值\nposition：inherit；从父级元素继承定位属性的值\n\nposition：relative|absolute|fixed|static|inherit\n```\n\n### 透明度\n\n```css\nopacity:0~1; 1表示不透明，0表示完全透明。这个内容是默认继承父级的透明度的。\n```\n\n广告弹层示例：\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\tdiv{\n\t\t\t\twidth: 300px;\n\t\t\t\theight: 300px;\n\t\t\t}\n\t\t\t.box{\n\t\t\t\tmargin: 100px auto;\n\t\t\t\tposition: relative;\n\t\t\t}\n\t\t\t.content{\n\t\t\t\tposition: absolute;\n\t\t\t\tbackground-color: blue;\n\t\t\t\tleft: -6px;\n\t\t\t\ttop: -6px;\n\t\t\t\tz-index: 2;\n\t\t\t}\n\t\t\t.mark{\n\t\t\t\tposition: absolute;\n\t\t\t\tbackground-color: black;\n\t\t\t\tright: -6px;\n\t\t\t\tbottom: -6px;\n\t\t\t\tz-index: 1;\n\t\t\t\topacity: 0.5;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"box\">\n\t\t\t<div class=\"content\"></div>\n\t\t\t<div class=\"mark\"></div>\n\t\t</div>\n\t</body>\n</html>\n```\n\n## Tip\n\n### 默认高度和宽度的问题\n\n（1）父子都是块级元素\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>fortest</title>\n    <style>\n        div.parent{\n            width: 500px;\n            height: 300px;\n            background: #ccc;\n        }\n        div.son{\n            width: 100%;\n            height: 200px;\n            background: green;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"parent\">\n        <div class=\"son\"></div>\n    </div>\n</body>\n</html>\n```\n\n这时，子元素设置为了父元素width的100%，那么子元素的宽度也是500px；但是如果我们把子元素的width去掉之后，就会发现子元素还是等于父元素的width。**也就是说，对于块级元素，子元素的宽度默认为父元素的100%。**\n\n> **当我们给子元素添加padding和margin时，可以发现宽度width是父元素的宽度减去子元素的margin值和padding值。**\n\n**毫无疑问，如果去掉子元素的height，就会发先子元素的高度为0，故height是不会为100%的，**一般我们都是通过添加内容（子元素）将父元素撑起来。\n\n（2）父：块级元素  子：内联元素\n\n如果内联元素是不可替换元素（除img，input以外的一般元素），元素是没有办法设置宽度的，也就谈不上100%的问题了。 即内联元素必须依靠其内部的内容才能撑开。\n\n如果内联元素是可替换元素（img，input，本身可以设置长和宽），**不管怎么设置父元素的宽度和高度，而不设置img的宽和高时，img总是表现为其原始的宽和高。**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>...</title>\n    <style>\n        div.parent{\n            width: 500px;\n            height: 300px;\n            background: #ccc;\n        }\n        img{\n            height: 100px;\n            background: green;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"parent\">\n        <img class=\"son\" src=\"s1.jpg\"></img>\n    </div>\n</body>\n</html>\n```\n\n由此我们可以发现，虽然没有设置宽度，但是表现在浏览器上为160px，它并没有继承父元素的100%得到500px，而是根据既定的高度来等比例缩小宽度。  同样， 如果只设置width，那么height也会等比例改变。   如果我们把img的width设置为100%，就可以发现其宽度这时就和父元素的宽度一致了。而我们一般的做法时，首先确定img的父元素的宽度和高度，然后再将img的宽度和高度设置为100%，这样，图片就能铺满父元素了。\n\n## 后台布局框架\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <style>\n\n        .pg-header{\n           height: 48px;\n           width: 100%;\n           background-color: #2459a2;\n           position: fixed;\n           top:0;\n           left: 0;\n        }\n        .left{\n            position:absolute;\n            left:0;\n            top:48px;\n            bottom:0;\n            width:200px;\n            background-color: #ededed;\n        }\n\n        .right{\n            position:absolute;\n            right:0;\n            left:200px;\n            top:48px;\n            bottom:0;\n            overflow:auto;\n\n        }\n        .content{\n            height: 2000px;\n            width: 100%;\n           \n        }\n    </style>\n</head>\n<body>\n\n\n<div class=\"pg-header\"></div>\n<div>\n    <div class=\"left\">\n\n    </div>\n    <div class=\"right\">\n      <div class=\"content\"></div>\n    </div>\n</div>\n\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"03-浮动.md","path":"05-Frontend/02-CSS/03-浮动.md","content":"> 参考文章\n>\n> - http://www.cnblogs.com/Zigzag/archive/2009/02/19/position.html\n> - http://www.cnblogs.com/coffeedeveloper/p/3145790.html\n> - https://segmentfault.com/a/1190000004237437\n> - http://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html\n> - http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/\n> - http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%BA%8C/\n\n## Float\n\n>关于浮动，其实浮动的本意即让文字可以像流水一样环绕自己,\n>\n>浮动的特性：\n>\n>- 包裹性\n>\n>  ```\n>  # 具有包裹性的其他小伙伴\n>  - display:inline-block/table-cell\n>  - position:absulute(近亲)/fixed/sticky\n>  - overflow:hidden/scroll\n>  ```\n>\n>- 破坏，父容器被破坏，体现上就是父级元素的高度塌陷。\n>\n>  ```\n>  # 具有破坏性的小伙伴\n>  - display:none\n>  - position:absolute/fixed/sticky\n>  ```\n>\n>  \n\n，学习浮动可以从以下几个方面去学习查看。\n\n#### 平级的浮动\n\n- 首先说浮动会破坏对象本身的display属性，比如把一个块级别的div设置为浮动以后，默认的display: block的属性就会被破坏。比如下面的3个div，我设置为第二个div为浮动以后，那么它就会脱离正常的文档流，第三个div会跑到它下面被它覆盖。首先说什么是文档流，在英文原版里文档流不是document flow，而是normal flow。意即html文档从上到下读取各个元素本来应该显示在的位置\n- 浮动元素会查看上一个元素是不是浮动的，如果不是浮动的按照正常文档流，如果是浮动的那么就紧贴着上一个元素。顺序按照文档顺序从上到下。\n\n<iframe height=\'265\' scrolling=\'no\' title=\'Study Float1\' src=\'https://codepen.io/lamber/embed/ypxoPP/?height=265&theme-id=0&default-tab=css,result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/lamber/pen/ypxoPP/\'>Study Float1</a> by lamber (<a href=\'https://codepen.io/lamber\'>@lamber</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n\n#### 父级浮动\n\n父级浮动会呈现出元素的包裹性。针对块级元素来讲，默认内部内容撑起高度，块级别元素如果不指定宽度的话那么就会100%撑满，但是即使设置了宽度由于块属性元素的特征，依然会占满这一行，不允许其他的元素。但是元素一旦设置了float属性以后就会“浮起来”，像inline元素一样，产生包裹性，比如：\n\n```html\n<div style=\"border: 2px solid black;float: left\">\n    <div style=\"width: 100px;height: 100px;background: greenyellow\"></div>\n</div>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-12-20/65943745.jpg)\n\n#### 子级浮动\n\n子级浮动会产生高度欺骗，让外层包裹层的高度塌陷了。内部内容的浮动使得包裹层认为内部元素的高度为0，因此出现了高度塌陷的问题。因此浮动并不是让元素的高度塌陷了，而是让元素具有高度塌陷的欺骗性。\n\n<iframe height=\'265\' scrolling=\'no\' title=\'Study Float2\' src=\'https://codepen.io/lamber/embed/opPePK/?height=265&theme-id=0&default-tab=css,result&embed-version=2\' frameborder=\'no\' allowtransparency=\'true\' allowfullscreen=\'true\' style=\'width: 100%;\'>See the Pen <a href=\'https://codepen.io/lamber/pen/opPePK/\'>Study Float2</a> by lamber (<a href=\'https://codepen.io/lamber\'>@lamber</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n\n### 浮动的清除\n\n首先要说明的一点是clear影响的对象是自己，比如一个对象设置了`clear: left;`那么我是要不允许我自己的左侧不允许有浮动的对象，但是我不改变别人，而是改变我自己。通常清除浮动有以下的形式：\n\n- HTML block水平元素底部走起\n\n- CSS after伪元素底部生成\n\n  ```css\n  .clearfix:after{content:\'\';display:block;height:0;overflow:hidden;clear:both;}\n  # 或者\n  .clearfix:after{content:\'\'display:table;clear:both;}\n  ```\n\nclearfix应该只用在包含浮动子元素的父级元素上。\n\n\n\n\n\n\n\n## Position\n\n","timestamp":1540005876713},{"name":"06-vertical&line-hight.md","path":"05-Frontend/02-CSS/06-vertical&line-hight.md","content":"www.cnblogs.com/yuanchenqi/articles/6870763.html","timestamp":1540005876713},{"name":"20-CSS3.md","path":"05-Frontend/02-CSS/20-CSS3.md","content":"# CSS3入门\n\n## Selector\n\n### 属性选择器\n\n- p[miaov]：只选择属性名\n\n- p[miaov=leo]：带属性名而且要求属性值\n\n- p[attr~=\"value\"]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格分开，其中词列表中包含了一个value词，而且等号前面的“~”是不能省略的。\n\n  ```css\n  /*表示对应的属性词列表里有old就能匹配上*/\n  p[miaov~=old]\n  ```\n\n- p[attr^=\"value\"]：指定属性名，并且具有属性值，属性值是以value开头的。\n\n  ```css\n  p[miaov^=g]\n  ```\n\n- E[attr$=\"value\"]：指定属性名，有属性值，而且属性值是以value结束的，区分大小写\n\n- E[attr*=\"value\"]：指定属性名，有属性值，而且属性值中包含了value\n\n- E[attr|=\"value\"]：指定属性名，并且属性值是value或者以value-开头的值，如zh-cn\n\n### 结构选择器\n\n- E:nth-child(n) 标识E父元素中的第n个节点 （CSS3中是从1开始计数，而不是0）\n  - p:nth-child(odd){background:red} 匹配奇数行，并且这个元素是p标签\n  - p:nth-child(even){background:red} 匹配偶数行，并且这个元素是p标签。\n  - p:nth-child(2n){background:red} 匹配偶数行，n表示自然数，这里可以计算，比如说（2n-1）\n- E:nth-last-child(n) 表示E父元素中的第n个子节点，从后往前计算\n- E:nth-of-type(n) 表示E父元素中的第n个子节点，类型为E\n- E:nth-last-of-type(n) 表示E父级元素中的第n个子节点，类型为E，从后往前计算\n- E:empty 表示匹配E元素中没有子节点的，并且里面没有内容的。其实就是找一个空标签，有文字不行，在这里文字也算一个节点。\n- E:first-child  表示E元素中的第一个子节点，相当于nth-child(1)\n- E:last-child 表示E元素中的最后一个子节点，相当于nth-last-child(1)\n- E:first-of-type 表示E父元素中的第一个子节点且节点类型为E的，等价于nth-of-type(1)\n- E:last-of-type 表示E父元素中的最后一个子节点且节点类型为E的，等价于nth-last-of-type(1)\n- E:only-child 表示E元素中只有一个子节点，注意：子节点不包含文本节点\n- E:only-of-type：表示E的父元素只有一个子节点，且这个唯一的子节点类型必须是E，注意子节点不包含文本节点\n\n```html\n<!----实例示例：新浪导航------>\n样式：\n.list {list-style: none;margin: 0;padding:0;}\n.list li {width: 150px;float: left;border-right: 1px solid #000;}\n.list li:nth-last-child(1){border: none}\n.list li a{text-decoration: none;width: 40px;float: left;text-align: center;margin: 0 4px;font: 12px/30px 宋体 ;color:#000}\n.list a:nth-child(3n+1){font-weight: bold;}\n.list li:nth-child(3) a:nth-child(2){color: orange}\n\nhtml：\n<ul class=\"list\">\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n    <li>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n        <a href=\"\">新闻</a>\n    </li>\n\n</ul>\n```\n\n### 伪类\n\n- E:target  匹配相关URL指向的E元素。\n\n  ```css\n  /*URL后面跟锚点#，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)，:target选择器用于选取当前活动的目标元素。*/\n  #demo:target{color:#f00;}\n\n  <div id=\"demo\">\n  \t<p>E:target伪类使用方法</p>\n  </div>\n  当访问连接为：www.example.com/#demo的时候，我们会发现字体变成了红色\n  ```\n\n- E:disabled  表示不可点击的表单控件 `input:enabled{background:red}`\n\n- E:enabled  表示可点击的表单控件\n\n- E:checked  表示已选中的checkbox或者radio，其实复选框也没有太多可以设置的。这个主要是配合使用的，配合选择后面的兄弟标签。\n\n  ```html\n  <!--点击对应的方块都会变红-->\n  <label>\n      <input type=\"radio\" name=\"tab\">\n      <span></span>\n  </label>\n  <label>\n      <input type=\"radio\" name=\"tab\">\n      <span></span>\n  </label>\n  <label>\n      <input type=\"radio\" name=\"tab\">\n      <span></span>\n  </label>\n\n  label{\n      float: left;\n      position: relative;\n      margin: 0 5px;\n      overflow: hidden;\n  }\n  label input{\n      position: absolute;\n      top: -50px;\n      left: -50px;\n  }\n  span{\n      float: left;\n      width: 50px;\n      height: 50px;\n      border: 3px solid #000;\n  }\n  ```\n\n- E:first-line  表示E元素中的第一行\n\n- E:first-letter 表示E元素中的第一个字符，设置了以后第一个字符不会被选中。\n\n- E::selection  表示E元素在用户选中文字时，触发的一个样式。比如设置选中以后背景色和文字颜色\n\n- E::before 生成内容在E元素前\n\n- E::after 生成内容在E元素后\n\n- E:not(s) 表示E元素不被匹配，帮我们排除掉一些元素\n\n  ```html\n  # 除了class=“h2”的就都被排除掉了。\n  h1:not(.h2){xxx}\n  ```\n\n- E~F表示E元素毗邻的F元素，往下找不往上找\n\n- Content属性\n\n  ```css\n  p::before{content: \"hahahaha\";display:block;}\n  ```\n\n## 文本新增属性\n\n### 新增颜色模式\n\n- rgba：rgba(0,0,0,0.5)；加给背景，背景透明，文字不透明。加给color可以使文字透明。给边框加，边框也可以变成透明的。\n\n  | r    | red   | 红   | 0~255 |\n  | ---- | ----- | ---- | ----- |\n  | g    | green | 绿   | 0~255 |\n  | b    | Blue  | 蓝色 | 0~255 |\n  | a    | Alpha | 透明 | 0~1   |\n\n### 文字阴影\n\n- text-shadow: x y blur color, …（文字可以有多层阴影，写多个就行了，不同的层之间用逗号隔开）\n- 参数：\n  - x：横向偏移，正数往右偏移\n  - y：纵向偏移，正数是从上往下偏移\n  - blur：模糊距离\n  - color：阴影颜色\n- 文本阴影如果加很多层，会很卡很卡很卡\n\n```css\n# 对阴影的一种巧妙的利用，会产生一种浮雕的感觉\n<h1>longfor</h1>\n\nh1{text-align:center; color:#ffffff;text-shadow: 2px 2px 4px #000000;}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-2/33669204.jpg)\n\n```css\n/*光晕的效果*/\nh1{\n    color: white;\n    text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px #ffffff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de,0 0 100px #ff00de,0 0 150px #ff00de;\n}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-2/42382960.jpg)\n\n```css\n/*火焰的效果*/\nh1{\n    color: white;\n    text-align: center;\n    text-shadow: 0 0 20px #fefcc9,10px -10px 30px #feec85,-20px -20px 40px #ffae34,20px -40px 50px #ec760c,-20px -60px 60px #cd4606,0 -80px 70px #973716,10px -90px 80px #451b0e;\n    font-family: Verdana,Geneva,sans-serif;\n    font-weight: bold;\n}\n```\n\n### 文字模糊效果\n\n```css\nh1{text-align: center;color:#000;text-shadow:0 0 0 rgba(0,0,0,1);\n    transition: 1s;}\nh1:hover{color:rgba(0,0,0,0);text-shadow: 0 0 20px rgba(0,0,0,0.2);}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-2/95067259.jpg)\n\n### 文字的描边：\n\n```css\n/*描边只适用于webkit内核的浏览器，而且写的时候要带上webkit的前缀*/\n/*两个参数，一个描边宽度，一个描边颜色*/\nh1{\n    text-align: center;\n    color:#000;\n    -webkit-text-stroke: 3px red;\n}\n```\n\n### Direction文字排列方式（全兼容）\n\n- Rtl从右向左排列\n- Ltr从左向右排列\n- 注意要配合unicode-bidi一块使用\n\n```css\n# 如果不使用unicode-bidi的话那么文字顺序不变，只是文字从右侧开始打印\n# 如果使用上unicode-bidi的话那么文字顺序也会随着改变\nh1{text-align: center;direction: rtl;unicode-bidi: bidi-override;}\n```\n\n### Text-overflow定义省略文本的处理方式（全兼容）\n\n- clip 无省略号\n- Ellipsis 省略号（注意配合overflow:hidden和white-space:nowrap一起使用）\n  - white-space:nowrap可以使文字超出以后不换行\n  - overflow:hidden 使得超出部分隐藏\n\n```css\ntext-overflow:ellpsis\n```\n\n### 自定义字体\n\n```css\n略\n```\n\n## 盒模型\n\n### 弹性盒模型\n\n> 注意在使用弹性盒模型的时候，父元素必须要加display:box或者display:inline-box，同时要加上浏览器的内核比如：`display:-webkit-box`。加上box属性了会看上去像左浮动一样。因为默认的box-orient就是Horizontal横向显示的。\n\n- box-orient 定义盒模型的布局方向：`-webkit-box-orient:vertical;`\n\n  - Horizontal 水平显示\n  - vertical 垂直方向\n\n- box-direction 元素排列顺序：`-webkit-box-direction:reverse;`\n\n  - Normal 正序\n  - Reverse 逆序，即使是逆序显示但是还是靠左的，富裕空间在右侧，可以通过box-pack调整\n\n- box-ordinal-group 设置元素的具体位置\n\n  ```css\n  # 找到正常顺序中的第一个，让它显示在第二个\n  .box div:nth-of-type(1){-webkit-box-ordinal-group:2;}\n  ```\n\n- box-flex 定义盒子的弹性空间\n\n  - 子元素的尺寸=盒子的尺寸*子元素的box-flex属性值/所有子元素的box-flex属性值的和（其实就是这有一排盒子你在这排盒子里占了多少的百分比，乘以盒子的尺寸那么就是你的，尺寸，这个尺寸是自适应的，比如说有一部分已经固定了，那么其他部分会自适应）\n\n    $\\frac{子元素box-flex属性值}{所有子元素box-flex属性值之和}$\\times$盒子尺寸\n\n    ```css\n    # example\n    <div class=\"box\">\n        <div>1</div>\n        <div>2</div>\n        <div>3</div>\n    </div>\n\n    .box{height:100px;border:3px solid #000;padding:3px;display: -webkit-box;}\n    .box div{height: 100px;background: pink;border:1px solid brown; }\n    .box div:nth-of-type(1){width: 300px;}\n    .box div:nth-of-type(2){-webkit-box-flex:1}\n    .box div:nth-of-type(3){-webkit-box-flex:9}\n    ```\n\n- box-pack对盒子富裕空间进行管理（水平方向）\n\n  - Star 所有子元素在盒子左侧显示，富裕空间在右侧\n\n  - End 所有子元素在盒子右侧显示，富裕空间在左侧（可以产生一个右浮动的效果）\n\n    ![](http://omk1n04i8.bkt.clouddn.com/18-4-3/91875351.jpg)\n\n  - Center 所有子元素居中\n\n  - Justify 富裕空间在子元素中平均分布\n\n    ![](http://omk1n04i8.bkt.clouddn.com/18-4-3/57241073.jpg)\n\n- box-align 在垂直方向上对元素的位置进行管理(-webkit-box-align)\n\n  - Star 所有子元素在据顶\n  - End 所有子元素在据底\n  - Center 所有子元素居中\n\n### 盒模型的阴影\n\n- box-shadow:[inset] x y blur [spread] color （这个也是可以多层叠加的，层之间用逗号隔开）\n  - inset：投影方式\n    - inset：内投影\n    - 不给：外投影\n  - x,y：x轴和y轴的偏移距离\n  - blur：模糊半径\n  - spread：扩展阴影半径\n    - 先扩展原有形状，再开始画阴影\n  - color：阴影颜色\n\n### 其他盒模型属性\n\n- box-reflect 倒影，目前只在webkit内核下的浏览器实现了，是以使用的时候要加上webkit的前缀\n\n  - direction 方向   above | below | right | left；  （镜像显示）\n  - 距离，可选参数，是倒影和元素之间的距离。\n  - 渐变（可选）：`-webkit-linear-gradient(right,rgba(0,0,0,1) 0,rgba(0,0,0,0) 100%)`\n\n- resize自由缩放\n\n  - Both 水平垂直都可以缩放\n  - Horizontal 只有水平方向可以缩放\n  - Vertical 只有垂直方向可以缩放\n  - none 不能缩放\n  - 注意：一定要配合overflow：auto 一块使用\n\n- box-sizing 盒模型解析模式（比较鸡肋）\n\n  - Content-box 标准盒模型（width/height=border+padding+content）\n  - Border-box 怪异盒模型 width/height=content\n\n  ```css\n  # 针对如下这一个示例\n  <div class=\"box\">\n      <div>1</div>\n  </div>\n\n  .box{width:200px;height:200px;border:10px solid red;padding:10px;}\n  .box div{background: greenyellow}\n\n  在标准盒模型中，box内部的div会继承外部box的宽度也就是200px，200加上两边的border和两边的padding，那么总宽度应该是200+20+20=240；\n\n  # 但是当设置为怪异盒模型的时候\n  .box{width:200px;height:200px;border:10px solid red;padding:10px;box-sizing: border-box}\n  .box div{background: greenyellow}\n\n  整体的父级宽度就被卡死了，就是200px，那么content的内容就等于200-10*2-10*2=160px,可以发现整体变小了。\n  ```\n\n## 响应式布局\n\n### CSS3分栏布局\n\n> 目前只有webkit内核实现了这个功能，因此记得加上webkit的前缀\n\n- column-width 栏目宽度：只限制栏目的宽度的时候，列数浏览器会去为我们进行计算\n- column-count 栏目列数：只设置列数的时候，浏览器会自动为我们计算每一栏的宽度\n- column-gap 栏目距离：设置每一栏的间隔\n- column-rule 栏目间隔线，栏目分割线的写法和border是一样的，比如1px solid #000\n\n**响应式布局的设置**\n\n```html\n# 其实是通过media来进行实现的，不兼容ie6，7，8，在这几种情况下只能通过js判断浏览器宽度，根据不同的宽度引入不同的样式表。\n\n# 800px以上引用\n<link rel=\"stylesheet\" type=\"text/css\" href=\"A.css\" media=\"screen and (min-width:800px)\">\n\n# 400~800之间\n<link rel=\"stylesheet\" type=\"text/css\" href=\"B.css\" media=\"screen and (min-width:400px) and (max-width:800px)\">\n\n# 小于400的时候引入的样式表\n<link rel=\"stylesheet\" type=\"text/css\" href=\"C.css\" media=\"screen and  (max-width:400px)\">\n\n## 直接使用style的方式进行响应式的控制而不是使用引用样式表\n@media screen and (min-width:400px) and (max-width:500px) {.box{margin:0 auto;}}\n```\n\n**横屏竖屏**\n\n```html\n# 竖屏，当屏幕的宽度小于高度的时候。\n<link rel=\"stylesheet\" type=\"text/css\" href=\"portrait.css\" media=\"all and (orientation:portrait)\">\n# 横屏\n<link rel=\"stylesheet\" type=\"text/css\" href=\"landscape.css\" media=\"all and (orientation:landscape)\">\n```\n\n## 新的UI样式\n\n### 圆角\n\n- border-radius:1-4个数字/1-4个数字\n  - 前面是水平，后面是垂直\n  - 不给“/”则水平和垂直一样\n    - border-radius：10px/5px;\n- 参数\n  - 各种长度单位都可以：px，% ……\n  - %有时候很方便\n    - 但是宽度不一致时不太好\n\n```css\n# 第一个值左上角+右下角，第二个值右上角+左下角\nborder-radius: 20px 40px\n# 左上角，右上角+左下角，右下角\nborder-radius: 20px 30px 40px;\n# 从左上角开始顺时针旋转\nborder-radius: 10px 20px 30px 40px;\n# 画一个椭圆，x轴和y轴的半径就不一样了，这种情况下可以分别制定xy二轴的半径\nborder-radius: 100px/150px  (分别对应x轴半径和y轴半径)\n# x和y轴的半径还可以整体加，比如\nborder-radius: 20px 40px 60px 80px/10px 20px 30px 40px;\n# 使用百分比\nborder-radius: 50%\n```\n\n使用圆角的功能去做一个风车的效果：\n\n```html\n<style>\n.box{width:200px;height:200px;margin:50px auto; transition:5s linear;}\n.box div{width:80px;height:80px;margin:10px;border:1px solid #000; box-sizing:border-box;float:left;background:orange;}\n.box div:nth-child(1),.box div:nth-child(4){ border-radius:0 70%;}\n.box div:nth-child(2),.box div:nth-child(3){ border-radius:70% 0;}\n/*这里用到了一个旋转，rotate，后面的720deg指的是720°*/\n.box:hover{ -webkit-transform:rotate(720deg);}\n</style>\n</head>\n<body>\n<div class=\"box\">\n\t<div></div>\n    <div></div>\n    <div></div>\n    <div></div>\n</div>\n```\n\n### 边框背景\n\n> 内容参考：\n>\n> - https://www.cnblogs.com/rain-null/p/6677913.html\n> - http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/\n> - https://blog.csdn.net/foreverling_ling/article/details/52247649\n\n- border-image\n  - border-image-source 引入图片\n  - border-image-slice 切割图片; 0 10，第一个值是上下切，第二个值是左右切，不带px\n  - border-image-width 边框宽度\n  - border-image-repeat 图片的排列方式\n    - round 平铺，repeat 重复，stretch 拉伸（默认）\n\nborder-image工作原理就是把图片切割成九块（九宫格），然后对应到边和角。\n\n```css\n# border-image是一个复合样式\n\n# 只设置一张图片的话会把完整的图片填充到四个角\nborder-image: url(\"/static/imgs/border/border.png\")\n\n# 关于图片的切割，接收大小默认单位就是px，不用手写，否则就无法识别。\nborder-image-slice: 10;   /*距离上下左右均为10px;*/\nborder-image-slice: 10 30;   /*距离上下10px,左右30px;*/\nborder-image-slice: 10 30 20;   /*距离上10px,下20px,左右30px;*/\nborder-image-slice: 10 30 20 40;   /*距离上10px,右30px,下20px,左40px;*/\n```\n\n- border-colors 边框颜色\n\n###渐变\n\n#### 线性渐变\n\n \n\n","timestamp":1540005876713},{"name":"98-常见样式布局.md","path":"05-Frontend/02-CSS/98-常见样式布局.md","content":"\n\n\n\n- 渐变\n\n```css\n.gradient{    \n\t/*top指的是从上到下，left指的是从左到右，top left指的是从左上角到右下角*/\n    /*firefox*/\n    background: -moz-linear-gradient(top,#FFFFFF,#f8f8f8);\n    /*chrome core*/\n    background: -webkit-linear-gradient(top,#FFFFFF,#f8f8f8);\n    /*common*/\n    background: linear-gradient(top,#FFFFFF,#f8f8f8);\n}\n```\n\n| **渐变模式**                                 | 渐变效果                                     |\n| ---------------------------------------- | ---------------------------------------- |\n| 纵向渐变：background: linear-gradient(to bottom, blue, white); | <img src=\"http://omk1n04i8.bkt.clouddn.com/18-1-25/42803622.jpg\" style=\"width:100px;height:100px\" /> |\n| 横向渐变：background: linear-gradient(to right, blue, white); | <img src=\"http://omk1n04i8.bkt.clouddn.com/18-1-25/24963190.jpg\" style=\'width:100px;height:100px;\'> |\n| 对角线方向的渐变：background: linear-gradient(to bottom right, blue, white); | <img src=\"http://omk1n04i8.bkt.clouddn.com/18-1-25/79186286.jpg\" style=\'width:100px;height:100px;\'> |\n\n","timestamp":1540005876713},{"name":"01-BootStrap.md","path":"05-Frontend/02-CSS/99-CSS框架/01-BootStrap.md","content":"# BootStrap\n\n> https://github.com/twbs\n>\n> bootstrap是移动优先的。\n>\n> bootstrap的JS是基于Jquery的，因此自己下载一个Jquery放到js文件夹\n\n## 栅格系统\n\n把整个页面分成12列，同时支持响应式。表示一行的class就是row，表示一列的class就是col。\n\n- 容器\n\n  - container-fluid\n\n    - 流体（平铺整体百分百），这个流体平铺的布局并不会顶格，他有一个padding值。\n\n  - container\n\n    - 固定（居中）\n    - 1170（默认是1170，根据不同的分辨率会显示为不同的width）\n    - 970\n    - 750\n    - auto\n\n    ```html\n    不同分辨率其实是存在一个阈值\n    - 1200>= 较大的分辨率的设备  col-lg-xx，低于1200就会纵向排列\n    - 992>=  中等屏幕的设备      col-md，低于992会纵向排列\n    - 768>=  相当于pad的尺寸      col-sm-xx，小于768会纵向排列\n    - 768<   小于768就是手机的尺寸    col-xs-xx，永远都是水平的\n    ```\n\n不要把container和container-flued嵌套使用。可以作为兄弟存在，比如header用流体的，body用container。\n\n如果一列多了12个格子就会被挤到第二行。\n\n### 栅格的组合模式\n\n```html\n<div class=\'row\'>\n  <!--依此根据class进行匹配-->\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n  <div class=\'col-lg-3 col-md-4 col-sm-6 \'></div>\n</div>\n在大屏幕分辨率的时候，一个是占用3个格子，也就是四个，当达到了md的阈值的时候就是12/4=3，一行3个，然后当到了sm阈值的时候就是一行两个。再小就是一行一个了。\n```\n\n#### 栅格系统中的列偏移\n\n```html\n#  向右偏移四个网格的距离，假如偏移10个就会出去，做多可以写12，整个都偏移出去，超过12或者小于1都是不起作用的。当达到了lg的阈值的时候就会进行纵向排列，不受偏移的影响了。\n<div class=\'col-lg-4 col-lg-offset-4\'></div>\n# 当没有设置栅格的网格大小，而只设置了偏移那么可以根据偏移去自动设置栅格大小哦，比如偏移为4，那么栅格大小就为12-4=8。列偏移同样适用于多种栅格混合适合用。\n```\n\n#### 列排序\n\n```html\n# 比如有两个，我想让这俩互换顺序。\n<div class=\"col-lg-2\"></div>\n<div class=\"col-lg-10\"></div>\n# push是向后，pull是往前拉，第一个往后推10个格子，第二个往前拉两个格子\n<div class=\"col-lg-2 col-lg-push-10\"></div>\n<div class=\"col-lg-10 col-lg-pull-2\"></div>\n```\n\n那么列排序和偏移和什么区别呢？\n\n- offset只能往右偏，但是排序可以使用pull和push向前向后。\n- offset还存在一个问题就是当有多个元素存在的情况下如果这一行撑满了，那么就会跳转到下一行进行偏移。比如一行有两个div都是col-lg-4，右侧的div的offset设置为5的时候可想而知，4+5+4=13，一行撑满了，因此右侧的div会直接跳转到第二行，然后offset出来5个格子。那么如果有这种需求的时候就可以使用排序来做了。\n\n#### 栅格系统的嵌套\n\nrow和row之间是可以互相嵌套的，宽度会按照父级的宽度进行12个网格的分配。\n\n如果一行有三个div分别为6,3,3的网格占位，如果6中的内容很多会单独把这个网格撑开，比如：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-4/17459743.jpg)\n\n那么假如我再加一个col，会变成如下的情况，因为本身这些内容更都是基于浮动的。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-4/55780879.jpg)\n\n如果想要另起一行显示需要清除浮动。\n\n```html\n<div class=\"row\">\n            <div class=\"col-lg-6 \" id=\"box1\">很多的文字</div>\n            <div class=\"box2 col-lg-3 \">col-lg-3</div>\n            <div class=\"box2 col-lg-3 \">col-lg-3</div>\n            <div class=\"clearfix\"></div>\n            <div class=\"box2 col-lg-3 \">col-lg-3</div>\n</div>\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-4/46976091.jpg)\n\n当然如果你另起一个row的话就是另起一行了。\n\n## 导航条\n\n\n\n\n\n","timestamp":1540005876713},{"name":"01-JS基础.md","path":"05-Frontend/03-JavaScript/01-JS基础.md","content":"# JavaScript基础\n[TOC]\n\n## ECMAScript\n\n1996年11月，JavaScript的创造者--Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这门语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。\n\n该标准一开始就是针对JavaScript语言制定的，但是没有称其为JavaScript，有两个方面的原因。一是商标，JavaScript本身已被Netscape注册为商标。而是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开发性和中立性。\n\n因此ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。\n\n尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：\n\n- 核心（ECMAScript） \n- 文档对象模型（DOM） Document object model (整合js，css，html)\n- 浏览器对象模型（BOM） Broswer object model（整合js和浏览器）\n- Javascript 在开发中绝大多数情况是基于对象的.也是面向对象的. \n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-30/66244224.jpg)\n\n## JavaScript基础\n\n### JS的引入方式\n\n```html\n1 直接编写\n    <script>\n        alert(\'hello yuan\')\n    </script>\n2 导入文件\n    <script src=\"hello.js\"></script>\n```\n\n### JS语言规范\n\n#### 注释\n\n```\n单行 //\n多行 /**/\n```\n\n#### 结束符\n\n变量规范和语句规范，记得每一个结束的位置要写分号。\n\n### JS的变量&标识符\n\n#### JS的变量\n\n```javascript\nx=5\ny=6\nz=x+y\n```\n\n在代数中，我们使用字母（比如 x）来保存值（比如 5）。通过上面的表达式 z=x+y，我们能够计算出 z 的值为 11。在 JavaScript 中，这些字母被称为变量。\n\n那么如何在JS中定义使用变量呢？\n\n1. 声明变量时不用声明变量类型. 全都使用var关键字;\n\n   ```javascript\n   var a;a=3;\n   ```\n\n2. 一行可以声明多个变量.并且可以是不同类型\n\n   ```\n   var name=\"yuan\", age=20, job=\"lecturer\";\n   ```\n\n3. 声明变量时 可以不用var. 如果不用var 那么它是全局变量\n\n4. 变量命名,首字符只能是字母,下划线,$美元符 三选一，余下的字符可以是下划线、美元符号或任何字母或数字字符且区分大小写，x与X是两个变量。\n\n   ```\n   Camel 标记法\n   首字母是小写的，接下来的字母都以大写字符开头。例如：\n   var myTestValue = 0, mySecondValue = \"hi\";\n   Pascal 标记法\n   首字母是大写的，接下来的字母都以大写字符开头。例如：\n   Var MyTestValue = 0, MySecondValue = \"hi\";\n   匈牙利类型标记法\n   在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。例如，i 表示整数，s 表示字符串，如下所示“\n   Var iMyTestValue = 0, sMySecondValue = \"hi\";\n   ```\n\n\n**关于匈牙利命名法**\n\n- 可读性，能看懂\n- 规范性，符合规则\n\n- 类型前缀\n- 首字母大写\n\n| 类型     | 前缀 | 类型     | 实例         |\n| -------- | ---- | -------- | ------------ |\n| 数组     | a    | Array    | aItems       |\n| 布尔值   | b    | Boolean  | BIsComplete  |\n| 浮点数   | f    | Float    | fPrice       |\n| 函数     | fn   | Function | fnHandler    |\n| 整数     | i    | Interger | iItemCount   |\n| 对象     | o    | Object   | oDiv1        |\n| 正则     | re   | RegExp   | reEmailCheck |\n| 字符串   | s    | String   | sUserName    |\n| 变体变量 | v    | Variant  | vAnything    |\n\n#### 常量和标识符\n\n**常量** ：直接在程序中出现的数据值\n\n标识符：\n\n1. 由不以数字开头的字母、数字、下划线(_)、美元符号($)组成\n2. 常用于表示函数、变量等的名称\n3. 例如：_abc,$abc,abc,abc123是标识符，而1abc不是\n4. JavaScript语言中代表特定含义的词称为保留字，不允许程序再定义为标识符\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-30/7990746.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-30/85002275.jpg)\n\n##### 补充\n\n*ES6新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。例如：for循环的计数器就很适合使用let命令。*\n\n```\nfor (let i=0;i<arr.length;i++){...}\n```\n\n*ES6新增const用来声明常量。一旦声明，其值就不能改变。*\n\n```\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3\n// TypeError: \"PI\" is read-only\n```\n\n**变量作用域**\n\n- 局部变量：定义在函数内的，只能在函数内部使用。\n- 全局变量：定义在函数外部，可以在全局使用\n\n#### JS的数据类型\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-30/24701208.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-30/35594254.jpg)\n\n常见的变量类型如下：\n\n- undifined：未定义的，未声明过的，或者声明了没有值\n- boolean：布尔值，非黑即白，真假\n- number：整数，小数都是number，部分int、float、double\n- string：字符串，一般用引号去引起来。\n- object：比如div什么的，数组也属于一个对象\n- function：方法\n\ntypeof的应用，相当于python中的isinstanceof\n\n```javascript\n<script type=\"text/javascript\">\n\tvar a = \'asdasd\';\n\tvar b = \'111\';\n\tvar c = 3333;\n\talert(typeof a)\n\talert(typeof b)\n\talert(typeof c)\n</script>\n```\n\n##### number数字类型\n\n```javascript\n# 表示整数10\nvar num=10;\n# 表示的是浮点数1.1\nvar num2=1.1;\n# 表示的是0.1\nvar num3=.1;\n# 表示的是整数10\nvar num4=10.0;\n# 小数点后没有数字会被解析成整数10\nvar num5=10.;\n# 等于31240000，科学计数法\nvar num6=3.124e7\n```\n\n- 不区分整型数值和浮点型数值;\n- 所有数字都采用64位浮点格式存储，相当于Java和C语言中的double格式\n- 能表示的最大值是±1.7976931348623157 x 10308\n- 能表示的最小值是±5 x 10 -324 \n\n```\n整数：\n在JavaScript中10进制的整数由数字的序列组成\n精确表达的范围是 -9007199254740992 (-253) 到 9007199254740992 (253)\n超出范围的整数，精确度将受影响\n\n浮点数：\n使用小数点记录数据\n例如：3.4，5.6\n使用指数记录数据\n例如：4.3e23 = 4.3 x 1023\n\n16进制和8进制数的表达:\n16进制数据前面加上0x，八进制前面加0;16进制数是由0-9,A-F等16个字符组成;8进制数由0-7等8个数字组成\n\n16进制和8进制与2进制的换算:\n2进制: 1111 0011 1101 0100   <-----> 16进制:0xF3D4 <-----> 10进制:62420\n2进制: 1 111 001 111 010 100 <-----> 8进制:0171724\n```\n\n##### 字符串String\n\n```\n是由Unicode字符、数字、标点符号组成的序列；字符串常量首尾由单引号或双引号括起；JavaScript中没有字符类型；常用特殊字符在字符串中的表达；\n字符串中部分特殊字符必须加上右划线\\；常用的转义字符 \\n:换行 \\\':单引号 \\\":双引号 \\\\:右划线\n```\n\n##### 布尔类型\n\n```javascript\nBoolean类型仅有两个值：true和false，也代表1和0，实际运算中true=1,false=0\n布尔值也可以看作on/off、yes/no、1/0对应true/false\nBoolean值主要用于JavaScript的控制语句，例如：\n\nif (x==1){\n      y=y+1;\n}else{\n      y=y-1;\n}\n```\n\n##### Null&Undefined类型\n\n**Undefined类型**\n\nUndefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。\n\n当函数无明确返回值时，返回的也是值 \"undefined\";\n\n**Null类型**\n\n另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。\n\n尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。\n\n##### 数据类型转换\n\n- parseInt：类型转换成数字，如果字符串有数字会把数字提取出来，如果字符串没办法转成数字就会转成NaN，任何数+Nan结果还是NaN\n- parsefloat：可以提取一个浮点数\n\n#### JS运算符\n\n```\n算术运算符：\n    +   -    *    /     %       ++        -- \n\n比较运算符：\n    >   >=   <    <=    !=    ==    ===   !==\n\n逻辑运算符：\n     &&   ||   ！\n\n赋值运算符：\n    =  +=   -=  *=   /=\n\n字符串运算符：\n    +  连接，两边操作数有一个或两个是字符串就做连接运算\n```\n\n##### 算数运算符\n\n**注意1: 自加自减**\n\n假如x=2，那么x++表达式执行后的值为3，x--表达式执行后的值为1；i++相当于i=i+1，i--相当于i=i-1；\n递增和递减运算符可以放在变量前也可以放在变量后：--i\n\n```javascript\n# 这个在赋值的收是有差异的。\nvar i=10;\na = ++i  # 先让i自加1，然后再赋值给a,a=11.\n\nvar i=10;\na = i++  # 先赋值，再让i+1，a=10\n```\n\n**注意2: 单元运算符**\n\n```\n- 除了可以表示减号还可以表示负号  例如：x=-y.减法，乘法，除法都会把两边内容转换成一种类型再做数学运算\n+ 除了可以表示加法运算还可以用于字符串的连接  例如：\"abc\"+\"def\"=\"abcdef\"；加法有一点特殊，一个数做字符串链接，另外一个是做数字的相加，做数字的相加的话要parseint以后再做。它不会做自动的转换操作。\n```\n\nJS不同于Python，是一种弱类型的语言：\n\n```\n静态类型语言\n一种在编译期间就确定数据类型的语言。大多数静态类型语言是通过要求在使用任一变量之前声明其数据类型来保证这一点的。Java 和 C 是静态类型语言。 \n\n动态类型语言\n一种在运行期间才去确定数据类型的语言，与静态类型相反。VBScript 和 Python 是动态类型的，因为它们确定一个变量的类型是在您第一次给它赋值的时候。 \n\n强类型语言\n一种总是强制类型定义的语言。Java 和 Python 是强制类型定义的。您有一个整数，如果不明确地进行转换 ，不能将把它当成一个字符串去应用。 \n\n弱类型语言\n一种类型可以被忽略的语言，与强类型相反。JS 是弱类型的。在JS中，可以将字符串 \'12\' 和整数 3 进行连接得到字符串\'123\'，然后可以把它看成整数 123 ，所有这些都不需要任何的显示转换。 \n所以说 Python 既是动态类型语言 (因为它不使用显示数据类型声明)，又是强类型语言 (因为只要一个变量获得了一个数据类型，它实际上就一直是这个类型了)。\n```\n\n**注意3:** **NaN**\n\n```\nvar d=\"yuan\";\nd=+d;\nalert(d);//NaN:属于Number类型的一个特殊值,当遇到将字符串转成数字无效时,就会得到一个NaN数据\nalert(typeof(d));//Number\n\n//NaN特点:\n\nvar n=NaN;\n\nalert(n>3);\nalert(n<3);\nalert(n==3);\nalert(n==NaN);\n\nalert(n!=NaN);//NaN参与的所有的运算都是false,除了!=\n```\n\n因此，判断是不是NaN不能用xxx==NaN来进行判断，因为NaN和任何数值都不相等，包括它自己。也就是说NaN==NaN做判断的结果也是false，有点奇葩，不过有一个函数可以做判断就是isNaN(args)\n\n**示例**\n\n```javascript\n# 比如取模进行隔行变色\nwindow.onload = function(){\n\tvar oUL = document.getElementById(\'ul1\')\n\tvar oli = oUL.getElementsByTagName(\'li\')\n\tfor (i=0;i<oli.length;i++){\n\t\tif ((i+1)%2==0){\n\t\t\toli[i].style.background=\'green\'\n\t\t}\n\t}\n}\n```\n\n##### 比较运算符\n\n```\n>   >=   <    <=    !=    ==    ===   !==\n```\n\n用于控制语句时：\n\n```javascript\nif (2>1){       //  3  0  false null undefined ［］\n    console.log(\"条件成立!\")\n}\n```\n\n等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。\n\n**关于双等和三等**\n\n- ==：先把两边的东西转成一样的类型，然后再做比较\n- ===：不转换直接比较。建议用三等，但是用双等也没问题的\n\n**Tip**\n\n注意1：\n\n```javascript\n# 字符串的比较\nvar bResult = \"Blue\" < \"alpha\";\nalert(bResult); //输出 true　　\n在上面的例子中，字符串 \"Blue\" 小于 \"alpha\"，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。\n\n# 比较数字和字符串\n另一种棘手的状况发生在比较两个字符串形式的数字时，比如：\nvar bResult = \"25\" < \"3\";\nalert(bResult); //输出 \"true\"\n上面这段代码比较的是字符串 \"25\" 和 \"3\"。两个运算数都是字符串，所以比较的是它们的字符代码（\"2\" 的字符代码是 50，\"3\" 的字符代码是 51）。\n\n不过，如果把某个运算数该为数字，那么结果就有趣了：\n\nvar bResult = \"25\" < 3;\nalert(bResult); //输出 \"false\"\n\n这里，字符串 \"25\" 将被转换成数字 25，然后与数字 3 进行比较，结果不出所料。\n\n# 总结：\n\n比较运算符两侧如果一个是数字类型,一个是其他类型,会将其类型转换成数字类型.\n比较运算符两侧如果都是字符串类型,比较的是最高位的asc码,如果最高位相等,继续取第二位比较.\n```\n\n注意2：\n\n```javascript\n等性运算符：执行类型转换的规则如下：\n\n如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 \n如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 \n如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 \n如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 \n在比较时，该运算符还遵守下列规则：\n\n值 null 和 undefined 相等。 \n在检查相等性时，不能把 null 和 undefined 转换成其他值。 \n如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 \n如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等\n```\n\n##### 逻辑运算符\n\n```javascript\nif (2>1 && [1,2]){\n    console.log(\"条件与\")\n}\n\n// 思考返回内容?\nconsole.log(1 && 3);\nconsole.log(0 && 3);\nconsole.log(0 || 3);\nconsole.log(2 || 3);\n```","timestamp":1540005876713},{"name":"02-JS流程&循环.md","path":"05-Frontend/03-JavaScript/02-JS流程&循环.md","content":"# 流程控制\n\n- 顺序结构(从上向下顺序执行)\n- 分支结构\n- 循环结构\n\n## 顺序结构\n\n```javascript\n<script>\n    console.log(“星期一”);\n    console.log(“星期二”);\n    console.log(“星期三”);\n</script>\n```\n\n## 分支结构\n\n**if-else**\n\n```javascript\nif (表达式){\n   语句１;\n   ......\n} else{\n   语句２;\n   .....\n}\n```\n\n功能说明：如果表达式的值为true则执行语句1,否则执行语句2，示例如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function (){\n\t\t\tvar obtn = document.getElementById(\'btn\');\n\t\t\tvar oul1 = document.getElementById(\'ul1\');\n\t\t\tobtn.onclick = function(){\n\t\t\t\tif (oul1.style.display==\'none\')\n\t\t\t\t{\n\t\t\t\t\toul1.style.display=\'block\';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n                    oul1.style.display=\'none\';\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t</script>\n</head>\n<body>\n\t<div id=\"box\">\n\t\t<p id=\"btn\">输入法</p>\n\t\t<ul id=\"ul1\" style=\"display: none;\">\n\t\t\t<li><a href=\"#\">手写</a></li>\n\t\t\t<li><a href=\"#\">拼音</a></li>\n\t\t\t<li><a href=\"#\">关闭</a></li>\n\t\t</ul>\n\t</div>\n</body>\n</html>\n```\n\n**if-elif－else结构：**\n\n```javascript\nif (表达式1) {\n    语句1;\n}else if (表达式2){\n    语句2;\n}else if (表达式3){\n    语句3;\n} else{\n    语句4;\n}\n```\n\n**switch-case结构**\n\n```javascript\nswitch(变量)\n{\n      case 值1：\n            ……\n            break;\n       case 值2：\n            ……\n            break;\n       ……\n       default:\n            ……\n}\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-31/69808685.jpg)\n\n示例：\n\n```javascript\nswitch(x){\ncase 1:y=\"星期一\";    break;\ncase 2:y=\"星期二\";    break;\ncase 3:y=\"星期三\";    break;\ncase 4:y=\"星期四\";    break;\ncase 5:y=\"星期五\";    break;\ncase 6:y=\"星期六\";    break;\ncase 7:y=\"星期日\";    break;\ndefault: y=\"未定义\";\n}\n```\n\nswitch比else if结构更加简洁清晰，使程序可读性更强,效率更高。\n\n**三目运算符**\n\n```javascript\na%2==0?alert(\'双数\'):alert(\'单数\')\n条件?结果1:other结果2\n```\n\n## 循环结构\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-31/43951902.jpg)\n\n**for循环**\n\n```javascript\n语法规则：\n\n    for(初始表达式;条件表达式;自增或自减)\n    {\n            执行语句\n            ……\n    }\n```\n\n功能说明：实现条件循环，当条件成立时，执行语句1，否则跳出循环体\n\n**for循环的另一种形式：**\n\n```javascript\nfor( 变量 in 数组或对象)\n    {\n        执行语句\n        ……\n    }\n```\n\n**while循环：**\n\n```javascript\n语法规则：\n\nwhile (条件){\n    语句1；\n    ...\n}\n```\n\n功能说明：运行功能和for类似，当条件成立循环执行语句花括号{}内的语句，否则跳出循环；同样支持continue与break语句。\n\n```javascript\nvar i=1;\nwhile (i<=7) {\n    document.write(\"<H\"+i+\">hello</H \"+i+\"> \");\n    document.write(\"<br>\");\n    i++;\n}\n```\n\n循环while，for（break，continue）\n\n- cotinue：跳出本次循环继续下一次循环\n- break：退出整个循环体\n\n**True or false**\n\n那么什么是真的什么是假的？\n\n- true：可以返回true的布尔值的、非零数字、非空字符串、Object（window或者document）即非空对象也是真的\n- false：false、数字0、空字符串、null、undefined\n\n### 循环的小例子\n\n**权限功能**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<script type=\"text/javascript\">\n        window.onload = function(){\n        \tvar obtn = document.getElementById(\'btn\');\n        \tvar oinput = document.getElementsByTagName(\'input\');\n        \n\t        var i=0;\n\t        obtn.onclick=function(){\n\t        \tfor(i=0;i<oinput.length;i++)\n\t        \t{\n\t        \t\tif (oinput[i].checked == true)\n\t        \t\t{\n\t        \t\t\toinput[i].checked=false;\n\t        \t\t}\n\t        \t\telse\n\t        \t\t{\n\t        \t\t\toinput[i].checked=true;\n\t        \t\t}\n\t        \t\t\n\t        \t};\n\t        };\n        };\n\n\n\t</script>\n</head>\n<body>\n\t<p id=\'btn\'>全选</p>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t<input type=\"checkbox\"><br>\n\t\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"03-异常处理.md","path":"05-Frontend/03-JavaScript/03-异常处理.md","content":"# 异常处理\n\n```javascript\ntry {\n    //这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行\n}\ncatch (e) {\n    // 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。\n    //e是一个局部变量，用来指向Error对象或者其他抛出的对象\n}\nfinally {\n     //无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。\n}\n```\n\n注：主动抛出异常 throw Error(\'xxxx\')","timestamp":1540005876713},{"name":"04-ECMA对象.md","path":"05-Frontend/03-JavaScript/04-ECMA对象.md","content":"# ECMA对象\n\n>http://www.cnblogs.com/yuanchenqi/articles/6893904.html\n>\n>http://www.cnblogs.com/yuanchenqi/articles/5980312.html\n>\n>https://www.cnblogs.com/liwenzhou/p/8004649.html\n\n从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。\n\n> var o = new Object();\n\n## 对象的概念和分类\n\n- 由ECMAScript定义的本地对象.独立于宿主环境的 ECMAScript 实现提供的对象.(native object)\n- ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现.这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。（built-in object）\n- 所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有 BOM 和 DOM 对象都是宿主对象\n\n**object对象**：ECMAScript 中的所有对象都由这个对象继承而来；Object 对象中的所有属性和方法都会出现在其他对象中\n\n## **11**种内置对象\n\n> **包括：**\n>\n> **Array ,String , Date, Math, Boolean, Number Function, Global, Error, RegExp , Object**\n>\n> **简介：**\n>\n> 在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，String、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是通过对象实现的，比如：\n>\n> ```javascript\n> <script language=\"javascript\">\n> var aa=Number.MAX_VALUE; \n> //利用数字对象获取可表示最大数\n> var bb=new String(\"hello JavaScript\"); \n> //创建字符串对象\n> var cc=new Date();\n> //创建日期对象\n> var dd=new Array(\"星期一\",\"星期二\",\"星期三\",\"星期四\"); \n> //数组对象\n> </script>\n> ```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/98355586.jpg)\n\n### String对象\n\n```javascript\n# 调用字符串的对象属性或方法时自动创建对象，用完就丢弃\nvar s = \'hello\'                 # type:string\n# 手工创建字符串对象，采用new创建字符串对象str1，全局有效。\nvar s = new String(\'Hello\')     # type:object\n```\n\n#### 字符串对象常用方法\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/17422823.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/63109260.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/95793116.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/47610132.jpg)\n\n```javascript\n# 获取字符串的长度\nvar s = \'hello world\'\ns.length                 # 结果：11\n\n# 获取指定位置的字符\ns.charAt(3)              # 结果：l\n\n# 书写格式:\nString对象提供了一组针对HTML格式的方法，如x.anchor()返回锚定义字符串<a>x</a>，\nx.bold()返回粗体表示字符串<b>x</b>，x.sup()返回上标格式字符串<sup>x</sup>。\n-----------------------------------------\n\nvar x=\"yuan\";\nvar y=\"x.italics():\"+x.italics();\ndocument.write(y.fontsize(10));//<font size=\"10\">x.italics():<i>yuan</i></font>\n\n# 字符串的正则表达式\n//使用注解\n//\n//x代表字符串对象\n//\n//regexp代表正则表达式或字符串\n//\n//match返回匹配字符串的数组，如果没有匹配则返回null\n//\n//search返回匹配字符串的首字符位置索引\n//-------------------------------------\nvar str1=\"welcome to the world of JS!\";\nvar str2=str1.match(\"world\"); \n# str2 -> [\"world\", index: 15, input: \"welcome to the world of JS!\"]\nvar str3=str1.search(\"world\");\nalert(str2[0]);\n//结果为\"world\"，因为str2的结果是一个列表。\nalert(str3);\n//结果为15，返回的是索引的位置\n\n# 顾头不顾尾\nvar s = \'hello world\'\nalert(s.substring(3,5))  # 结果为：\"lo\"，只打印3~4\nalert(s.substr(3,5))    # 结果为：\"lo wo\" 从索引为3的位置开始，打印长度为5\nalert(s.slice(1,4))     # 这个就和python的列表的切片很相似了。\nalert(s.slice(2)))      # 从索引为2的位置到最后\nalert(s.slice(-4,-1))   # 结果为：\"orl\"\n\n# string的slice和substring有什么异同？\n两者的相同点：\n如果start等于end，返回空字符串\n如果stop参数省略，则取到字符串末\n如果某个参数超过string的长度，这个参数会被替换为string的长度\n\nsubstirng()的特点：\n如果 start > stop ，start和stop将被交换\n如果参数是负数或者不是数字，将会被0替换\n\nsilce()的特点：\n如果 start > stop 不会交换两者\n如果start小于0，则切割从字符串末尾往前数的第abs(start)个的字符开始(包括该位置的字符)\n如果stop小于0，则切割在从字符串末尾往前数的第abs(stop)个字符结束(不包含该位置字符)\n```\n\n字符串的替换\n\n```javascript\n//x.replace(findstr,tostr)\n\nvar str1=\"abcdefgh\";\nvar str2=str1.replace(\"cd\",\"aaa\");\nalert(str2);\n//结果为\"abaaaefgh\"\n```\n\n字符串的分割\n\n```javascript\nvar str1=\"一,二,三,四,五,六,日\"; \n\nvar strArray=str1.split(\",\");\n\nalert(strArray[1]);\n//结果为\"二\"\n```\n\n字符串的拼接\n\n```javascript\n//y=x.concat(addstr)\n//\n//使用注解\n//\n//x代表字符串对象\n//addstr为添加字符串\n//返回x+addstr字符串\n    \nvar str1=\"abcd\"; \nvar str2=str1.concat(\"efgh\");\n\nalert(str2);\n//结果为\"abcdefgh\" \n```\n\n补充：\n\n*ES6中引入了模板字符串。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。*\n\n```javascript\n// 普通字符串\n`这是普通字符串！`\n// 多行文本\n`这是多行的\n文本`\n// 字符串中嵌入变量\nvar name = \"q1mi\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n\n# 注意：\n如果模板字符串中需要使用反引号，则在其前面要用反斜杠转义。\nJSHint启用ES6语法支持:/* jshint esversion: 6 */\n```\n\n### 数组对象\n\n创建数组对象：\n\n```javascript\nArray 对象用于在单个的变量中存储多个值。\n语法:\n\n创建方式1:\nvar a=[1,2,3];\n\n创建方式2:\nnew Array();     //  创建数组时允许指定元素个数也可以不指定元素个数。\nnew Array(size);//if 1个参数且为数字,即代表size,not content\n    初始化数组对象:\n    var cnweek=new Array(7);\n        cnweek[0]=\"星期日\";\n        cnweek[1]=\"星期一\";\n        ...\n        cnweek[6]=\"星期六\";\n\nnew Array(element0, element1, ..., elementn)//也可以直接在建立对象时初始化数组元素，元素类型允许不同\n\nvar test=new Array(100,\"a\",true);\n```\n\n创建二维数组\n\n```javascript\nvar cnweek=new Array(7);\nfor (var i=0;i<=6;i++){\n    cnweek[i]=new Array(2);\n}\ncnweek[0][0]=\"星期日\";\ncnweek[0][1]=\"Sunday\";\ncnweek[1][0]=\"星期一\";\ncnweek[1][1]=\"Monday\";\n...\ncnweek[6][0]=\"星期六\";\ncnweek[6][1]=\"Saturday\";\n```\n\nArray对象的属性：\n\n```javascript\n# 获取数组元素的个数：length\nvar cnweek=new Array(7);\ncnweek[0]=\"星期日\";\ncnweek[1]=\"星期一\";\ncnweek[2]=\"星期二\";\ncnweek[3]=\"星期三\";\ncnweek[4]=\"星期四\";\ncnweek[5]=\"星期五\";\ncnweek[6]=\"星期六\";\nfor (var i=0;i<cnweek.length;i++){\n  document.write(cnweek[i]+\" | \");\n}\n\n# 数组的length是允许赋值的\n//首先定义一个数组\nvar arr = [1,2,3,4]\narr.length=2;\nalert(arr);\n//此时你会发现虽然数组内容是1,2,3,4但是由于数组可以赋值，我们赋值为2，所以就打印出来了1和2.\n//如果把数组的长度设置为大于数组实际长度的值，那些其他的位置会被undefined给填充。\n\n# 清空数组\narr.length=0;\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/88028889.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-20/80226406.jpg)\n\nJoin方法\n\n```javascript\n//书写格式\n//x.join(bystr)\n//使用注解\n//\n//x代表数组对象\n//bystr作为连接数组中元素的字符串\n//返回连接后的字符串\n//与字符串的split功能刚好相反\n    \nvar arr1=[1, 2, 3, 4, 5, 6, 7];\n\nvar str1=arr1.join(\"-\");\n\nalert(str1);\n//结果为\"1-2-3-4-5-6-7\" \n```\n\nconcat链接方法：\n\n```javascript\n//连接数组-concat方法\n//\n//x.concat(value,...)\n\n\nvar a = [1,2,3];\nvar a = new Array(1,2,3);\nvar b=a.concat(4,5) ; # 等价于var b = a.concat([4,5])\n\n\nalert(a.toString());\n//返回结果为1,2,3\nalert(b.toString());\n//返回结果为1,2,3,4,5\n```\n\n数组逆序：\n\n```javascript\n//x.reverse()\n\nvar arr1=[32, 12, 111, 444];\n//var arr1=[\"a\",\"d\",\"f\",\"c\"];\n\narr1.reverse(); //颠倒数组元素，单纯的颠倒不排序\nalert(arr1.toString());\n//结果为444,111,12,32\n```\n\n数组的排序是按照最高位的默认形式去排的，比如112和25,112会排在前面。其实实际上排的是ascii表的数字，看一下下面这个例子：\n\n```javascript\n# 语法，后面可以接受一个排序规则的参数，必须是函数\narrayObject.sort(sortby)\n\n\n>> var s = [11,23,112,87,\'abc\',\'%\',\'@\']\n>> s.sort()\n<< (7) [\"%\", 11, 112, 23, 87, \"@\", \"abc\"]\n# 如上的记录，对比的都是第一个字符在ascii表中对应的数字：\n- % : 37\n- 1 : 49 \n- 2 : 50\n- 8 : 56\n- @ : 64\n- a : 97\n按照上面的标准得到如上的排序结果\n\n# 那么其实按照上面的结果并不符合我们实际理想中的要求，因此要达到我们想要的结果那就只能自己写函数拉。\n# 两个参数比较来返回对应的值\nfunction intSort(a,b){\n    if (a>b){\n        return 1;//-1\n    }\n    else if(a<b){\n        return -1;//1\n    }\n    else {\n        return 0\n    }\n}\n# 等价于\n\nfunction IntSort(a,b){\n    return a-b;\n}\n\n# 将我们定义的函数作为参数传递给sort，sort就会按照咱们的依据进行排序。其实相当于重写sort\narr.sort(intSort);\nalert(arr);\n```\n\n数组的切片：\n\n```javascript\n//x.slice(start, end)\n//\n//使用注解\n//\n//x代表数组对象\n//start表示开始位置索引\n//end是结束位置下一数组元素索引编号\n//第一个数组元素索引为0\n//start、end可为负数，-1代表最后一个数组元素\n//end省略则相当于从start位置截取以后所有数组元素\n\nvar arr1=[\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\',\'h\'];\nvar arr2=arr1.slice(2,4);\nvar arr3=arr1.slice(4);\nvar arr4=arr1.slice(2,-1);\n\nalert(arr2.toString());\n//结果为\"c,d\" \nalert(arr3.toString());\n//结果为\"e,f,g,h\"\nalert(arr4.toString());\n//结果为\"c,d,e,f,g\"\n```\n\n删除子数组\n\n```javascript\n//x. splice(start, deleteCount, value, ...)\n//\n//使用注解\n//\n//x代表数组对象\n//splice的主要用途是对数组指定位置进行删除和插入\n//start表示开始位置索引\n//deleteCount删除数组元素的个数\n//value表示在删除位置插入的数组元素\n//value参数可以省略\n\n\nvar a = [1,2,3,4,5,6,7,8];\na.splice(1,2);            //a变为 [1,4,5,6,7,8]\nalert(a.toString());\na.splice(1,1);            //a变为[1,5,6,7,8]\nalert(a.toString());\na.splice(1,0,2,3);        //a变为[1,2,3,5,6,7,8]\nalert(a.toString());\n\n# 那么其实就可以达到一个效果是先删除再添加，比如\n>> var a = [1,2,3,4,5]\n>> a.splice(2,2,\'lamber\',\'mxy\')\n<< (2) [3, 4]\n>> a\n<< (5) [1, 2, \"lamber\", \"mxy\", 5]\n\n# 那么我们其实可以利用这个特点完成一个简单的替换，但是实际也可以不这么使用\n>> var a = [1,2,3,\'lamber\']\nundefined\n>> a.splice(3,1,\'maxiaoyu\')\n[\"lamber\"]\n>> a\n(4) [1, 2, 3, \"maxiaoyu\"]\n```\n\n数组的进出栈操作\n\n```javascript\n//push pop这两个方法模拟的是一个栈操作\n\n//x.push(value, ...)  压栈，压到数组的队尾\n//x.pop()             弹栈，弹出也是弹出的最后一个     \n//使用注解\n//\n//x代表数组对象\n//value可以为字符串、数字、数组等任何值\n//push是将value值添加到数组x的结尾\n//pop是将数组x的最后一个元素删除\n\n\nvar arr1=[1,2,3];\narr1.push(4,5);\nalert(arr1);\n//结果为\"1,2,3,4,5\"\narr1.push([6,7]);\nalert(arr1)\n//结果为\"1,2,3,4,5,[6,7]\",[6,7]这里是arr1的索引为5的元素，是一个整体\narr1.pop();\nalert(arr1);\n//结果为\"1,2,3,4,5\"\n```\n\nshift和unshift\n\n```javascript\n// unshift shift \n//x.unshift(value,...)\n//x.shift()\n//使用注解\n//\n//x代表数组对象\n//value可以为字符串、数字、数组等任何值\n//unshift是将value值插入到数组x的开始，压入到数组头部\n//shift是将数组x的第一个元素删除，把首位的删除\n其实就是一个后进先出的过程\n\nvar arr1=[1,2,3];\narr1.unshift(4,5);\nalert(arr1);\n//结果为\"4,5,1,2,3\"\narr1. unshift([6,7]);\nalert(arr1);\n//结果为\"6,7,4,5,1,2,3\"\narr1.shift();\nalert(arr1);\n//结果为\"4,5,1,2,3\"\n```\n\n小结：\n\n```javascript\n//  js中数组的特性\n//  java中数组的特性,  规定是什么类型的数组,就只能装什么类型.只有一种类型.如果要存多种类型建议使用json\n//  js中的数组特性1: js中的数组可以装任意类型,没有任何限制.\n//  js中的数组特性2: js中的数组,长度是随着下标变化的.用到多长就有多长.\nvar arr5 = [\'abc\',123,1.14,true,null,undefined,new String(\'1213\'),new Function(\'a\',\'b\',\'alert(a+b)\')];\n        /*  alert(arr5.length);//8\n         arr5[10] = \"hahaha\";\n         alert(arr5.length); //11\n         alert(arr5[9]);// undefined */\n```\n\n### Date对象\n\nDate对象的创建\n\n```javascript\n//方法1：不指定参数\nvar date1=new Date();\nalert(date1.toLocaleString( ));   # 只有date对象有toLocaleString这个方法\n# date1返回的结果为：Wed Nov 22 2017 10:43:41 GMT+0800 (中国标准时间)\n# date1.toLocaleString的返回结果为：\"2017/11/22 上午10:43:41\"\n\n//方法2：参数为日期字符串，获取指定日期的。\nvar nowd2=new Date(\"2004/3/20 11:12\");\n>> nowd2.toLocaleString( )\n<< \"2004/3/20 上午11:12:00\"\n# 注意这里是月，日，年的后两位\nvar nowd3=new Date(\"04/03/20 11:12\");\n>> nowd3.toLocaleString( )\n<< \"2020/4/3 上午11:12:00\"\n\n//方法3：传一个时间戳进去，只不过参数单位为毫秒数\nvar nowd3=new Date(5000);\nalert(nowd3.toLocaleString( ));\nalert(nowd3.toUTCString());\n\n//方法4：参数为年月日小时分钟秒毫秒\nvar nowd4=new Date(2004,2,20,11,12,0,300);\n>> nowd4.toLocaleString( );\n<< \"2004/3/20 上午11:12:00\"\n//毫秒并不直接显示，注意这里这个月份，0表示1月份，1表示2月份，是从0开始的，而不是1，因此上面的结果就是3月20号，而不是2月20号。\n```\n\nDate对象获取时间的一些方法：\n\n```javascript\n获取日期和时间\ngetDate()                 获取日\ngetDay ()                 获取星期\ngetMonth ()               获取月（0-11）\ngetFullYear ()            获取完整年份\ngetYear ()                获取年\ngetHours ()               获取小时\ngetMinutes ()             获取分钟\ngetSeconds ()             获取秒\ngetMilliseconds ()        获取毫秒\ngetTime ()                返回累计毫秒数(从1970/1/1午夜)\n```\n\n小练习：拼一个完整的日期：\n\n```javascript\nfunction getCurrentDate(){\n        //1. 创建Date对象\n        var date = new Date(); //没有填入任何参数那么就是当前时间\n        //2. 获得当前年份\n        var year = date.getFullYear();\n        //3. 获得当前月份 js中月份是从0到11.\n        var month = date.getMonth()+1;\n        //4. 获得当前日\n        var day = date.getDate();\n        //5. 获得当前小时\n        var hour = date.getHours();\n        //6. 获得当前分钟\n        var min = date.getMinutes();\n        //7. 获得当前秒\n        var sec = date.getSeconds();\n        //8. 获得当前星期\n        var week = date.getDay(); //没有getWeek\n        // 2014年06月18日 15:40:30 星期三\n        return year+\"年\"+changeNum(month)+\"月\"+day+\"日 \"+hour+\":\"+min+\":\"+sec+\" \"+parseWeek(week);\n    }\n\nalert(getCurrentDate());\n\n//解决 自动补齐成两位数字的方法\n    function changeNum(num){\n    if(num < 10){\n        return \"0\"+num;\n    }else{\n        return num;\n    }\n\n}\n//将数字 0~6 转换成 星期日到星期六，因为获取兴趣返回的只是0~6的数值。我们要返回我们想要的内容可以自己定义个函数去映射\n    function parseWeek(week){\n    var arr = [\"星期日\",\"星期一\",\"星期二\",\"星期三\",\"星期四\",\"星期五\",\"星期六\"];\n    //             0      1      2      3 .............\n    return arr[week];\n}\n```\n\nDate对象设置时间的一些方法：\n\n```javascript\n//设置日期和时间\n//setDate(day_of_month)       设置日\n//setMonth (month)                 设置月\n//setFullYear (year)               设置年\n//setHours (hour)         设置小时\n//setMinutes (minute)     设置分钟\n//setSeconds (second)     设置秒\n//setMillliseconds (ms)       设置毫秒(0-999)\n//setTime (allms)     设置累计毫秒(从1970/1/1午夜)\n    \nvar x=new Date();\nx.setFullYear (1997);    //设置年1997\nx.setMonth(7);        //设置月7，实际是8月，写JavaScript的人脑子有坑，这块没法改了，记住\nx.setDate(1);        //设置日1\nx.setHours(5);        //设置小时5\nx.setMinutes(12);    //设置分钟12\nx.setSeconds(54);    //设置秒54\nx.setMilliseconds(230);        //设置毫秒230\ndocument.write(x.toLocaleString( )+\"<br>\");\n//返回1997年8月1日5点12分54秒\n\nx.setTime(870409430000); //设置累计毫秒数\ndocument.write(x.toLocaleString( )+\"<br>\");\n//返回1997年8月1日12点23分50秒  \n```\n\nDate对象方法：日期和时间的转换\n\n```javascript\n日期和时间的转换:\n\ngetTimezoneOffset():8个时区×15度×4分/度=480;\n返回本地时间与GMT的时间差，以分钟为单位\ntoUTCString()\n返回国际标准时间字符串\ntoLocaleString()\n返回本地格式时间字符串\nDate.parse(x)\n返回累计毫秒数(从1970/1/1午夜到本地时间)，比如：Date.parse(\'2014/04/20\')\nDate.UTC(x)\n返回累计毫秒数(从1970/1/1午夜到国际时间)\n```\n\n### Math对象\n\n```javascript\n//Math对象\n//该对象中的属性方法 和数学有关.\n//Math是内置对象 , 与Global的不同之处是, 在调用时 需要打出 \"Math.\"前缀.\n//属性学习:\n//alert(Math.PI);\n//方法学习:\n    //alert(Math.random()); // 获得随机数 0~1 不包括1.\n    //alert(Math.round(1.5)); // 四舍五入\n    //练习：获取1-100的随机整数，包括1和100\n         //var num=Math.random();\n        //num=num*10;\n        //num=Math.round(num);\n        // alert(num)\n    //============max  min=========================\n    /* alert(Math.max(1,2));// 2\n    alert(Math.min(1,2));// 1 */\n    //-------------pow--------------------------------\n    alert(Math.pow(2,4));// pow 计算参数1 的参数2 次方.\n        \n\n\n\nabs(x)    返回数的绝对值。\nexp(x)    返回 e 的指数。\nfloor(x)  直接取整。\nlog(x)    返回数的自然对数（底为e）。\nmax(x,y)  返回 x 和 y 中的最高值。\nmin(x,y)  返回 x 和 y 中的最低值。\npow(x,y)  返回 x 的 y 次幂。\nrandom()  返回 0 ~ 1 之间的随机数。\nround(x)  把数四舍五入为最接近的整数。\nsin(x)    返回数的正弦。\nsqrt(x)   返回数的平方根。\ntan(x)    返回角的正切。\n\n# 生成一个0~100的随机整数\nMath.round(Math.random()*100)\n```\n\n### RegExp对象\n\n```javascript\n//RegExp对象\n// 在表单验证时使用该对象验证用户填入的字符串是否符合规则.\n\n// 创建正则对象方式1  参数1 正则表达式  参数2 验证模式  g global / i 忽略大小写. //参数2一般填写g就可以，也有“gi”.\n\n    // 用户名 首字母必须是英文, 除了第一位其他只能是英文数字和_ . 长度最短不能少于6位 最长不能超过12位\n    //----------------------------创建方式1\n    /* var reg1 = new RegExp(\"^[a-zA-Z][a-zA-Z0-9_]{5,11}$\",\"g\");\n    //\n    //验证字符串\n    var str = \"bc123\";\n    alert(reg1.test(str));// true\n    \n    //----------------------------创建方式2  /填写正则表达式/匹配模式;\n    var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/g;\n    \n    alert(reg2.test(str));// true\n     */\n    //-------------------------------正则对象的方法-------------------\n        //test方法  ==>  测试一个字符串是否复合 正则规则. 返回值是true 和false.\n    \n    //-------------------------String 中与正则结合的4个方法------------------.\n    // macth search split replace\n    var str = \"hello world\";\n    \n    //alert(str.match(/o/g)); //查找字符串中 复合正则的 内容.\n    //alert(str.search(/h/g));// 0  查找字符串中符合正则表达式的内容位置\n    //alert(str.split(/o/g)); // 按照正则表达式对字符串进行切割. 返回数组;\n    alert(str.replace(/o/g, \"s\")); // hells wsrld  对字符串按照正则进行替换.\n```\n\n### 函数对象（重要）\n\n函数的定义：\n\n```javascript\nfunction 函数名 (参数){\n    函数体;\n    return 返回值;\n}\n```\n\n**功能说明：**\n\n- 可以使用变量、常量或表达式作为函数调用的参数\n- 函数由关键字function定义\n- 函数名的定义规则与标识符一致，大小写是敏感的\n- 返回值必须使用return\n\n返回值不是必须的，函数如果没有设置返回值的时候，默认会返回undefined.retrun空也是undefined。关于函数的参数，和python很像，位置参数……不过多赘述。\n\nFunction 类可以表示开发者定义的任何函数。用 Function 类直接创建函数的语法如下：\n\n```javascript\nvar 函数名 = new Function(\"参数1\",\"参数n\",\"function_body\"); # 基本不用这种用法\n```\n\n虽然由于字符串的关系，第二种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。示例如下：\n\n```javascript\nalert(1);\nfunction func1(){\n    alert(\'hello yuan!\');\n    return 8\n}\n \n    ret=func1();\n    alert(ret)\n－－－－－－－－－－－－－－－－\n \nvar func1=new Function(\"name\",\"alert(\\\"hello\\\"+name);\")\nfunc1(\"yuan\")\n```\n\n**注意：js的函数加载执行与python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以：**\n\n**Function 对象的 length 属性**\n\n如前所述，函数属于引用类型，所以它们也有属性和方法。\n\n比如，ECMAScript 定义的属性 length 声明了函数期望的参数个数。\n\n```javascript\nalert(func1.length)\n```\n\n**Function 对象的方法**\n\nFunction 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。\n\n```javascript\nalert(void(fun1(1,2)))\n# 运算符void()作用：拦截方法的返回值　\n```\n\n**函数的调用**：\n\n```javascript\nfunction func1(a,b){\n\n    alert(a+b);\n}\n\n    func1(1,2);  //3\n    func1(1,2,3);//3\n    func1(1);    //NaN，相当于1+undifined，一个数字加一个undefined。\n    func1();     //NaN\n\n    //只要函数名写对即可,参数怎么填都不报错.\n\n-------------------面试题-----------\n function a(a,b){\n    alert(a+b);\n}\n\n   var a=1;\n   var b=2;\n   a(a,b)\n\n# 结论：会直接进行报错，因为a被重新赋值以后a就不是一个函数了，直接就报错了。\n```\n\n**函数的内置对象arguments**\n\n```javascript\n# 用作不定长参数，相当于python里面的*args，实际上arguments就是一个数组。arguments和位置参数是可以共存的。\nfunction add(a,b){\n\n        console.log(a+b);//3\n        console.log(arguments.length);//2\n        console.log(arguments);//[1,2]\n\n    }\n    add(1,2)\n\n    ------------------arguments的用处1 ------------------\n    function nxAdd(){\n        var result=0;\n        # arguments是一个内置对象，假如我传了参数其实是可以不再函数那里体现形式参数的。\n        for (var num in arguments){\n            result+=arguments[num]\n        }\n        alert(result)\n\n    }\n\n    nxAdd(1,2,3,4,5)\n\n//     ------------------arguments的用处2 ------------------\n\n    function f(a,b,c){\n        if (arguments.length!=3){\n            throw new Error(\"function f called with \"+arguments.length+\" arguments,but it just need 3 arguments\")\n        }\n        else {\n            alert(\"success!\")\n        }\n    }\n\n    f(1,2,3,4,5)\n```\n\n**匿名函数**\n\n```javascript\n// 匿名函数的应用\n(function(){\n    alert(\"tony\");\n} )()\n\n(function(arg){\n    console.log(arg);\n})(\'123\')\n```\n\n**函数的作用域和闭包**\n\n```javascript\n作用域\n\njs的作用域和py相似，if while等控制语句并没有自己作用域；而函数是有自己的作用域的；\n\n    if(1==1){\n    \n            var s=12;\n        }\n        console.log(s);//12\n    \n       // ----------------------\n        function f(){\n            var temp=666;\n        }\n        f();\n        console.log(temp);//Uncaught ReferenceError: temp is not defined\n\n嵌套函数的作用域：\n\n    # example 1\n    var city = \'beijing\';\n    \n        function func(){\n            var city = \'shanghai\';\n            function inner(){\n                var city = \'shenzhen\';\n                console.log(city);\n            }\n            inner();\n        }\n        func();   # shenzhen\n    \n    # example 2\n    var city = \'beijing\';\n    function Bar(){\n        console.log(city);\n    }\n    function func(){\n    \n        var city = \'shanghai\';\n        return Bar;  # 这里的bar会去先找Bar函数内部，如果内部没有会去找全局的\n    }\n    var ret = func();\n    ret();    //beijing\n\n闭包：子函数可以使用父函数的局部变量\n\n    var city = \'beijing\';\n    \n    function func(){\n        var city = \"shanghai\";\n        function inner(){\n            // var city = \"langfang\";\n            console.log(city);\n        }\n        return inner;\n    }\n    var ret = func();\n    ret();  # shanghai\n```\n\n### JSON对象\n\n> 什么是json？Javascript Object Notation专门为js诞生的一个数据交换语言.也是支持和python字典类似的一种格式.\n\n```javascript\n>> d = {\"name\":\"maxiaoyu\",\'age\':12}\n<< {name: \"maxiaoyu\", age: 12}\n```\n\n在JS里面的key的引号是可有可无的，但是再python中必须是有的否则会报错，针对值的话是必须要有引号的。如果针对这种内容进行遍历的话遍历的也是key。他的type是object。\n\n\n\n","timestamp":1540005876713},{"name":"05-词法分析.md","path":"05-Frontend/03-JavaScript/05-词法分析.md","content":"# 词法分析\n\n## 回顾JS作用域\n\n作用域是JavaScript最重要的概念之一，想要学好JavaScript就需要理解JavaScript作用域和作用域链的工作原理。\n\n任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。\n\n### 全局作用域\n\n在代码中任何地方都能访问到的对象拥有全局作用域，一般来说一下几种情形拥有全局作用域：\n\n(1)最外层函数和在最外层函数外面定义的变量拥有全局作用域\n\n```javascript\nvar name=\"yuan\";\n\n    function foo(){\n        var age=23;\n        function inner(){\n            console.log(age);\n        }\n\n        inner();\n    }\n\n    console.log(name);    // yuan\n    //console.log(age);   // Uncaught ReferenceError: age is not defined\n    foo();                // 23\n    inner();              // Uncaught ReferenceError: inner is not defined\n```\n\n(2)所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：\n\n```javascript\n    var name=\"yuan\";\n\n    function foo(){\n        age=23;\n\n        var sex=\"male\"\n    }\n    foo();\n    console.log(age);   //  23\n    console.log(sex);   // sex is not defined\n```\n\n(3)所有window对象的属性拥有全局作用域\n\n一般情况下，window对象的内置属性都都拥有全局作用域，例如window.alert()、window.location、window.top等等。\n\n### 局部作用域\n\n和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域成为函数作用域.\n\n## 作用域链\n\n在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。\n\n```javascript\nvar x=1;\nfunction foo() {\n    var y = 2;\n    \n    function bar() {\n        var z = 3;\n    }\n}\n\n#bar的作用域链： barScopeChain=[bar.AO, foo.AO, global.VO];\n\n#foo的作用域链： fooScopeChain=[foo.Ao, global.VO];\n\n########################################################\n什么是AO,VO?\n       在函数创建时，每个函数都会创建一个活动对象Active Object(AO)，全局对象为Global Object(VO)，创建函数的过程也就是为这个对象添加属性的过程，作用域链就是由这些绑定了属性的活动对象构成的。\n        例如：找x变量；bar函数在搜寻变量x的过程中，先从自身AO对象上找，如果bar.AO存在这个属性，那么会直接使用这个属性的值，如果不存在，则会转到父级函数的AO对象，也就是foo.AO\n        如果找到x属性则使用，找不到继续 在global.VO对象查找，找到x的属性，返回属性值。如果在global.VO中没有找到，则会抛出异常ReferenceError\n\n### 执行上下文。\n       函数在执行时会创建一个称为“执行上下文（execution context）”的内部对象，执行上下文定义了函数\n       执行时的环境。每个执行上下文都有自己的作用域链，用于标识符解析，当执行上下文被创建时，而它的作用\n       域链初始化为当前运行函数的[[Scope]]所包含的对象。\n### 函数执行\n       在函数执行过程中，每遇到一个变量，都会检索从哪里获取和存储数据，该过程从作用域链头部，也就是从活\n       动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没有则继续搜索作用域\n       链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义，函数执行过程中，每个标识符都\n       要经历这样的搜索过程。\n```\n\n创建作用域链的过程\n\n```javascript\n函数进入全局，创建VO对象，绑定x属性<入栈>\nglobal.VO={x=underfind; foo:reference of function}\n(这里只是预解析，为AO对象绑定声明的属性，函数执行时才会执行赋值语句，所以值是underfind)\n\n遇到foo函数，创建foo.AO，绑定y属性<入栈>\nfoo.AO={y=underfind, bar:reference of function}\n\n遇到bar函数，创建bar.AO，绑定z属性<入栈>\nbar.AO={z:underfind}\n\n作用域链和执行上下文都会保存在堆栈中，所以：\nbar函数的scope chain为：[0]bar.AO-->[1]foo.AO-->[2]global.VO\n\nfoo函数的scope chain为：[0]foo.AO-->[1]global.Vo\n//建议：少定义全局变量\n//理由：因为作用域链是栈的结构，全局变量在栈底，每次访问全局变量都会遍历一次栈，//这样会影响效率\n```\n\n函数的scope等于自身的AO对象加上父级的scope，也可以理解为一个函数的作用域等于自身活动对象加上父级作用域.\n\n函数执行前后的作用域链：\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-22/30024822.jpg)\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-22/30016708.jpg)\n\n**注意：作用域链的非自己部分在函数对象被建立（函数声明、函数表达式）的时候建立，而不需要等到执行**\n\n思考实例：\n\n```javascript\nfor (var i=1; i<=9; i++) {\n     setTimeout( function timer(){\n     console.log( i );\n     },1000 );\n }\n\n//＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝\n\nfor (var i=1; i<=9; i++) {\n    (function(){\n      var j = i;\n      setTimeout( function timer(){\n           console.log( j );\n      }, 1000 );\n     })();\n```\n\n思考实例2：\n\n```javascript\nfunction bar(age) {\n\n        console.log(age);\n        var age = 99;\n        var sex=\"male\";\n        console.log(age);\n        function age(){\n            alert(123);\n        } ;\n        console.log(age);\n        return 100;\n}\n\nresult=bar(5);\n\n一 词法分析过程(涉及参数，局部变量声明，函数声明表达式)：\n    1-1 、分析参数，有一个参数，形成一个 AO.age=undefine;\n    1-2 、接收参数 AO.age=5;\n    1-3 、分析变量声明，有一个 var age, 发现 AO 上面有一个 AO.age ，则不做任何处理\n    1-4 、分析变量声明，有一个 var sex，形成一个 AO.sex=undefine;\n    1-5 、分析函数声明，有一个 function age(){} 声明， 则把原有的 age 覆盖成 AO.age=function(){};\n二 执行过程：\n    2-1 、执行第一个 console.log(age) 时，当前的 AO.age 是一个函数，所以输出的一个函数\n    2-2 、这句 var age=99; 是对不 AO.age 的属性赋值， AO.age=99 ，所以在第二个输出的age是 99;\n    2-3 、同理第三个输出的是 99, 因为中间没有改变 age 值的语句了。\n\n          注意：执行阶段：\n                        function age(){\n                            alert(123)\n                        } ;\n\n            不进行任何操作，将执行语句复制给age这部操作是在词法分析时，即运行前完成的。\n```\n\n\n\n","timestamp":1540005876713},{"name":"06-DOM&BOM.md","path":"05-Frontend/03-JavaScript/06-DOM&BOM.md","content":"# DOM&BOM\n\n> http://www.cnblogs.com/yuanchenqi/articles/5980312.html\n>\n> http://www.cnblogs.com/yuanchenqi/articles/6893904.html\n\n## BOM\n\nBOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 JavaScript 有能力与浏览器“对话”。\n\n**window对象**\n\n```\n所有浏览器都支持 window 对象。\n概念上讲.一个html文档对应一个window对象.\n功能上讲: 控制浏览器窗口的.\n使用上讲: window对象不需要创建对象,直接使用即可.\n```\n\n**window对象方法**\n\n```javascript\nalert()            \n# 显示带有一段消息和一个确认按钮的警告框。\nconfirm()          \n# 显示带有一段消息以及确认按钮和取消按钮的对话框。\n# 根据用户不同的选择会有一个返回值，确定返回true，取消返回false\nprompt(str)           \n# 显示可提示用户输入的对话框。返回值就是用户输入的值，接收到的内容都是String\nopen()             \n# 打开一个新的浏览器窗口或查找一个已命名的窗口。open(\"http://www.baidu.com\");如果写了参数那么就是跳转到指定的url，如果没有写就是一个空白的窗口，about blank 参数1 什么都不填 就是打开一个新窗口.  参数2.填入新窗口的名字(一般可以不填). 参数3: 新打开窗口的参数.\n# open(\'http://www,baidu.com\',\'test_window\',\'width=200,resizable=no,height=100\'); \n# 新打开一个宽为200 高为100的窗口\nclose()            \n# 关闭浏览器窗口。\nsetInterval(func_name,时间(单位：毫秒))      \n# 按照指定的周期（以毫秒计）来调用函数或计算表达式。简单来说即是定时器，先等待这个time_interval然后执行这个函数。\nclearInterval()    \n# 取消由 setInterval() 设置的定时器\nsetTimeout()       \n# 在指定的毫秒数后调用函数或计算表达式。\nclearTimeout()     \n# 取消由 setTimeout() 方法设置的 timeout。\nscrollTo()         \n# 把内容滚动到指定的坐标。\n```\n\n**方法使用**\n\n```javascript\n//----------alert confirm prompt----------------------------\n//alert(\'aaa\');\n    \n    \n/* # 如果确认返回true\nvar result = confirm(\"您确定要删除吗?\");\nalert(result); \n*/\n\n//prompt 参数1 : 提示信息.   参数2:输入框的默认值. 返回值是用户输入的内容.\n\n// var result = prompt(\"请输入一个数字!\",\"haha\");\n// alert(result);\n\n\n方法讲解:    \n//open方法 打开和一个新的窗口 并 进入指定网址.参数1 : 网址.\n//调用方式1\n//open(\"http://www.baidu.com\");\n//参数1 什么都不填 就是打开一个新窗口.  参数2.填入新窗口的名字(一般可以不填). 参数3: 新打开窗口的参数.\nopen(\'\',\'\',\'width=200,resizable=no,height=100\'); // 新打开一个宽为200 高为100的窗口\n//close方法  将当前文档窗口关闭.\n//close();\n```\n\n猜数示例：\n\n```javascript\nvar num = Math.round(Math.random()*100);\nfunction acceptInput(){\n//2.让用户输入(prompt)    并接受 用户输入结果\nvar userNum = prompt(\"请输入一个0~100之间的数字!\",\"0\");\n//3.将用户输入的值与 随机数进行比较\n        if(isNaN(+userNum)){\n            //用户输入的无效(重复2,3步骤)\n            alert(\"请输入有效数字!\");\n            acceptInput();\n        }\n        else if(userNum > num){\n        //大了==> 提示用户大了,让用户重新输入(重复2,3步骤)\n            alert(\"您输入的大了!\");\n            acceptInput();\n        }else if(userNum < num){\n        //小了==> 提示用户小了,让用户重新输入(重复2,3步骤)\n            alert(\"您输入的小了!\");\n            acceptInput();\n        }else{\n        //答对了==>提示用户答对了 , 询问用户是否继续游戏(confirm).\n            var result = confirm(\"恭喜您!答对了,是否继续游戏?\");\n            if(result){\n                //是 ==> 重复123步骤.\n                num = Math.round(Math.random()*100);\n                acceptInput();\n            }else{\n                //否==> 关闭窗口(close方法).\n                close();\n            }\n        }\n```\n\n定时器的使用\n\n```javascript\n# setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。\n语法：<br>     setInterval(code,millisec)\n其中，code为要调用的函数或要执行的代码串。millisec周期性执行或调用 code 之间的时间间隔，以毫秒计。\n```\n\nLocation的使用\n\n```javascript\nLocation 对象包含有关当前 URL 的信息。\nLocation 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。\n\nLocation 对象方法\nlocation.assign(URL)\nlocation.reload()\nlocation.replace(newURL)//注意与assign的区别\n```\n\n一个在input的数据框显示时间的小练习：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<script type=\"text/javascript\">\n\t\tvar global_id;\n\t\tfunction start_current_time(){\n\t\t\t// 首先判断一下这个global_id有没有值，如果没有值的话说明是第一次调用\n\t\t\t// 这里如果不做判断的话每一次调用都会产生一个定时器，但是返回的global_id\n\t\t\t// 只有一个全局变量在接收，stop的时候也只能关掉这么一个，其他的是关不掉的。\n\t\t\tif(global_id==undefined){\n\t\t\t\tget_current_time()\n\t\t\t\tglobal_id = setInterval(get_current_time,1000)\n\t\t\t};\n\t\t};\n\t    function get_current_time(){\n\t    \tvar c_date = new Date();\n\t    \tvar str_date = c_date.toLocaleString();\n\n\t    \tvar timebar = document.getElementById(\'timebar\');\n\t    \ttimebar.value = str_date;\n\t    }\n\t    function stop_current_time(){\n  \t\t\tclearInterval(global_id);\n  \t\t\t// 清空global_id\n  \t\t\tglobal_id = undefined;\n\t    };\n\t</script>\n</head>\n<body>\n\t<input type=\"text\" name=\"box\" id=\'timebar\' value=\'\' onfocus=\"start_current_time()\">\n\t<button id=\'btn\' onclick=\"stop_current_time()\">Stop</button>\n\n\n</body>\n</html>\n```\n\n## DOM中级\n\n> 什么是DOM？DOM 是 W3C（万维网联盟）的标准。DOM 定义了访问 HTML 和 XML 文档的标准：\n>\n> \"W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。\"\n>\n> W3C DOM 标准被分为 3 个不同的部分：\n>\n> - 核心 DOM - 针对任何结构化文档的标准模型\n> - XML DOM - 针对 XML 文档的标准模型\n> - HTML DOM - 针对 HTML 文档的标准模型\n> - 什么是 XML DOM？  －－－－>XML DOM 定义了所有 XML 元素的对象和属性，以及访问它们的方法。\n> - 什么是 HTML DOM？－－－－>HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。\n\n### DOM节点\n\n根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点(NODE)：\n\n- 整个文档是一个文档节点(document对象)\n- 每个 HTML 元素是元素节点(element 对象)\n- HTML 元素内的文本是文本节点(text对象)\n- 每个 HTML 属性是属性节点(attribute对象)\n- 注释是注释节点(comment对象)\n\n画dom树是为了展示文档中各个对象之间的关系，用于对象的导航。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-31/19321428.jpg)\n\n\n\n![](http://omk1n04i8.bkt.clouddn.com/17-11-22/74616341.jpg)\n\n节点(自身)属性:\n\n- attributes - 节点（元素）的属性节点\n- nodeType – 节点类型\n- nodeValue – 节点值\n- nodeName – 节点名称\n- innerHTML - 节点（元素）的文本值\n\n导航属性:\n\n- parentNode - 节点（元素）的父节点 (推荐)\n- firstChild – 节点下第一个子元素\n- lastChild – 节点下最后一个子元素\n- childNodes - 节点（元素）的子节点 \n\n### 创建DOM元素\n\n- createElement(标签名)\n- appendChild(节点)：比如为ul插入li\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\n\t</style>\n\t<script type=\"text/javascript\">\n  \t\twindow.onload = function(){\n  \t\t\tvar otxt1 = document.getElementById(\'txt1\')\n  \t\t\tvar obtn1 = document.getElementById(\'btn1\');\n  \t\t\tvar oul1 = document.getElementById(\'ul1\');\n\n  \t\t\tobtn1.onclick=function(){\n  \t\t\t\tvar oli = document.createElement(\'li\');\n  \t\t\t\t//更改标签内部的内容，放在追加之前可以减少页面的渲染\n  \t\t\t\toli.innerHTML = otxt1.value\n  \t\t\t\t//在一个父级插入一个子节点\n  \t\t\t\toul1.appendChild(oli)\n  \t\t\t}\n  \t\t}\n\t</script>\n</head>\n<body>\n\t<input id=\"txt1\" type=\"text\"></input>\n\t<input id=\'btn1\' type=\"button\" value=\"创建li\">\n<ul id=\'ul1\'>\n\t\n</ul>\n</body>\n</html>\n```\n\n上面的例子是默认插入到后面，而不是插入到前面，比如微博或者qq空间的说说这种，一般新发表的都是默认的生成在一个的。越往后的数据其实是越来越旧的。因此可以使用insertBefore(子节点，在谁之前插入子节点)\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\n\t</style>\n\t<script type=\"text/javascript\">\n  \t\twindow.onload = function(){\n  \t\t\tvar otxt1 = document.getElementById(\'txt1\')\n  \t\t\tvar obtn1 = document.getElementById(\'btn1\');\n  \t\t\tvar oul1 = document.getElementById(\'ul1\');\n\n  \t\t\tobtn1.onclick=function(){\n  \t\t\t\tvar oli = document.createElement(\'li\');\n  \t\t\t\t//获取到当前的所有li的一个数组\n  \t\t\t\tvar ali = oul1.getElementsByTagName(\'li\');\n  \t\t\t\t//更改标签内部的内容，放在追加之前可以减少页面的渲染\n  \t\t\t\toli.innerHTML = otxt1.value;\n  \t\t\t\t//在一个父级插入一个子节点\n  \t\t\t\tif (ali.length==0){\n  \t\t\t\t\t//首先确认有没有li，如果本来就没有走这里否则会报错\n  \t\t\t\t\toul.appendChild(oli);\n  \t\t\t\t}\n  \t\t\t\telse{\n  \t\t\t\t\toul1.insertBefore(oli,ali[0]);\n  \t\t\t\t}\n  \t\t\t};\n  \t\t};\n\t</script>\n</head>\n<body>\n\t<input id=\"txt1\" type=\"text\"></input>\n\t<input id=\'btn1\' type=\"button\" value=\"创建li\">\n<ul id=\'ul1\'>\n\t<li>aaa</li>\n</ul>\n</body>\n</html>\n```\n\n如何删除子节点？[removeChild(子节点)]\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function()\n\t\t{\n\t\t\tvar aA = document.getElementsByTagName(\'a\');\n\t\t\tvar oUL = document.getElementById(\'ul1\');\n\n\t\t\tfor (i=0;i<aA.length;i++){\n\t\t\t\taA[i].onclick=function(){\n\t\t\t\t\t//这里要求点击a删除它的父级li，因此用到了parentNode\n\t\t\t\t\toUL.removeChild(this.parentNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t</script>\n</head>\n<body>\n\t<ul id=\"ul1\">\n\t\t<li>我是第1个li<a href=\"javascript:;\">删除</a></li>\n\t\t<li>我是第2个li<a href=\"javascript:;\">删除</a></li>\n\t\t<li>我是第3个li<a href=\"javascript:;\">删除</a></li>\n\t\t<li>我是第4个li<a href=\"javascript:;\">删除</a></li>\n\t</ul>\n\t\n</body>\n</html>\n```\n\n### 常用操作\n\n#### 常用节点操作\n\n```javascript\ncreateElement：创建节点\nappendChild:把节点添加到最后作为最后的子节点\ninsertBefore(newnode,某个节点):把增加的节点放到某个节点的前面\nremoveChild：删除节点\nreplaceChild(newnode,某个节点)：替换节点\n```\n\n#### 常用查找节点的方式\n\n```javascript\ndocument.getElementById(\'\')\ndocument.getElementByTagName(\'div\')  # 返回的是一个数组\ndocument.getElementByName(\'name\')\ndocument.getElementByClassName(\'cls_name\') # 返回的是一个数组\n```\n\n常用导航节点属性\n\n```javascript\nparentElement           // 父节点标签元素\nchildren                // 所有子标签\nfirstElementChild       // 第一个子标签元素\nlastElementChild        // 最后一个子标签元素\nnextElementtSibling     // 下一个兄弟标签元素\npreviousElementSibling  // 上一个兄弟标签元素\n# 注意，js中没有办法找到所有的兄弟标签！\n```\n\n#### 常用节点属性操作\n\n1、获取文本节点的值：innerText    innerHTML\n\n2、attribute操作\n\n```\n     elementNode.setAttribute(name,value)    \n\n     elementNode.getAttribute(属性名)        <-------------->elementNode.属性名(DHTML)\n\n     elementNode.removeAttribute(“属性名”);\n```\n\n3、value获取当前选中的value值\n\n- input   \n- select （selectedIndex）\n- textarea  \n\n4、innerHTML 给节点添加html代码：\n\n        ```\n#  该方法不是w3c的标准，但是主流浏览器支持    \ntag.innerHTML = “<p>要显示内容</p>”;\n        ```\n\n5、关于class的操作：\n\n```javascript\nelementNode.className\nelementNode.classList.add\nelementNode.classList.remove\n```\n\n6、改变css样式：\n\n```javascript\n<p id=\"p2\">Hello world!</p>\ndocument.getElementById(\"p2\").style.color=\"blue\";\ndocument.getElementById(\"p2\").style.fontSize=48px\n```\n\n### DOM事件\n\n#### 事件类型\n\n```javascript\n# 当用户点击某个对象时调用的事件句柄。\nonclick    \n\n# 当用户双击某个对象时调用的事件句柄。\nondblclick     \n\n# 元素获得焦点。   练习：输入框\nonfocus    \n\n# 元素失去焦点;应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.\nonblur         \n\n# 域的内容被改变。应用场景：通常用于表单元素,当元素内容被改变时触发.（三级联动）\nonchange       \n\n# 某个键盘按键被按下。应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.\nonkeydown\n\n# 某个键盘按键被按下并松开。\nonkeypress     \n\n# 某个键盘按键被松开。\nonkeyup        \n\n# 一张页面或一幅图像完成加载。\nonload         \n\n# 和鼠标相关的操作\nonmousedown    鼠标按钮被按下。\nonmousemove    鼠标被移动。\nonmouseout     鼠标从某元素移开。\nonmouseover    鼠标移到某元素之上。\nonmouseleave   鼠标从元素离开\n\n\nonselect       文本被选中。\nonsubmit       确认按钮被点击。\n```\n\n#### 事件绑定的方式\n\n方式1：\n\n```javascript\n<div id=\"div\" onclick=\"foo(this)\">点我呀</div>\n\n<script>\n    function foo(self){           // 形参不能是this;\n        console.log(\"点你大爷!\");\n        console.log(self);   \n    }\n</script>\n```\n\n方式2：\n\n```javascript\n<p id=\"abc\">试一试!</p>\n\n<script>\n\n    var ele=document.getElementById(\"abc\");\n\n    ele.onclick=function(){\n        console.log(\"ok\");\n        console.log(this);    // this直接用\n    };\n\n</script>\n```\n\n#### 事件介绍\n\n##### onload\n\nonload 属性开发中 只给 body元素加.这个属性的触发 标志着 页面内容被加载完成.应用场景: 当有些事情我们希望页面加载完立刻执行,那么可以使用该事件属性，比如`window.onload = function(){xxxx}`\n\n##### onsubmit\n\n当表单在提交时触发. 该属性也只能给form元素使用.应用场景: 在表单提交前验证用户输入是否正确.如果验证失败.在该方法中我们应该阻止表单的提交.\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <script>\n\n        window.onload=function(){\n            //阻止表单提交方式1().\n            //onsubmit 命名的事件函数,可以接受返回值. 其中返回false表示拦截表单提交.其他为放行.\n\n             var ele=document.getElementById(\"form\");\n             ele.onsubmit=function(event) {\n            //    alert(\"验证失败 表单不会提交!\");\n            //    return false;\n\n            // 阻止表单提交方式2 event.preventDefault(); ==>通知浏览器不要执行与事件关联的默认动作。\n             alert(\"验证失败 表单不会提交!\");\n             event.preventDefault();\n\n    }\n\n        };\n\n    </script>\n</head>\n<body>\n\n<form id=\"form\">\n            <input type=\"text\"/>\n            <input type=\"submit\" value=\"点我!\" />\n</form>\n\n</body>\n</html>\n```\n\n##### 事件传播\n\n```javascript\n<div id=\"abc_1\" style=\"border:1px solid red;width:300px;height:300px;\">\n        <div id=\"abc_2\" style=\"border:1px solid red;width:200px;height:200px;\">\n        </div>\n</div>\n\n<script type=\"text/javascript\">\n        document.getElementById(\"abc_1\").onclick=function(){\n            alert(\'111\');\n        };\n        document.getElementById(\"abc_2\").onclick=function(event){\n            alert(\'222\');\n            event.stopPropagation(); //阻止事件向外层div传播.\n        }\n</script>\n```\n\n##### onkeydown\n\nEvent 对象：Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！event对象在事件发生时系统已经创建好了,并且会在事件函数被调用时传给事件函数.我们获得仅仅需要接收一下即可.比如onkeydown,我们想知道哪个键被按下了，需要问下event对象的属性，这里就是KeyCode.\n\n```javascript\n<input type=\"text\" id=\"t1\"/>\n<script type=\"text/javascript\">\n    var ele=document.getElementById(\"t1\");\n    ele.onkeydown=function(e){\n        e=e||window.event;\n        var keynum=e.keyCode;\n        var keychar=String.fromCharCode(keynum);\n        alert(keynum+\'----->\'+keychar);\n    };\n</script>\n```\n\n##### onmouseout&onmouseleave的区别\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        #container{\n            width: 300px;\n        }\n        #title{\n            cursor: pointer;\n            background: #ccc;\n        }\n       #list{\n           display: none;\n           background:#fff;\n       }\n\n        #list div{\n            line-height: 50px;\n        }\n        #list  .item1{\n            background-color: green;\n        }\n\n         #list  .item2{\n            background-color: rebeccapurple;\n        }\n\n         #list  .item3{\n            background-color: lemonchiffon;\n        }\n\n\n    </style>\n</head>\n<body>\n\n\n<p>先看下使用mouseout的效果:</p>\n\n<div id=\"container\">\n        <div id=\"title\">使用了mouseout事件↓</div>\n        <div id=\"list\">\n                <div class=\"item1\">第一行</div>\n                <div class=\"item2\">第二行</div>\n                <div class=\"item3\">第三行</div>\n        </div>\n</div>\n\n\n<script>\n\n// 1.不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。\n\n// 2.只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。\n\n   var container=document.getElementById(\"container\");\n   var title=document.getElementById(\"title\");\n   var list=document.getElementById(\"list\");\n\n\n   title.onmouseover=function(){\n       list.style.display=\"block\";\n   };\n\n   container.onmouseleave=function(){  // 改为mouseout试一下\n       list.style.display=\"none\";\n   };\n\n/*\n\n因为mouseout事件是会冒泡的，也就是onmouseout事件可能被同时绑定到了container的子元素title和list\n上，所以鼠标移出每个子元素时也都会触发我们的list.style.display=\"none\";\n\n*/\n\n\n  /*\n  思考:\n  if:\n\n       list.onmouseout=function(){\n           list.style.display=\"none\";\n   };\n\n\n     为什么移出第一行时,整个list会被隐藏?\n\n     其实是同样的道理,onmouseout事件被同时绑定到list和它的三个子元素item上,所以离开任何一个\n     子元素同样会触发list.style.display=\"none\";\n\n   */\n\n</script>\n</body>\n</html>\n```\n\n### 文档碎片\n\n- 文档碎片可以提高DOM操作性能（理论上），有时候还会降低性能，这个东西其实很诡异，一般只有面试用得到。实际性能提升的很低。\n- 文档碎片原理\n- document.createDocumentFragment()\n\n","timestamp":1540005876713},{"name":"07-Jquery.md","path":"05-Frontend/03-JavaScript/07-Jquery.md","content":"# Jquery\n\n> http://jquery.cuishifeng.cn/\n>\n> http://www.cnblogs.com/yuanchenqi/articles/6936986.html\n>\n> http://www.cnblogs.com/yuanchenqi/articles/6070667.html\n\n## Jq是什么\n\n- jQuery由美国人John Resig创建，至今已吸引了来自世界各地的众多 javascript高手加入其team。\n- jQuery是继prototype之后又一个优秀的Javascript框架。其宗旨是——WRITE LESS,DO MORE!\n- 它是轻量级的js库(压缩后只有21k) ，这是其它的js库所不及的，它兼容CSS3，还兼容各种浏览器\n- jQuery是一个快速的，简洁的javaScript库，使用户能更方便地处理HTMLdocuments、events、实现动画效果，并且方便地为网站提供AJAX交互。\n- jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。\n\n## JQ对象\n\njQuery 对象就是通过jQuery包装DOM对象后产生的对象。jQuery 对象是 jQuery 独有的**.** 如果一个对象是 jQuery 对象**,** 那么它就可以使用 jQuery 里的方法: $(“#test”).html();\n\n```javascript\n$(\"#test\").html() \n   \n         意思是指：获取ID为test的元素内的html代码。其中html()是jQuery里的方法 \n\n         这段代码等同于用DOM实现代码： document.getElementById(\" test \").innerHTML; \n\n         虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法.乱使用会报错\n\n         约定：如果获取的是 jQuery 对象, 那么要在变量前面加上$. 这样一看就知道是dom对象还是jq对象了。\n\nvar $variable = jQuery 对象\nvar variable = DOM 对象\n\n$variable[0]：jquery对象转为dom对象      $(\"#msg\").html(); $(\"#msg\")[0].innerHTML\n```\n\n jquery的基础语法：$(selector).action() \n\n## 选择器和筛选器\n\n### 选择器\n\n**基本选择器**\n\n```javascript\n$(\"*\")  $(\"#id\")   $(\".class\")  $(\"element\")  $(\".class,p,div\")\n```\n\n**层级选择器**\n\n```javascript\n$(\".outer div\")  $(\".outer>div\")   $(\".outer+div\")  $(\".outer~div\")\n```\n\n**基本筛选器**\n\n```javascript\n# even取的是索引的偶数，索引的0，2，4\n# odd拿的是索引的奇数\n$(\"li:first\")  $(\"li:eq(2)\")  $(\"li:even\") $(\"li:gt(1)\")\n```\n\n**属性选择器**\n\n```javascript\n$(\'[id=\"div1\"]\')   $(\'[\"alex=\"sb\"][id]\')\n```\n\n**表单选择器**\n\n```javascript\n$(\"[type=\'text\']\")----->$(\":text\")         注意只适用于input标签  : $(\"input:checked\")\n```\n\n**表单属性选择器**\n\n```javascript\n:enabled\n:disabled\n:checked\n:selected\n\n<body>\n\n<form>\n    <input type=\"checkbox\" value=\"123\" checked>\n    <input type=\"checkbox\" value=\"456\" checked>\n\n\n  <select>\n      <option value=\"1\">Flowers</option>\n      <option value=\"2\" selected=\"selected\">Gardens</option>\n      <option value=\"3\" selected=\"selected\">Trees</option>\n      <option value=\"3\" selected=\"selected\">Trees</option>\n  </select>\n</form>\n\n\n<script src=\"jquery.min.js\"></script>\n<script>\n    // console.log($(\"input:checked\").length);     // 2\n\n    // console.log($(\"option:selected\").length);   // 只能默认选中一个,所以只能lenth:1\n\n    $(\"input:checked\").each(function(){\n\n        console.log($(this).val())\n    })\n</script>\n</body>\n```\n\n### 筛选器\n\n**过滤筛选器**\n\n```javascript\n$(\"li\").eq(2)  $(\"li\").first()  $(\"ul li\").hasclass(\"test\")\n```\n\n**查找筛选器**\n\n```javascript\n查找子标签：(children是找子代，find是找的后代)      \n$(\"div\").children(\".test\")      $(\"div\").find(\".test\")  \n                              \n向下查找兄弟标签：  \n# 取下面的一个标签，括号里可以多加限制条件，比如$(\"a\").next(\'.item\')   \n# 记住这里只能是下一个标签，并且满足条件的。\n$(\".test\").next()                \n$(\".test\").nextAll()    # 取下面的所有标签\n$(\".test\").nextUntil()  # 设置一个区间，到这个设置的区间位置，是一个开区间，中间的生效。\n                          \n向上查找兄弟标签：    \n$(\"div\").prev()                  \n$(\"div\").prevAll()       \n$(\"div\").prevUntil()   \n\n查找所有兄弟标签：    \n$(\"div\").siblings()  \n             \n查找父标签：         \n$(\".test\").parent()              \n$(\".test\").parents()     \n$(\".test\").parentUntil() \n```\n\n## 操作元素\n\n### 事件\n\n**页面载入**\n\n```javascript\nready(fn) // 当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。\n$(document).ready(function(){}) -----------> $(function(){})　\n还有一种简写方式就是\n$(function(){\n  ……………………\n})\n```\n\n**事件绑定**\n\n```javascript\n//语法:  标签对象.事件(函数)    \neg: $(\"p\").click(function(){})\n\nTip：有一个事件绑定顺序的问题，后天生成的标签不会被应用上之前的事件绑定。这里就要用到事件委派了。\n比如我点击一个button按钮的时候会给ul下添加li标签：\n$(\"button\").click(function(){\n  $(\"ul\").append(\"<li>asdasd</li>\")\n})\n我想要点击li的时候弹出alert\n$(\"li\").click(function(){\n  alert(123)\n})\n\nhtml:\n<ul>\n  <li>123</li>\n  <li>123</li>\n  <li>123</li>\n  <li>123</li>\n</ul>\n\n在一开始的时候就有4个li，这4个li会被我们写的click时间所绑定，但是如果按button按钮后，新添加的li并不会收到click事件绑定的影响，这个就是我们所说的问题。\n```\n\n**事件委派**\n\n```javascript\n# 现在在3.x里只剩下一个方法用这个on可以搞定\n$(\"\").on(event,[selector],[data],fn)  // 在选择元素上绑定一个或多个事件的事件处理函数。\n\n# 示例，现在不给li绑定事件了，我们给ul绑定时间，然后委派给ul下的li。\n# 这个li不管是你先有的，还是后有的都是ul下的，因此都会触发on的click事件。\n# 在jq2.x中是delegate\n# 如果没有事件委派的话也可以用on，只不过selector这个可选参数这里不写就行了。\n$(\"ul\").on(\"click\",\'li\',function(){\n  console.log(123)\n})\n\n# 在jq2.x中有一个老的写法，由于部分jq代码还是2的版本因此也要知道这个内容\n$(\".p\").bind(function(){xxxxx})\n\n# 与事件委派相反的解除时间就是是用off。off不加参数表示取消所有事件，加的话表示取消具体事件，比如click\n$(\"p\").off()\n```\n\n示例\n\n```html\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n</ul>\n<hr>\n<button id=\"add_li\">Add_li</button>\n<button id=\"off\">off</button>\n\n<script src=\"jquery.min.js\"></script>\n<script>\n    $(\"ul li\").click(function(){\n        alert(123)\n    });\n\n    $(\"#add_li\").click(function(){\n        var $ele=$(\"<li>\");\n        $ele.text(Math.round(Math.random()*10));\n        $(\"ul\").append($ele)\n\n    });\n\n\n//    $(\"ul\").on(\"click\",\"li\",function(){\n//        alert(456)\n//    })\n\n     $(\"#off\").click(function(){\n         $(\"ul li\").off()\n     })\n    \n</script>\n```\n\n**事件切换**\n\nhover事件：\n\n一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。\n\nover:鼠标移到元素上要触发的函数\n\nout:鼠标移出元素要触发的函数\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n        }\n        .test{\n\n            width: 200px;\n            height: 200px;\n            background-color: wheat;\n\n        }\n    </style>\n</head>\n<body>\n\n\n<div class=\"test\"></div>\n</body>\n<script src=\"jquery.min.js\"></script>\n<script>\n//    function enter(){\n//        console.log(\"enter\")\n//    }\n//    function out(){\n//        console.log(\"out\")\n//    }\n// $(\".test\").hover(enter,out)\n\n\n$(\".test\").mouseenter(function(){\n        console.log(\"enter\")\n});\n\n$(\".test\").mouseleave(function(){\n        console.log(\"leave\")\n    });\n\n</script>\n</html>\n```\n\n### 属性操作\n\n```javascript\n--------------------------CSS类\n$(\"\").addClass(class|fn)\n$(\"\").removeClass([class|fn])\n\n--------------------------属性\n$(\"\").attr();\n$(\"\").removeAttr();\n$(\"\").prop();\n$(\"\").removeProp();\n\n--------------------------HTML代码/文本/值\n$(\"\").html([val|fn]) # 获取到的是整个标签的内容\n$(\"\").text([val|fn]) # 获取的是标签的内部文本\n$(\"\").val([val|fn|arr])\n\n---------------------------\n$(\"#c1\").css({\"color\":\"red\",\"fontSize\":\"35px\"})\n```\n\nattr方法使用：\n\n```html\n<input id=\"chk1\" type=\"checkbox\" />是否可见\n<input id=\"chk2\" type=\"checkbox\" checked=\"checked\" />是否可见\n\n\n\n<script>\n\n//对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。\n//对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。\n//像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此\n//需要使用prop方法去操作才能获得正确的结果。\n\n\n//    $(\"#chk1\").attr(\"checked\")\n//    undefined\n//    $(\"#chk1\").prop(\"checked\")\n//    false\n\n//  ---------手动选中的时候attr()获得到没有意义的undefined-----------\n//    $(\"#chk1\").attr(\"checked\")\n//    undefined\n//    $(\"#chk1\").prop(\"checked\")\n//    true\n\n    console.log($(\"#chk1\").prop(\"checked\"));//false\n    console.log($(\"#chk2\").prop(\"checked\"));//true\n    console.log($(\"#chk1\").attr(\"checked\"));//undefined\n    console.log($(\"#chk2\").attr(\"checked\"));//checked\n</script>\n```\n\n#### 循环\n\n我们知道：\n\n```javascript\n$(\"p\").css(\"color\",\"red\")　\n```\n\n是将css操作加到所有的标签上，内部维持一个循环；但如果对于选中标签进行不同处理，这时就需要对所有标签数组进行循环遍历啦\n\njquery支持两种循环方式：\n\n **方式一**：**格式：$.each(obj,fn)**\n\n```javascript\nli=[10,20,30,40];\ndic={name:\"yuan\",sex:\"male\"};\n$.each(li,function(i,x){\n    console.log(i,x)\n});\n```\n\n**方式二：格式：$(\"\").each(fn)**\n\n```javascript\n$(\"tr\").each(function(){\n    console.log($(this).html())\n})\n```\n\n其中,$(this)代指当前循环标签。\n\n**each扩展**\n\n关于循环中，return false和return true有什么区别。\n\n```javascript\n/*\n        function f(){\n\n        for(var i=0;i<4;i++){\n\n            if (i==2){\n                return\n            }\n            console.log(i)\n        }\n\n    }\n    f();  // 这个例子大家应该不会有问题吧!!!\n//-----------------------------------------------------------------------\n\n\n    li=[11,22,33,44];\n    $.each(li,function(i,v){\n\n        if (v==33){\n                return ;   //  ===试一试 return false会怎样?\n            }\n            console.log(v)\n    });\n\n//------------------------------------------\n\n\n    // 大家再考虑: function里的return只是结束了当前的函数,并不会影响后面函数的执行\n\n//本来这样没问题,但因为我们的需求里有很多这样的情况:我们不管循环到第几个函数时,一旦return了,\n//希望后面的函数也不再执行了!基于此,jquery在$.each里又加了一步:\n     for(var i in obj){\n\n         ret=func(i,obj[i]) ;\n         if(ret==false){\n             return ;\n         }\n\n     }\n// 这样就很灵活了:\n// <1>如果你想return后下面循环函数继续执行,那么就直接写return或return true\n// <2>如果你不想return后下面循环函数继续执行,那么就直接写return false\n\n\n// ---------------------------------------------------------------------\n```\n\n#### 文档节点处理\n\n```javascript\n# 创建一个标签对象\n$(\"<p>\")\n\n\n# 内部插入，append在末尾插入，prepend在开头插入。appendto是某一个节点插入到某个父节点\n# 比如自己新建一个标签然后插入到某一个父节点内。\n$(\"\").append(content|fn)      ----->$(\"p\").append(\"<b>Hello</b>\");\n$(\"\").appendTo(content)       ----->$(\"p\").appendTo(\"div\");\n$(\"\").prepend(content|fn)     ----->$(\"p\").prepend(\"<b>Hello</b>\");\n$(\"\").prependTo(content)      ----->$(\"p\").prependTo(\"#foo\");\n\n# 外部插入，这个是同级别兄弟节点之间的插入，insertAfter就是新节点查到谁后面和上面append和appendto的区别其实是一样的。\n$(\"\").after(content|fn)       ----->$(\"p\").after(\"<b>Hello</b>\");\n$(\"\").before(content|fn)      ----->$(\"p\").before(\"<b>Hello</b>\");\n$(\"\").insertAfter(content)    ----->$(\"p\").insertAfter(\"#foo\");\n$(\"\").insertBefore(content)   ----->$(\"p\").insertBefore(\"#foo\");\n\n# 替换\n$(\"\").replaceWith(content|fn) ----->$(\"p\").replaceWith(\"<b>Paragraph. </b>\");\n\n# 删除，empty是清空内容，但是本身标签还存在，但是remove是直接把内容连带标签一起给删除了。\n$(\"\").empty()\n$(\"\").remove([expr])\n\n# 复制，对应原生js下的cloneNode方法\n$(\"\").clone([Even[,deepEven]])\n```\n\n示例：\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head>\n\n</head>\n<body>\n<div class=\"box\">\n    <div class=\"item\">\n        <input type=\"button\" value=\"+\">\n        <input type=\"text\" value=\"请输入默认值\">\n    </div>\n</div>\n<script src=\"/static/js/jquery-3.2.1.min.js\"></script>\n<script>\n    $(\':button\').click(function () {\n        var $aaa = $(this).parent().clone();\n        $aaa.children(\':button\').val(\'-\').click(function () {\n            $(this).parent().remove();\n        });\n        $(\'.box\').append($aaa);\n    })\n\n</script>\n</body>\n</html>\n```\n\n#### 动画效果\n\n**显示隐藏**\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.1.4.min.js\"></script>\n    <script>\n\n$(document).ready(function() {\n    $(\"#hide\").click(function () {\n        $(\"p\").hide(1000);\n    });\n    $(\"#show\").click(function () {\n        $(\"p\").show(1000);\n    });\n\n//用于切换被选元素的 hide() 与 show() 方法。省的绑定两个方法了。\n    $(\"#toggle\").click(function () {\n        $(\"p\").toggle();\n    });\n})\n\n    </script>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n\n\n    <p>hello</p>\n    <button id=\"hide\">隐藏</button>\n    <button id=\"show\">显示</button>\n    <button id=\"toggle\">切换</button>\n\n</body>\n</html>\n```\n\n**滑动**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.1.4.min.js\"></script>\n    <script>\n    // 类似于幕布的一种上拉下拉的效果。\n    $(document).ready(function(){\n     $(\"#slideDown\").click(function(){\n         $(\"#content\").slideDown(1000);\n     });\n      $(\"#slideUp\").click(function(){\n         $(\"#content\").slideUp(1000);\n     });\n      $(\"#slideToggle\").click(function(){\n         $(\"#content\").slideToggle(1000);\n     })\n  });\n    </script>\n    <style>\n\n        #content{\n            text-align: center;\n            background-color: lightblue;\n            border:solid 1px red;\n            display: none;\n            padding: 50px;\n        }\n    </style>\n</head>\n<body>\n\n    <div id=\"slideDown\">出现</div>\n    <div id=\"slideUp\">隐藏</div>\n    <div id=\"slideToggle\">toggle</div>\n\n    <div id=\"content\">helloworld</div>\n\n</body>\n</html>\n```\n\n**淡入淡出**：淡入淡出其实就是一个透明度的变化，应用于addclass和removeclass，hide的值。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.1.4.min.js\"></script>\n    <script>\n    $(document).ready(function(){\n   $(\"#in\").click(function(){\n       $(\"#id1\").fadeIn(1000);\n\n\n   });\n    $(\"#out\").click(function(){\n       $(\"#id1\").fadeOut(1000);\n\n   });\n    $(\"#toggle\").click(function(){\n       $(\"#id1\").fadeToggle(1000);\n   });\n    $(\"#fadeto\").click(function(){\n       // 这个fadeto第一参数是时间，第二个是到某一个透明度\n       // 上面的都是透明度是0~1之间，这个是0.4~1.这个意思。\n       $(\"#id1\").fadeTo(1000,0.4);\n   });\n   // 回调函数\n   $(\"toggle\").click(function(){\n       $(\'#id1\').fadeToggle(1000, function(){\n           …………………………\n       })\n   })\n});\n</script>\n\n</head>\n<body>\n      <button id=\"in\">fadein</button>\n      <button id=\"out\">fadeout</button>\n      <button id=\"toggle\">fadetoggle</button>\n      <button id=\"fadeto\">fadeto</button>\n\n      <div id=\"id1\" style=\"display:none; width: 80px;height: 80px;background-color: blueviolet\"></div>\n\n</body>\n</html>\n```\n\n**回调函数**：完成某个动作以后触发的函数。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.1.4.min.js\"></script>\n\n</head>\n<body>\n  <button>hide</button>\n  <p>helloworld helloworld helloworld</p>\n\n\n\n <script>\n   $(\"button\").click(function(){\n       $(\"p\").hide(1000,function(){\n           alert($(this).html())\n       })\n\n   })\n    </script>\n</body>\n</html>\n```\n\n#### CSS处理\n\n*CSS位置操作*\n\n```javascript\n# offset获取的是当前视口的相对偏移。var $xxx=$(\'xxx\').offset()拿到的是一个对象。\n# 有left属性，top属性等等。\n$(\"\").offset([coordinates])\n# offset赋值操作\n$(\'.p1\').offset({left:300,top:200})\n\n# 相当于已定位的父级的位置\n$(\"\").position()\n\n# 返回顶部，不加val就是取当前的位置，如果填值的话那就是相当于一个赋值的操作。\n$(\"\").scrollTop([val])\n# 示例，这个是对当前的window窗口生效。\n$(\".top\").click(function(){\n  $(window).scrollTop(0);\n})\n\n# 控制没拉到最下面的时候先不显示这个回到顶部的按钮\nwindow.onscroll=function(){\n  if($(window)).scrolltop()>200){\n    $(\".top\").show();\n  }else{\n    $(\".top\").hide();\n  }\n}\n\n$(\"\").scrollLeft([val])\n```\n\nExample1:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        .test1{\n            width: 200px;\n            height: 200px;\n            background-color: wheat;\n        }\n    </style>\n</head>\n<body>\n\n\n<h1>this is offset</h1>\n<div class=\"test1\"></div>\n<p></p>\n<button>change</button>\n</body>\n<script src=\"jquery-3.1.1.js\"></script>\n<script>\n    var $offset=$(\".test1\").offset();\n    var lefts=$offset.left;\n    var tops=$offset.top;\n\n    $(\"p\").text(\"Top:\"+tops+\" Left:\"+lefts);\n    $(\"button\").click(function(){\n\n        $(\".test1\").offset({left:200,top:400})\n    })\n</script>\n</html>\n```\n\nExample2:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        *{\n            margin: 0;\n        }\n        .box1{\n            width: 200px;\n            height: 200px;\n            background-color: rebeccapurple;\n        }\n        .box2{\n            width: 200px;\n            height: 200px;\n            background-color: darkcyan;\n        }\n        .parent_box{\n             position: relative;\n        }\n    </style>\n</head>\n<body>\n\n\n\n\n<div class=\"box1\"></div>\n<div class=\"parent_box\">\n    <div class=\"box2\"></div>\n</div>\n<p></p>\n\n\n<script src=\"jquery-3.1.1.js\"></script>\n<script>\n    var $position=$(\".box2\").position();\n    var $left=$position.left;\n    var $top=$position.top;\n\n    $(\"p\").text(\"TOP:\"+$top+\"LEFT\"+$left)\n</script>\n</body>\n</html>\n```\n\nExample3:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <style>\n        body{\n            margin: 0;\n        }\n        .returnTop{\n            height: 60px;\n            width: 100px;\n            background-color: peru;\n            position: fixed;\n            right: 0;\n            bottom: 0;\n            color: white;\n            line-height: 60px;\n            text-align: center;\n        }\n        .div1{\n            background-color: wheat;\n            font-size: 5px;\n            overflow: auto;\n            width: 500px;\n            height: 200px;\n        }\n        .div2{\n            background-color: darkgrey;\n            height: 2400px;\n        }\n\n\n        .hide{\n            display: none;\n        }\n    </style>\n</head>\n<body>\n     <div class=\"div1 div\">\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n           <h1>hello</h1>\n     </div>\n     <div class=\"div2 div\"></div>\n     <div class=\"returnTop hide\">返回顶部</div>\n\n <script src=\"jquery-3.1.1.js\"></script>\n    <script>\n         $(window).scroll(function(){\n             var current=$(window).scrollTop();\n              console.log(current);\n              if (current>100){\n\n                  $(\".returnTop\").removeClass(\"hide\")\n              }\n              else {\n              $(\".returnTop\").addClass(\"hide\")\n          }\n         });\n\n\n            $(\".returnTop\").click(function(){\n                $(window).scrollTop(0)\n            });\n\n\n    </script>\n</body>\n</html>\n```\n\n**尺寸操作**\n\n```javascript\n# 内容区域的高度\n$(\"\").height([val|fn])\n# 我们一直说的width其实是content内容部分的宽度，这就是为什么设置了padding之后容器被撑开了。\n$(\"\").width([val|fn])\n# 这个innerheight拿的就是padding+内容的大小。\n$(\"\").innerHeight()\n$(\"\").innerWidth()\n# centent+padding+border，默认这个里面还有一个参数，默认为false，如果改为true的话会默认计算margin的值\n# 比如$(\"\").outerHeight(true)，记住这里的参数默认是false，也就是不会计算margin的值。\n$(\"\").outerHeight([soptions])\n$(\"\").outerWidth([options])\n```\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        *{\n            margin: 0;\n        }\n        .box1{\n            width: 200px;\n            height: 200px;\n            background-color: wheat;\n            padding: 50px;\n            border: 50px solid rebeccapurple;\n            margin: 50px;\n        }\n\n    </style>\n</head>\n<body>\n\n<div class=\"box1\">\n    DIVDIDVIDIV\n</div>\n\n\n<p></p>\n\n<script src=\"jquery-3.1.1.js\"></script>\n<script>\n    var $height=$(\".box1\").height();\n    var $innerHeight=$(\".box1\").innerHeight();\n    var $outerHeight=$(\".box1\").outerHeight();\n    var $margin=$(\".box1\").outerHeight(true);\n\n    $(\"p\").text($height+\"---\"+$innerHeight+\"-----\"+$outerHeight+\"-------\"+$margin)\n</script>\n</body>\n</html>\n```\n\n## Jq的插件\n\n```javascript\njQuery.extend({\n    // 扩展方法的名字: 方法的内容\n    min: function(a, b){ return a < b ? a : b;},\n    max: function(a, b){ return a > b ? a : b;},\n});\n```\n\n调用：\n\n```javascript\n// 这里的$其实指代的就是jQuery\n$.min(2,3)  // 2\n$.max(4,5)  // 5\n```\n\n扩充jquery对象\n\n```javascript\n$.fn.extend({\n    checkall: function(){\n        // 这个this是当前的选中的标签组\n        this.each(function(){\n            // 当前选中的标签\n            this.checked=true;\n        })\n    }\n})\n```\n\n调用：\n\n```javascript\n$(\':checkbox\').checkall()\n```\n\n","timestamp":1540005876713},{"name":"01-左侧菜单.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/01-左侧菜单.md","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n        }\n          .left{\n              width: 20%;\n              height: 500px;\n              float: left;\n              background-color: wheat;\n          }\n\n          .right{\n              float: left;\n              width: 80%;\n              height: 500px;\n              background-color: lightgray;\n\n          }\n\n           .title{\n               text-align: center;\n               line-height: 40px;\n               background-color: #0e90d2;\n               color: white;\n           }\n        .item{\n            padding: 10px;\n        }\n\n        .hide{\n            display: none;\n        }\n    </style>\n</head>\n<body>\n\n\n\n<div class=\"outer\">\n      <div class=\"left\">\n           <div class=\"item\">\n               <div class=\"title\">菜单一</div>\n               <ul class=\"con\">\n                   <li>111</li>\n                   <li>111</li>\n                   <li>111</li>\n               </ul>\n           </div>\n          <div class=\"item\">\n               <div class=\"title\">菜单二</div>\n               <ul class=\"con hide\">\n                   <li>222</li>\n                   <li>222</li>\n                   <li>222</li>\n               </ul>\n           </div>\n          <div class=\"item\">\n               <div class=\"title\">菜单三</div>\n               <ul class=\"con hide\">\n                   <li>333</li>\n                   <li>333</li>\n                   <li>333</li>\n               </ul>\n           </div>\n      </div>\n      <div class=\"right\"></div>\n</div>\n\n\n<script>\n\n    var eles_title=document.getElementsByClassName(\"title\");\n\n\n\n    for (var i=0;i<eles_title.length;i++){\n         eles_title[i].onclick=function(){\n\n             this.nextElementSibling.classList.remove(\"hide\");\n\n             for(var j=0;j<eles_title.length;j++){\n\n                 if (eles_title[j]!=this){\n                     eles_title[j].nextElementSibling.classList.add(\"hide\")\n                 }\n\n             }\n\n\n         }\n\n    }\n\n\n\n\n</script>\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"02-搜索框.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/02-搜索框.md","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n\n<script>\n\nfunction Focus(){\n\n    var input=document.getElementById(\"ID1\");\n    if (input.value==\"请输入用户名\"){\n        input.value=\"\";\n    }\n\n}\n\nfunction Blurs(){\n\n    var ele=document.getElementById(\"ID1\");\n    var val=ele.value;\n    if(!val.trim()){\n\n        ele.value=\"请输入用户名\";\n    }\n}\n\n</script>\n</head>\n<body>\n    <input id=\"ID1\" type=\"text\" value=\"请输入用户名\" onblur=\"Blurs()\" onfocus=\"Focus()\">\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"03-模态框.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/03-模态框.md","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        .back{\n            background-color: white;\n            height: 2000px;\n        }\n\n        .shade{\n            position: fixed;\n            top: 0;\n            bottom: 0;\n            left:0;\n            right: 0;\n            background-color: grey;\n            opacity: 0.4;\n        }\n\n        .hide{\n            display: none;\n        }\n\n        .models{\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            margin-left: -100px;\n            margin-top: -100px;\n            height: 200px;\n            width: 200px;\n            background-color: wheat;\n\n        }\n    </style>\n</head>\n<body>\n<div class=\"back\">\n    <input class=\"c\" type=\"button\" value=\"click\">\n</div>\n\n<div class=\"shade hide handles\"></div>\n\n<div class=\"models hide handles\">\n    <input class=\"c\" type=\"button\" value=\"cancel\">\n</div>\n\n\n<script>\n\n\n    var eles=document.getElementsByClassName(\"c\");\n    var handles=document.getElementsByClassName(\"handles\");\n    for(var i=0;i<eles.length;i++){\n        eles[i].onclick=function(){\n\n            if(this.value==\"click\"){\n\n                for(var j=0;j<handles.length;j++){\n\n                    handles[j].classList.remove(\"hide\");\n\n                 }\n\n            }\n            else {\n                for(var j=0;j<handles.length;j++){\n\n                    handles[j].classList.add(\"hide\");\n                }\n\n            }\n        }\n    }\n\n</script>\n\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"04-表格案例.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/04-表格案例.md","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<button class=\"select_all\">全选</button>\n<button class=\"select_reverse\">反选</button>\n<button class=\"cancel\">取消</button>\n\n<hr>\n\n<table class=\"server_table\" border=\"2px\" cellspacing=\"2px\">\n    <tr>\n        <td><input type=\"checkbox\" class=\"item\"></td>\n        <td>111</td>\n        <td>111</td>\n        <td>111</td>\n    </tr>\n    <tr>\n        <td><input type=\"checkbox\" class=\"item\"></td>\n        <td>222</td>\n        <td>222</td>\n        <td>222</td>\n    </tr>\n    <tr>\n        <td><input type=\"checkbox\" class=\"item\"></td>\n        <td>333</td>\n        <td>333</td>\n        <td>333</td>\n    </tr>\n    <tr>\n        <td><input type=\"checkbox\" class=\"item\"></td>\n        <td>444</td>\n        <td>444</td>\n        <td>444</td>\n    </tr>\n</table>\n\n\n<script>\n/*\n    var ele_all=document.getElementsByClassName(\"select_all\")[0];\n    var ele_reverse=document.getElementsByClassName(\"select_reverse\")[0];\n    var ele_cancel=document.getElementsByClassName(\"cancel\")[0];\n    var input_arr=document.getElementsByClassName(\"item\");\n\n    ele_all.onclick=function(){\n          for(var i=0;i<input_arr.length;i++){\n              console.log(input_arr[i]);\n              var input=input_arr[i];\n              input.checked=true;\n          }\n    };\n\n     ele_cancel.onclick=function(){\n          for(var i=0;i<input_arr.length;i++){\n              console.log(input_arr[i]);\n              var input=input_arr[i];\n              input.checked=false;\n          }\n    };\n\n    ele_reverse.onclick=function(){\n          for(var i=0;i<input_arr.length;i++){\n              console.log(input_arr[i]);\n              var input=input_arr[i];\n              if(input.checked){\n                  input.checked=false;\n              }\n              else{\n                  input.checked=true;\n              }\n          }\n    };\n\n*/\n\n\n    var input_arr=document.getElementsByClassName(\"item\");\n    var button_arr=document.getElementsByTagName(\"button\");\n\n    for(var i=0;i<button_arr.length;i++){\n\n        button_arr[i].onclick=function(){\n\n\n            for (var j=0;j<input_arr.length;j++){\n                 var inp=input_arr[j]\n                 if(this.innerText==\"全选\"){\n                     console.log(\"ok\");\n                 inp.checked=true;\n             }\n            else if(this.innerText==\"取消\"){\n                  inp.checked=false;\n             }\n            else {\n                 if(inp.checked){\n                     inp.checked=false;\n                 }else {\n                     inp.checked=true;\n                 }\n             }\n                \n            }\n        }\n\n    }\n</script>\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"05-Select移动.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/05-Select移动.md","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n\n    <style>\n        .outer{\n            margin: 0 auto;\n            background-color: darkgray;\n            width: 80%;\n            height: 600px;margin-top: 30px;\n            word-spacing: -5px;\n\n        }\n\n        #left{\n            display: inline-block;\n            width: 100px ;\n            height: 140px;\n            background-color: wheat;\n            text-align: center;\n\n\n        }\n\n        #choice{\n            display: inline-block;\n            height: 140px;\n            background-color: darkolivegreen;\n\n            vertical-align: top;\n            padding:0 5px;\n\n\n        }\n\n        #choice button{\n            margin-top: 20px;\n        }\n\n         #right{\n            display: inline-block;\n            width: 100px ;\n            height: 140px;\n            background-color: wheat;\n            text-align: center;\n            line-height: 140px;\n\n        }\n\n    </style>\n</head>\n<body>\n\n\n\n<div class=\"outer\">\n\n    <select multiple=\"multiple\" size=\"5\" id=\"left\">\n    <option>红楼梦</option>\n    <option>西游记</option>\n    <option>水浒传</option>\n    <option>JinPingMei</option>\n    <option>三国演义</option>\n</select>\n\n\n\n\n<span id=\"choice\">\n    <button id=\"choose_move\"> > </button><br>\n    <button id=\"all_move\"> >> </button>\n</span>\n\n\n\n<select multiple=\"multiple\" size=\"10\" id=\"right\">\n    <option>放风筝的人</option>\n</select>\n\n\n</div>\n\n\n\n\n<script>\n\n    var choose_move=document.getElementById(\"choose_move\");\n    var all_move=document.getElementById(\"all_move\");\n\n    var right=document.getElementById(\"right\");\n    var left=document.getElementById(\"left\");\n    var options=left.options;\n\n\n\n    choose_move.onclick=function(){\n\n        for (var i=0; i<options.length;i++){\n\n             var option=options[i];\n             if(option.selected==true){\n\n                   // var news=option.cloneNode(true);\n                   // console.log(news);\n\n                   right.appendChild(option);\n                   i--;\n             }\n         }\n    };\n\n    all_move.onclick=function(){\n\n        for (var i=0; i<options.length;i++){\n\n             var option=options[i];\n\n                   right.appendChild(option);\n                   i--;\n\n         };\n    };\n\n\n\n\n    /*\n   var buttons=document.getElementsByTagName(\"button\");\n   for(var i=0;i<buttons.length;i++) {\n        buttons[i].onclick = function () {\n\n            for (var i = 0; i < options.length; i++) {\n\n                var option = options[i];\n\n                if (this.innerText == \">\") {\n                    if (option.selected == true) {\n\n                        // var news=option.cloneNode(true);\n                        // console.log(news);\n\n                        right.appendChild(option);\n                        i--;\n                    }\n                } else {\n                    right.appendChild(option);\n                    i--;\n                }\n            }\n        };\n    }\n\n\n   */\n\n\n</script>\n\n\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"06-二级联动.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/06-二级联动.md","content":"```html\n<select id=\"province\">\n    <option>请选择省:</option>\n</select>\n\n<select id=\"city\">\n    <option>请选择市:</option>\n</select>\n\n\n<script>\n    data={\"河北省\":[\"廊坊\",\"邯郸\"],\"北京\":[\"朝阳区\",\"海淀区\"]};\n\n\n      var p=document.getElementById(\"province\");\n      var c=document.getElementById(\"city\");\n    \n    for(var i in data){\n        var option_pro=document.createElement(\"option\");\n\n        option_pro.innerHTML=i;\n\n        p.appendChild(option_pro);\n    }\n     p.onchange=function(){\n\t\t\t# 这里这个this其实就是这个select标签，this.options就是\n            # select标签下的option标签，这是一个列表，因为有多个标签\n            # selectedIndex表示选中的标签索引，直接填入到this.options中就可以锁定选中的标签了。\n            # 然后就能知道用户选择的省份是哪一个了\n            pro=(this.options[this.selectedIndex]).innerHTML;\n            # 通过省份获取到data中的区域。\n            citys=data[pro];\n\n         c.options.length=0;\n\n         for (var i in citys){\n             var option_city=document.createElement(\"option\");\n             option_city.innerHTML=citys[i];\n             c.appendChild(option_city);\n         }\n\n        }\n</script>\n```\n\n","timestamp":1540005876713},{"name":"07-跑马灯&tab切换.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/07-跑马灯&tab切换.md","content":"```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>tab</title>\n  <style>\n    *{margin:0; padding:0; list-style:none;}\n    body{\n        font-family: \"Helvetica Neue\", \"Hiragino Sans GB\", \"Microsoft YaHei\", \"\\9ED1\\4F53\", Arial, sans-serif;\n    }\n    h3{\n        text-align: center;\n        color:darkcyan;\n        margin-top: 30px;\n        letter-spacing: 5px;\n    }\n    .box{\n      width: 1000px;\n      margin:50px auto 0px;\n    }\n    #title{\n      line-height: 40px;\n      background-color: rgb(247,247,247);\n      font-size: 16px;\n      font-weight: bold;\n      color: rgb(102,102,102);\n    }\n    #title span{\n      float: left;\n      width: 166px;\n      text-align: center;\n    }\n    #title span:hover{\n      /*color: black;*/\n      cursor: pointer;\n    }\n    #content{\n      margin-top: 20px;\n    }\n    #content li{\n      width: 1050px;\n      display: none;\n      background-color: rgb(247,247,247);\n    }\n    #content li div{\n      width: 156px;\n      margin-right: 14px;\n      float: left;\n      text-align: center;\n    }\n    #content li div a{\n      font-size: 14px;\n      color: black;\n      line-height: 14px;\n    /*  float: left;*/\n    display: inline-block;\n      margin-top: 10px;\n    }\n    #content li a:hover{\n      color: #B70606;\n    }\n    #content li div span{\n        font-size: 16px;\n        line-height: 16px;\n        /*float: left;*/\n        display: block;\n        color: rgb(102,102,102);\n        margin-top: 10px;\n      }\n    #content img{\n      float: left;\n      width: 155px;\n      height: 250px;\n    }\n    #title .select{\n      background-color: #2459a2;\n      color: white;\n        border-radius: 10%;\n    }\n    #content .show{\n      display: block;\n    }\n\n    .show span{\n        color: red!important;\n        font-size: 30px;\n    }\n  </style>\n</head>\n\n<body>\n    <h3 id=\"wel\">京东商城欢迎您</h3>\n    <!--  direction=\"right up down left\" -->\n<!--  behavior：滚动方式(包括3个值：scroll、slide、alternate) -->\n<!--  说明：scroll：循环滚动，默认效果；slide：只滚动一次就停止；alternate：来回交替进行滚动。 -->\n<!--  scrollamount=\"5\" 滚动速度 -->\n\n<marquee behavior=\"scroll\" direction=\"right\">欢迎您苑昊先生</marquee>\n    <script>\n\n    function test(){\n\n        var mywel = document.getElementById(\"wel\");\n        var content = mywel.innerText;\n\n        var f_content = content.charAt(0);\n        var l_content = content.substring(1,content.length);\n\n        var new_content = l_content + f_content;\n        mywel.innerText = new_content;\n\n    }\n\n    // setInterval(\"test();\", 500);\n</script>\n    <div class=\"box\">\n      <p id=\"title\">\n        <span class=\"select\">家用电器</span>\n        <span>家具</span>\n        <span>汽车</span>\n        <span>食品</span>\n        <span>女鞋</span>\n        <span>医疗保健</span>\n      </p>\n\n      <ul id=\"content\">\n        <li class=\"show\">\n\n          <div><img src=\"https://img10.360buyimg.com/n1/s450x450_jfs/t4786/325/2470647304/119102/9e1a4ed5/59005841Nd786a8df.jpg\" alt=\"冰箱\"><a href=\"#\">容声(Ronshen)冰箱</a><span>价格:5600</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/s450x450_jfs/t3037/347/1290968859/201366/7c1028a0/57c00194N9d0a54c6.jpg\" alt=\"洗衣机\"><a href=\"#\">海尔洗衣机</a><span>价格:5400</span></div>\n          <div><img src=\"https://img11.360buyimg.com/n1/jfs/t3289/128/2393835119/236360/af1d283b/57e0f300N53dde603.jpg\" alt=\"电饭煲\"><a href=\"#\">福库(CUCKOO)电饭煲</a><span>价格:3999</span></div>\n          <div><img src=\"https://img13.360buyimg.com/n1/jfs/t3235/137/2361713777/152258/a6908440/57e098c2N44a90a5d.jpg\" alt=\"智能电视\"><a href=\"#\">三星智能电视</a><span>价格:8999</span></div>\n          <div><img src=\"https://img10.360buyimg.com/n1/jfs/t2053/101/1391591157/215066/572e131b/5696ee9bN2376492d.jpg\" alt=\"净水器\"><a href=\"#\">净水器</a><span>价格:1300</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3175/78/2357430273/262835/9a8e7f65/57e0a3e9Nbda39dd2.jpg\" alt=\"空气净化器\"><a href=\"#\">空气净化器</a><span>价格:5300</span></div>\n        </li>\n\n        <li>\n\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t1948/172/2877517581/556924/682eb107/56f63dc8Naddf77e5.jpg\" alt=\"沙发\"><a href=\"#\">沙发</a><span>价格:2900</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t1948/172/2877517581/556924/682eb107/56f63dc8Naddf77e5.jpg\" alt=\"沙发\"><a href=\"#\">沙发</a><span>价格:2900</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t1948/172/2877517581/556924/682eb107/56f63dc8Naddf77e5.jpg\" alt=\"沙发\"><a href=\"#\">沙发</a><span>价格:2900</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t1948/172/2877517581/556924/682eb107/56f63dc8Naddf77e5.jpg\" alt=\"沙发\"><a href=\"#\">沙发</a><span>价格:2900</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t1948/172/2877517581/556924/682eb107/56f63dc8Naddf77e5.jpg\" alt=\"沙发\"><a href=\"#\">沙发</a><span>价格:2900</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t1948/172/2877517581/556924/682eb107/56f63dc8Naddf77e5.jpg\" alt=\"沙发\"><a href=\"#\">沙发</a><span>价格:2900</span></div>\n\n        </li>\n        <li>\n          <div><img src=\"http://img11.360buyimg.com/n1/jfs/t4969/76/45396935/144539/347153d4/58d9cff4N36872ad6.jpg\" alt=\"长安汽车\"><a href=\"#\">长安汽车</a><span>价格:12900</span></div>\n          <div><img src=\"http://img11.360buyimg.com/n1/jfs/t4969/76/45396935/144539/347153d4/58d9cff4N36872ad6.jpg\" alt=\"长安汽车\"><a href=\"#\">长安汽车</a><span>价格:12900</span></div>\n          <div><img src=\"http://img11.360buyimg.com/n1/jfs/t4969/76/45396935/144539/347153d4/58d9cff4N36872ad6.jpg\" alt=\"长安汽车\"><a href=\"#\">长安汽车</a><span>价格:12900</span></div>\n          <div><img src=\"http://img11.360buyimg.com/n1/jfs/t4969/76/45396935/144539/347153d4/58d9cff4N36872ad6.jpg\" alt=\"长安汽车\"><a href=\"#\">长安汽车</a><span>价格:12900</span></div>\n          <div><img src=\"http://img11.360buyimg.com/n1/jfs/t4969/76/45396935/144539/347153d4/58d9cff4N36872ad6.jpg\" alt=\"长安汽车\"><a href=\"#\">长安汽车</a><span>价格:12900</span></div>\n          <div><img src=\"http://img11.360buyimg.com/n1/jfs/t4969/76/45396935/144539/347153d4/58d9cff4N36872ad6.jpg\" alt=\"长安汽车\"><a href=\"#\">长安汽车</a><span>价格:12900</span></div>\n        </li>\n        <li>\n\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t4414/110/2582917360/207971/b7e129ad/58f0ee1fN94425de1.jpg\" alt=\"嘉兴粽子\"><a href=\"#\">嘉兴粽子</a><span>价格:1</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t4414/110/2582917360/207971/b7e129ad/58f0ee1fN94425de1.jpg\" alt=\"嘉兴粽子\"><a href=\"#\">嘉兴粽子</a><span>价格:1</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t4414/110/2582917360/207971/b7e129ad/58f0ee1fN94425de1.jpg\" alt=\"嘉兴粽子\"><a href=\"#\">嘉兴粽子</a><span>价格:1</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t4414/110/2582917360/207971/b7e129ad/58f0ee1fN94425de1.jpg\" alt=\"嘉兴粽子\"><a href=\"#\">嘉兴粽子</a><span>价格:1</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t4414/110/2582917360/207971/b7e129ad/58f0ee1fN94425de1.jpg\" alt=\"嘉兴粽子\"><a href=\"#\">嘉兴粽子</a><span>价格:1</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t4414/110/2582917360/207971/b7e129ad/58f0ee1fN94425de1.jpg\" alt=\"嘉兴粽子\"><a href=\"#\">嘉兴粽子</a><span>价格:1</span></div>\n\n        </li>\n        <li>\n\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3079/298/5759209435/92674/14818594/587f1c33N53e5d2a9.jpg\" alt=\"星期六\"><a href=\"#\">星期六</a><span>价格:439</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3079/298/5759209435/92674/14818594/587f1c33N53e5d2a9.jpg\" alt=\"星期六\"><a href=\"#\">星期六</a><span>价格:439</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3079/298/5759209435/92674/14818594/587f1c33N53e5d2a9.jpg\" alt=\"星期六\"><a href=\"#\">星期六</a><span>价格:439</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3079/298/5759209435/92674/14818594/587f1c33N53e5d2a9.jpg\" alt=\"星期六\"><a href=\"#\">星期六</a><span>价格:439</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3079/298/5759209435/92674/14818594/587f1c33N53e5d2a9.jpg\" alt=\"星期六\"><a href=\"#\">星期六</a><span>价格:439</span></div>\n          <div><img src=\"https://img14.360buyimg.com/n1/jfs/t3079/298/5759209435/92674/14818594/587f1c33N53e5d2a9.jpg\" alt=\"星期六\"><a href=\"#\">星期六</a><span>价格:439</span></div>\n\n        </li>\n        <li>\n\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t5755/127/1139389729/356866/99d4e869/5923e410Nb2983f70.jpg\" alt=\"汇仁 肾宝片\"><a href=\"#\">汇仁 肾宝片</a><span>价格:322</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t5755/127/1139389729/356866/99d4e869/5923e410Nb2983f70.jpg\" alt=\"汇仁 肾宝片\"><a href=\"#\">汇仁 肾宝片</a><span>价格:322</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t5755/127/1139389729/356866/99d4e869/5923e410Nb2983f70.jpg\" alt=\"汇仁 肾宝片\"><a href=\"#\">汇仁 肾宝片</a><span>价格:322</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t5755/127/1139389729/356866/99d4e869/5923e410Nb2983f70.jpg\" alt=\"汇仁 肾宝片\"><a href=\"#\">汇仁 肾宝片</a><span>价格:322</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t5755/127/1139389729/356866/99d4e869/5923e410Nb2983f70.jpg\" alt=\"汇仁 肾宝片\"><a href=\"#\">汇仁 肾宝片</a><span>价格:322</span></div>\n          <div><img src=\"https://img12.360buyimg.com/n1/jfs/t5755/127/1139389729/356866/99d4e869/5923e410Nb2983f70.jpg\" alt=\"汇仁 肾宝片\"><a href=\"#\">汇仁 肾宝片</a><span>价格:322</span></div>\n\n        </li>\n\n\n      </ul>\n    </div>\n\n    <script>\n      var title=document.getElementById(\'title\');\n      var content=document.getElementById(\'content\');\n      var category=title.getElementsByTagName(\'span\');\n      var item=content.getElementsByTagName(\'li\');\n\n      for (var i = 0; i < category.length; i++) {\n\n          category[i].index=i;\n\n          category[i].onclick=function(){\n\n            for (var j = 0; j < category.length; j++) {\n              category[j].className=\'\';\n              item[j].className=\'\';\n            }\n            this.className=\'select\';\n            item[this.index].className=\'show\';\n          }\n\n\n      }\n\n    </script>\n</body>\n</html>\n```\n\ntab切换的关键就是，给每一个tab标题添加一个属性=对应的内容的div的id，我只要点击某一个tab标签我就能获取到这个属性，根据这个属性，我就能知道你找的是哪一个内容区域。\n\n","timestamp":1540005876713},{"name":"08-轮播图练习.md","path":"05-Frontend/03-JavaScript/08-JS实例练习/08-轮播图练习.md","content":"## 轮播图实验效果\n\n![](http://omk1n04i8.bkt.clouddn.com/17-12-28/40041146.jpg)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>轮播图测试</title>\n    <style>\n        /*关于样式重置*/\n        * {margin: 0;padding: 0;}\n        a{text-decoration: none;}\n        ul,li{list-style: none;}\n\n\n\n        /*具体样式*/\n        #outer{\n            width: 750px;\n            height: 380px;\n            margin: 20px auto;\n            border: 1px solid red;\n            position: relative;\n        }\n\n        #pics li {\n            display: none;\n        }\n\n        .pic{\n            position: absolute;\n            top: 0;\n            left: 0;\n        }\n\n\n\n        .pointer{\n            position: absolute;\n            bottom: 20px;\n            left: 260px;\n        }\n\n        .pointer li{\n            display: inline-block;\n            width: 16px;\n            height: 16px;\n            background: gray;\n            text-align: center;\n            line-height: 16px;\n            border-radius: 8px;\n            margin-left: 10px;\n        }\n\n        .btn{\n            position: absolute;\n            top: 50%;\n            width: 26px;\n            height: 76px;\n            margin-top: -38px;\n            font-size: 24px;\n            color: white;\n            text-align: center;\n            line-height: 76px;\n            background: rgba(156,156,156,0.7);\n        }\n        .left{\n            left: 0;\n        }\n        .right{\n            right: 0;\n        }\n\n        .pointer .active {\n            background: white;\n        }\n    </style>\n</head>\n<body>\n<div id=\"outer\">\n    <div id=\"pics\">\n        <ul>\n            <li class=\"pic\" style=\"display: block;\"><a href=\"#\"><img src=\"img/longhuyun1.png\" alt=\"\"></a></li>\n            <li class=\"pic\"><a href=\"#\"><img src=\"img/longhuyun2.png\" alt=\"\"></a></li>\n            <li class=\"pic\"><a href=\"#\"><img src=\"img/longhuyun3.png\" alt=\"\"></a></li>\n            <li class=\"pic\"><a href=\"#\"><img src=\"img/longhuyun4.png\" alt=\"\"></a></li>\n            <li class=\"pic\"><a href=\"#\"><img src=\"img/longhuyun5.png\" alt=\"\"></a></li>\n            <li class=\"pic\"><a href=\"#\"><img src=\"img/longhuyun6.png\" alt=\"\"></a></li>\n            <li class=\"pic\"><a href=\"#\"><img src=\"img/longhuyun7.png\" alt=\"\"></a></li>\n        </ul>\n    </div>\n\n    <ul class=\"pointer\">\n        <li class=\"active\"></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n\n    <div class=\"left btn\"> < </div>\n    <div class=\"right btn\"> > </div>\n</div>\n<script src=\"jquery-3.2.1.js\"></script>\n<script>\n    var i=0;\n    function f() {\n        // 一开始显示的就是第一张，因此setInterval过后显示的应该是第二张，索引为1\n        // 一共是7张图，显示到第七张索引值为6，当等于6的时候应该直接从头开始了\n        // 因此当i=6的时候就让他从头开始，不过要从第一张也就是索引值为0的地方开始\n        if (i==6){\n            i=-1;\n        }\n        i++;\n        // 渐入渐出是单开的线程，setInterval不会等你渐入渐出的时间\n        // 因此将渐入渐出的时间总和调整到interval以下就行。\n        $(\'#pics li\').eq(i).fadeIn(500).siblings().fadeOut(500);\n        $(\'.pointer li\').eq(i).addClass(\"active\").siblings().removeClass(\"active\")\n\n    }\n\n\n    function f2() {\n        // 这个方法和f正好想法，这个是逆向的轮播，因此索引都是-1的操作\n        // 当i=0的时候，我们就把i给设置成最大，继续轮播。\n        if (i==0){\n            i=7;\n        }\n        i--;\n        // 渐入渐出是单开的线程，setInterval不会等你渐入渐出的时间\n        // 因此将渐入渐出的时间总和调整到interval以下就行。\n        $(\'#pics li\').eq(i).fadeIn(500).siblings().fadeOut(500);\n        $(\'.pointer li\').eq(i).addClass(\"active\").siblings().removeClass(\"active\")\n\n    }\n    // setInterval接收两个参数，一个执行函数，一个是等待的时间\n    // 这里的1000指的是1000ms，也就是1s的时间，一开始先等待1s钟然后执行f()\n    // 返回一个 ID（数字），可以将这个ID传递给clearInterval()，clearTimeout() 以取消执行。\n    var ID = setInterval(f,1000);\n\n    // 手动轮播，当鼠标放在下面的小按钮的时候，悬浮在哪个上面就显示哪一个\n    // 1、先让它悬浮后停止自动轮播\n    $(\'#outer\').hover(function () {\n        clearInterval(ID)\n    },function () {\n        ID = setInterval(f,1000);\n    });\n\n    $(\'.pointer li\').mousemove(function () {\n        // 关于这里为什么要使用i作为变量？\n        // 因为之前自动轮播的时候保存着一个i的状态，比如i=4\n        // 假如现在我指针指向第一张，当我离开的时候讲道理要从第二张开始\n        // 但是由于自动轮播图保存了i的关系，他会从5继续开始，因此我们要重新声明i的值\n        // 保证轮播图是随着我们的操作去轮询的\n        $i=$(this).index();\n        $(\'#pics li\').eq($i).fadeIn(500).siblings().fadeOut(500);\n        $(\'.pointer li\').eq($i).addClass(\"active\").siblings().removeClass(\"active\")\n    });\n\n    // click事件\n    $(\'.right\').click(f);\n    $(\'.left\').click(f2);\n\n</script>\n</body>\n</html>\n```\n\n","timestamp":1540005876713},{"name":"10-其他.md","path":"05-Frontend/03-JavaScript/10-其他.md","content":"\n\n**如何用JavaScript取非行间样式？**\n\n通过document.get方式获取的直接调用对象的.style只能获取行间样式，如果要获取外联的或者写在head头部的，就不可以直接使用style而需要使用currentStyle来获取了，这个写法指的是获取计算后的样式，或者说当前样式，最终样式，叫法很多。\n\n```javascript\noDiv1.currentStyle.width;\n```\n\n不过这个用法在不同的浏览器存在兼容性的问题，不过这个currentStyle只在ie下使用，火狐下使用getComputedStyle()，这个函数接受两个参数，第一个是要获取的对象，第二个是一个布尔值（true or false），这第二个参数其实没什么实际的意义。\n\n```javascript\ngetComputedStyle(oDiv1,false).width\n```\n\n在新版的火狐这个函数的第二个参数已经被取消。\n\n兼容性的处理：\n\n```javascript\nif (oDiv1.currentStyle){\n    //For IE\n    alert(oDiv1.currentStyle.width);\n}\nelse\n{\n    //For firefox\n    alert(getComputedStyle(oDiv1).width);\n}\n```\n\n但是使用if和else很麻烦，因此可以把这个功能封装成一个函数。\n\n```javascript\n//哪个元素，哪个样式\nfunction getStyle(obj,attr){\n    if (obj.currentStyle){\n    //For IE，获取属性的时候不是点而是一个中括号\n    alert(obj.currentStyle[attr]);\n  }\nelse\n{\n    //For firefox\n    alert(getComputedStyle(obj)[attr]);\n  }\n}\n```\n\n获取样式可以获取到有一些没有设置的默认值，比如font-size这种，但是针对于background这种复合样式支持是存在问题的。复合样式是获取不到的，只能获取到单一样式（基本样式）。\n\n\n\n**2、转义**\n\n- decodeURI( )                   URl中未转义的字符  转移url中的中文\n- decodeURIComponent( )   URI组件中的未转义字符 这种连冒号和斜杠也会给你转义\n- encodeURI( )                   URI中的转义字符\n- encodeURIComponent( )   转义URI组件中的字符\n- escape( )                         对字符串转义  下面这三个不是针对url是针对值的转义。\n- unescape( )                     给转义字符串解码\n- URIError                         由URl的编码和解码方法抛出\n\nthrow new Error\n\n\n\n### DOM（Document Object Model）\n\n文档对象模型，把文档变成一个js可以操作的对象。（有一些兼容性问题）\n\n### BOM（Browser Object Model）\n\n给予JS操作浏览器的手段和方法。（几乎不兼容，所以不存在兼容性问题）\n\n\n\n\n\n# js学习小结\n\n在js的使用过程中，一定要注意语法\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>初学js</title>\n\t<style type=\"text/css\">\n\t\t#div1{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground: red;\n\t\t}\n\t</style>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function (){\n\t\t\tvar oDiv1 = document.getElementById(\'div1\');\n             # 事件提取的时候函数不加括号\n\t\t\toDiv1.onmouseover = toGreen;\n\t\t\toDiv1.onmouseout = toRed;\n\t\t}\n\t\tfunction toGreen(){\n\t\t\tvar odiv1 = document.getElementById(\'div1\');\n\t\t\todiv1.style.width = \'200px\';\n\t\t\todiv1.style.height = \'200px\';\n\t\t\todiv1.style.background = \'green\';\n\t\t};\n\t\tfunction toRed(){\n\t\t\tvar odiv1 = document.getElementById(\'div1\');\n\t\t\todiv1.style.width = \'100px\';\n\t\t\todiv1.style.height = \'100px\';\n\t\t\todiv1.style.background = \'red\';\n\t\t};\n\t</script>\n</head>\n<body>\n\t<div id=\"div1\">\n\t\t\n\t</div>\n\t\n</body>\n</html>\n```\n\n- 上面代码中涉及到方法的不管是有名称的还是匿名的都要加一个小括号，然后函数体用一个花括号括起来。\n- 变量要用var去声明，而且每一句都要有分号结尾，每一个函数后面也要有分号结尾。\n- 涉及到style变化的，记得style的属性值要用引号引起来。\n- 事件提取的话函数不要带小括号\n- js的读取是从上到下一行一行的去执行的。window.onload的作用是预先把页面内容给加载了。如果不加window.onload是会报错的\n\n- 注意不该大写的不要大写，比如checked=true，就不要写成True了。\n\n## this指代的是当前发生事件的那个元素\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<script type=\"text/javascript\">\n        window.onload = function(){\n        \tvar oinput = document.getElementsByTagName(\'input\');\n            oinput[0].onclick = function()\n            {\n            \talert(this.value);\n            };\n\n        };\n\n\n\t</script>\n</head>\n<body>\n\t<input type=\"button\" value=\'你点我干嘛！\'>\n</body>\n</html>\n```\n\n- this指代的是当前操作的元素。比如点input就是当前那个input\n- alter是错误的，是alert\n- getElementByTagName得到的是一个数组而不是一个单个元素，因此在取用的时候要加下标\n\n```javascript\n# 例二\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\tinput {\n\t\t\tbackground: white;\n\t\t}\n\t\t.active {\n\t\t\tbackground: red;\n\t\t}\n\t\tdiv {\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tbackground: green;\n\t\t\tdisplay: none;\n\t\t}\n\t</style>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function(){\n\t\tvar oinput = document.getElementsByTagName(\'input\');\n\t\tvar odiv = document.getElementsByTagName(\'div\')\n\t\tfor(i=0;i<oinput.length;i++)\n\t\t{\n            //加一个索引值用来给div做索引\n\t\t    oinput[i].index = i;\n        \toinput[i].onclick = function()\n        \t{\n        \t\tfor(i=0;i<oinput.length;i++)\n        \t\t{\n                      //先把所有的class都置为空\n\t\t\t\t\toinput[i].className=\'\';\n\t\t\t\t\todiv[i].style.display=\'none\';\n\t\t\t\t}\n\t\t\t\todiv[this.index].style.display=\'block\';\n                  //将当前的元素的class置为active\n\t\t\t\tthis.className = \'active\';\n        \t};\n\t\t}\n    };\n\t</script>\n</head>\n<body>\n\t<input class=\'active\' type=\"button\" name=\"\">\n\t<input type=\"button\" name=\"\">\n\t<input type=\"button\" name=\"\">\n\t<div style=\'display: block;\'>111</div>\n\t<div>222</div>\n\t<div>333</div>\n</body>\n</html>\n```\n\nToString() :  返回对象的原始字符串表示。\nValueOf()  : 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。\n\n\n\n\n\n","timestamp":1540005876713},{"name":"01-Ajax入门.md","path":"05-Frontend/05-Ajax/01-Ajax入门.md","content":"# Ajax全套\n\n> http://www.cnblogs.com/wupeiqi/articles/5703697.html\n>\n> 什么是Ajax？(Asynchronous Javascript and XML)，异步JavaScript和XML\n>\n> - 节省用户操作，时间，提高用户体验，减少护具请求\n> - 传输获取数据\n>\n> Ajax最直接的作用就是数据交互。Ajax其实是可以通过不刷新页面的情况去请求和发送数据。\n\n## 原生Ajax\n\nJQuery的Ajax内部是基于原生的ajax，其实就是jquery就是封装了ajax\n\n### Ajax流程\n\n```javascript\n# HTML\n<form action=\"\" method=\"post\">\n    <input type=\"button\" value=\"button\" id=\"btn\">\n</form>\n\n\n# JS\nwindow.onload = function () {\n    var oBtn = document.getElementById(\'btn\');\n    oBtn.onclick = function () {\n        // 1-相当于打开浏览器\n        var xhr = new XMLHttpRequest();\n        // 2-在地址栏输入地址\n        xhr.open(\'get\', \'/login/\',true);\n        // 3-提交\n        xhr.send();\n        // 4-等待服务器返回内容\n        xhr.onreadystatechange = function () {\n            if( xhr.readyState == 4 ){\n                if ( xhr.status == 200 ){\n                    alert(xhr.responseText)\n                } else {\n                    alert(\'出错了！,Err\' + xhr.status);\n                }\n            }\n        }\n    }\n};\n```\n\n1. 新建一个ajax的对象\n2. 相当于在地址栏中输入地址，open方法需要三个参数，第一个参数是打开方式，第二个是打开的地址，第三个是是否异步。\n3. 发送请求给服务端\n4. 数据的获取，responseText存放ajax请求返回的内容。readyState代表ajax的工作状态，4表示接受完成可以直接调用了。并且我们可以通过responseText\n\n### XMLHttpRequest\n\n**1、XmlHttpRequest对象介绍**\n\nXmlHttpRequest对象的主要方法：\n\n```\na. void open(String method,String url,Boolen async)\n   用于创建请求\n   \n参数：\n- method： 请求方式（字符串类型），如：POST、GET、DELETE...\n- url：    要请求的地址（字符串类型）\n- async：  是否异步（布尔类型），体现在回调。默认就是异步的\n如果是异步，那么偷偷的给后台发数据，然后期间你该干嘛干嘛。前面的代码不会影响后面的代码的执行。\n如果是非异步，那么后台处理期间，整个页面就被卡主了。当后面的代码用到了前面的内容的时候就应该使用同步的。\n\nb. void send(String body)\n    用于发送请求，向请求体里塞内容\n\n    参数：\n        body： 要发送的数据（字符串类型）\n\nc. void setRequestHeader(String header,String value)\n    用于设置请求头\n\n    参数：\n        header： 请求头的key（字符串类型）\n        vlaue：  请求头的value（字符串类型）\n\nd. String getAllResponseHeaders()\n    获取所有响应头\n\n    返回值：\n        响应头数据（字符串类型）\n\ne. String getResponseHeader(String header)\n    获取响应头中指定header的值\n\n    参数：\n        header： 响应头的key（字符串类型）\n\n    返回值：\n        响应头中指定的header对应的值\n\nf. void abort()\n\n    终止请求\n```\n\nXmlHttpRequest对象的主要属性：\n\n```\na. Number readyState\n   状态值（整数）\n\n   详细：\n      0-初始化，尚未调用open()方法；\n      1-启动，调用了open()方法；\n      2-发送，已经调用了send()方法，未接收到响应；\n      3-接收，已经接收到部分响应数据；\n      4-完成，已经接收到全部响应数据，并解析完成，可以在客户端进行调用了；\n\nb. Function onreadystatechange\n   当readyState的值改变时自动触发执行其对应的函数（回调函数）\n\nc. String responseText\n   服务器返回的数据（字符串类型）\n\nd. XmlDocument responseXML\n   服务器返回的数据（Xml对象）\n\ne. Number states\n   状态码（整数），如：200、404...等，可以通过状态码做容错处理，来规避一些错误，比如我们的请求输错了，或者服务器挂了，数据库down了返回来的一些错误信息等。\n\nf. String statesText\n   状态文本（字符串），如：OK、NotFound...\n```\n\n### 举例应用：\n\n```javascript\n### GET请求\nfunction add2(){\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystateChange = function(){\n    # 当状态码为4的时候触发执行回调函数。\n    if (xhr.readyState == 4){\n      alert(xhr.responsetext)\n    }\n  };\n  # 打开一个连接，是否异步不写默认就是异步的\n  xhr.open(\'GET\',\'/add2/?i1=1&i2=2\');\n  //encodeURI解决编码问题，解决缓存问题就在请求的路径后面接一个时间戳\n  //为避免和后台要获取的key产生冲突，因此直接在请求的连接后面加一个&然后直接接时间戳，不指定key\n  //注意千万不要忘了“&”，不然就直接接到30后面了。\n  //xhr.open(\'get\',\'2.get.php?username=\'+encodeURI(\'刘伟\')+\'&age=30&\' + new Date().getTime(),true);\n  # 用于发送请求，\n  xhr.send();\n}\n\n### POST请求\nfunction add2(){\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystateChange = function(){\n    # 当状态码为4的时候执行回调函数。\n    if (xhr.readyState == 4){\n      alert(xhr.responsetext)\n    }\n  }\n  # 打开一个连接，是否异步不写默认就是异步的\n  xhr.open(\'POST\',\'/add2/\');\n  # POST请求的时候要记得设置Content-Type请求头，申明发送的数据类型。告诉后端我提交的数据是二进制编码的数据。并且post不存在get方法提交时候的缓存问题。所以也无需关系，而且编码问题也无需关心。\n  # 不设置请求头的话会返回一个空字典\n  xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded\');\n  # 把数据放到send的参数中，用于发送请求，无需编码\n  xhr.send(\'i1=12&i2=23\');\n}\n```\n\n### Ajax获取数据的处理\n\n> - JSON.stringify()：可以把一个对象转换成对应的字符串\n> - JSON.parse：可以把字符串转换成对应的对象\n>\n> Tip：Json的key值必须是双引号引起来的，json针对这格式是异常严格的，单引号也不行，注意。\n\n### 封装Ajax的方法\n\n```javascript\nfunction ajax(method, url, data, success){\n    xhr = new XMLHttpRequest();\n    if (method == \'get\' && data){\n        // 把url和参数数据分开\n        url += \'?\' + data;\n    }\n    \n    xhr.open(method,url,true);\n    if (method == \'get\'){\n        xhr.send();\n    } else {\n        xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded\');\n        xhr.send(data)\n    }\n    \n    xhr.onreadystateChange = function(){\n    \tif (xhr.readyState == 4){\n            if (xhr.status == 200){\n                // 判断有没有success这个函数，如果有就调用\n                // success函数的作用就是把获取到的数据进行处理，比如格式化，放到哪个标签下等\n                // xhr.responseText作为success的参数回调给调用端。\n                success && success( xhr.responseText );\n            }else{\n                alert(\'Error\' + xhr.status);\n            }\n    \t}\n  \t}\n}\n```\n\n## Ajax上传文件\n\n上面的这些都是发送的文字，接下来来看如何使用ajax在后台上传文件。\n\n```javascript\nfunction upload(){\n  # 创建一个FormData对象，这个对象能传字符串能传文件\n  var formData = new FormData();\n  # 字符串\n  formData.append(\'k1\',\'v1\')\n  # 拿到文件对象，i1为input的type为file的标签的id，它下面有一个files属性值，拿到的是\n  # 一个文件对象的列表，因为有可能上传多个文件，我们取第一个就是索引0的位置\n  formData.append(\'fafafa\',document.getElementById(\'i1\').files[0])\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystateChange = function(){\n    if (xhr.readyState == 4){\n      # 定一个变量用来获取后端传递过来的file_path\n      var file_path = xhr.responsetext;\n      var tag = document.createElement(\'img\');\n      # 返回的路径是相对的，我们要加一个斜杠，要这个路径是针对根显示的。\n      tag.src = \"/\" + file_path;\n      # container是页面中的一个容器，我们往这个容器里添加内容\n      document.getElementById(\'container1\').appendChild(tag);\n    }\n  }\n  xhr.open(\'POST\',\'/add2/\');\n  # 当使用formdata这个特殊对象的时候就不用指定这个content-type头了，直接把整个form-data对象传递到后台，后台会做统一处理。因此这个设置请求头的操作要省略。\n  # xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded\');\n  # 用于发送请求，将formData对象放到这里，formData里既有普通的文本又有文件\n  xhr.send(formData);\n}\n\n\ndef upload(request):\n  if request.method == \"GET\":\n    return render(xxx)\n  else:\n    # request.POST拿传递过来的文本数据\n    file_obj = request.FILES.get(\'fafafa\')\n    # 将上传过来的文件一点一点的写到本地\n    file_path = os.path.join(\"static\",file_obj.name)\n    with open(file_path, \'wb\') as f:\n      for chunk in file_obj.chunks():\n        f.write(chunk)\n    \n    return HttpResponse(file_path)\n```\n\n使用jquery封装的ajax提交\n\n```javascript\nfunction upload2(){\n  var formData = new FormData();\n  formData.append(\'k1\',\'v1\');\n  formData.append(\'fafafa\',$(\'#i2\')[0].files[0]);\n  # jquery对象和Dom对象的互换，直接把dom对象加个$(dom对象)就变成jquery对象\n  # 把jquery对象加个0的索引就能转换成dom对象，比如$(\'#i2\')[0]\n  $.ajax({\n    url:\'/upload/\',\n    type:\'POST\',\n    data:formData,\n    # 在原生ajax中我们知道不需要指定content-type，在这里同样也要告诉jquery不要添加Content-Type，让jquery不做处理。需要设置如下的两个参数。\n    contentType:false,\n    processData:false\n    success:function(arg){\n      var tag = document.createElement(\'img\');\n      tag.src = \"/\" + arg;\n      $(\'#container2\').append(tag);\n    }\n  })\n}\n```\n\n### Ajax上传的兼容性处理\n\n> 通过伪造的Ajax来实现，也就是iframe的实现方案。\n\nFormData对象是html5以后提出来的这么一个对象，主流的浏览器和ie10以上都是可以使用的，但是针对以前的浏览器就会有问题。因此兼容性存在一定的问题，如果想要兼容性更好一些，可以使用伪造的Ajax。\n\n```javascript\n# html:务必要指定enctype为multipart/form-data\n<form id=\"f1\" method=\"POST\" action=\"/upload/\" target=\'ifr\' enctype=\"multipart/form-data\">\n  <iframe id=\'ifr\' name=\'ifr\' style=\'display:none\'></iframe>\n  <input type=\"file\" name=\"fafafa\" />\n  <a onclick=\"upload3;\">上传</a>\n</form>\n\n\nfunction upload3(){\n  document.getElementById(\'f1\').submit();\n  document.getElementById(\'ifr\').onload=loadIframe();\n}\nfunction loadIframe(){\n  var content = document.getElementById(\'ifr\').contentWindow.document.body.innerText;\n  # 这个拿到的content就是上传文件的地址。\n  alert(\'content\');\n}\n```\n\n总结：\n\n1. 上传文件，推荐使用伪造的。\n2. 上传数据，推荐有限使用jQuery，而且可以打包整体发送过去。如果不允许使用jQuery可以使用XMLHttpRequest。\n3. 不要被好看的上传按钮所迷惑，好看的上传按钮就是一个定位，然后把input框透明度设置为0而已。这样点击好看的上传按钮其实就是点击这个input框上传。","timestamp":1540005876713},{"name":"02-伪造ajax.md","path":"05-Frontend/05-Ajax/02-伪造ajax.md","content":"# 伪造的ajax\n\n> 从iframe标签说起：iframe标签可以伪造出局部刷新的效果。可以开辟一个类似向后台提交的通道。不刷新，发送HTTP请求。`<form>`标签可以把input的数据打包，因此这俩结合起来也可以实现不刷新向后台提交数据的功能。iframe相当于又嵌套了一个页面。\n\n```html\n# 这样就可以在后台通过request.POST拿到用户在不刷新的条件下拿到的数据\n<body>\n  <!--用于检测页面是否刷新，实际检测，伪ajax下，页面并不会刷新-->\n  <input type=\'text\' />\n  <!--使用target可以指定提交的方式，不用form原来的提交方式了。-->\n  <form method=\'post\' action=\'/fake_ajax/\' target=\"ifr\">\n    <!--这个iframe放哪其实无碍-->\n    <iframe name=\"ifr\" style=\'display:none\'></iframe>\n    <input type=\"text\" name=\"user\" />\n    <input type=\"submit\" value=\"提交\" />\n  </form>\n</body>\n```\n\n这种情况下是无法使用回调函数的，当然也没法写回调。后台返回的值会放到iframe中去。那么其实可以这样，只要iframe中有内容的时候，证明后台的值就返回来了。如果里面有内容了，是可以执行一个onload函数的。这个onload也适用于其他的标签，只要加载的时候就会执行这个onload，后台返回一次数据就会加载一次。\n\n```html\n<body>\n  <!--使用target可以指定提交的方式，不用form原来的提交方式了。-->\n  <form method=\'post\' action=\'/fake_ajax/\' target=\"ifr\">\n    <!--这个iframe放哪其实无碍-->\n    <iframe name=\"ifr\" onload=\"loadIframe();\"></iframe>\n    <input type=\"text\" name=\"user\" />\n    <input type=\"submit\" value=\"提交\" />\n  </form>\n  <script>\n    function loadIframe(){\n      alert(123);\n    }\n  </script>\n</body>\n```\n\n但是这个会出现一个问题，console会报错，html从上往下加载第一次执行到iframe的时候回进行加载，但是此时js脚本还没有读到呢，因此会报错，说loadIframe找不到。为了避免这个问题：\n\n```html\n<body>\n  <input type=\'text\' />\n  <!--使用target可以指定提交的方式，不用form原来的提交方式了。-->\n  <form id=\"f1\" method=\'post\' action=\'/fake_ajax/\' target=\"ifr\">\n    <!--这个iframe放哪其实无碍-->\n    <iframe name=\"ifr\"  id=\'ifr\' style=\'display:none\'></iframe>\n    <input type=\"text\" name=\"user\" />\n    <a onclick=\"submitForm();\">提交</a>\n  </form>\n  <script>\n    # 通过js代码提交表单，可以在提交的时候再绑定事件。\n    function submitForm(){\n      # 我直接用js进行提交。\n      document.getElementById(\'f1\').submit();\n      # 在点的时候才绑定事件，第一遍读取的时候并不绑定事件。\n      document.getElementById(\'ifr\').onload=loadIframe();\n    }\n    function loadIframe(){\n      # 取iframe中的数据要用contentWindow取内容。因为iframe相当于又嵌套一个页面\n      var content = document.getElementById(\'ifr\').contentWindow.document.body.innerText;\n      alert(\'content\')\n    }\n  </script>\n</body>\n```","timestamp":1540005876713},{"name":"03-跨域Ajax.md","path":"05-Frontend/05-Ajax/03-跨域Ajax.md","content":"# 跨域的Ajax JSONP\n\n>JSONP（json with padding）是一种技巧和一种技术，或者叫一种访问方式。\n>\n>同源策略参考：http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\n>\n>https://www.cnblogs.com/rockmadman/p/6836834.html\n\n## 跨域的问题\n\n- 域：域名\n- 跨域请求（访问）：一个域名下的文件请求另外一个域名下的资源就产生了跨域。\n\nAjax存在：访问自己域名下的内容是没问题的，但是访问别的域名的请求就会存在被阻止的问题。浏览器会阻挡下来，ajax的回调函数不会执行的。如果去调用的话会出现如下的一个报错：\n\n```javascript\nNo \'Access-Control-Allow-Origin\' header is present on the requested resource.\n```\n\n应该如何去理解这个问题呢，相当于服务器设置的一个访问白名单，如果不在这个白名单的话是不允许访问的。\n\n浏览器：同源策略，浏览器遵循同源策略。从浏览器向别的网址发请求会被浏览器组织掉。请求会发过去，数据也会回来，但是被浏览器阻挡，数据拿不到的。相当于数据能发出去但是回不来。\n\n解决跨域问题的方案：\n\n- 服务端代理：服务端的一个文件去请求资源获得结果保存，然后再去访问当前域名下这个结果。\n- Flash：服务端存在一个跨域xml文件保存了能够去访问它的域名，如果这个域名存在，允许访问，如果不存在，那就拒绝。比如qq要去访问百度，那么在百度下面会有一个xml文件保存了qq域名。\n- JSONP\n\nJSONP可以解决上面的问题：\n\n> 核心：\n>\n> 1. script标签\n> 2. 用script标签加载资源是没有跨域问题的\n> 3. ​\n\nJSONP可以绕过同源策略，去把数据拿回来。浏览器不是针对所有都有同源策略的限制，允许带有src属性的标签是允许跨域的。比如js，jquery我们可以用网络的资源，jquery cdn。针对这种请求是没有做同源策略限制的。因此就可以钻这个空子。\n\n在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数利用这个参数做一些事情，然后需要的时候通过script标签加载对应远程文件资源，当远程文件资源被加载进来的时候就会去执行我们前面定义好的函数，并且把数据当做这个函数的参数传入进去。\n\n```javascript\n# JSON with padding 把json内容填充进来使用\n```\n\n\n\n\n\n```html\n# 在页面上创建一个标签，这样就不会有同源策略的限制而且能发送请求。\n# 1、发送端：把数据拼接成一个srcipt代码，把script代码放到html代码中。\n<script src=\'http://www.baidu.com\'>\n</script>\n\n# 2、如果返回的内容恰巧是：\"func(123123)\"\n\n<a onclick=\"SendMSg();\">发送</a>\n<script>\n  function SendMsg(){\n    # 动态的创建标签进行加载，而不是预先加载。控制执行的过程，实现按需加载。\n    var tag = document.createElement(\'script\')\n    tag.src = \'http://www.baidu.com\';\n    # 在头部加一个script代码，访问网站的返回值就被读到内存了。\n    document.head.appendChild(\'tag\');\n  }\n</script>\n```\n\n双方有约定，和远程约定好共同遵循规则。一个约定好的测试地址如下：\n\n`http://www.jxntv.cn/data/jmd-jxtv2.html?callback=list&_=1454376870403`\n\n\n\n开发需求：向其他网站发送http请求\n\n- 浏览器直接发送请求，需要考虑同源策略。\n\n\n- 把请求发给服务端，让本地服务端去请求然后再返给本地服务器，此时就不会有同源策略，因为不是浏览器。\n\n```javascript\nfunction getUser(){\n  var tag = document.createElement(\'script\');\n  # 传递参数传递一个funcname\n  tag.src = \"http://xxx:8881/users/?funcname=bbb\"\n  document.head.appendChild(tag);\n}\n\n#\nfunction bbb(arg){\n  console.log(arg)\n}\n\n# 后端数据\ndef users(request):\n    v = request.GET.get(\'funcname\')\n    user_list = [\'aaa\',\'vvv\',\'bbb\']\n    user_list_str = json.dumps(user_list)\n    temp = \"%s(%s)\" % (v,user_list_str,)\n    return HttpResponse(temp)\n```\n\njs中尽量少用全局变量，因此为了避免这个问题使用callback回调函数，而不是使用返回全局变量。\n\nJSONP的要求：\n\n- 客户端和服务端要达成一致。或者对返回的数据进行数据分析然后采取相应的方式进行处理\n- 在客户端的URL中要加一个?funcname=xxxx\n- 在客户端要有一个和funcname同名的函数\n- 服务端要获取funcname\n- 返回funcname(args)\n\n一般情况下funcname叫callback，其实就是回调函数。\n\n不过上面这些东西Jquery有现成的。\n\n```javascript\nfunctiuon getUsers(){\n  # 默认使用XMLHttpRequest，如果指定dataType为JSONP那么内部就会\n  # 使用JSONP来进行发送\n  # jquery内部会在触发以后添加一个script标签，然后又给你删掉了\n  $.ajax({\n    url: \'xxxxxx\',\n    type:\'GET\',\n    dataType: \'JSONP\',\n    # 下面这俩参数相当于  xxxx/?callback=list，一个对应前面的一个对应后面的。\n    jsonp: \'callback\',\n    jsonpCallback: \'list\'\n  })\n}\n\nfunction bbb(arg){\n  console.log(arg)\n}\n```\n\nJSONP只能发get请求，因此jquery中的ajax不写type也是可以的。\n\n使用：\n\n- 动态创建script标签然后删除\n- Jquery去做\n\n使用JSONP的时候：\n\n- 只能发get请求，不能发POST，即使写了POST，内部JSONP还是通过get传递。\n- 客户端和服务端相互约定好。\n\nJSONP在哪一种语言都有\n\n额外的在响应头中加点值就可以让浏览器忽略同源策略：cors\n\n```javascript\nfunction getUsers(){\n  $.ajax({\n    url:\'xxxxx/new_users\',\n    type:\'GET\',\n    success:function(arg){\n      console.log(arg);\n    }\n  })\n}\n\ndef new_users(request):\n  user_list = [1,2,3]\n  user_list_str = json.dumps(user_list)\n  obj = HttpResponse(user_list_str)\n  # 跨站资源共享\n  # 允许所有人访问：\n  # obj[\'Access-Control-Allow-Origin\'] = \"*\"\n  obj[\'Access-Control-Allow-Origin\'] = \"访问源地址，表示允许来源拿数据\"\n  return obj\n```\n\n简单请求就是发过来加个响应头，如果是内部（复杂）请求，会发两次请求，有一个预检的过程。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-27/24003776.jpg)\n\n如何区分复杂请求和简单请求，见博客。\n\n\n\n\n\n\n\n\n\n伪造Ajax：\n\n- iframe+form(target=\'xx\')\n- JS:document.getElementById(\'f1\').submit()\n\n原生Ajax:\n\n- XMLHttpRequest对象\n  - POST请求时注意请求头：Content-type，如果不加的话Request.POST没有，在Request.Body里，POST请求会根据content-type去判断是否从request.body中取值并解析。\n- Jquery Ajax\n\n\n\nInterview\n\n- python基础\n- 数据库一类的，根据需求做数据库设计，数据库性能\n- 前端，作用域，词法分析，this，面向对象，JSONP\n\n\n\n**2、跨浏览器支持**\n\n- XmlHttpRequest\n  IE7+, Firefox, Chrome, Opera, etc.\n- ActiveXObject(\"Microsoft.XMLHTTP\")\n  IE6, IE5\n\n```javascript\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n\n    <h1>XMLHttpRequest - Ajax请求</h1>\n    <input type=\"button\" onclick=\"XmlGetRequest();\" value=\"Get发送请求\" />\n    <input type=\"button\" onclick=\"XmlPostRequest();\" value=\"Post发送请求\" />\n\n    <script src=\"/statics/jquery-1.12.4.js\"></script>\n    <script type=\"text/javascript\">\n\n        function GetXHR(){\n            var xhr = null;\n            if(XMLHttpRequest){\n                xhr = new XMLHttpRequest();\n            }else{\n                xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n            return xhr;\n\n        }\n\n        function XhrPostRequest(){\n            var xhr = GetXHR();\n            // 定义回调函数\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    // 已经接收到全部响应数据，执行以下操作\n                    var data = xhr.responseText;\n                    console.log(data);\n                }\n            };\n            // 指定连接方式和地址----文件方式\n            xhr.open(\'POST\', \"/test/\", true);\n            // 设置请求头\n            xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded; charset-UTF-8\');\n            // 发送请求\n            xhr.send(\'n1=1;n2=2;\');\n        }\n\n        function XhrGetRequest(){\n            var xhr = GetXHR();\n            // 定义回调函数\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState == 4){\n                    // 已经接收到全部响应数据，执行以下操作\n                    var data = xhr.responseText;\n                    console.log(data);\n                }\n            };\n            // 指定连接方式和地址----文件方式\n            xhr.open(\'get\', \"/test/\", true);\n            // 发送请求\n            xhr.send();\n        }\n\n    </script>\n\n</body>\n</html>\n```\n\n\n\n\n\n使用原生的ajax：\n\n```javascript\n\n```\n\n\n\n\n\n不同的数据接口返回的数据使用不同的方式去处理。\n\n\n\n豆瓣Ajax请求\n\n```\napi.douban.com/book/subjects?q=javascript&alt=xd&cb=fn1\n```\n\nJSONP豆瓣实例\n\n```javascript\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>无标题文档</title>\n<style>\n#q {width: 300px; height: 30px; padding: 5px; border:1px solid #f90; font-size: 16px;}\ndl {border-bottom: 1px dotted #000;}\ndt {font-weight: bold;}\n</style>\n<script>\nfunction fn1(data) {\n\n\tvar oMsg = document.getElementById(\'msg\');\n\tvar oList = document.getElementById(\'list\');\n\t\n\tconsole.log(data);\n\t\n\toMsg.innerHTML = data.title.$t + \' : \' + data[\'opensearch:totalResults\'].$t;\n\t\n\tvar aEntry = data.entry;\n\tvar html = \'\';\n\tfor (var i=0; i<aEntry.length; i++) {\n\t\t\n\t\thtml += \'<dl><dt>\'+ aEntry[i].title.$t +\'</dt><dd><img src=\"\'+ aEntry[i].link[2][\'@href\'] +\'\" /></dd></dl>\';\n\t\t\n\t}\n\t\n\toList.innerHTML = html;\n\t\n}\nwindow.onload = function() {\n\t\n\tvar oQ = document.getElementById(\'q\');\n\tvar oBtn = document.getElementById(\'btn\');\n\tvar oMsg = document.getElementById(\'msg\');\n\tvar oList = document.getElementById(\'list\');\n\t\n\toBtn.onclick = function() {\n\n\t\tif ( oQ.value != \'\' ) {\n\t\t\tvar oScript = document.createElement(\'script\');\n\t\t\toScript.src = \'http://api.douban.com/book/subjects?q=\'+oQ.value+\'&alt=xd&callback=fn1\';\n\t\t\tdocument.body.appendChild(oScript);\n\t\t}\n\t\t\n\t\t//http://api.douban.com/book/subjects?q=\'+oQ.value+\'&alt=xd&callback=fn1&start-index=(当前页*每页显示的条数)&max-results=10(每页显示的条数)\n\t\t\n\t}\n\t\n}\n</script>\n</head>\n\n<body>\n\thttp://www.douban.com/service/apidoc/reference/\n\t<input type=\"text\" id=\"q\" /><input type=\"button\" id=\"btn\" value=\"搜索\" />\n    <p id=\"msg\"></p>\n    <hr />\n\t<div id=\"list\"></div>\n</body>\n</html>\n```\n\n\n\n","timestamp":1540005876713},{"name":"01-响应式介绍和BootStrap.md","path":"05-Frontend/08-响应式前段实战/01-响应式介绍和BootStrap.md","content":"**meta标签**\n\n```html\n<!--设置字符集-->\n<meta charset=\"utf-8\">\n<!--启用最新的IE引擎进行页面的渲染-->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<!--设置移动设备时候需要的视口-->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n```\n\n**媒询**\n\n> - css3\n> - 根据当前媒体设备（媒体特征），显示媒询内的对应样式。\n\n利用媒询选择加载样式\n\n```css\n@media\n    - 在对应的媒体下，媒询中的样式才会被解析\n```\n\n媒体的类型：\n\n- all，所有的类型的设备\n- screen，彩屏设备，电脑啊，手机啊都算\n- braille，盲文触觉设备，基本不用\n- handheld，手持设备，基本不用\n- print，打印预览\n- ……………………\n\n按照我们写css的标准：同一个样式写在后面的会替换掉前面的，\n\n媒体的特征：比如width，device-width，min-width；\n\n```css\n@media screen and (min-width: 800px){\n    /*在彩屏设备并且宽度大于等于800的时候符合条件*/\n    #box{\n        background: pink;\n    }\n}\n\n# 这里的这个and叫做关键词，我们可以用的关键词有\n- and：用于连接设备和设备特征，这是最常用的。\n- only：只有\n- not：除……之外\n```\n\n**布局容器&流体容器**\n\n```css\n/*.container在最大屏幕下是一个1170px的尺寸，这个是从大屏往小屏匹配，也可以小屏幕到大屏逐一匹配*/\n.container{\n    width: 1170px;\n    height: 500px;\n    background: #000;\n    margin:0 auto;\n}\n/*小于1200*/\n@media all and (max-width: 1199px){\n    .container{\n        width:970px;\n        background:red;\n    }\n}\n/*小于992*/\n@media all and (max-width: 991px){\n    .container{\n        width:750px;\n        background: pink;\n    }\n}\n@media all and (max-width: 768px){\n    .container{\n        width: 100%;\n        background: orange;\n    }\n}\n```\n\n**栅格系统**\n\n- 列为什么要放到行（row）里，即使不放到row里仍然可以正常使用。\n- 行必须包含在container或者container-fluid里面，以便为其赋予核实的排列和内填充\n\n**行和列**\n\n```\n可视宽度=width + border + padding\nborder-box的可视宽度就等于当前写的宽度。\n```\n\n\n\n```css\n.col-xs-1,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-10{float:left;box-sizing: border-box;}\n.col-xs-1{width:10%;}\n.col-xs-2{width:20%;}\n.col-xs-3{width:30%;}\n.col-xs-4{width:40%;}\n.col-xs-5{width:50%;}\n.col-xs-6{width:60%;}\n.col-xs-7{width:70%;}\n.col-xs-8{width:80%;}\n.col-xs-9{width:90%;}\n.col-xs-10{width:100%;}\n```\n\n\n\n## 需求\n\n### 去除默认样式\n\n#### PC端\n\n```css\n\n```\n\n#### 移动端\n\n### 响应式\n\n> 分三种屏幕+一个最小屏幕\n>\n> - xs < 768px\n> - sm >=768px\n> - md >=970px\n> - lg >=1180px\n\n### 头部\n\n- 导航栏\n- 个人信息\n  - 头像、人名\n  - 个性签名\n  - 个人信息\n  - 联系方式\n- 技能展示\n  - 标题\n  - 技能展示列表\n- 工作时光轴\n  - 标题\n  - 工作经验（无序列表）\n- 案例展示\n  - 标题\n  - 案例栏目标题\n  - 案例内容\n- 项目池\n  - 标题\n  - 项目列表\n    - 项目图片\n    - 文章\n- 底部\n  - 更新时间\n  - copyright\n\n\n\n# LESS\n\n## 编译工具\n\n- Koala：国人开发的less、sass编译工具\n- http://koala-app.com/index-zh.html\n\n```css\n# less中的注释\n/**/：这种形式的注释会被编译到css中\n//：这种形式的注释是不会被编译到css中的\n\n# less中的变量，想要声明变量的话一定要用@开头，例如：@变量名：值；\n@test_width: 300px\n.box{\n    width: @test_width;\n}\n\n# less中的混合，比如可以用在样式的重用里，在下面的例子里中，直接拿过来用就可以了。\n.border{border:solid 5px #333;}\n.box{width:100px;.border;}\n\n# 带参数的混合\n.border_02(@border_width){\n    border:solid yellow @border_width;\n}\n.test_hehehe{\n    // 注意这里写了需要参数就必须带值，否则会报错。\n    .border_02(30px)\n}\n\n# 不仅可以带参数，参数还可以有默认值\n.border_03(@border_width:30px){\n    border:solid pink @border_width;\n}\n.test_hehehe{\n    // 我这里有一个默认值，所以可以不带值进去，没变量的时候括号可以省略\n    .border_03();\n}\n\n# 匹配模式，相当于if但是不完全是。比如下面这段匹配\n.triangle(top,@width:5px,@color:#ccc){\n  border-width:@width;\n  border-color: transparent transparent @color transparent;\n}\n\n.triangle(bottom,@width:5px,@color:#ccc){\n  border-width:@width;\n  border-color: @color transparent transparent transparent;\n}\n\n.triangle(left,@width:5px,@color:#ccc){\n  border-width:@width;\n  border-color: transparent @color transparent transparent;\n}\n\n.triangle(right,@width:5px,@color:#ccc){\n  border-width:@width;\n  border-color: transparent transparent  transparent @color;\n}\n\n.triangle(@_,@width:5px,@color:#ccc){\n  width: 0;\n  height:0;\n  overflow: hidden;\n}\n\n.sanjiao{\n  .triangle(right)\n}\n\n生成的css就是下面这样的，\n.sanjiao {\n  border-width: 5px;\n  border-color: transparent transparent transparent #cccccc;\n  width: 0;\n  height: 0;\n  overflow: hidden;\n}\n它会去根据你输入的第一个判断是哪一个方向的三角，然后进行对应的编译生成响应的css文件，注意匹配到上下左右的时候同时最后一条也会匹配到，因为也满足条件，因此width和height为0px也会被编译进去。如果说你写的不是上下左右而是其他的内容的时候，就会匹配到最后一个。仅仅体现宽高和overflow。\n\n# 匹配模式的简单应用，下面的内容就可以直接进行调用了。\n.pos(r){\n    postion:relative;\n}\n.pos(a){\n    postion:absolute;\n}\n.pos(f){\n    postion:fixed;\n}\n\n# 运算\n@test_01:300px;\n.box_02{\n    // 没有强制要求后面这个20带这个px，只要里面其中带一个单位就可以了。注意变量与减号之间要有空格，否则会被ide识别成变量的一部分\n    width:(@test_01 - 20) * 20;\n    // 同样的颜色也可以进行计算，less会为你抓换成255然后-10.颜色的加减一般也要用不到。\n    color:#ccc - 10;\n}\n\n# less中的嵌套\n比如下面这样一个内容：\n.list{}\n.list li{}\n.list a{}\n.list span{}\n如果使用嵌套写的话就是：\n.list{\n    width:200px;\n    margin:0 autu;\n    list-style: none;\n    li{……一大堆样式……};\n    a{……一大堆样式……};\n    span{………………}\n}\n\n# 在控制伪类的时候，之前写的时候是这么写的，比如\n.list a{}\n.list a:hover{}\n\n# 现在可以这么来写\n.list {\n    a{\n        float:left;\n        // &代表它的上一层选择器，这里的上一层选择器其实就是a。\n        &:hover{\n            color:red;\n        }\n    }\n}\n\n# arguments变量，用的不多，@arguments包含了所有传递进来的参数，如果你不想单独处理每一个参数的话你就可以这样写。\n.border_arg(@w:30px,@c:red,@xx:solid){\n    border:@arguments;        \n}\n然后进行调用：\n.test_arguments{\n    .border_arg()\n}\n最后生成的css结果就是这样的：\n.test_arguments {\n  border: 30px #ff0000 solid;\n}\n\n# 避免编译，!important以及总结\n有的时候我们需要输出一些不正确的css语法或者使用一些less不认识的专有语法，要输出这样的值我们可以在字符串前加一个\"~\"，就可以让less给原封不动的输出来。\n例如：width:~\"calc(300px-30px)\";\n\n# 混合模式可以添加!important，会被编译到css文件中去。\n.test_important{\n    .border_radius() !important;\n}\n```\n\n","timestamp":1540005876713}]