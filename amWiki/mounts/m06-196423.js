if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m06']=[{"name":"01-Web框架的本质.md","path":"06-Django/01-Web框架的本质.md","content":"数据库\n\n1. 安装\n2. 创建用户+授权\n3. 连接\n   - 数据库：终端创建数据库（字符编码）\n   - 数据表：终端，orm，pymysql（create……，engine innodb，charset）\n   - 数据行：增删改查\n\n\n\n问题：简述ORM原理\n\n浏览器的请求头：\n\n```html\nGET / HTTP/1.1\nHost: localhost:10020\nConnection: keep-alive\nCache-Control: max-age=0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36\\\nUpgrade-Insecure-Requests: 1\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8,en;q=0.7,zh-TW;q=0.6\nCookie: Pycharm-2f1c850a=df26fed3-d2a7-4be6-bfa1-4dc7a4831b46\n```\n\n服务器会返回对应的响应头和响应体。\n\n\n\n小结：\n\n```\n1、HTTP 短连接，无状态\n2、浏览器 socket客户端    网站 socket服务端\n3、自己写网站\n   a：socket服务端\n   b：根据URL不同返回不同的内容，路由系统：URL -- 函数\n   c：字符串返回给用户，末班引擎渲染，html充当模板(特殊自符)，自己创造任意数据。\n4、web框架：\n   框架种类：\n     - a,b,c                 ----- tornado\n     - 第三方的a,b,c          ------ wsgiref -> Django\n     - 第三方的a,b,第三方的c   ------ Flask\n   分类：\n     - Django框架(包含n多的web工具，是一个大家伙)\n     - 其他\n```\n\n","timestamp":1531448340028},{"name":"02-Django开篇.md","path":"06-Django/02-Django开篇.md","content":"# Django\n\n## 1、初识Django\n\n### 1.1、安装\n\n```shell\npip3 install django\n```\n\n在终端新建一个django项目(记得跳转到指定的目录中去创建)：\n\n```bash\ndjango-admin startproject myfirstsite\n```\n\n目录结构：\n\n```bash\n➜  myfirstsite git:(master) ✗ > tree ./\n./\n├── manage.py        # 管理网站的使用，对当前Django程序的所有操作都可以基于 python manage.py runserver……等等来进行操作\n└── myfirstsite\n    ├── __init__.py\n    ├── settings.py  # 配置文件\n    ├── urls.py      # 路由系统，写的是url和函数的对应关系\n    └── wsgi.py      # web socket模块，用于定义Django用什么socket来实现。\n```\n\n启动django：\n\n```bash\n# 切换到项目目录，不加地址的话，默认监听的是本地的8000端口\npython3 manage.py runserver \n```\n\n**附：Pycharm创建Django项目**\n\n点击File→New Project→找到django→起名字→选择对应的Interrupter→点击确定：结束~\n\n### 1.2、第一个Django请求\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.shortcuts import HttpResponse\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容，在这里return的内容需要按照django的规则，\n    直接返回字符串的login或者是字节串都是不行的，如果想要原原本本的返回写的内容\n    需要from django.shortcuts import HttpResponse才可以\n    这里的参数request是一个对象。\n    :param request:\n    :return:\n    \"\"\"\n    # HttpResponse只加字符串\n    return HttpResponse(\'login\')\n\n\nurlpatterns = [\n    \"\"\"\n    做路由内容的匹配，要按照人家django的规则，注意后面调用的是函数的名字，记住不要加小括号\n    \"\"\"\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\n### 1.3、Django静态文件以及模板配置\n\n1.2小节是直接使用HttpResponse返回一个字符串，那么如果想要返回一个模板内容该怎么办呢？首先在template文件夹下新建一个html文件，然后要想django可以访问到这个模板文件的话还需要引入render模块：\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.shortcuts import HttpResponse, render\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容\n    :param request:\n    :return:\n    \"\"\"\n    return render(request, \'login.html\')\n\n\nurlpatterns = [\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\nrender需要两个参数，一个是request，另外一个就是模板文件，你在打的时候都可以给你提示，因为系统默认配置的会去templates文件夹下去找这个模板，如果想要换其他的模板的话可以在django的配置文件settings.py中进行配置：\n\n```python\nTEMPLATES = [\n    {\n        \'BACKEND\': \'django.template.backends.django.DjangoTemplates\',\n        \'DIRS\': [os.path.join(BASE_DIR, \'templates\')]\n        ,\n        \'APP_DIRS\': True,\n        \'OPTIONS\': {\n            \'context_processors\': [\n                \'django.template.context_processors.debug\',\n                \'django.template.context_processors.request\',\n                \'django.contrib.auth.context_processors.auth\',\n                \'django.contrib.messages.context_processors.messages\',\n            ],\n        },\n    },\n]\n```\n\n其实render的本质还是调用了HTTPResponse：\n\n```python\ndef render(request, template_name, context=None, content_type=None, status=None, using=None):\n    \"\"\"\n    Return a HttpResponse whose content is filled with the result of calling\n    django.template.loader.render_to_string() with the passed arguments.\n    \"\"\"\n    content = loader.render_to_string(template_name, context, request, using=using)\n    return HttpResponse(content, content_type, status)\n```\n\n那么静态文件应该放在那里呢？比如我们在项目的根目录下新建一个static文件夹。静态文件无外乎css，js和img图片文件夹：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-8/70769756.jpg)\n\n新建一个样式文件，然后渲染刚才的那个login.html\n\n```html\n<link rel=\"stylesheet\" href=\"/static/css/style.css\">\n```\n\n结果就会发现html并没有发生更改，其实主要原因是这个时候，样式的调用也是通过django去调用的。因此这个静态文件的目录也是需要配置的，找到settings.py文件，找到最后一行：\n\n```python\nSTATIC_URL = \'/static/\'\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \'static\'),\n)\n```\n\n我们要添加的内容是`STATICFILES_DIRS`，注意，这里是一个元组，因此一个元素后面必须要跟逗号，不然会被默认为一个元素，肯定会报错的。\n\n其实这里`STATIC_URL`只不过是一个前缀而已，当调用static下的css的时候那么它会去找`STATICFILES_DIRS`中的路径，你这个路径是啥都行，只要添加到对应的路径下，每当访问static前缀的时候就会去找这个路径。\n\n### 1.4、Django创建程序步骤\n\n- 创建project，pycharm还是terminal都可以。\n\n- 配置：\n\n  - 模板路径：给render用\n  - 静态文件路径：css，js，img\n\n- 额外配置：\n\n  ```python\n  # 暂时先将MIDDLEWARE中的csrf注释掉。\n  MIDDLEWARE = [\n      \'django.middleware.security.SecurityMiddleware\',\n      \'django.contrib.sessions.middleware.SessionMiddleware\',\n      \'django.middleware.common.CommonMiddleware\',\n      # \'django.middleware.csrf.CsrfViewMiddleware\',\n      \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n      \'django.contrib.messages.middleware.MessageMiddleware\',\n      \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n  ]\n  ```\n\n### 1.5、用户登录示例\n\n模板界面：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <link rel=\"stylesheet\" href=\"/static/css/style.css\">\n    <title>login_test</title>\n</head>\n<body>\n    <form method=\"POST\" action=\"\">\n        <h1>登录测试</h1>\n        <!--这里我们用name进行pist提交，那么在服务端其实会收到一个QueryDict字典\n\t\t\t这里的username和password就是key值，我们输入的内容就是value值-->\n        <input type=\"text\" name=\"username\">\n        <input type=\"password\" name=\"password\">\n        <input type=\"submit\">\n      \t{{ msg }}\n    </form>\n</body>\n</html>\n```\n\nurl路由配置：\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\n# 引入redirect用户重定向使用，其中redirect跳转第三方网站域名要写全，但是如果要跳转自己地的网站的话我们可以直接写后缀比如 \"redirect(\'/index/\')\"，它会自动去找urlpatterns进行匹配，Django会为你自动拼接.\nfrom django.shortcuts import HttpResponse, render, redirect\n\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容\n    :param request:\n    :return:\n    \"\"\"\n    # 通过request.method来获取用户请求的方式\n    if request.method == \'GET\':\n        return render(request, \'login.html\')\n    else:\n        # 用户post提交的数据（请求体的内容），那么request.GET就是get请求的数据。获取到的\n        # 是一个字典内容，比如xx/?p=123，结果就为{\'p\': \'123\'}\n        # 这里其实可以使用request.POST[\'username\']这样去取数据，但是如果说name不是这个\n        # 那么就会报错，因此我们可以使用get方法，如果name不是这个的话不会报错，会返回空\n        user = request.POST.get(\'username\')\n        password = request.POST.get(\'password\')\n        if user == \'root\' and password == \'123123\':\n            print(\'登录成功\')\n            return redirect(\'http://bbs.dcgamer.top\')\n        else:\n            print(\'====验证失败====\')\n            # render可以接受的第三个参数是一个字典，Django的模板引擎会根据你传递的\n            # 内容替换对应的特殊字符，比如下面的字典的key是msg，它就会替换模板中的\n            # {{ msg }}字段的值。\n            return render(request, \'login.html\', {\'msg\': \'用户名或密码错误\'})\n\n\nurlpatterns = [\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\n### 1.6、小结\n\n- 发get请求的时候，只有request.GET有值\n\n- 发post请求的时候，request.GET和request.POST是都可能有值的，因为你在发POST请求的时候，你请求的内容是可以带参数的。比如：\n\n  ```html\n  <form method=\'POST\' action=\"/login/?p=123\"></form>\n  ```\n\n## 2、学员管理系统初步\n\n### 2.1、单表操作（增删改查）\n\n表结构设计\n\n```mysql\n# 班级表\nid   title\n1    全栈4期\n2    全栈5期\n\n# 学生表\nid   name    班级id(FK)\n1    user1   1\n\n# 老师表(老师和班级是多对多的关系)\nid   name\n1    林海峰\n2    林狗\n3    袁日天\n\n# 老师和班级关系表\nid   老师id   班级id\n1       1       1\n2       1       2\n3       2       2\n\n########表结构设计##########\ncreate database django1;\n\ncreate table class(\n  id int unsigned not null primary key auto_increment,\n  title varchar(255) not null\n) engine=innodb charset=utf8;\n\ncreate table student(\n  id int unsigned not null primary key auto_increment,\n  name varchar(255) not null,\n  class_id int unsigned not null,\n  constraint `fk_class_id` foreign key (`class_id`) references class(`id`)\n) engine=innodb charset=utf8;\n\ncreate table teacher(\n  id int unsigned not null primary key auto_increment,\n  name varchar(255) not null\n) engine=innodb charset=utf8;\n\ncreate table teacher2class(\n  id int unsigned not null primary key auto_increment,\n  teacher_id int unsigned not null,\n  class_id int unsigned not null,\n  constraint `fk_teacher_id` foreign key (`teacher_id`) references teacher(`id`),\n  constraint `fk_cls_id` foreign key (`class_id`) references class(`id`)\n) engine=innodb charset=utf8;\n```\n\n### 2.2、一对多操作（增删改查）\n\n\n\n\n\n#### 基于ajax创建班级\n\n**模态对话框**（一般和ajax进行绑定）\n\n主要用于以下（比如登录）：\n\n> - 少量的输入框\n> - 数据少\n>\n> 相比较新URL的方式，新URL可以承载更多的操作已经更大的数据量。\n\n默认submit提交的时候会导致页面的刷新，这个属于form表单提交时的一个特性。这个是不受后台返回内容所限制的，不管你后台是return一个render重新渲染还是return一个httpresponse亦或是return一个redirect都不会影响。\n\n\n\n```javascript\n引入jquery：\n$.ajax({\n  url: \'要提交的地址\'，\n  type: \'POST\', // post或者是get这里指的是提交的方式\n  data: {\'k1\':\'v1\', \'k2\':\'v2\' ……}, // 这里指的是要提交的数据\n  success: function(data){\n      //当服务器处理完成并返回数据后会自动调用的一个函数。\n      //data表示返回的数据\n}\n \n})\n```\n\n使用Ajax删除班级，使用Ajax编辑班级。\n\n\n\n\n\n```javascript\n# 当页面框架加载完成后执行\n$(function(){\n  balabala……\n})\n\n# jquery阻止默认事件的发生\njquery绑定事件直接在函数中返回一个false就可以阻止事件的默认发生了，比如：\n$(function(){\n  $(\'#testmodel\').click(function(){\n    alert(123);\n    return false;\n  });\n});\n\n```\n\n模板的额外使用：\n\n```django\n{% if item.id in class_id %}\n\n{% else %}\n\n{% endif %}\n```\n\n\n\n### 2.3、多对多操作（增删改查）\n\n多对多的设计：\n\n\n\n\n\n\n\n=============\n\n响应头中如果有location的话，浏览器会直接再次发起请求。\n\n当a标签有默认跳转功能和其他事件比如click事件的时候会优先发生其他的附加事件，最后再执行跳转事件，如果想让默认事件不执行，可以让附加事件return一个函数，函数再renturn一个false默认事件就不会执行了，如果想让这个事件执行的话return true就可以了。\n\n\n\nplaceholder属性\n\nselect标签里的multiple属性，可以实现select标签的多选，size设置显示的范围大小。\n\npymysql中的lastrowid，在提交的时候还要把自增id拿到，lastrow_id要在commit以后才能拿到。\n\n取前端返回的多个数据可以使用\n\n```django\nrequest.POST.getlist(\'select标签的name\')\n```\n\n\n\n数据库类操作：\n\n```python\nclass DB():\n    \n    \n    def __init__(self):\n        # 从配置文件把配置读取出来\n        self.connect()\n    \n    def connect(self):\n        self.conn = pymysql.connect(xxxx)\n        self.cursor = self.conn.cursor(XXX)\n        \n    def get_list(self, sql, args):\n        self.cusor.excude(sql,args)\n        result = self.cursor.fethall()\n        return result\n    \n    def get_one(self, sql, args):\n        self.cursor.excute(sql, args)\n        result = self.cursor.fetchone()\n        return result\n    \n    def modify(self, sql, args):\n        # 这是链接一次提交多次，如果多次操作的每一次提交也是耗时\n        self.cursor.excute(sql, args)\n        self.conn.commit()\n        \n    def create(self, sql, args):\n        self.cursor.excute(sql, args)\n        self.conn.commit()\n        return self.cursor.lastrowid\n    \n    def multuple_modify(self, sql, args):\n        # 链接一次，提交一次，args是多个元组，我们要去构造。\n        self.cursor.excutemany(sql, args)\n        self.conn.commit()\n        \n    def close(self):\n        self.conn.close()\n        self.cursor.close()\n        \n        \n\n```\n\n\n\n表格的左右移动\n\n\n\n新URL方式\n\n\n\n通过ajax获取select列表的option所有的选项，在点击弹出框的时候通过ajax去服务器去取值。\n\n```javascript\n# 加载框显示的时机：用户一点弹出框增加的时候，先把透明底层和这个加载层显示出来，最后等数据加载完成了，也就是加载数据的这一块代码结束了，然后再把这个loading遮罩层给干掉，加上hide的class\n\n$.each(arg, function(i, row){\n  var tag = document.createElement(\'option\')\n  tag.innerHTML = row.title;\n  tag.setAttribute(\'value\', row.id);\n  $(\'#classIds\').append(tag);\n})\n// 加载框，加载完了以后先把loading的显示层隐藏掉，添加的框显示出来\n$(\'#loading\').addClass(\'hide\');\n$(\'#addModel\').removeClass(\'hide\');\n```\n\n注意：\n\n```javascript\n# 如果ajax里面传递的json有列表，如果要服务端显示为列表要加上traditional:true\n# 因为ajax会给你做特殊处理，如果加上traditional就不会做特殊处理，返回的就是列表，只支持列表，并不支持字典。\n$.ajax({\n  url: \'要提交的地址\'，\n  type: \'POST\', // post或者是get这里指的是提交的方式\n  data: {\'k1\':\'v1\', \'k2\':\'v2\' ……}, // 这里指的是要提交的数据\n  traditional: true,\n  success: function(data){\n      //当服务器处理完成并返回数据后会自动调用的一个函数。\n      //data表示返回的数据\n}\n```\n\n如何判断某个元素是不是在js的某个列表中\n\n```javascript\nv = [11,22,33]\nv.indexOf(22)\n# 如果有的话返回索引，如果没有的话返回-1\n```\n\n\n\nHTTP请求的生命周期\n\n请求头→提取URL→路由关系匹配→函数（模板+数据渲染）→返回用户（响应头+响应体）\n\n模版的渲染工作发生在哪一端？\n\n在服务端，浏览器拿到的一定是渲染完毕后的结果。\n\n默认从a标签跳转过去的都是get请求。\n\n\n\n## 初识BootStrap & fontawesome(图标库)\n\n使用bootstrap3\n\n下载用于生产环境的\n\n一个bootstrap.css，另外一个就是bootstrap.min.css，第二个是第一个的压缩版，但是功能是一模一样的。这样在调试的时候可以看，但是生产的时候要用压缩版。\n\nfonts是字体文件，特殊的图标文件也在里面。\n\n在static下新建一个plugin目录把这个放到里面去\n\n如何引用：\n\n```html\n<link ref=\'stylesheet\' href=\'/static/plugins/bootstrap……\'>\n```\n\n组件里有图标\n\nBootStrap：一个包含CSS和JS的样式库\n\n- 样式\n- 响应式：会根据用户的访问环境显示出不同的结构，比如手机端和pc端访问\n\n```css\n/*当小于等于700px的宽度的时候会执行@media里面的内容*/\n@media (max-width:700px){\n  .pg_header{\n   \tstyle1;\n    style2;\n  }\n}\n\n这样的可以添加多个形成一个多层改变的过程\n```\n\n组件：导航条\n\n响应式的代表一类是导航条，\n\nbootstrap总共给你把页面分成了12格子（bootstrap的栅格系统）\n\ncol-md col-lg col-xs col-sm\n\n\n\n全局样式里有一个：目的是是否允许移动设备进行缩放\n\n在 Bootstrap 2 中，我们对框架中的某些关键部分增加了对移动设备友好的样式。而在 Bootstrap 3 中，我们重写了整个框架，使其一开始就是对移动设备友好的。这次不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。也就是说，**Bootstrap 是移动设备优先的**。针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。\n\n为了确保适当的绘制和触屏缩放，需要在 `<head>` 之中**添加 viewport 元数据标签**。\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n```\n\n在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 `user-scalable=no` 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n```\n\n\n\n\n\n关于后台管理的布局，一般标准的就是那种布局，一般不去做响应式，不过也可以做响应式。但是使用bootstrap做响应式定制性不高。\n\n创建用户表，使用用户登录\n\ni标签\n\nhover是可以实现级联的：\n\n```css\n.pg-header .avatar:hover .user-infor{\n  xxxxx\n}\n```\n\n\n\nposition:absolute一会出现高度塌陷\n\n\n\n路径导航：\n\n\n\nDjango的程序目录介绍\n\n```python\n# 在对应的项目目录通过manage.py直接创建小的小项目，简单来说一个平台需要很多功能，但是功能之间又没有太大的联系。\npython manage.py startapp app01\n\n\n# 通过pycharm也是可以创建的\n在创建project的时候，在more settings下直接写一个application name就可以在创建project的同时会创建一个app，但是我们也可以在pycharm的terminal终端通过命令去创建，创建的目录里面其实会自带已给view\n\n一般业务代码放在对应的app文件夹里；\n\napp中的migrations是和数据库相关的。\nadmin是内部存在的后台管理，xxxx/admin，默认的账号和密码是：\napps是当前app的配置文件\nmodels是django的orm的类，和数据库进行沟通的\ntests是进行单元测试的。\nviews就是和之前一样的页面的，views不一定就是一个单文件，有时候逻辑特别多的时候写到一个py文件不是很好，我们可以把这个views.py删掉换成一个views文件夹，然后里面针对业务分成多个py文件。\n```\n\n## 路由系统\n\n### 动态路由\n\nurl->函数\n\n- 一一对应：/login/ → def login\n- /add-user/(+d)\n\n\n\nSEO会把get传参的内容页面的权重变低，因为爬虫会认为get传参的是经常变的，因此不经常变动的优先级会较高一些。\n\n```python\n# 正则表达式\nhttp://127.0.0.1/edit/ffff\nurl(r\'^edit/(\\w+)\', view.edit),\nurl(r\'^edit/(\\w+)/(\\w+)\', view.edit), ## 函数要接收两个参数，按照顺序接收\n# 这个并不是什么html文件，只是一个正则模版，这个叫伪静态\nurl(r\'^edit/(\\w+).html$\', view.edit),\ndef edit(requst, a1):\n    print(a1)\n    return xxxx\n\nurl(r\'^edit/(?P<a1>\\w+)/(?P<a2>\\w+)/\')\n这样就可以按照对应的标签去匹配了，a1就是第一个，a2就是第二个。这个可以不按照顺序去接收。这个就是按照参数名称进行存放的方式。\n\n如果加名字的和不加名字的共存那是如何接收的？\n答：这样就会直接报错，这个函数她会不知道如何接收，因此用法要统一，要不就关键字要不就位置的。\n\n函数在接收参数的时候可以使用*args和**kwargs\n\n推荐使用终止符号\nurl(r\'^edit$\'， view.edit)\n```\n\n什么是伪静态\n\n```\n\n```\n\n路由分发\n\n```python\nfrom django.conf.urls import include\n\n# 先从主的转到对应的app下的url路由关系，然后根据引入的urls再进行路由匹配\nurl(r\'^app01\', include(\'app01.urls\'))\n# 对应的访问结果应该就是这样的，路由分发只匹配到app01，后面的内容不会进行匹配\nhttp://128.0.0.1/app01/xxx/xxx.html\n\n转到具体的urls就不会看从app01开始往前的内容了。\n\n经过如上的操作，路由被分成了两级，project的入口成为了路由分发器\n\n啥没写可以跳转到一个默认的页面，比如跳转到主页\nurl(r\'^\', views.index)\n```\n\n路由系统之别名反向生成URL\n\n```python\nfrom django.urls import reverse\nurl(r\'^edit/\', view.edit, name=\'n1\'),  # 起一个别名\n# 可用于日后根据别名反生成url\nv = reverse(\'n1\')   # \'/edit/\'\n\n# 指定反向生成的内容\nurl(r\'^edit/(\\d+)\', view.edit, name=\'n1\')\nv = reverse(\'n1\', args=(1,))  # \'/edit/1/\'\n\n# 指定反向生成的内容(dict)\nurl(r\'^edit/(?P<a1>\\d+)\', view.edit, name=\'n1\')\nv = reverse(\'n1\', kwargs={\'a1\':\'111\'}  # \'/edit/111/\'\n            \n# 有了这个别名以后，form表单的action以后就可以这样写了，也可以根据名称反生成url\n<form method=\'POST\' action=\'{% url \"m1\" %}\'></form>\n            \n# 对应的跳转链接也可以通过反向链接实现，这是不使用python而是使用html模版循环的方法\n{% for i in list %}\n# 可以按照对应的值生成URL<a href=\"{% url \'n1\' i.1,i.2,i.3…… %}\">\n# 结果： <a href=\'/edit/aaa/bbb/ccc/ddd\'>\n<a href=\"{% url \'n2\' i %}\">xxxx\n{% endfor %}\n            \n\n# 在web中分全权限显示页面\n每个人的权限不一样，保存的权限跳转链接也不一样。\n            \n假如说可以访问的url很长，那么在数据库也要存储很长，如果说有一个别名的话就可以使用别名存储到数据库就可以了。通过别名就可以找到相对的url了。这个别名只在django里面有，在其他的系统里并不存在。当然不使用别名，完全使用url也是可以的。在crm权限管理中会用到，稍后说。\n```\n\n## CBV & FBV（之前用的）\n\n CBV：\n\n在视图函数匹配的时候，一个url可以对应一个函数，但是同时也可以对应一个类。\n\n```python\n# Login是一个类，其中as_view()是特殊的写法\nurl(r\'^login.html$\', views.Login.as_view())\n\n# 这个类需要继承这个Views\n# 看的是类里是不是getattr GET POST利用反射获取对应的方法\nfrom django.views import View\nclass Login(View):\n    \n    def get(self, request):\n        pass\n    \n    def post(self, request):\n        pass\n    \n    def dispath(self, request, *args, **kwargs):\n        # 可以对dispatch进行重写，先把父类的功能拿过来，先执行dispatch方法，然后dispatch去执行GET或者post方法，然后拿到返回值return才行\n        # 我们可以在执行dispatch的时候对一些方法进行统一的调用，或者循环操作等等，类似一个装饰器。\n        print(\'before\')\n        obj = super(Login, self).dispatch(self, request, *args, **kwargs)\n        print(\'after\')\n        return obj\n    \nGET和POST方法执行之前还执行了一个dispatch方法，这个即使利用反射获取GET还是POST，可以在父类Views里查看\n```\n\n## Django的分页\n\n### Django内置分页\n\n```python\nmodels.Userinfo.objects.all()[0:10]\nmodels.Userinfo.objects.all()[11:20]\n\nfrom django,core paginator import Paginator, Page\nuser_list = model.UserInfor.object.all()\npaginator = Paginator(user_list, 10)\n# 这个对象可以找到以下属性\n# - per_page: 每页显示条目数量\n# - count： 数据总个数\n# - num_pages: 总页数\n# - page_range： 总页数的索引范围，比如(1,10),(1,200)\n# - page： page对象，可以指定当前显示第几页\nposts = paginator.page(2)\n这个posts有以下方法：\n\nposts = paginator.page(current_page)\n        # has_next              是否有下一页\n        # next_page_number      下一页页码\n        # has_previous          是否有上一页\n        # previous_page_number  上一页页码\n        # object_list           分页之后的数据列表\n        # number                当前页\n        # paginator             paginator对象\n        \n就把posts.object_list传递给前端的模板就可以了\n\n上下页：\n{% if posts.has_next %}\n\t<a href=\'index.html?page={{ posts.next_page_number}}\'>下一页</a>\n{% endif %}\n\n如果传递的不是整形的花那么就默认让你访问第一页\n\nfrom django.shortcuts import render\nfrom django.core.paginator import Paginator, EmptyPage, PageNotAnInteger\n\nL = []\nfor i in range(999):\n    L.append(i)\n\ndef index(request):\n    current_page = request.GET.get(\'p\')\n\n    paginator = Paginator(L, 10)\n    # per_page: 每页显示条目数量\n    # count:    数据总个数\n    # num_pages:总页数\n    # page_range:总页数的索引范围，如: (1,10),(1,200)\n    # page:     page对象\n    try:\n        posts = paginator.page(current_page)\n        # has_next              是否有下一页\n        # next_page_number      下一页页码\n        # has_previous          是否有上一页\n        # previous_page_number  上一页页码\n        # object_list           分页之后的数据列表\n        # number                当前页\n        # paginator             paginator对象\n    except PageNotAnInteger:\n        posts = paginator.page(1)\n    except EmptyPage:\n        posts = paginator.page(paginator.num_pages)\n    return render(request, \'index.html\', {\'posts\': posts})\n```\n\n### 自定义分页\n\n```python\ndef custom(request):\n    # 获取当前页面，表示用户当前想要访问的页码\n    current_page = request.GET.get(\'page\')\n    # 设置一下每一页显示的数目\n    per_page = 10\n    current_page = int(current_page)\n   \n\t# 设置起始位置\n    start = (current_page-1) * per_page\n    stop = current * per_page\n   \n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[start, stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list})\n```\n\n把上面的逻辑封装到一个类\n\n```python\nclass PageInfor(object):\n    \n    def __init__(self, current_page, all_count, per_page, show_page=11)\n    \ttry:\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        # 数据库总行数\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        pages, spare = divmod(self.all_count, self.per_page)\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        \n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        page_list = []\n        # 当前页的每一边有几个\n        half = int((self.show_page-1)/2)\n        \n        # 关于极限值做一下判断，如果说当前页已经小于等于两边的分页了 \n        if self.current_page <= half:\n            # 那么就把左侧的极限值抠出来，也即是begin\n            begin = 1\n            # 如果说我想要显示n页面，实际要大于n页，stop就是我要显示的。\n            if self.all_pager > self.show_page:\n            \tstop = self.show_page + 1\n            # 如果说实际不够我要显示的页数，那么就是有几页就显示几页了\n            else:\n                stop = self.all_pager +1\n        # 没到极值的时候就按照之前的逻辑\n        else:\n        \tbegin = self.current_page - half\n        \tstop = self.current_page + half + 1\n            \n        for i in range(begin, stop):\n            if i == self.page:\n            \ttemp = \"<a style=\'display=inline-block;padding:5px;background:red;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            else:\n                temp = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n        \n    \n\n# 再次调用\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10)\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\n# 如果模板端需要使用的话需要，加上safe表示是安全的，而不是xss跨站脚本攻击。如果是安全的话就会渲染成标签，而不是字符串。\n{{ page_info.pager|safe }}\n```\n\n上面写的还有一些啰嗦，针对这个问题再做一下优化：\n\n```python\nclass PageInfor(object):\n    \n    def __init__(self, current_page, all_count, per_page, show_page=11)\n    \ttry:\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        # 数据库总行数\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        pages, spare = divmod(self.all_count, self.per_page)\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        \n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        page_list = []\n        # 当前页的每一边有几个\n        half = int((self.show_page-1)/2)\n\t\t# 如果数据库的总页数小于咱们设置的显示的页数那就看这点吧\n        if self.all_pager < self.show_page:\n            begin = 1\n            stop =  self.all_pager + 1\n        # 如果总页数大于11\n        else:\n            # 如果当前页小于等于5，那么就永远显示1~11页\n            if current_page < half:\n            \tbegin = 1\n            \tstop = self.show_pager + 1\n            else:\n                # 当前页大于5\n                if (self.current_page + half) > self.all_pager: \n                    begin = self.all_pager - self.show_page + 1\n                    stop = self.current_page + 1\n                else:\n        \t\t\tbegin = self.current_page - half\n        \t\t\tstop = self.current_page + half + 1\n        \n        if self.current_page < = 1 :\n        \tprev = \"<a style=\'display=inline-block;padding:5px;\' href=\'#\'>上一页</a>\"\n        else:\n        \tprev = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>上一页</a>\" % self.current_page - 1\n        \n        page_list.append(prev)\n        \n        for i in range(begin, stop):\n            if i == self.page:\n            \ttemp = \"<a style=\'display=inline-block;padding:5px;background:red;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            else:\n                temp = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n    \n    \tif self.current_page >= self.all_pager:\n            nxt = \"<a style=\'display=inline-block;padding:5px;\' href=\'#\'>下一页</a>\"\n        else:\n        \tnxt = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>下一页</a>\" % self.current_page + 1\n        page_list.append(nxt)\n    \n\n# 再次调用\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10)\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\n# 如果模板端需要使用的话需要，加上safe表示是安全的，而不是xss跨站脚本攻击。如果是安全的话就会渲染成标签，而不是字符串。\n{{ page_info.pager|safe }}\n```\n\n针对如上的内容再次进行优化：\n\n```python\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    # 加一个html的前缀\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10, \'/custom.html\' )\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\nclass PageInfor(object):\n    # 接收位置参数调整一下\n    def __init__(self, current_page, all_count, per_page, base_url, show_page=11)\n    \ttry:\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        # 数据库总行数\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        pages, spare = divmod(self.all_count, self.per_page)\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        # 要跳转的连接前缀\n        self.base_url = base_url\n        \n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        page_list = []\n        # 当前页的每一边有几个\n        half = int((self.show_page-1)/2)\n\t\t# 如果数据库的总页数小于咱们设置的显示的页数那就看这点吧\n        if self.all_pager < self.show_page:\n            begin = 1\n            stop =  self.all_pager + 1\n        # 如果总页数大于11\n        else:\n            # 如果当前页小于等于5，那么就永远显示1~11页\n            if current_page < half:\n            \tbegin = 1\n            \tstop = self.show_pager + 1\n            else:\n                # 当前页大于5\n                if (self.current_page + half) > self.all_pager: \n                    begin = self.all_pager - self.show_page + 1\n                    stop = self.current_page + 1\n                else:\n        \t\t\tbegin = self.current_page - half\n        \t\t\tstop = self.current_page + half + 1\n        \n        if self.current_page < = 1 :\n        \tprev = \"<li><a href=\'#\'>上一页</a></li>\"\n        else:\n        \tprev = \"<li><a href=\'%s?page=%s\'>上一页</a></li>\" % (self.base_url, self.current_page - 1)\n        \n        page_list.append(prev)\n        \n        for i in range(begin, stop):\n            if i == self.page:\n            \ttemp = \"<li class=\'active\'><a href=\'%s?page=%s\'>%s</a></li>\" % (self.base_url, i, i)\n            else:\n                temp = \"<li><a href=\'%s?page=%s\'>%s</a></li>\" % (self.base_url, i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n    \n    \tif self.current_page >= self.all_pager:\n            nxt = \"<li><a href=\'#\'>下一页</a></li>\"\n        else:\n        \tnxt = \"<li><a href=\'%s?page=%s\'>下一页</a></li>\" % (self.base_url, self.current_page + 1)\n        page_list.append(nxt)\n```\n\n结合bootstrap进行样式优化，然后就可以把类单独拿出来了\n\n```python\n创建一个目录叫utils，用来存放工具类。把这个类拿过来，放到这个模块里就行了。\n```\n\n\n\n\n\n## Django Admin\n\n> Django Admin是由Django自身提供的一个管理后台\n\n创建用户名密码：\n\n```python\npython manage.py createsuperuser\n```\n\n\n\n```python\n# admin.py\nfrom django.crontrib import admin\nfrom app01 import models\nadmin.site.register(models.UserInfo)\n```\n\n这样操作就可以把我们自己创建的Userinfo注册到Django\n\n就可以在Django admin中操作数据表了。\n\n","timestamp":1531448340028},{"name":"01-Django_orm初识.md","path":"06-Django/03-Django ORM/01-Django_orm初识.md","content":"# Django ORM\n\n> 首先针对ORM不做太对的赘述，ORM不仅仅是Python有，其他的语言也有。比较重要的就是记住其中的映射关系。类对应数据表，字段对应属性，类的对象对应表中的每一条记录。\n>\n> - 数据库操作：事先创建好数据库\n> - 数据表操作：创建表，修改表，删除表\n> - Django Query_set的链式操作\n>\n> django的orm没办法直接连接数据库，需要pymysql等第三方工具去连接数据库。默认连接mysql的时候用的是 MysqlDB模块，py3中没有。因此需要修改默认连接mysql的方式。\n\n## 1、配置Django连接数据库\n\nDjango里面默认连接sqlite，那么修改的花其实就是修改settings的配置啦\n\n```python\n# http://www.cnblogs.com/wupeiqi/articles/5237704.html\n# 由sqlite变为mysql\nDATABASES = {\n    \'default\': {\n    \t\'ENGINE\': \'django.db.backends.mysql\',\n    \t\'NAME\':\'dbname\',  # 数据库的名称，要先创建好数据库\n    \t\'USER\': \'root\',\n    \t\'PASSWORD\': \'xxx\',\n    \t\'HOST\': \'localhost\',\n    \t\'PORT\': \'3306\',\n    }\n}\n\n# 在project同名的__init__.py中引入一下pymysql\n# 由于Django内部连接MySQL时使用的是MySQLdb模块，而python3中还无此模块，所以需要使用pymysql来代替\n# 如下设置放置的与project同名的配置的 __init__.py文件中\n  \nimport pymysql\npymysql.install_as_MySQLdb()\n```\n\n**踩坑记录~**\n\n```python\n# 因为我学习的时候django2.0刚发布没多久，因此默认安装的就是2.0的django。在使用过程中遇到如下报错，报我的mysql版本太低：\ndjango.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None\n\n找到对应使用的python版本的site-packages下django下db下banckends下mysql下的base.py\n我的位置是在如下的位置，win，mac，或者其他的linux版本位置可能不一样自己确定好位置再改。\n/usr/local/lib/python3.6/site-packages/django/db/backends/mysql\n\n在base.py中有这么一句，给注释掉就可以了，否者都不能创建django app\nif version < (1, 3, 3):\n    raise ImproperlyConfigured(\"mysqlclient 1.3.3 or newer is required; you have %s\" % Database.__version__)\n```\n\n**扩展：查看Django ORM执行的原生SQL**\n\n```python\n# 在settings中添加这些语句，这样重启项目以后我们就可以在终端查看到执行的所有语句了，调试的时候可以打开查看进行调试学习使用。\nLOGGING = {\n    \'version\': 1,\n    \'disable_existing_loggers\': False,\n    \'handlers\': {\n        \'console\':{\n            \'level\':\'DEBUG\',\n            \'class\':\'logging.StreamHandler\',\n        },\n    },\n    \'loggers\': {\n        \'django.db.backends\': {\n            \'handlers\': [\'console\'],\n            \'propagate\': True,\n            \'level\':\'DEBUG\',\n        },\n    }\n}\n\n当然这个不一定打开，因为打开以后实在是有点烦，你可以用对象的query方法，比如print(ob.query)进行单独查看。\n```\n\n## 2、Django数据表的创建\n\n> Django的ORMD是data_first类型的ORM，使用前必须先创建数据库\n\n### 2.1、建表流程\n\ndjango orm之创建数据表，在app的models类，创建一个类，这个类就是表（对应文件为小的项目下的models.py文件），表中的一行就是一个对象。\n\n```python\n# 表类创建示例\nclass Userinfo(models.Model):\n    # AutoField()就是自增的，在内部生成的是Int类型，还有一个BigAutoField，就是bigint\n    # 在django里，这一列可以不写，在内部会默认生成一列叫id，是int类型的，并且自增的，是PrimaryKey\n    # 当然这一列你写了就用你的。\n    nid = models.AutoField(primary_key = True)\n    # CharField就是字符串类型\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    \n# 表的修改\n直接修改models中的class数据模型类就行了。在已经有数据的表里添加字段的时候要添加默认值\nage = models.IntergerField(null=True)\n或者\nage = models.IntergerField(default=1)\n```\n\n表与表可以通过外键之间建立关系，但是表之间的关系Django提供了更多的处理方式\n\n```python\n# 下面这条命令是和UserGroup进行建立关系，关系建立后并不会在当前的表生成一个叫group_id的字段而是会\n# 自动生成一个group_id_id的这么一列，生成外键的关系。也就是说我们创建的外键在实际的表中会生成一个我们创建# 的名字_id形式的名字字段，因此如果说向这个表中添加数据的时候，指定的字段名应该是，外键_id的形式。\ngroup_id = models.ForeignKey(\"UserGroup\", null=False)\n\n示例：\nclass Userinfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(max_length=16)\n    age = models.IntegerField()\n    ut = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n    \n    那么结果会有id，name，age，ut_id字段，共4个字段\n```\n\n### 2.2、注册你的项目\n\n```python\n# 在settings中注册app\nINSTALLED_APPS = [\n    \'django.contrib.admin\',\n    \'django.contrib.auth\',\n    \'django.contrib.contenttypes\',\n    \'django.contrib.sessions\',\n    \'django.contrib.messages\',\n    \'django.contrib.staticfiles\',\n    \'app01\',  # 把你自己的小项目给加上\n]\n```\n\n### 2.3、创建数据表：\n\n```python\n# 最后创建数据库表\npython manage.py makemigrations  # 生成配置文件\n# 通过配置文件进行操作数据库，每一次都有一个配置文件，保存在app中的migrations文件夹中，修改的依据也是这个文件夹的操作配置的记录的配置文件。我们其实可以理解为一个数据库修改操作的记录表\npython manage.py migrate         \n\n# django自己会创建很多表\nmysql> show tables;\n+----------------------------+\n| Tables_in_study            |\n+----------------------------+\n| auth_group                 |\n| auth_group_permissions     |\n| auth_permission            |\n| auth_user                  |\n| auth_user_groups           |\n| auth_user_user_permissions |\n| backend_userinfo           |\n| django_admin_log           |\n| django_content_type        |\n| django_migrations          |\n| django_session             |\n+----------------------------+\n11 rows in set (0.00 sec)\n\n# 只有这个backend_userinfo才是我们自己的表，其他的都是django默认创建的。\n# Django通过自身的ORM为我们生成的表名默认是以appname_小写的类名。\n# 比如app名称是backend，那么对应的class UserInfo这个类生成的orm就是：backend_userinfo\n```\n\n## 3、Django Admin\n\n> Django为我们提供了一个内置的后台，我们可以使用\n\n登录后台是需要账号密码的，不过我们一开始也不知道，因此要重新设置一下密码\n\n```python\npython3 manage.py createsuperuser\n```\n\n按照命令行的提示输入账号和密码就可以啦~\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/1250519.jpg)\n\n主界面：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/37524661.jpg)\n\n假如说Django Admin的密码忘了怎么办？\n\n```python\npython manage.py changepassword <username>\n```\n\n通过Django Admin注册model实现数据插入：\n\n```python\n# 在对应的app的admin.py下引入models模块进行注册\nfrom django.contrib import admin\nfrom main import models\n\n# Register your models here.\nadmin.site.register(models.Article)\nadmin.site.register(models.Category)\nadmin.site.register(models.Tag)\nadmin.site.register(models.User)\n```\n\n再访问admin界面的时候我们就可以使用Django Admin进行数据添加了。\n\n","timestamp":1531448340028},{"name":"02-Django Model.md","path":"06-Django/03-Django ORM/02-Django Model.md","content":"# Django Model\n\n## 常用Model\n\n### 数字类型\n\n- AutoField(Field)\n\n  ```python\n  int自增列，必须填入参数 primary_key = True\n  ```\n\n- BigAutoField(AutoField)\n\n  ```python\n  这是bigint的自增列，必须填入参数primary_key=True\n  注：当model中如果没有自增列，则自动会创建一个列名为id的列\n\n  from django.db import models\n\n  class UserInfo(models.Model):\n      # 自动创建一个列名为id的且为自增的整数列\n      username = models.CharField(max_length=32)\n\n  class Group(models.Model):\n      # 当然我们可以自定义自增列\n      nid = models.AutoField(primary_key=True)\n      name = models.CharField(max_length=32)\n  ```\n\n- SmallIntegerField(IntegerField)\n\n  ```python\n  - 小整数 -32768 ～ 32767\n  ```\n\n- PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\n\n  ```python\n  - 正小整数 0 ～ 32767\n  ```\n\n- IntegerField(Field)\n\n  ```python\n  - 整数列(有符号的) -2147483648 ～ 2147483647\n  ```\n\n- PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\n\n  ```python\n  - 正整数 0 ～ 2147483647\n  ```\n\n- BigIntegerField(IntegerField):\n\n  ```python\n  - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807\n\n  自定义无符号整数字段\n\n  class UnsignedIntegerField(models.IntegerField):\n      def db_type(self, connection):\n          return \'integer UNSIGNED\'\n  ```\n\n- FloatField(Field)\n\n  ```python\n  浮点型\n  ```\n\n- DecimalField(Field)\n\n  ```python\n  - 10进制小数,精确浮点\n  - 参数：\n     max_digits，总长度\n     decimal_places，小数位长度\n  ```\n\n### 字符串类型\n\n- CharField(max_length=255)\n\n  ```python\n  字符类型，必须提供max_length参数，max_length表示字符长度\n  ```\n\n- EmailField(CharField)\n\n  ```python\n  也是字符串类型，在Django Admin以及Model Form中可以提供邮箱格式的验证，但是直接create增加数据这样是并不能够提供验证功能的\n  ```\n\n- IPAddressField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制\n  ```\n\n- URLField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 URL\n  ```\n\n- SlugField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）\n\n  Slug这个Field是用在文章的URL的，比如一个文章标题是i love django，那么可以把slug设置成i-love-django，然后这样这篇文章的url可以是www.example.com/article/i-love-django，每一篇文章都是唯一的，所以slug也要唯一，unique要设置为True。当然你可以不这么用，单纯的用文章的id也行。\n  ```\n\n- UUIDField(Field)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证\n  ```\n\n- GenericIPAddressField(Field)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6；参数1：protocol，用于指定Ipv4或Ipv6， \'both\',\"ipv4\",\"ipv6\"；参数2：unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\"both\"\n  ```\n\n- FilePathField(Field)\n\n  ```python\n  字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能。\n  参数如下：path（文件夹路径）,match=None（正则匹配）,recursive=False（是否递归下面的文件夹）,allow_files=True（允许文件）,allow_folders=False（允许文件夹）\n  ```\n\n- FileField(Field)\n\n  ```python\n  字符串，路径保存在数据库，文件上传到指定目录，可以在Django Admin中，直接进行使用。\n  参数1：upload_to = \"\"表示上传文件的保存路径；\n  参数2：storage = None表示存储组件，默认：django.core.files.storage.FileSystemStorage\n  ```\n\n- ImageField(FileField)\n\n  ```python\n  字符串，路径保存在数据库，文件上传到指定的目录；\n  参数如下：\n  - upload_to=\"\"（表示上传文件的保存路径）；\n  - storage=None(表示存储组件，默认的是django.core.files.storage.FileSystemStorage)；\n  - width_field=None（上传图片的高度保存的数据库字段名，字符串形式）；\n  - height_field=None（ 上传图片的宽度保存的数据库字段名，字符串形式）；\n\n  这个字段依赖于PIL库，因此确保你使用的时候安装了这个库，如果没有安装的话可以使用pip安装一下：pip install PIL否则是会报错的哦~\n  ```\n\n- CommaSeparatedIntegerField(CharField)\n\n  ```python\n  字符串类型，格式必须为逗号分割的数字\n  ```\n\n- TextField(Field)\n\n  ```python\n  - 文本类型\n  ```\n\n### 时间类型\n\n- DateTimeField(DateField)\n\n  ```python\n  - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]\n  ```\n\n- DateField(DateTimeCheckMixin, Field)\n\n  ```python\n  - 日期格式      YYYY-MM-DD\n  ```\n\n- TimeField(DateTimeCheckMixin, Field)\n\n  ```python\n  - 时间格式      HH:MM[:ss[.uuuuuu]]\n  ```\n\n- DurationField(Field)\n\n  ```python\n  - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型\n  ```\n\n关于时间类型，Django提供的model有DateTimeField，DateField，TimeField三种类型。分别对应的datetime()，date()，time()三种对象。这三个field有相同的参数，一个事auto_now，一个是auto_now_add。\n\n1. auto_now：这个字段属性值默认是false的，在保存数据对象的时候，将其设置为当前时间，然后当你修改的时候这个时间会随着你修改的时间变化而变化。简单来说，这个对象的时间会一直是最新的时间，你没办法为这个字段进行手动的赋值。\n2. auto_now_add：这个字段默认也是false的，如果设置为True以后其实和auto_now差不多，只不过这个时间不会因为你后续的修改而进行改变，而是只保存第一次创建的时间。比如说用户创建时间，这个不应该随着用户信息变化而发生改变，但是论坛发的帖子，可以有一个最后的修改时间可以随着修改而改变。\n\nauto_now和auto_now_add被设置为True后，这样做会导致字段成为editable=False和blank=True的状态。editable=False将导致字段不会被呈现在admin中，blank=True表示允许在表单中不输入值。此时，如果在admin的fields或fieldset中强行加入该日期时间字段，那么程序会报错，admin无法打开；如果在admin中修改对象时，想要看到日期和时间，可以将日期时间字段添加到admin类的readonly_fields中：\n\n```python\nclass YourAdmin(admin.ModelAdmin):\n    readonly_fields = (\'save_date\', \'mod_date\',)\nadmin.site.register(Tag, YourAdmin)\n```\n\n实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？\n\ndjango中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：\n\n```python\nfrom django.db import models\nimport django.utils.timezone as timezone\nclass Doc(models.Model):\n    add_date = models.DateTimeField(\'保存日期\',default = timezone.now)\n    mod_date = models.DateTimeField(\'最后修改日期\', auto_now = True)\n```\n\nhtml页面从数据库中读出DateTimeField字段时，显示的时间格式和数据库中存放的格式不一致，比如数据库字段内容为2016-06-03 13:00:00，但是页面显示的却是Apr. 03, 2016, 1 p.m.\n\n为了页面和数据库中显示一致，需要在页面格式化时间，需要添加如下类似的过滤器。刷新页面，即可正常显示。\n\n```python\n<td>{{ **infor.updatetime|date:\"Y-m-d H:i:s\" **}}</td>\n```\n\n### 布尔类型\n\n- BooleanField(Field)：布尔值类型\n- NullBooleanField(Field)：可以为空的布尔值类型\n\n### 枚举类型\n\n```python\nchoice=(\n        (1,\'male\'),\n        (2,\'female\'),\n        (3,\'other\')\n    )\nlover=models.IntegerField(choices=choice) #枚举类型\n\n# 在数据库存储枚举类型，比外键有什么优势？\n1、无需连表查询性能高一些，省硬盘空间(选项不固定时用外键)\n2、在model文件里不能动态增加（选项一成不变用Django的choice），选项固定的时候可以使用枚举，如果需要动态增加的时候建议使用外键。\n3、在Django Admin中可以直接结合枚举生效，生成下拉框。\n```\n\n### 二进制类型\n\n- BinaryField(Field)：二进制类型\n\n## Model中的其他参数\n\n```python\n# 字段参数\nnull                数据库中字段是否可以为空\ndb_column           数据库中字段的列名\ndefault             数据库中字段的默认值\nprimary_key         数据库中字段是否为主键\ndb_index            数据库中字段是否可以建立索引\nunique              数据库中字段是否可以建立唯一索引\nunique_for_date     数据库中字段【日期】部分是否可以建立唯一索引\nunique_for_month    数据库中字段【月】部分是否可以建立唯一索引\nunique_for_year     数据库中字段【年】部分是否可以建立唯一索引\n\n# 设置是否为空，设置默认值\nxxx = models.CharField.(max_length=32, null=True, default=\'111\')\nxxx = models.CharField.(max_length=32, db_index=True, unique=True)\n# unique_for_month,unique_for_day,unique_for_year，指定日期类型中的哪一端为索引，在数据库中我们添加索引的时候可以指定prefix长度为多少，这里可以指定年月日。\nxxx = models.DateTimeField(null=True, unique_for_data=True)\n\n# 联合唯一索引\nclass Meta:\n\tunique_together = (\n \t\t(\'email\',\'ctime\'),\n\t)\n    \n# 联合索引，不唯一（不做限制）\n\tindex_together = (\n\t\t(\'email\',\'ctime\'),\n\t)\n    \n# 联合唯一约束\nclass Love(models.Model):\n    b = models.ForeignKey(\'Boy\')\n    g = models.ForeignKey(\'Girl\')\n    \n    class Meta:\n        unique_together = [\n            (\'b\',\'g\'),\n        ]\n```\n\n### 元数据中可以填些啥？\n\n> 官方参考：https://docs.djangoproject.com/en/1.10/ref/models/options/\n\n```python\nclass UserInfo(models.Model):\n    nid = models.AutoField(primary_key=True)\n    username = models.CharField(max_length=32)\n    class Meta:\n        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名\n        db_table = \"table_name\"\n\n        # 联合索引\n        index_together = [\n            (\"pub_date\", \"deadline\"),\n        ]\n\n        # 联合唯一索引\n        unique_together = ((\"driver\", \"restaurant\"),)\n\n        # admin中显示的表名称\n        verbose_name\n\n        # verbose_name加s\n        verbose_name_plural\n```\n\n## 模型类在数据库中的对照参考\n\n```python\n# 以下为Django模型创建的字段值，在数据库中的属性体现\n\n\'AutoField\': \'integer AUTO_INCREMENT\',\n\'BigAutoField\': \'bigint AUTO_INCREMENT\',\n # 只能存储字节数据，无法作为过滤选项\n\'BinaryField\': \'longblob\',\n\'BooleanField\': \'bool\',\n\'CharField\': \'varchar(%(max_length)s)\',\n # 存储由逗号分隔的数字，实质为字符串\n\'CommaSeparatedIntegerField\': \'varchar(%(max_length)s)\',\n\'DateField\': \'date\',\n\'DateTimeField\': \'datetime\',\n\'DecimalField\': \'numeric(%(max_digits)s, %(decimal_places)s)\',\n\'DurationField\': \'bigint\',\n\'FileField\': \'varchar(%(max_length)s)\',\n\'FilePathField\': \'varchar(%(max_length)s)\',\n\'FloatField\': \'double precision\',\n\'IntegerField\': \'integer\',\n\'BigIntegerField\': \'bigint\',\n\'IPAddressField\': \'char(15)\',\n\'GenericIPAddressField\': \'char(39)\',\n\'NullBooleanField\': \'bool\',\n\'OneToOneField\': \'integer\',\n\'PositiveIntegerField\': \'integer UNSIGNED\',\n\'PositiveSmallIntegerField\': \'smallint UNSIGNED\',\n\'SlugField\': \'varchar(%(max_length)s)\',\n\'SmallIntegerField\': \'smallint\',\n\'TextField\': \'longtext\',\n\'TimeField\': \'time\',\n\'UUIDField\': \'char(32)\',\n```","timestamp":1531448340028},{"name":"03-表间关系.md","path":"06-Django/03-Django ORM/03-表间关系.md","content":"# 表与表之间的关系\n\n>- 一对多：当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）\n>  *例如：创建用户信息时候，需要选择一个用户类型【普通用户】【金牌用户】【铂金用户】等。*\n>- 多对多：在某表中创建一行数据是，有一个可以多选的下拉框\n>  *例如：创建用户信息，需要为用户指定多个爱好*\n>- 一对一：在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了\n>  *例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据*\n\n- 一对一：OneToOneField\n- 一对多（多对一）：ForeignKey\n- 多对多：ManyToManyField\n\n## 表间关系说明\n\n### 一对多（ForeignKey）\n\n创建测试表，然后用Django Admin创建点测试数据：\n\n```python\nclass UserType(models.Model):\n    caption = models.CharField(max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass UserInfo(models.Model):\n    username = models.CharField(max_length=32)\n    age = models.IntegerField()\n    user_type = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.username\n```\n\n比如现在我要从UserInfo表跨表去查拿到用户所属的用户分类的分类名称，我可以这样取：\n\n```python\nobj = models.UserInfo.objects.filter(username=\'马晓雨\').values(\'id\', \'username\', \'user_type__caption\')\n```\n\n通过UserInfo表去跨表找到对应分类的用户：\n\n```python\nobj = models.UserInfo.objects.filter(user_type__caption=\'2B用户\')\n```\n\n上面都是在查的时候直接跨表，通过用户对象跨表就不使用双下划线的写法了，直接使用“.”：\n\n```python\n# 注意是通过设置的外键跳过去的。\nobj = models.UserInfo.objects.filter(username=\'马晓雨\').first()\nprint(obj.user_type.caption)\n```\n\n而且也可以通过UserType进行逆向查询：\n\n```python\nobj = models.UserType.objects.filter(userinfo__username=\'齐茂森\')\nprint(obj)\n\n# 使用表名_set的前提是拿到一个UserType的对象才会有userinfo_set的方法\n# obj2.userinfo_set拿到的是一个relatemanager对象\nobj2 = models.UserType.objects.filter(caption=\'2B用户\').first()\nprint(obj2.userinfo_set.all())\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 字段以及相关参数\n\n```python\nForeignKey(ForeignObject) # ForeignObject(RelatedField)\n        to,               # 要进行关联的表名，这个默认可以不写，直接写个表名就是to=\'表名\'\n        to_field=None,    # 要关联的表中的字段名称，默认关联到主键字段。\n        on_delete=None,   # 当删除关联表中的数据时，当前表与其关联的行的行为，下面是其他属性值\n            - models.CASCADE，删除关联数据，与之关联也删除\n            - models.DO_NOTHING，删除关联数据，引发错误IntegrityError\n            - models.PROTECT，删除关联数据，引发错误ProtectedError\n            - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）\n            - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）\n            - models.SET，删除关联数据，\n                a. 与之关联的值设置为指定值，设置：models.SET(值)\n                b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)\n                Example：\n                    def func():\n                        return 10\n\n                    class MyModel(models.Model):\n                        user = models.ForeignKey(\n                                   to=\"User\",\n                                   to_field=\"id\"\n                                   on_delete=models.SET(func),\n                        )\n        related_name=None,  # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\n        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(\'表名__字段名\')\n        limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件：\n                               # 如：\n                                   - limit_choices_to={\'nid__gt\': 5}\n                                   - limit_choices_to=lambda : {\'nid__gt\': 5}\n\n                                   from django.db.models import Q\n                                   - limit_choices_to=Q(nid__gt=10)\n                                   - limit_choices_to=Q(nid=8) | Q(nid__gt=10)\n                                   - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption=\'root\')\n        db_constraint=True          # 是否在数据库中创建外键约束\n        parent_link=False           # 在Admin中是否显示关联数据\n\n\nOneToOneField(ForeignKey)\n        to,                         # 要进行关联的表名\n        to_field=None               # 要关联的表中的字段名称\n        on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为\n\n                                    ###### 对于一对一 ######\n                                    # 1. 一对一其实就是 一对多 + 唯一索引\n                                    # 2. 当两个类之间有继承关系时，默认会创建一个一对一字段\n                                    # 如下会在A表中额外增加一个c_ptr_id列且唯一：\n                                    class C(models.Model):\n                                        nid = models.AutoField(primary_key=True)\n                                        part = models.CharField(max_length=12)\n\n                                    class A(C):\n                                        id = models.AutoField(primary_key=True)\n                                        code = models.CharField(max_length=1)\n\nManyToManyField(RelatedField)\n        to,                         # 要进行关联的表名\n        related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\n        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(\'表名__字段名\')\n        limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：\n                                    # 如：\n                                            - limit_choices_to={\'nid__gt\': 5}\n                                            - limit_choices_to=lambda : {\'nid__gt\': 5}\n\n                                            from django.db.models import Q\n                                            - limit_choices_to=Q(nid__gt=10)\n                                            - limit_choices_to=Q(nid=8) | Q(nid__gt=10)\n                                            - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption=\'root\')\n        symmetrical=None,           # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段\n                                    # 做如下操作时，不同的symmetrical会有不同的可选字段\n                                        models.BB.objects.filter(...)\n\n                                        # 可选字段有：code, id, m1\n                                            class BB(models.Model):\n\n                                            code = models.CharField(max_length=12)\n                                            m1 = models.ManyToManyField(\'self\',symmetrical=True)\n\n                                        # 可选字段有: bb, code, id, m1\n                                            class BB(models.Model):\n\n                                            code = models.CharField(max_length=12)\n                                            m1 = models.ManyToManyField(\'self\',symmetrical=False)\n\n        through=None,               # 自定义第三张表时，使用字段用于指定关系表\n        through_fields=None,        # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表\n                                        from django.db import models\n\n                                        class Person(models.Model):\n                                            name = models.CharField(max_length=50)\n\n                                        class Group(models.Model):\n                                            name = models.CharField(max_length=128)\n                                            members = models.ManyToManyField(\n                                                Person,\n                                                through=\'Membership\',\n                                                through_fields=(\'group\', \'person\'),\n                                            )\n\nclass Membership(models.Model):\n    group = models.ForeignKey(Group, on_delete=models.CASCADE)\n    person = models.ForeignKey(Person, on_delete=models.CASCADE)\n    inviter = models.ForeignKey(\n          Person,\n                                                on_delete=models.CASCADE,\n                                                related_name=\"membership_invites\",\n                                            )\n                                            invite_reason = models.CharField(max_length=64)\n        db_constraint=True,         # 是否在数据库中创建外键约束\n        db_table=None,              # 默认创建第三张表时，数据库中表的名称\n```\n\n\n\n## 针对Django Admin生效的参数\n\n有一些Django提供的字段模型比如EmailField或者IPAddressField等都可以在Django Admin中提供字段验证的功能（Module Form也可以生效），但是这些功能对于直接create创建添加并不会起到验证的效果。\n\n如何在Django Admin中注册我们自己的模型类：\n\n```python\n# 在我们自己创建的app下的admin.py中进行注册\nfrom django.contrib import admin\nfrom backend import models\nadmin.site.register(models.DjangoAdmin_test)\n```\n\n再次查看后台主界面的时候就会发现我们注册的表已经添加进去了：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/33506367.jpg)\n\n点击Django admin_tests，进入到内部，点击右上方的ADD Django ADMIN_TEST我们其实就可以向绑定的这个表内添加数据了。在这里我们就可以看到Django提供的那些特殊字段的验证效果了，比如EmailField会验证是不是邮箱。\n\n- FileFeild()：在Django Admin中会变成上传的组件\n\n- DateTimeField()：时间类型，可以传入2017-10-11类似的。\n\n- 枚举类型，Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作，体现出来就是一个下拉菜单。如果不在Django Admin中使用的话，我们自己通过for循环取也是完全没有问题的。\n\n  ```python\n  # example1：\n  color_list = (\n      (1, \'black\'),\n      (2, \'white\'),\n      (3, \'blue\')\n  )\n  color = models.IntegerField(choices=color_list)\n\n  # example2：\n  gf = models.IntegerField(choices=[(0, \'何穗\'),(1, \'大表姐\'),],default=1)\n  ```\n\n- verbose_name：Admin中显示的字段名称，或者说使用model组件的时候显示的名称\n\n- blank：Admin中是否允许用户输入为空。\n\n- editable：Admin中是否可以编辑，如果为false你在页面上就直接看不到了。\n\n- help_text：Admin中显示该字段的提示信息\n\n- error_messages：自定义错误信息（字典类型），从而定制想要显示的错误信息；结合validators使用。\n\n  ```python\n  # 这个error_messages优先级是比较低的。错误信息会在Module Form中找的。\n  字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date                        如：{\'null\': \"不能为空.\", \'invalid\': \'格式错误\'}\n  ```\n\n- validators：自定义错误验证（列表类型），从而定制想要的验证规则\n\n  ```python\n  from django.core.validators import RegexValidator\n  from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\\                      MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator\n  # 如：\n  test = models.CharField(\n  \tmax_length=32,\n      error_messages={\n          # 这里的错误信息会优先于下面的validators中的错误进行显示。\n      \t\'c1\': \'优先错信息1\',\n          \'c2\': \'优先错信息2\',\n          \'c3\': \'优先错信息3\',\n      },\n      validators=[\n           RegexValidator(regex=\'root_\\d+\', message=\'错误了\', code=\'c1\'),\n           RegexValidator(regex=\'root_112233\\d+\', message=\'又错误了\', code=\'c2\'),\n           EmailValidator(message=\'又错误了\', code=\'c3\'), ]\n  )\n  ```\n\n\n\n\n#### \n\n小结：\n\n- Django Admin定制型太强，一般不会用很多，或者根本不用\n\n\n\n\n\n```python\n# ########### 基础函数 ###########\n\n    # 1. Concat，用于做类型转换\n    # v = models.UserInfo.objects.annotate(c=Cast(\'pwd\', FloatField()))\n\n    # 2. Coalesce，从前向后，查询第一个不为空的值\n    # v = models.UserInfo.objects.annotate(c=Coalesce(\'name\', \'pwd\'))\n    \"\"\"\n    上面内容的意思是，新加一列列名为c，当查询到每一行数据的时候如果name部位空，那么c这一列就为name，如果name为空，那么c就为pwd\n    \"\"\"\n    # v = models.UserInfo.objects.annotate(c=Coalesce(Value(\'666\'),\'name\', \'pwd\'))\n\n    # 3. Concat，拼接\n    # models.UserInfo.objects.update(name=Concat(\'name\', \'pwd\'))\n    \"\"\"如果要加单纯的字符串而不是字段的话需要用value渲染一下\"\"\"\n    # models.UserInfo.objects.update(name=Concat(\'name\', Value(\'666\')))\n    # models.UserInfo.objects.update(name=Concat(\'name\', Value(\'666\'),Value(\'999\')))\n\n    # 4.ConcatPair，拼接（仅两个参数）\n    # v = models.UserInfo.objects.annotate(c=ConcatPair(\'name\', \'pwd\'))\n    # v = models.UserInfo.objects.annotate(c=ConcatPair(\'name\', Value(\'666\')))\n\n    # 5.Greatest，获取比较大的值;least 获取比较小的值;\n    # v = models.UserInfo.objects.annotate(c=Greatest(\'id\', \'pwd\',output_field=FloatField()))\n\n    # 6.Length，获取长度\n    # v = models.UserInfo.objects.annotate(c=Length(\'name\'))\n\n    # 7. Lower,Upper,变大小写\n    # v = models.UserInfo.objects.annotate(c=Lower(\'name\'))\n    # v = models.UserInfo.objects.annotate(c=Upper(\'name\'))\n\n    # 8. Now，获取当前时间\n    # v = models.UserInfo.objects.annotate(c=Now())\n\n    # 9. substr，子序列\n    # 取name字段，第一个1是起始位置，2表示取多长的长度\n    # v = models.UserInfo.objects.annotate(c=Substr(\'name\',1,2))\n    # 下面是在数据库实际的操作，可以使用v.query查看。\n    select *,Concat(\'nid\',\'title\') from table_name \n\n    # ########### 时间类函数 ###########\n    # 1. 时间截取，不保留其他：Extract, ExtractDay, ExtractHour, ExtractMinute, ExtractMonth,ExtractSecond, ExtractWeekDay, ExtractYear,\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractYear(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractMonth(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractDay(\'ctime\'))\n    #\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'year\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'month\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'year_month\'))\n    \"\"\"\n    MICROSECOND\n    SECOND\n    MINUTE\n    HOUR\n    DAY\n    WEEK\n    MONTH\n    QUARTER\n    YEAR\n    SECOND_MICROSECOND\n    MINUTE_MICROSECOND\n    MINUTE_SECOND\n    HOUR_MICROSECOND\n    HOUR_SECOND\n    HOUR_MINUTE\n    DAY_MICROSECOND\n    DAY_SECOND\n    DAY_MINUTE\n    DAY_HOUR\n    YEAR_MONTH\n    \"\"\"\n\n    # 2. 时间截图，保留其他：Trunc, TruncDate, TruncDay,TruncHour, TruncMinute, TruncMonth, TruncSecond, TruncYear\n    # v = models.UserInfo.objects.annotate(c=functions.TruncHour(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.TruncDate(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Trunc(\'ctime\',\'year\'))\n```\n\n自定义Func\n\n```python\nfrom django.db.models.functions.base import Func\nclass CustomFunc(Func):\n    function = \'DATE_FORMAT\'\n    \n    template = \'%(function)s(%(exporessions)s,%(format)s)\'\n    \n    def __init__(self, expression, **extra):\n        expressions = [expression]\n        super(CustomFunc, self).__init__(*expressions, ** extra)\n        \nCustomFunc(\'create_time\', \'%Y-%m\')\n# DATE_FORMAT(\'create_time\',\'%Y-%m\')\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-6/17906939.jpg)\n\n### 多对多\n\n> 比如一个老师可以任教多个班级，一个班级可以被多个老师任教，这就是一个多对多的关系\n\n```python\nclass Class(models.Model):\n    name = models.CharField(max_length=32, verbose_name=\"班级名\")\n    course = models.CharField(verbose_name=\"课程\", max_length=32)\n\n    def __str__(self):\n        return self.name\n\n\nclass Teacher(models.Model):\n    name = models.CharField(max_length=23, verbose_name=\"姓名\")\n    classes = models.ManyToManyField(verbose_name=\"所属班级\", to=\"Class\")\n\n    def __str__(self):\n        return self.name\n```\n\n针对多对多的关系就可以直接使用ManyToManyField进行声明。Django会为我们分别生成appname_class和appname_teacher这两个表，其中appname指的是你的app的名称。但是并不会在你的teacher的表中生成classes这么一个字段，而是单独的为你创建一个class和teacher的关系表。\n\n不过这个m2m的表只会为你创建三个字段，一个id，还有两个字段分别关联到class的主键字段和teacher的主键字段，如果我们还有其他的需求的话，这个Django默认是无法为我们完成的。因此这个表我们也可以自己进行定义的。\n\n\n\n\n\n## 多对多关系\n\nDjango自动生成多对多关联表：\n\n```python\nclass Boy(models.Model):\n    name = models.CharField(max_length=32)\n    # 为你生成一张多对多的关联表，表名app_boy_m\n    m = models.ManyToManyField(\'Girl\')\n    \n# 但是这张表是django为我们生成的，models里没有模型的定义，那么该如何操作呢？\n# 答案是无法直接对第三张表操作，但是可以通过这个m进行间接的操作。\n\nobj = models.Boy.objects.filter(name=\'user1\').first()\nobj.m.add(xxx)\nobj.m.add(xxx,xxx)\nobj.m.add(*list)\n# 删数据\nobj.m.remove(xxx)\nobj.m.remove(xxx,xxx)\nobj.m.remove(*list)\n# 修改，传值传入一个列表，set会进行重置。\nobj.m.set([1,])\n# 获取，因为没有第三张表的类定义，因为返回的内容并不是关系表的对象，而是关联表的对象\n# 比如A表和B关联，C表示A和B的关系表，通过A.m.all()这个取出来的不是c的对象而是B的对象\nobj.m.all()\n# 还可以进行二次筛选 obj.m.filter(xxx=xxx)\n# 删除\nobj.m.clear()\n# 逆向查找，关系表在Boy表中定义的，那么如何在Girl的对象中拿到呢？\nobj = models.Girl.objects.filter(nick=\'小鱼\').first\n# 可以使用_set进行逆向查找，这个下划线set同样有all，filter，add等操作\nobj.boy_set.all()\n\n# ManyToMany自动生成的关系表只能有三列，如果要有其他的列的时候，就得自己写了。\n# 比如男女相亲，还要记录相亲时间等等其他的字段这个就超出了Django默认能做的范畴了。\n# 所以到底选用什么方法要根据自己的需要进行选择，推荐自己去写，相对来讲更灵活。\n```\n\n如果说manytomany也用了，也自己定义了关系表了，那么按照原则来讲，Django会替我们创建一张关系表。我们可以通过配置让着两种用法同事存在并且不创建新表，让Django默认我们创建的就是那张关系表。\n\n```python\n# 这样可以用之前提到的manytomany的obj.m.clear()属性和obj.m.all()属性，其他的不能用\nclass Boy(models.Model):\n    name = models.CharField(max_length=32)\n    m = models.ManyToManyField(\"Girl\", through=\"Love\", through_fields=(\'b\',\'g\'))\n```\n\n","timestamp":1531448340028},{"name":"04-ORM数据操作.md","path":"06-Django/03-Django ORM/04-ORM数据操作.md","content":"# Django数据操作\n\n## 增&删&改\n\n针对于增删改来讲，相对来说是很简单的，\n\n```python\nfrom app01 import models\n\n# 增加数据\nmodels.UserGroup.objects.create(title=\'销售部\')\nmodels.UserInfo.objects.create(x,x,x,ut_id=1) # 虽然外键是ut，但是在数据表中生成的是ut_id\n\n# 使用字典形式添加数据\nuser_dict = {\"name\": \"chenchao\", \"age\": \"18\", \"user_type_id\": 1}\nmodels.UserInfo.objects.create(**user_dict)\n\n# 通过传递对象的方式添加数据，这里的ut就是我们添加的外键而不是表中实际的字段，实际字段为ut_id\nuser_type_obj = models.UserType.objects.get(id=1)   #先获取外键表中的数据对象\nuser_dict = {\"username\": \"chenchao\", \"age\": \"18\", \"ut\": user_type_obj} # 对象传入字典\nuser_type_obj.save() 或者 models.UserType.objects.create(**user_dict)\n或者\nobj = models.UserInfo(name=\'lamber\',age=15,ut_id=\'2\')\nobj.save()\n\nmodels.UserInfo.objects.create(**user_dict)\n\n# 删除\nmodels.UserGroup.objects.filter(id=2).delete()\n\n# 更新\nmodels.UserGroup.objects.filter(id=2).update(title=\'new_str\')\nmodels.UserGroup.objects.filter(id=2).update(**dict)\n```\n\n## 查\n\n查表的其实也是数据库里比较麻烦的，对应到orm操作内容也就相对来讲多一些。在查询的时候需要铭记于心的就是下面的两条：\n\n- **在联表操作过滤查找数据时用双下划线 \"__\"**\n- **在取数据时用点 \".\"**\n\n### 简单的查询\n\n```python\n# 简单的查\nret = models.UserGroup.objects.all().first()\nret = models.UserGroup.objects.all()\n- 返回的也是一个结果集（QuerySet），结果集我们可以看做是一个列表。列表中的每一个数据数一个数据对象。可以使用对应的对象.属性的方法去调用属性值。形如：\n<QuerySet [<Class: Class object (1)>, <Class: Class object (2)>, <Class: Class object (3)>, <Class: Class object (4)>, <Class: Class object (5)>]>\n\nQuerySet特点：\n<1>  可迭代的 \n<2>  可切片\n- books=models.Book.objects.all()[:10]  #切片 应用分页\n- books = models.Book.objects.all()[::2]\n- book= models.Book.objects.all()[6]    #索引\n<3>  惰性计算和缓存机制\n- 所谓惰性计算，就是查询返回的QuerySet（查询结果集对象），它并不会马上执行sql，而是当调用QuerySet的时候才执行。相当于一个生成器，不应用返回的Query_Set不会执行任何SQL操作。\n- query_set缓存机制：1次数据库查询结果query_set都会对应一块缓存，再次使用该query_set时，不会发生新的SQL操作；这样减小了频繁操作数据库给数据库带来的压力;\n\n# 取个数\nret = models.UserGroup.objects.all().count()\n\n# 根据查询方式的不同，返回的数据类型也是不一样的\n返回对象对象 UserInfo.objects.all()\n返回字典 UserInfo.objects.values(\"name\",\"age\").all()\n返回元组 User.objects.values_list(\"name\",\"age\").all()\n\n# 如果取出来的数据太大的话有可能会撑爆内存，这个时候只要迭代器就可以优雅的解决这个问题\nret = models.UserInfo.objects.all().iterator()\n```\n\n### 带条件的查询：\n\n如果没查到数据的话会返回一个空的Query_set（列表）\n\n```python\n# where条件，条件之间默认是and关系，下面这个就是相当于where id=1 and title=\'xx\'\nret = models.UserGroup.objects.filter(id=1,title=xx)\n\n# where条件大于和小于1，我们可以使用带双下划线的操作来获取(__gt&__lt)\nret = models.UserGroup.objects.filter(id__gt=1)\nret = models.UserGroup.objects.filter(id__lt=1)\n\n# 根据字典去过滤\ncondition = {\n    \'id\': 1,\n    \'name\': lamber\n}\nmodels.UserInfo.objects.filter(**condition)\n```\n\n### 联表\n\n多表连接操作涉及到多种对应关系，比如一对多，多对多等。首先看一个简单的例子：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-26/80257083.jpg)\n\n```python\n# Create your models here.\nclass UserType(models.Model):\n    \"\"\"用户类型\"\"\"\n    title = models.CharField(max_length=32)\n\n\nclass Userinfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(max_length=16)\n    age = models.IntegerField()\n    ut = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n```\n\n#### 通过外键正向联表查找\n\n```python\n# foreign key 就代指对应关联表的一行数据，如下是在取数据的时候才跨表查询数据   \nresult = models.Userinfo.objects.all()\nfor user in result:\n    print(user.id, user.name, user.age, user.ut_id, user.ut.title)\n    \n# 在取数据的时候跨表查询数据，记住这种双下划线的使用方法。不同于在查的时候跨表\nmodels.Userinfo.objects.all.values(\'id\',\'name\', \'ut__title\')\n    \n# userinfo表里有一个外键叫ut，虽然生成的字段叫ut_id，但是可以直接调用ut，ut代表的是usertype里的一行数据，因此可以直接通过“.”把属性获取到，借由这个特性，我们可以横跨多张表。这个跨表操作是django帮我们做的。假如说我们这里的usertyle还有一个和其他表的外键关联，那么我们还可以继续多张表关联。比如\n\n现在有三张表A，B，C\nA有一个外键b指向B表的id\nb = models.ForeignKey(\'B\', on_delete=models.CASCADE)\nB有一个外键c指向C表的id\nc = models.ForeignKey(\'C\', on_delete=models.CASCADE)\n那么按照说的，A表实际生成的是一个叫b_id的字段，B表实际生成的是一个c_id的字段\n\n外键分别为b何c，根据上面的结论，我们创建的外键其实指代的就是指向表的一行数据，那么我们可以通过A表跨到C表去查数据：\nret = models.A.objects.all().first()\n那么我就可以这样取到C表的数据，假设C表有一个字段叫column_c\nret2 = ret.b.c.column_c   # 这样就可以获取到我们想要的数据了。\n\n# 在filter中也是可以进行跨表的，正向跨表实例：\nmodels.UserInfo.objects.filter(\'ut__title=\'超级用户\').values(\'id\', \'name\', \'ut__title\')\n```\n\n**Tip**\n\n```python\n# 这里有一个需要注意的点，在 Django 2.0 后，models.ForeignKey() 函数 和 models.OneToOneField() 中的 on_delete 参数不再默认为 CASCADE ，而是必须参数，因此在用：\n\nut = models.ForeignKey(\'UserType\')\n\n# 这样写的时候是会直接报错的，会报错说少一个参数，但是在django2.0之前是没有问题的。\n```\n\n#### 逆向查找\n\n```python\n# 如果有人和我做了外键，纵使我这边看不见，但是仍然是有一个隐含的字段。比如我userinfo和我usertype字段做了外键，我usertype是看不到的，但是会有一个隐含的字段，如下：\nobj = models.UserType.objects.all().first()  # 获取一个usertype的对象\nprint(obj.id, obj.title)\nfor row in obj.userinfo_set.all():  # 通过usertype的对象去逆向的查userinfo的数据\n  # 每一个row是一个userinfo对象，这里其实就是把type=obj.title的所有用户取出来了\n  print(row.name, row.age)\n  \n# 含表名小写_set.all()，反向操作。针对反向操作，我们还可以进行过滤等其他的操作\nobj.userinfo_set.all().filter(age__gt=20)\n\n# 在取的时候逆向查找。相当于UserType left join Userinfo谁在前面以谁为准，这就和left join让谁在前面一样，根据自己的需求去选择。跨表字段是小写的表名进行跨表。重要！！！\n# 如果要取表的字段可以使用双下划线，比如：userinfo__name\nret = models.UserType.objects.values(\'id\', \'title\', \'userinfo\')\n- 我们可以打开django的sql执行日志，看看sql内部执行了什么：\nSELECT `app_usertype`.`id`, `app_usertype`.`title`, `app_userinfo`.`name` FROM `app_usertype` LEFT OUTER JOIN `app_userinfo` ON (`app_usertype`.`id` = `app_userinfo`.`ut_id`);\n\n# 使用filter实现反向跨表\n# 在filter中也是可以进行跨表的，正向跨表实例：\nmodels.UserType.objects.filter(\'userinfo__name=\'lamber\').values(\'id\', \'title\', \'userinfo__name\')\n```\n\n### 其他查询操作\n\n首先来讲我们查询到的如果返回的是一个query_set的话里面的内容其实是一个一个的对象，但是我们并不知道这些里面是什么内容，因此我们可以改写一下models模型类，比如：\n\n```python\nclass Class(models.Model):\n\n    title = models.CharField(max_length=255)\n    \n    def __str__(self):  ## 如果是python2的话要协程__unicode__\n        return self.title\n# 这个时候我们再去排查的时候，比如print一下返回的return值就可以大概了解都是什么内容了，其实这个还可以根据我们的需求进行深度的定制，显示更加全面的信息，比如查询班级表中的所有内容：\n<QuerySet [<Class: 全栈4期>, <Class: 全栈5期>, <Class: php培训班>, <Class: java培训班>, <Class: mysql实战班>]>\n```\n\n#### order by\n\n```python\n# 按照id排序，从小到大\nmodels.UserInfo.objects.all().order_by(\'id\')\n# 按照id逆向排序\nmodels.UserInfo.objects.all().order_by(\'-id\')\n# 多个条件判定排序，先按照id从大到小，再按照name从小到大\nmodels.UserInfo.objects.all().order_by(\'-id\', \'name\')\n```\n\n#### 分组\n\n```python\nfrom django.db.models import Count, Sum, Max, Min\nret = models.UserInfo.objects.values(\'ut_id\').annotate(xxx=Count(\'id\'))\nprint(ret.query)   # 查看生成的sql语句\n# select “app_userinfo”.\"ut_id\",COUNT(\"app_userinfo\".\"id\") as xxx FROM \"app_userinfo\" GROUP BY \"app_userinfo\".\"ut_id\"\n简单来说就是不加annotate的话前面的语句就是直接select ut_id from userinfo，如果加上了annotate的话，那么values的内容即使group by的条件，后面的xxx是select count(app_userinfo.id)的别名。\n\n# having的使用，filter在annotate之前就是where，在annotate之后就是having\nret = models.UserInfo.objects.values(\'ut_id\').annotate(xxx=Count(\'id\')).filter(xxx__gt=2)\n```\n\n#### 其他\n\n```python\nmodels.UserInfo.objects.filter(id__gt=1) # 大于1\nmodels.UserInfo.objects.filter(id__lt=1) # 小于1\nmodels.UserInfo.objects.filter(id__gte=1) # 大于等于1\nmodels.UserInfo.objects.filter(id__lte=1) # 小于等于1\nmodels.UserInfo.objects.exclude(id=1)   # id不等于1\nmodels.UserInfo.objects.filter(id__in=[1,2,3]) # where in\nmodels.UserInfo.objects.filter(id__range=[1,2]) # 范围\nmodels.UserInfo.objects.filter(name__startswith=\'xxx\') # startwith\nmodels.UserInfo.objects.filter(name__endswith=\'xxx\')  # endwith\nmodels.UserInfo.objects.filter(name__contains=\'xxx\')  # 包含\nmodels.UserInfo.objects.filter(name__isnull=True)  # 判断是否为空\n```\n\n## Django中神奇的F和Q\n\n### 神奇的F\n\n```python\nfrom django.db.models import F\n\n# 比如我要把用户表的age字段的所有年龄自加一，F可以让你获取基础值\nmodels.UserInfo.objects.all().update(age=F(\'age\')+1)\n```\n\n### 神奇的Q\n\nQ可以用于构造复杂的查询条件\n\n```python\nfrom django.db.models import Q\n# 一个Q对象就是一个条件\nmodels.Userinfo.objects.filter(Q(id=1))\n# 多个Q对象实现或(or)的关系\nmodels.Userinfo.objects.filter(Q(id=1) | Q(id=2))\n# 多个Q对象实现与(and)的关系\nmodels.Userinfo.objects.filter(Q(id=1) & Q(id=2))\n\n# 第二种q的用法\ncon = Q()\nq1 = Q()\nq1.connector = \'OR\'  # q1的内部条件是什么，OR就是用或来连接，AND就是与\nq1.children.append((\'id\', 1)) # 通过append来添加不同的条件按照如上的条件进行or\nq1.children.append((\'id\', 10))\nq1.children.append((\'id\', 9))\nq2 = Q()\nq2.connector = \'OR\'\nq2.children.append((\'c1\', 1))\nq2.children.append((\'c1\', 10))\nq2.children.append((\'c1\', 9))\ncon.add(q1, \'AND\')   # 将q1和q2通过AND将两个大条件连接起来\ncon.add(q2, \'AND\')\n# 相当于\n(id=1 or id=10 or id=9) and (c1=1 or c1=10 or c1=9)\n# 按照上面的条件进行筛选\nmodels.Table_class.objects.filter(con)\n```\n\n这个可以应对来自前端页面传递过来的复杂查询：\n\n```python\n# 比如前端有很多条件要进行匹配查询，我们可以在前端把对应的数据拼成一个字典格式的json传递过来\n# 每一个大的过滤条件是一个key+value\ncondition_dict = {\n    \'k1\': [1,2,3,4],\n    \'k2\':[1,],\n}\ncon = Q()\nfor k, v in condition_dict.items():\n    q = Q()\n    # 每一个大条件之间的条件用or来匹配\n    q.connector = \'OR\'\n    for i in v:\n        q.children.appeend((\'id\', i))\n    # 大条件之前用AND来匹配，根据自己的需要。\n    con.add(q, \'AND\')\nmodels.UserInfo.objects.filter(con)\n```\n\n## Extra\n\n> 在使用mysql的时候经常会出现使用临时表的语句，比如：\n>\n> ```mysql\n> select id,name,(select count(1) from app_usertype where id>1) as count) from app_userinfo;\n> ```\n>\n> 这种临时表在ORM的操作中也是可以实现的，就是使用extra。\n>\n> 额外查询条件及相关表操作\n\n使用extra添加额外的查询，其中字典中的key n可以充当我们取出来的内容\n\n```python\n# select_params中的是按位置一个一个占位的。\nret = models.UserInfo.objects.all().extra(\n    select={\n        \'n\': \"select count(1) from app_usertype where id>%s and id < %s\",\n        \'m\': \"select count(1) from app_usertype where id>%s and id < %s\",\n    },\n    select_params=[1,3,4,6],\n)\n\nfor obj in ret:\n    print(obj.id, obj.name, obj.n)\n```\n\nextra中还可以使用where：\n\n```python\n# where后面接一个列表，列表中的元素以and连接\nmodels.UserInfo.objects.extra(\n    where=[\"id=1\",\"name=\'alex\'\"]\n)\n\n# 列表中的每个元素内部可以用or\nmodels.UserInfo.objects.extra(\n    where=[\"id=1 or id=%s\",\"name=%s\"],\n    params=[1,\'alex\']\n)\n```\n\ntables的应用\n\n```python\n# 相当于笛卡尔积:select * from app_userinfo,app_usertype\nmodels.UserInfo.objects.extra(\n    tables=[\'app_usertype\'],\n)\n\n# 使用where条件:select * from app_userinfo,app_usertype where app_usertype.id=app_userinfo.ut_id\nmodels.UserInfo.objects.extra(\n    tables=[\'app_usertype\'],\n    where=[\'app_usertype.id = app_userinfo.ut_id\']\n)\n```\n\n排序的使用：\n\n```python\n# 按照nid倒序排\nmodels.UserInfo.objects.extra(select={\'new_id\': \"select id from tb where id > %s\"}, select_params=(1,), order_by=[\'-nid\'])\n```\n\n当然上面四中条件还是可以混在一起写的：\n\n```python\nmodels.UserInfo.objects.extra(\n    select={\'newid\':select count(1) from tb1 where id>%s},\n    select_params=[1,],\n    where=[\'age>%s\'],\n    params=[18,],\n    order_by=[\'-age\',],\n    tables=[\'app_usertype\']\n)\n转换为sql以后就是如下的内容：\n\"\"\"\nselect \n\tapp_userinfo.id,  # 隐含的会取到\n\t(select count(1) from tb1 where id>1) as newid\nfrom app_userinfo,app_usertype\n\twhere \n\t\tapp_userinfo.age>18\n\torder_by\n\t\tapp_userinfo.age desc\n\t\n\"\"\"\n```\n\n## 执行原生SQL\n\n针对非常复杂的sql，django orm也是支持使用原生sql的。\n\n```python\nfrom django.db import connection, connections\n\ncursor = connection.cursor()\ncursor.execute(\'sql语句，和pymysql一样\')\nrow = cursor.fetchall()   # fetchall也有\nconnection.close()\n\n# 我们还可以使用connections去创建cursor\ncursor = connections[\'db_setting_name\'].cursor()\n\n# 在connections中可以填一个db设置的名称，这个设置的名称就是在配置文件中DATABASE部分设置的字典的key，如果存在多个数据库的话，那么我们可以配置连接不同的数据库。只要填上不同的db的配置文件的key就可以了。默认的就是default的数据。\nDATABASES = {\n    \'default\': {\n        \'ENGINE\': \'django.db.backends.mysql\',\n        \'NAME\': \'django_test\',\n        \'USER\': \'lamber\',\n        \'PASSWORD\': \'13082171785\',\n        \'HOST\': \'47.94.132.15\',\n        \'PORT\': \'3306\',\n    }\n    \'db2\': {\n\t\t……………………\n    }\n}\n\n比如：cursor = connections[\'db2\'].cursor()\n```\n\n## Django ORM细节梳理\n\n```python\n##################################################################\n# PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n##################################################################\n\ndef all(self)\n    # 获取所有的数据对象\n\ndef filter(self, *args, **kwargs)\n    # 条件查询\n    # 条件可以是：参数，字典，Q\n\ndef exclude(self, *args, **kwargs)\n    # 条件查询\n    # 条件可以是：参数，字典，Q\n\ndef select_related(self, *fields)\n     # 性能相关：表之间进行join连表操作，一次性获取关联的数据。\n     model.tb.objects.all().select_related()\n     # 会把外键字段关联的表连起来去取，相当于两个表inner join，相当于一次性查询到\n     # 如果外键存在多个的话用逗号分隔，比如select_related(\'fk1\',\'fk2\')\n     # 避免发起多次查询请求。\n     # select * from tb1 inner join tb2 on ……\n     # 有Foreign Key数据较少的时候，联表性能下降也不是很大，就可以使用这个\n     model.tb.objects.all().select_related(\'外键字段\')\n     model.tb.objects.all().select_related(\'外键字段__外键字段\')\n\ndef prefetch_related(self, *lookups)\n    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。\n    # 不做联表，多次查询\n    # 获取所有用户表\n    # 获取用户类型表where id in (用户表中的查到的所有用户ID)\n    # select * from UserInfo;\n    # Django内部：把这张表的所有\"外键字段_id\"去重，然后取到\n    # 第二次查询：select * from user_type where id in 上面取到的外键字段的id。\n    # Django会将这两个结果集整合到一起\n    # 有外键，数据很多，查询次数频繁就可以用这个。进行单表查询提高性能。\n    models.UserInfo.objects.prefetch_related(\'外键字段\')\n\n\n\n    from django.db.models import Count, Case, When, IntegerField\n    Article.objects.annotate(\n        numviews=Count(Case(\n            When(readership__what_time__lt=treshold, then=1),\n            output_field=CharField(),\n        ))\n    )\n\n    students = Student.objects.all().annotate(num_excused_absences=models.Sum(\n                models.Case(\n                    models.When(absence__type=\'Excused\', then=1),\n                default=0,\n                output_field=models.IntegerField()\n            )))\n\ndef annotate(self, *args, **kwargs)\n    # 用于实现聚合group by查询\n\n    from django.db.models import Count, Avg, Max, Min, Sum\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\'))\n    # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\')).filter(uid__gt=1)\n    # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\',distinct=True)).filter(uid__gt=1)\n    # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1\n\ndef distinct(self, *field_names)\n    # 用于distinct去重，在不同的数据源上用法不一样\n    # 比如mysql或者sqlite是不能传递参数的。\n    # 如果使用的是PG(PostGreSQL)就要这么写：\n    # models.UserInfo.objects.distinct(\'nid\')\n    \n    models.UserInfo.objects.values(\'nid\').distinct()\n    # select distinct nid from userinfo\n\n    注：只有在PostgreSQL中才能使用distinct进行去重\n\ndef order_by(self, *field_names)\n    # 用于排序\n    models.UserInfo.objects.all().order_by(\'-id\',\'age\')\n\ndef extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)\n    # 构造额外的查询条件或者映射，如：子查询\n\n    Entry.objects.extra(select={\'new_id\': \"select col from sometable where othercol > %s\"}, select_params=(1,))\n    Entry.objects.extra(where=[\'headline=%s\'], params=[\'Lennon\'])\n    Entry.objects.extra(where=[\"foo=\'a\' OR bar = \'a\'\", \"baz = \'a\'\"])\n    Entry.objects.extra(select={\'new_id\': \"select id from tb where id > %s\"}, select_params=(1,), order_by=[\'-nid\'])\n\n def reverse(self):\n    # 倒序，只有前面有order_by的时候，reverse才有用。reverse会反转order_by的所有条件\n    # 比如order_by(\'-col1\',\'col2\')，反转以后就是order_by(\'col1\',\'-col2\')\n    models.UserInfo.objects.all().order_by(\'-nid\').reverse()\n    # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序\n\n\n def defer(self, *fields):\n    models.UserInfo.objects.defer(\'username\',\'id\')\n    或\n    models.UserInfo.objects.filter(...).defer(\'username\',\'id\')\n    #映射中排除某列数据，如上即取除了username和id以外的数据。主键一定会取的。所以写不写无所谓\n\n def only(self, *fields):\n    #仅取某个表中的数据\n     models.UserInfo.objects.only(\'username\',\'id\')\n     或\n     models.UserInfo.objects.filter(...).only(\'username\',\'id\')\n     等价于：\n\t models.UserInfo.objects.filter(...).values(\'username\',\'id\')\n     # 只不过返回的依然是一个对象而不是一个元组，这个是和values不一样的地方\n     # 当然返回的obj依然可以用“.”去访问我们取的之外的字段，但是会引发新的sql查询\n     # 因此当使用only的时候你取谁了，就用谁，不要多余的去访问其他的字段属性，会造成额外查询降低sql的性能。不要多拿，要是多拿还不如不写，或者你干脆多取就的了。\n       \n def using(self, alias):\n     # 指定使用的数据库，参数为别名（setting中的设置，事先得有这个表。\n     models.UserInfo.objects().all.using(\'db2\')\n\n\n##################################################\n# PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #\n##################################################\n\ndef raw(self, raw_query, params=None, translations=None, using=None):\n    # 执行原生SQL，返回的内容是userinfo的对象\n    models.UserInfo.objects.raw(\'select * from userinfo\')\n\n    # 如果SQL是其他表时，必须将列名字设置为当前UserInfo对象的主键列名\n    models.UserInfo.objects.raw(\'select id as nid from 其他表\')\n\n    # 为原生SQL设置参数\n    models.UserInfo.objects.raw(\'select id as nid from userinfo where nid>%s\', params=[12,])\n\n    # 将获取的到列名转换为指定列名\n    name_map = {\'first\': \'first_name\', \'last\': \'last_name\', \'bd\': \'birth_date\', \'pk\': \'id\'}\n    # 相当于first as first_name;last as last_name\n    Person.objects.raw(\'SELECT * FROM some_other_table\', translations=name_map)\n\n    # 指定数据库\n    models.UserInfo.objects.raw(\'select * from userinfo\', using=\"default\")\n\n    ################### 原生SQL ###################\n    from django.db import connection, connections\n    cursor = connection.cursor()  # cursor = connections[\'default\'].cursor()\n    cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1])\n    row = cursor.fetchone() # fetchall()/fetchmany(..)\n\n\ndef values(self, *fields):\n    # 获取每行数据为字典格式\n\ndef values_list(self, *fields, **kwargs):\n    # 获取每行数据为元祖\n\ndef dates(self, field_name, kind, order=\'ASC\'):\n    # 根据时间进行某一部分进行去重查找并截取指定内容\n    # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日）\n    # order只能是：\"ASC\"  \"DESC\"\n    # 并获取转换后的时间\n        - year : 年-01-01\n        - month: 年-月-01\n        - day  : 年-月-日\n\t# ctime字段名，day上面的格式（只能写上面三个），desc倒序。\n    models.DatePlus.objects.dates(\'ctime\',\'day\',\'DESC\')\n\ndef datetimes(self, field_name, kind, order=\'ASC\', tzinfo=None):\n    # field name就是时间字段\n    # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间\n    # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"\n    # order只能是：\"ASC\"  \"DESC\"\n    # tzinfo时区对象\n    models.DDD.objects.datetimes(\'ctime\',\'hour\',tzinfo=pytz.UTC)\n    models.DDD.objects.datetimes(\'ctime\',\'hour\',tzinfo=pytz.timezone(\'Asia/Shanghai\'))\n\n    \"\"\"\n    # 时区的转换需要安装这个模块\n    pip3 install pytz\n    import pytz\n    pytz.all_timezones\n    pytz.timezone(‘Asia/Shanghai’)\n    \"\"\"\n\ndef none(self):\n    # 空QuerySet对象，什么都不取。\n\n\n####################################\n# METHODS THAT DO DATABASE QUERIES #\n####################################\n\ndef aggregate(self, *args, **kwargs):\n   # 聚合函数，获取字典类型聚合结果\n   # 计算整个表的聚合结果(分组)\n   from django.db.models import Count, Avg, Max, Min, Sum\n   # 如果包含distinct的话会先进行去重，然后再进行聚合\n   result = models.UserInfo.objects.aggregate(k=Count(\'ut_id\', distinct=True), n=Count(\'nid\'))\n   ===> {\'k\': 3, \'n\': 4}\n\ndef count(self):\n   # 获取个数\n\ndef get(self, *args, **kwargs):\n   # 获取单个对象\n   models.UserInfo.objects.get(id=1)\n\ndef create(self, **kwargs):\n   # 创建对象，会有一个返回值，这个返回值就是增加的这条数据\n   obj = models.UsetType.objects.create(title=\'xxx\')\n   obj = models.UsetType.objects.create(**dict_data)\n  \n   # 使用save提交\n   obj = models.UserType(title=\'xxx\')\n   obj.save()\n\ndef bulk_create(self, objs, batch_size=None):\n    # 批量插入\n    # batch_size表示一次插入的个数\n    objs = [\n        models.DDD(name=\'r11\'),\n        models.DDD(name=\'r22\')\n    ]\n    # 这里的10指的是一次最多提交10个对象，最多不要超过999\n    models.DDD.objects.bulk_create(objs, 10)\n\ndef get_or_create(self, defaults=None, **kwargs):\n    # 如果存在，则获取，否则，创建\n    # defaults 指定创建时，其他字段的值\n    # 如果能找到username=root1的，那么就直接返回对象，忽略后面的参数。\n    # 否则就创建，并按照defaults中的内容填充其他字段数据。\n    # obj返回查询的对象，created返回创建的结果，返回true或者false\n    obj, created = models.UserInfo.objects.get_or_create(username=\'root1\', defaults={\'email\': \'1111111\',\'u_id\': 2, \'t_id\': 2})\n\ndef update_or_create(self, defaults=None, **kwargs):\n    # 如果存在，则更新，否则，创建\n    # defaults 指定创建时或更新时的其他字段\n    obj, created = models.UserInfo.objects.update_or_create(username=\'root1\', defaults={\'email\': \'1111111\',\'u_id\': 2, \'t_id\': 1})\n\ndef first(self):\n   # 获取第一个\n\ndef last(self):\n   # 获取最后一个\n\ndef in_bulk(self, id_list=None):\n   # 根据主键ID进行查找，相当于in操作。不同于__in的就是是根据主键查找\n   id_list = [11,21,31]\n   models.DDD.objects.in_bulk(id_list)\n\ndef delete(self):\n   # 删除\n\ndef update(self, **kwargs):\n    # 更新\n\ndef exists(self):\n   # 是否有结果\n```\n\n## 总结\n\nDjango执行原生sql的三种方法：\n\n- 原生sql\n- extra\n- raw","timestamp":1531448340028},{"name":"04-Django 中间件.md","path":"06-Django/04-Django 中间件.md","content":"# MiddleWare\n\n> 用户请求到达视图函数之前还隔着一层中间件，django 中的中间件（middleware），在django中，中间件其实就是一个类，在请求到来和结束后，django会根据自己的规则在合适的时机执行中间件中相应的方法。\n\n## 了解中间件\n\n 中间件中可以定义五个方法，分别是：\n\n - process_request(self,request)\n - process_view(self, request, callback, callback_args, callback_kwargs)\n - process_template_response(self,request,response)\n - process_exception(self, request, exception)\n - process_response(self, request, response)\n\n```python\n# Django的Settings文件。\nMIDDLEWARE = [\n    \'django.middleware.security.SecurityMiddleware\',\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.middleware.common.CommonMiddleware\',\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    \'django.contrib.messages.middleware.MessageMiddleware\',\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n]\n```\n\n对应到Django中其实就是一个个的类，请求进来是一套方法，请求返回又是一套方法。在每一层中间件的时候如果遇到了错误，就不会继续执行了而是直接返回，根本到达不了视图函数。\n\n以上方法的返回值可以是None和HttpResonse对象，如果是None，则继续按照django定义的规则向下执行，如果是HttpResonse对象，则直接将该对象返回给用户。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/45908211.jpg)\n\n比如我们在这里做一个黑名单的功能，拦下一些ip地址。\n\n```python\n# 自定义中间件\nfrom django.utils.deprecation import MiddlewareMixin\n\nclass M1(MiddlewareMixin):\n    def process_request(self, request):\n \t\tpass\n    \n    def process_response(self, request, response):\n        # 在response的时候要返回给下一个中间件\n        # request不用return，因为django内部帮忙操作了。添上反而有问题。\n        # 你如果在request部分返回值，中间件就不继续往下执行了。\n        return response\n```\n\n在配置文件中，中间件是一个有序列表，因此中间件也是按照顺序进行执行的。\n\n- 类\n  - process_request：django为你做了返回，如果自己添加的话中间件不会进一步运行\n  - process_response：需要有一个返回值\n- 注册中间件\n\n## 中间件的执行流程\n\n### process_request&process_response\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/35856559.jpg)\n\n中间绿色块是中间件层，每一个橙色的方块代表一个中间件，正常来讲是这样一个流程，当process_request有返回值的时候，就会停止请求下一个，找到自己的process_response返回。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/6924732.jpg)\n\n不过上面这个是django1.10以后的一个流程，在1.10之前的流程并不是这样的。稍微有些小小的不同，在较低版本，如果说某一个中间件的process_request有了返回值的话，它会找到最后一个中间件的process_response然后返回。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/94437225.jpg)\n\n### process_view\n\n中间件除了request和response外还有一个process_view方法\n\n```python\ndef process_view(self, request, callback, callback_args, callback_kwargs):\n    pass\n\ncallback是路由匹配对应的url函数的函数名。\n```\n\n那么这个process_view的执行顺序又是如何的呢？来看一下这个例子：\n\n```python\n# app01/md.py\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass M1(MiddlewareMixin):\n\n    def process_request(self, request):\n        print(\'M1-process-request\')\n\n    def process_response(self, request, response):\n        print(\"M1-process-response\")\n        return response\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        print(\'M1-process-view\')\n\n\nclass M2(MiddlewareMixin):\n\n    def process_request(self, request):\n        print(\'M2-process-request\')\n\n    def process_response(self, request, response):\n        print(\"M2-process-response\")\n        return response\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        print(\'M2-process-view\')\n```\n\n然后再settings中注册一下这两个中间件的组件：\n\n```python\n# settings.py\nMIDDLEWARE = [\n    \'django.middleware.security.SecurityMiddleware\',\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.middleware.common.CommonMiddleware\',\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    \'django.contrib.messages.middleware.MessageMiddleware\',\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n    \'middleware.md.M1\',\n    \'app01.md.M1\',\n    \'app01.md.M2\'\n]\n```\n\n我们随便定义个url去访问然后看终端控制台print的值结果为：\n\n```python\nM1-process-request\nM2-process-request\nM1-process-view\nM2-process-view\nM2-process-response\nM1-process-response\n```\n\n可以发现顺序是这样的：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/10046146.jpg)\n\n从上面的代码可以看到目前的process_view是没有返回值的。没有返回值的情况下，目前是这么个流程。我们发现process_view的参数多了很多，打印一下callback可以发现这个其实返回的就是我们的视图函数的地址。其实也就是说执行到process_view的时候我们已经可以拿到视图函数了，就是通过这个callback去拿就可以。那么现在加以改造上面的中间件写法，单独修改一下M1：\n\n```python\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass M1(MiddlewareMixin):\n\n    def process_request(self, request):\n        print(\'M1-process-request\')\n\n    def process_response(self, request, response):\n        print(\"M1-process-response\")\n        return response\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        print(\'M1-process-view\')\n        response = callback(request, *callback_args, **callback_kwargs)\n        return response\n```\n\n我们为process_view添加上返回值。再次观察终端输出的值\n\n```python\nM1-process-request\nM2-process-request\nM1-process-view\nM2-process-response\nM1-process-response\n```\n\n可以发现执行了M1的process_view，但是跳过了M2的process_view，我们在M1的process_view中去主动的调用视图函数了，所以流程可以归结如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/32736201.jpg)\n\n1. 先依次走完每个中间件的process_request\n2. 然后折返到最初的中间件去执行对应的各个中间件的process_view，当没有返回值的时候会依此执行每个中间件的process_view，当有返回值的时候，从这个中间件往下的其他中间件的process_view不会继续执行，而是直接去调用视图函数。\n3. 从最后一个中间件的process_response逐个返回。\n\n### process_exception\n\n这个方法会捕获视图函数中的错误，默认并不会执行，只有视图函数中报错的时候才会执行。执行流程如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/51116656.jpg)\n\n遇到视图函数报错以后会从最后一个中间件的exception依次执行到第一个，然后再折返到最后一个中间件去执行process_response然后返回。形状就像一个鸡爪或者两个闪电~，目前是exception没有返回值，一旦exception有返回值的时候那么就不会继续往下执行了。就算是谁把错误处理了以后就不会继续往下执行了。而是直接折返到最后一个中间件去执行process_response依次执行到第一个。\n\n### process_template_response(self, request, response)\n\n针对视图函数的返回值做一个要求，如果有render方法才会被调用，其他情况下是不会被调用的。这个render函数我们可以自己去定义，只要是名称为render：\n\n```python\n# 在视图函数中\nfrom django.shortcuts import render,HttpResponse\nimport json\n\nclass Foo:\n    def __init__(self,req,status,msg):\n        self.req = req\n        self.status = status\n        self.msg = msg\n    def render(self):\n        ret = {\n            \'status\':self.status,\n            \'msg\':self.msg\n        }\n        return HttpResponse(json.dumps(ret))\n    \ndef test(request):\n    return Foo(request,True,\"错误信息\")\n```\n\n相当于我们做一个类将信息封装成json格式给用户返回，而且我们定义了一个render方法，这样就会触发中间件的process_template_response方法（返回的对象中有render方法），然后通过这个方法可以再对返回内容做一定的规范和要求。\n\n## 小结\n\n到底什么时候开始应用中间件：\n\n- 适用于对所有请求或者一部分请求做批量处理。（比如针对所有的用户请求做日志统计）\n- 可以应用于请求做判断进行缓存应用的处理。","timestamp":1531448340028},{"name":"01-01-Form组件.md","path":"06-Django/05-Django Form/01-01-Form组件.md","content":"# Form组件\n\n[TOC]\n\n>Form组件能为我们做什么呢？\n>\n>- 根据用户请求对数据做验证\n>- 根据用户的输入还可以输出对应的错误信息\n>- 获取到数据然后进行验证，验证通过后对正确的信息进行打包并提交。\n>- 保留上一次的输入内容\n>- Form组件还可以创建HTML标签，通过挂件指定样式。\n>\n>在数据库操作之前进行一些规则的验证。\n\n问题：\n\n- 无法记住上次提交的内容，因此页面刷新数据消失\n- 重复的进行用户数据的校验：正则，长度，是否为空。\n\n## Form组件的简单使用\n\n### 定义组件\n\n```python\n# 首先简单定义一个Form组件，用于登录验证\n# 我们在app下新建一个form.py文件用于我们定义的Form验证规则\nfrom django.forms import fields, Form\n\nclass LoginForm(Form):\n    username = fields.CharField(\n        max_length=18,\n        min_length=6,\n        required=True,\n    )\n    password = fields.CharField(\n        max_length=16,\n        min_length=6,\n        required=True\n    )\n```\n\n### 组件的应用\n\n```python\n# 在views视图中直接调用，直接添加一个url路由用于匹配\nform main import form\n\ndef login(request):\n    if request.method == \'GET\':\n        # 当我直接访问的时候就直接返回登录页面\n        return render(request, \'login.html\')\n    else:\n        # 生成一个LoginForm的对象，要将用户在前端输入的账号密码传入\n        obj = form.LoginForm(request.POST)\n        # 调用对象的is_vaild方法进行规则的校验\n        # 返回值为True or False，因此直接调用is_valid()就可以\n        # 这个是由Django内部提供的一个验证机制。\n        if obj.is_valid():\n            # obj.cleaned_data是一个字典，就是验证通过后，用户提交的数据\n            # 这样如果遇到注册的时候创建用户直接使用create(**kwargs)就行了\n            print(obj.cleaned_data)\n            # 我们先让他说验证规则通过以后重定向到百度\n            return redirect(\'https://www.baidu.com\')\n        else:\n            # 如果验证不通过应该打印错误信息，Django内部也为我们提供了这种机制。\n            # obj.errors是所有的错误信息\n            # 这是一个对象，但是内部有一个__str__方法因此我们看到的是一大串html字符串\n            # 假如说用户没有输入错误的话那么就直接拿不到了会报错，这个其实我们不用太关心，因为我们不会在后台用，而是直接扔到前端里去。我拿不到顶多不显示就完了。\n            print(obj.errors)\n            print(obj.errors[\'username\'])\n            # 错误可以是存在多个的\n            # 拿多个错误信息的第一个，只要错误信息没满足就有问题，我们永远拿第一个就行了\n            print(obj.errors[\'password\'][0])\n            return render(request, \'login.html\', {\n                \'obj\': obj\n            })\n```\n\n### 校验的报错\n\n假如说没有满足验证规则的话就会进行报错，报错的内容如下：\n\n```html\n# 这个是obj.errors的内容，这里包含了所有的错误信息。\n# 本身这是一个对象，但是因为实现了__str__方法因此我们可以看到一大堆的字符串。\n<ul class=\"errorlist\">\n    <li>\n        username\n        <ul class=\"errorlist\">\n            <li>Ensure this value has at least 6 characters (it has 1).</li>\t\t</ul>\n    </li>\n    <li>password\n        <ul class=\"errorlist\">\n            <li>Ensure this value has at least 6 characters (it has 2).</li>\t\t</ul>\n    </li>\n</ul>\n```\n\n同样我们可以使用`obj.errors[\'username\']`单独拿某一个name属性的报错。\n\n```html\n<ul class=\"errorlist\">\n    <li>Ensure this value has at least 6 characters (it has 1).</li>\n</ul>\n```\n\n对应的前端界面如下：\n\n```html\n<form  method=\"post\">\n    {% csrf_token %}\n    <!--或者只取第一个{{ obj.errors.username.0 }}，因为有可能你这个输入的内容好多条规则都没有匹配，那么错误信息就应该有多个，我们没有必要在前端把所有的报错都显示出来，只需要显示报错就行了，因此只要你有报错我只让你显示第一个就好，如果没有报错的话，那就不需要显示了。-->\n    <p>用户名：<input type=\"text\" name=\"username\" />{{ obj.errors.username }}</p>\n    <p>密码：<input type=\"password\" name=\"password\" />{{ obj.errors.password }}</p>\n    <p><input type=\"submit\" value=\"提交\"></p>\n</form>\n```\n\n效果如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-26/5961066.jpg)\n\n### 自定义错误信息\n\n通过上图可以发现，这个报错是英文的，那么可不可以进行自定义呢？当然是可以的。\n\n```python\n# 修改我们的form文件\nclass LoginForm(Form):\n    username = fields.CharField(\n        max_length=18,\n        min_length=6,\n        required=True, # 这个默认是必填项，就算你不写出来也会包含这个默认项\n        error_messages={\n            \'required\': \'不能为空\',\n            \'min_length\': \'太短了！\',\n            \'max_length\': \'太长了！！！！\',\n        }\n    )\n    password = fields.CharField(\n        max_length=16,\n        required=True,\n        min_length=6,\n    )\n```\n\n添加上error_message参数就可以了，error_message对应的是一个字典，key是对应的我们添加的约束项目，比如min_length最小长度，max_length最大长度啊，required是否必填不能为空什么的，对应的value就是要报错的值，这样的话就可以将原来的内容替换成我们想写的内容了。\n\n一般来说，如果格式不对的话对应的error_message的key是`invalid`，针对其他的fields还有其他的属性，比如数字Integer属性，有数字的最大值`max_value`，最小值`min_value`等一些特殊的属于自己的属性。具体的可以参考下面的Django Form字段属性。\n\n## Django Form字段属性\n\n> 针对Django Form中不同的类型都有什么属性，比如Integer和CharField都是继承fields，因此它们都可以使用fields中的属性，emailField继承自CharField，那么它也可以把CharField中的属性继承下来，我们知道EmailField本质其实就是CharField。IntegerField会主动的调用父类的构造方法，CharField也是。如下，可以看到IntegerField主动的去调用父类的Field了，父类的构造方法还有一堆参数。\n>\n> ```python\n> def __init__(self, *, max_value=None, min_value=None, **kwargs):\n>     self.max_value, self.min_value = max_value, min_value\n>     if kwargs.get(\'localize\') and self.widget == NumberInput:\n>         # Localized number input is not well supported on most browsers\n>         kwargs.setdefault(\'widget\', super().widget)\n>     super().__init__(**kwargs)\n> ```\n>\n> 具体都有什么属性可以查看下面的内容\n\n- fields\n\n  ```python\n  required=True,               是否允许为空，默认的都是True，可以不用写\n  widget=None,                 HTML插件\n  label=None,                  用于生成Label标签或显示内容\n  initial=None,                初始值\n  help_text=\'\',                帮助信息(在标签旁边显示)\n  error_messages=None,         错误信息 {\'required\': \'不能为空\', \'invalid\': \'格式错误\'}\n  show_hidden_initial=False,   是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直）\n  validators=[],               自定义验证规则，在原有的规则上继续添加正则\n  localize=False,              是否支持本地化，比如时间的时区。\n  disabled=False,              是否可以编辑\n  label_suffix=None            Label内容后缀\n  ```\n\n- URLField(Field)\n\n- BooleanField(Field)  \n\n- NullBooleanField(BooleanField)\n\n- CharField\n\n  ```python\n  max_length=None,             最大长度\n  min_length=None,             最小长度\n  strip=True                   是否移除用户输入空白，strip属性是默认的，默认为true。\n  \n  UUIDField(CharField)         uuid类型\n  SlugField(CharField)         数字，字母，下划线，减号（连字符）\n  ```\n\n- IntegerField\n\n  ```python\n  max_value=None,              最大值\n  min_value=None,              最小值\n  \n  # FloatField(IntegerField)\n  ```\n\n- DecimalField(IntegerField)\n\n  ```python\n  max_value=None,              最大值\n  min_value=None,              最小值\n  max_digits=None,             总长度\n  decimal_places=None,         小数位长度\n  ```\n\n- BaseTemporalField(Field)\n\n  ```python\n  input_formats=None               时间格式化\n  # 其他继承BaseTemporalField的\n  DateField(BaseTemporalField)     格式：2015-09-01\n  TimeField(BaseTemporalField)     格式：11:12\n  DateTimeField(BaseTemporalField) 格式：2015-09-01 11:12\n  ```\n\n- DurationField(Field)            时间间隔：%d %H:%M:%S.%f\n\n- RegexField(CharField)    如果提供的不够用，支持自己书写正则表达式\n\n  ```python\n  regex,                      自定制正则表达式\n  max_length=None,            最大长度\n  min_length=None,            最小长度\n  error_message=None,         忽略，错误信息使用 error_messages={\'invalid\': \'...\'}\n  ```\n\n- EmailField(CharField)\n\n- FileField(Field)              \n\n  ```python\n  allow_empty_file=False     是否允许空文件\n  ```\n\n- ImageField(FileField) \n\n  ```python\n  注：需要PIL模块，pip3 install Pillow\n  以上两个字典使用时，需要注意两点：\n      - form表单中 enctype=\"multipart/form-data\"\n      - view函数中 obj = MyForm(request.POST, request.FILES)\n  ```\n\n- ChoiceField(Field)\n\n  ```python\n  choices=(),                选项，如：choices = ((0,\'上海\'),(1,\'北京\'),)\n  required=True,             是否必填\n  widget=None,               插件，默认select插件\n  label=None,                Label内容\n  initial=None,              初始值\n  help_text=\'\',              帮助提示\n  ```\n\n- MultipleChoiceField(ChoiceField)\n\n- ModelChoiceField(ChoiceField)\n\n  ```python\n  ...                        django.forms.models.ModelChoiceField\n  queryset,                  # 查询数据库中的数据\n  empty_label=\"---------\",   # 默认空显示内容\n  to_field_name=None,        # HTML中value的值对应的字段\n  limit_choices_to=None      # ModelForm中对queryset二次筛选\n  ```\n\n- ModelMultipleChoiceField(ModelChoiceField)\n\n  ```python\n  ...                        django.forms.models.ModelMultipleChoiceField\n  ```\n\n- TypedChoiceField(ChoiceField)\n\n  ```python\n  coerce = lambda val: val   对选中的值进行一次转换\n  empty_value= \'\'            空值的默认值\n  ```\n\n- TypedMultipleChoiceField(MultipleChoiceField)\n\n  ```python\n  coerce = lambda val: val   对选中的每一个值进行一次转换\n  empty_value= \'\'            空值的默认值\n  ```\n\n- ComboField(Field)，多个验证规则组合\n\n  ```python\n  fields=()                  \n  # 使用多个验证，如下：即验证最大长度20，又验证邮箱格式\n  fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])\n  ```\n\n- MultiValueField(Field)\n\n  ```python\n  PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用\n  ```\n\n- SplitDateTimeField(MultiValueField)\n\n  ```python\n  input_date_formats=None,   格式列表：[\'%Y--%m--%d\', \'%m%d/%Y\', \'%m/%d/%y\']\n  input_time_formats=None    格式列表：[\'%H:%M:%S\', \'%H:%M:%S.%f\', \'%H:%M\']\n  ```\n\n- FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中\n\n  ```python\n  path,                      文件夹路径\n  match=None,                正则匹配\n  recursive=False,           递归下面的文件夹\n  allow_files=True,          允许文件\n  allow_folders=False,       允许文件夹\n  required=True,\n  widget=None,\n  label=None,\n  initial=None,\n  help_text=\'\'\n  ```\n\n- GenericIPAddressField\n\n  ```python\n  protocol=\'both\',           both,ipv4,ipv6支持的IP格式\n  unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，\n              \t\t\t   可解析为192.0.2.1， PS：protocol必须为both才能启用\n  ```\n\n### 自定制正则表达式\n\n举个🌰：\n\n```python\n# regexfield继承charfield，可以使用是否为空，最长最短，还有自己写的，一共4种\nt = fields.RegexField(\'139\\d+\', error_messages={\'invalid\': \'格式错误\'})\n```\n\n## 简单实现原理\n\nfields本质就是验证规则，说验证规则实质就是正则表达式验证。可以说我们写的这个Form类似一个校验的模板。下面来看一下内部是如何实现验证的（is_valid的实现过程）。\n\n1. 每一次实例化Form组件类的时候，会先执行一个操作，就是把当前定义的字段放到self.fields中来。\n\n   ```python\n   # 实例化的时候：obj = LoginForm(request.POST)找到对应的Form组件类中的所有字段\n   # 把这些字段放到self.fields中\n   self.fields = {\n       \'username\': fields.CharField(xxxxx) # 包含正则表达式\n       \'password\': 正则2\n   }\n   ```\n\n2. 循环self.fields：\n\n   ```python\n   flag = True\n   errors = xxx  # 当数据校验失败的时候，将内容放到errors中来\n   cleand_data = xxx  # 当数据校验成功的时候，将内容放到cleand_data中。\n   for k, v in self.fields.items():\n     # k就是每个name属性字段，比如username，password，v就是对应的正则表达式\n     # 获取到用户输入的内容\n     input_value = request.POST.get(k)\n     # 通过正则表达式和用户输入的内容按照正则表达式进行匹配。\n     # 如果说校验成功，就返回True的flag并发成功的数据放入到cleaned_data\n     # 如果说校验失败了，返回一个False的flag，并把数据放到errors\n     # 注意这里是但凡有一条校验失败都会返回false\n     if not 正则校验，用re.match(xxxxx):\n    \tflag = False\n     return flag标志位\n   ```","timestamp":1531448340028},{"name":"02-02-Form生成HTML.md","path":"06-Django/05-Django Form/02-02-Form生成HTML.md","content":"# 使用Form生成HTML\n\n[TOC]\n\n## 简单实现\n\n> widget,label,disabled,label_suffix,initial,help_text其实是放在一起使用的，他可以帮你自动生成html标签。生成html标签不是目的，\n\n先写一个测试的form类：\n\n```python\n# 实质就是返回fields.CharField内部的__str__方法返回一串html代码字符串\nclass TestForm(Form):\n    t1 = fields.CharField(\n        max_length=10,\n        required=True, \n        label=\"用户名\",\n        help_text=\"我是这个输入框的帮助信息\",\n        # 表单的默认值\n        initial=\'666\',\n    )\n```\n\n然后在视图函数中调用\n\n```python\ndef testform(request):\n    if request.method == \"GET\":\n        obj = form.TestForm()\n        return render(request, \'testform.html\', {\n            \'obj\': obj,\n        })\n    else:\n        pass\n```\n\n在前端视图模板中进行调用：\n\n```html\n<form method=\"post\" id=\"f1\">\n    {% csrf_token %}\n    {{ obj.t1.label }}  # 这样调用只是简单的显示出来\n    {{ obj.t1 }}\n    {{ obj.t1.help_text }}   # 这样调用只是简单显示，但是并不是这么用的。\n    <input type=\"submit\">\n</form>\n```\n\n在前端界面就会生成如下的input输入框，这个就是form为我们生成的。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-27/6070256.jpg)\n\n其实比起上面的这种调用方式还有一种更为简单的调用方式：\n\n```python\n# 这种方式的实现原理是去对象把所有的字段找到，然后生成html标签，对应的参数也会应用上，比如help_text，label_suffix这种参数都会被应用。这种方法其实不太灵活\n{{ obj.as_p }}\n{{ obj.as_ul }}\n{{ obj.as_table }}\n\n# 使用ul的时候记得在外层套一个ul标签，生成table的时候在外面套一个table标签；这俩内容只生成标签内部的东西。\n```\n\n两种方法都可以使用，一个简单，一个控制灵活，因此如果真要用的话建议使用控制更为灵活的。范例如下\n\n```python\nlabel = \'xxxxx\'\n\n<form method=\"POST\" enctype=\"multipart/form-data\">\n    {% csrf_token %}\n    \n        {{ form.xxoo.label }} # 可以把class中定义的label内容显示出来\n        {{ form.xxoo.id_for_label }}\n        {{ form.xxoo.label_tag }}\n        {{ form.xxoo.errors }}\n        <p>{{ form.user }} {{ form.user.errors }}</p>\n        <input type=\"submit\" />\n</form>\n\n# 这里注意一下这个id_for_label的用法\n<form>\n    <div class=\"form-group\">\n        <label for=\"{{ obj.username.id_for_label }}\">用户名</label>\n        {{ obj.username }}\n    </div>\n</form>\n\n# 会生成如下的html，实现label和input的捆绑\n<div class=\"form-group\">\n    <label for=\"id_username\">用户名</label>\n    <input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"请输入您的用户名\" maxlength=\"32\" minlength=\"6\" required=\"\" id=\"id_username\">\n</div>\n```\n\n## 保存用户上次的数据\n\n```python\ndef testform(request):\n    if request.method == \"GET\":\n        # 在这里生成的是一个不带value值的input标签\n        obj = form.TestForm()\n        return render(request, \'testform.html\', {\'obj\': obj,})\n    else:\n        # 先别管用户数据对不对，用户提交的数据肯定是过来了\n        # 那么就会生成一个input标签带着value值，值为用户输入的值(因为传递了用户的POST数据)\n        obj = form.TestForm(request.POST)\n        if obj.is_valid():\n            # 数据验证部分\n            print(obj.cleaned_data)\n        else:\n            # 数据验证失败\n            print(obj.errors)\n        return render(request, \'testform.html\', {\'obj\': obj})\n```\n\nForm生成html标签，单独使用意义不大，结合POST请求生成HTML标签更有意义。会携带value属性，带着数据。解决Form上次输入内容。目前为止比较流行的浏览器都会为我们做一部分验证，我们在学习调试的过程中为了避免干扰可以在form表单中添加`novalidate`属性来规避这个问题。当然实际生产中当然是不要加这个参数，白给的一个验证为什么不加，对吧~\n\n## 修改数据\n\n> 一般修改数据的时候，要显示原来的数据，那么怎么让数据在修改的时候显示初始化的一个原来的值呢？\n\n```python\n# 这个字典就是你从数据库取出来的一个原来的数据，那么你在数据库取数据的时候你就得考虑一下怎么取数据了，应该用values给取出来一个字典放在这里\n# 默认也可以直接在这放一个字典，因为默认的就是data=字典，你不写这个data的时候默认就是data，系统会默认给你补上。而且这种方式会默认进行校验，也就是你这个默认初始值不对的话可是会报错的。放到obj.errors中。\nobj = ClassForm(data = 字典) \n```\n\n如果想要默认不进行校验的话需要传递另外一个参数，initial参数。这样就不会进行校验了。\n\n```python\nobj = ClassForm(initial = 字典) # 内部不会进行校验，让页面显示初始值\n\n# 示例\nrow = models.Student.objects.filter(id=nid).values(\'name\',\'email\',\'age\',\'cls_id\').first()\nobj = StudentForm(initial=row)\n# 体现预先选中的效果，value为1，2，3的会被提前默认选中\n# obj = xxxForm(initial={\'name\':xxxx, \'多选框字段\': [1,2,3])\n```\n\n## 数据的更新\n\n当修改后的数据提交过来以后，如何进行更新，和create的时候差不多，注意的是，针对更新的是针对某一个数据更新，记得要做一次内容的过滤（filter）：\n\n```python\n# 同样支持传递一个字典的方式进行更新。\nmodels.Classes.objects.filter(id=nid).update(**obj.cleand_data)\n```\n\n### Tips\n\n**添加数据的小技巧**\n\n小提醒，一般要插入数据库的一些内容，我们在定制Form组件的时候，我们的字段名称要和数据库中的字段名称是一致的，因为orm在create数据的时候是允许填入一个字典的，比如：\n\n```python\nmodels.xxx.objects.create(**obj.cleaned_data)\n```\n\n这样我们就可以方便的去添加用户数据了，这样插入数据就方便很多了。\n\n## widget挂件\n\n> 上面说了这么多，又有label，又有什么help_text，其实这一堆东西都是不建议使用，当然除了widget，widget其实是用来定制生成怎样的html的。\n\n用widget来指定生成的html标签是哪一种\n\n```python\nfrom django.forms import widgets\n\n# 指定生成的html标签是哪一种\nwidget = widgets.Select\n```\n\n### 单选下拉框\n\n单选下拉菜单，虽然这里显示的是名称，但是提交的却是id，所以可以直接更新或者修改数据库。\n\n```python\n# 这里其实choices接收的是一个列表（元组），列表中是一个个的小元组，那么我们就可以利用orm的values_list来取出来对应的格式。\n\"\"\"\nwidget = widgets.Select(choices=(\n\t(xx,xx),(xx,xx)\n))\n\"\"\"\nclass xxxForm(Form):\n    gender = fields.IntegerField(\n        widget=widgets.Select(choices=models.xxx.objects.values_list(\'id\', \'other_colume\'))\n    )\n    \n# 单选还可以使用ChoiceField，并且ChoiceField也只能搞单选。搞单选的时候IntergerField和ChoiceField本质一致，区别不大，因此都可以用来生成单选下拉框。\nxx = fields.ChoiceField(\n\tchoice=models.Classes.objects.values_list(\'id\',\'title\'),\n    widget=widgets.Select(attrs={\'class\': \'classxxxx\'})\n)\n```\n### 应用样式属性\n\n让我们的组件应用css的样式\n\n```python\n# 当然attrs里面可以写很多属性，class只是其中之一而已。\nwidget = widget.TextInput(attrs={\n    \'class\': \'form-control\',\n})\n```\n### 多选下拉框\n\n```python\n# 因为是多选的，是以widget要使用SelectMultiple，而不是Select，一旦使用了Select那么就说明我要生成的是单选的，即使你在widget中添加一个attr为\'multiple\'的属性也是不可以的。异常的表现就是不管你前端多选了一个，最后在后台获取到的提交的数据之后一个。\n# 因为它在内部是使用request.POST.get(\'xx\')去获取的，那么只能获取到一个\n# 要获取多个是request.POST.get_list，因此这里拿到的是一个数据。\n# 修改为以下的写法\nclass xxxForm(Form):\n    teacher = fields.CharField(widget=widgets.SelectMultiple(choice=models.xxx.objects.values_list(\'id\', \'title\')))\n\n    \n# 显示到前端以后查看的话其实显示是正常的，但是提交的时候我们会发现一个问题。比如我选了id为1号和2号的，根据我们的理解应该提交上来一个列表里，包含着1和2。但是到这里还不对。\n# 得到的值是形如：\"[\'1\',\'2\']\"这样列表形式的字符串，是str格式的，[\'1\',\'2\']是selectMultiple得到的，转换成字符串是CharField给我们多此一举。这种情况下针对单选的时候用CharField其实是没什么问题的，但是针对多选的话就有问题了。因此就不能使用CharField了。\n# 因此使用多选的时候要使用MultipleChoiceFiled+choices结合使用。\nxx = fields.MultipleChoiceField(\n\tchoice=models.Classes.objects.values_list(\'id\',\'title\'),\n    widget=widgets.SelectMultiple\n)\n```\n\n如果数据正确的话那么就应该添加数据了，有的时候可能要多表添加，或者你获取的字段并不是所有字段都需要作为添加的内容，因此有时候一个提交过来的大字典里要剔除去一些字段就可以使用pop\n\n```python\n# pop可以单独把其中一个数据拿出来。假如有这么一个关系，比如添加老师的时候，在前台填写的时候肯定是把老师以及老师任教班级这个关系都写上，但是如果是一个新老师的话还得添加新老师，所以应该先加老师，但是提交过来的任教班级又不能添加到老师表里，因此我们把选择的老师班级拿出来。\nxx = obj.cleaned_data.pop(\'xx\')\nrow = models.Teacher.objects.create(**obj.cleaned_data)\n# 然后再操作老师上课的关系表\nrow.c2t.add(*xx)  # xx = [\'1\',\'2\']\n```\n\n#### 解决静态字段不能实时显示的bug\n\n> 问题背景：比如我们要维护一个教务系统，要添加老师，添加老师的时候除了有老师的基本信息外，还有老师的所属班级，班级有一个单独的班级表，老师表是外键过去的。现在程序启动起来以后我实时的添加班级，但是发现在添加老师的时候在多选列表中并没有显示我们之前新添加的内容。这就是我们这里说到的一个实时显示的bug问题。\n\n首先回顾一下静态方法\n\n```python\nIn [1]: class FormTest2:\n    ...:     a = \'bbb\'\n    ...:     def __init__(self, name):\n    ...:         self.name = name        \n\nIn [2]: a = FormTest2(\'lamber\')\n\nIn [3]: b = FormTest2(\'mxy\')\n\nIn [4]: a.name\nOut[4]: \'lamber\'\n\nIn [5]: b.name\nOut[5]: \'mxy\'\n\nIn [6]: id(a.name)\nOut[6]: 4332738072\n\nIn [7]: id(b.name)\nOut[7]: 4336020872\n\nIn [8]: a.a\nOut[8]: \'bbb\'\n\nIn [9]: id(a.a)\nOut[9]: 4310928608\n\nIn [10]: b.a\nOut[10]: \'bbb\'\n\nIn [11]: id(b.a)\nOut[11]: 4310928608\n```\n\n通过上面的例子可以发现，其中这个变量a属于类的静态数据，实例化以后的内存地址也都是指向的同一块。我们在书写Form组件的时候，其实每一个字段都是这个Form组件类的一个静态字段。看一下我们这个多选的静态字段是如何实现的：\n\n```python\nxx = fields.MultipleChoiceField(\n    choices=models.Classes.objects.values_list(\'id\', \'title\'),\n    widget=widgets.SelectMultiple\n)\n```\n\n那么我们在实例化调用的时候：\n\n```python\n# 这些字段都是属于类的静态对象\nobj = teacherForm()\n1.找到所有字段\n2.放到self.fields = {\n    # 只执行一遍，tname后面的内容在创建对象的时候仅仅会执行一遍。\n    # 以后再使用永远是使用的启动的时候的数据。\n    \'tname\': fields.CharField(min_length=2)\n}\n```\n\n因为这个班级属于静态字段，再次实例化的时候使用的一直是启动时候的数据，因此添加班级的时候，老师关联的班级并不会刷新，因此我们针对这个问题要对这个Form类做一下改造。\n\n```python\nclass TeacherForm(Form):\n    tname = fields.CharFields(min_length=2)\n    xx = fields.MultipleChoiceField(\n\t# choice=models.Classes.objects.values_list(\'id\',\'title\'),\n    widget=widgets.SelectMultiple\n\t)\n    \n    def __init__(self, *args, **kwargs):\n        # 执行完父类的构造方法以后其实就是什么也没执行，但是多了一个self.fields属性\n        super(TeacherForm, self).__init__(*args, **kwargs)\n        # 每一次实例化的时候都重新取一次\n        # 这样处理更加灵活，可以使列表，又可以是字典等。\n        self.fields[\'xx\'].choice = models.Classes.objects.values_list(\'id\', \'title\')\n\n        可以通过查看父类Form来查看构造方法\n```\n\n解决动态显示还有另外一个办法，使用django提供的ModelChoiceField和ModelMultipleChoiceField字段来实现。但是并不推荐这个方法：\n\n```python\nfrom django import forms\nfrom django.forms import fields\nfrom django.forms import widgets\nfrom django.forms import models as form_model\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import RegexValidator\n \nclass FInfo(forms.Form):\n    # 这个方法需要对应的model的classes类加一个__str__方法然后return self.title，因为默认显示的其实是对象，而不是这个数据的名称，value是值。所以要单独加__str__方法。\n    xx = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())\n    # xx = form_model.ModelChoiceField(queryset=models.Classes.objects.all()) 单选\n    # 但是这种方法并不推荐使用，适用于代码量比较少或者小的时候可以使用，因为必须结合module使用（比如给model加一个__str__方法），耦合性略高。简单的程序可以去使用，推荐使用上面的上面的去操作self.fields的方式。\n```\n\n### 其他常用插件\n\n```python\nclass TestForm(Form):\n    t1 = fields.CharField(\n        # widget = widgets.PasswordInput\n        widget = widgets.Textarea(attr=字典)\n    )\n    t2 = fields.CharField(\n        # checkbox单选框\n        widget=widgets.CheckboxInput\n    )\n    t3 = fields.MultipleChoiceField(\n        # checkbox多选框\n        choices = [(1,\'basketball\')，(2，\'soccer\')],\n        widget=widgets.CheckboxSelectMultiple\n    )\n    \ndef test(request):\n    obj = TestForm(initial={\'t3\': [2,3]})\n    return render(request, \'test.html\', {\'obj\': obj})\n\n\n# radio，默认取回来的值只可能有一个，因此使用ChoiceField就可以了。\nt4 = fileds.ChoiceField(\n    choice=[(1,\'basketball\')，(2，\'soccer\')],\n    widget=widgets.RadioSelect\n)\n\n# 文件上传，提交过来的内容就是Bytes，返回值是一个文件对象。里面包含文件的属性\nt5 = fileds.FileField(\n    widget=widgets.FileInput\n)\n```\n\n### 内置插件\n\n```python\nTextInput(Input)\nNumberInput(TextInput)\nEmailInput(TextInput)\nURLInput(TextInput)\nPasswordInput(TextInput)\nHiddenInput(TextInput)\nTextarea(Widget)\nDateInput(DateTimeBaseInput)\nDateTimeInput(DateTimeBaseInput)\nTimeInput(DateTimeBaseInput)\nCheckboxInput\nSelect\nNullBooleanSelect\nSelectMultiple\nRadioSelect\nCheckboxSelectMultiple\nFileInput\nClearableFileInput\nMultipleHiddenInput\nSplitDateTimeWidget\nSplitHiddenDateTimeWidget\nSelectDateWidget\n```\n\n## 小结\n\n- 多对多\n  - ChoiceField（可被替代）\n  - MultipleChoiceField\n- 常用插件\n  - CheckBox\n  - radio\n  - input\n  - textarea\n  - File\n- 扩展Extra（比如跟数据库相关的，跟文件相关的）","timestamp":1531448340028},{"name":"03-03-数据的提交.md","path":"06-Django/05-Django Form/03-03-数据的提交.md","content":"# 数据的提交\n\n> - Form表单的方式提交：Form表单自身会刷新页面，因此提交的信息如果有误的话是不会被保留的\n> - Ajax方式的提交：页面不会刷新，偷偷的给服务器传递数据。上次内容自动保留，可以手动js刷新\n\n比如说现在的Form组件我定义了两个字段规则，一个username，一个password，然后反应在前端的代码是这样的：\n\n```html\n<!--提交我用一个a按钮代替，绑定一个onclick事件-->\n<form id=\"f1\" method=\"post\">\n    {% csrf_token %}\n    <p>用户名：<input type=\"text\" name=\"username\" />{{ obj.errors.username }}</p>\n    <p>密码：<input type=\"password\" name=\"password\" />{{ obj.errors.password }}</p>\n    <p><a onclick=\"submitForm();\">提交</a></p>\n</form>\n```\n\n对应的JS代码：\n\n```js\n# 引入Jquery\n<script src=\"/static/js/jquery-3.2.1.min.js\"></script>\n<script>\n    function submitForm() {\n    \t# 在执行这个方法开始将标签的样式还原，其实就是找到标签，然后remove掉。别让他重复显示\n        $(\'.c1\').remove();\n        $.ajax({\n            # 提交的地址，这个要在django的路由中加上\n            url: \"/ajax_login/\",\n            # 提交方式为POST\n            type: \'POST\',\n            # 通过上面的表单可以看到我们提交的内容有三个，用户名，密码，还有csrf_token\n            # 通过serialize方法可以获取打包后的数据将我们要提交的数据一起打包\n            # 打包后的格式为：“user=xxx&pwd=xxx&csrf_token=xxx”的字符串\n            data: $(\'#f1\').serialize(), \n            # 预期服务器返回的数据类型，我们返回类型为JSON\n            dataType: \"JSON\",\n            success: function (arg) {\n                if(arg.status){\n\t\t\t\t\tconsole.log(arg.msg)\n                }else{\n                    # 如果说验证失败其实是会返回错误的，如果username和password都有问题\n                    # 那么就是返回两个，如果其中有一个有问题就是返回一个，因此一个两个不确定\n                    # 为了处理这个问题，我们对返回的数据进行遍历\n                    $.each(arg.msg, function(index, value){\n            \t\t\t# index是key，value就是对应的报错内容\n                        console.log(index, value);\n            \t\t\t# 创建一个span标签\n                        var tag = document.createElement(\'span\');\n                        # 设置span标签的值为对应的报错信息，只显示第一个报错就行。\n                        tag.innerHTML = value[0];\n            \t\t\t# 在设置的时候设置一个类，用于重置显示内容\n                        # 因为页面没刷新，如果不做这个操作，每次触发onclick事件\n                        # 会不断的在后面添加内容。\n                        tag.className = \'c1\';\n            \t\t\t# 在form中找到属性name为对应的“index”属性的标签，在它后面加上tag\n                        # 这里用到了字符串的拼接。拼接结果为\"input[name=\"username\"]\"样\n                        $(\'#f1\').find(\'input[name=\"\' + index + \'\"]\').after(tag)\n                    })\n                }\n            }\n\n        })\n    }\n</script>\n```\n\n后端处理视图函数：\n\n```python\nimport json\ndef ajax_login(request):\n    # 初始化一个字典\n    ret = {\n        # 初始化验证后状态\n        \'status\': True,\n        \'msg\': None\n    }\n    if request.method == \"POST\":\n        obj = form.LoginForm(request.POST)\n        if obj.is_valid():\n            # 如果验证合法其实就应该要插入数据库了。\n            # print(obj.cleaned_data)\n            插入数据库等操作\n            ret[\'msg\'] = \"验证成功\"\n        else:\n            # 验证失败会把对应的失败报错内容放到errors中去。\n            # print(obj.errors)\n            # 对数据字典重新赋值\n            ret[\'status\'] = False\n            # 注意这里的obj.errors不是字符串是一个对象，对象是不能直接放到httpresponse里面直接进行返回的，但是可以序列化以后然后再进行返回。这就是这里要进行json.dump的原因。\n            ret[\'msg\'] = obj.errors\n    # 记得导入json模块\n    v = json.dumps(ret)\n    return HttpResponse(v)\n```\n\n## 到底要使用哪一种方式提交？\n\n今后两个一般只会用到一个\n\n- Ajax：仅用作验证功能（get+ajax）\n- Form：验证功能，生成HTML标签（get+post）。\n","timestamp":1531448340028},{"name":"04-04-Form组件内部原理.md","path":"06-Django/05-Django Form/04-04-Form组件内部原理.md","content":"# Form组件内部实现原理\n\n### Form验证执行流程以及钩子\n\n1. 验证字段`is_vaild`→`return self.is_bound and not self.errors`。这个`self.is_bound`是什么意思？当实例化Form对象的时候为data就是绑定数据会做校验，如果是initial那么is_bound就是false。做不做校验的时候最主要的这一个`is_bound`是True还是False。如果`self.is_bound`是true就做绑定，否则就返回false。不做验证。\n\n   ```python\n   def is_valid(self):\n       \"\"\"Return True if the form has no errors, or False otherwise.\"\"\"\n       return self.is_bound and not self.errors\n   ```\n\n2. 知道了`self.is_bound`我们通过`self.errors`进一步往下看。我们看到如果`self._errors`为空的时候也就是一开始验证时候是并没有错误信息的，会走入这个if的条件进行验证执行`self.full_clean()`函数。\n\n   ```python\n   @property\n   def errors(self):\n       \"\"\"Return an ErrorDict for the data provided for the form.\"\"\"\n       if self._errors is None:\n           self.full_clean()\n       return self._errors\n   ```\n\n3. `self.full_clean()`开始验证，到这里我们就看到了我们熟悉的`cleaned_data`，一上来就是一个默认的空字典。然后就是分别执行了`self._clean_fields,self._clean_form,self._post_clean`这三个函数。我们来一个一个的看。\n\n   ```python\n   def full_clean(self):\n       \"\"\"\n       Clean all of self.data and populate self._errors and self.cleaned_data.\n       \"\"\"\n       self._errors = ErrorDict()\n       if not self.is_bound:  # Stop further processing.\n           return\n       self.cleaned_data = {}\n       # If the form is permitted to be empty, and none of the form data has\n       # changed from the initial data, short circuit any validation.\n       if self.empty_permitted and not self.has_changed():\n           return\n   \n       self._clean_fields()\n       self._clean_form()\n       self._post_clean()\n   ```\n\n   **self._clean_fields**\n\n   遍历fields中的所有字段；value = fields.clean(value) 把值按照正则做校验。验证成功后：self.cleaned_data[name] = value填充cleaned_data。执行完这一条代码的时候相当于把所有的字段都已经执行完一遍了。\n\n   ```python\n   def _clean_fields(self):\n       # self.fields就是一个字典，其中key就是我们写的字段名，value就是插件还有正则的验证规则。\n       for name, field in self.fields.items():\n           # value_from_datadict() gets the data from the data dictionaries.\n           # Each widget type knows how to retrieve its own data, because some\n           # widgets split data over several HTML fields.\n           # 获取用户提交过来数据\n           if field.disabled:\n               value = self.get_initial_for_field(field, name)\n           else:\n               value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name))\n           # 根据正则进行数据的校验\n           try:\n               if isinstance(field, FileField):\n                   initial = self.get_initial_for_field(field, name)\n                   value = field.clean(value, initial)\n               else:\n                   value = field.clean(value)\n               # 验证通过以后更新字典，其中name为字段值，value就是用户提交过来的值。\n               self.cleaned_data[name] = value\n               # 执行钩子函数，这个钩子函数的命名规则为\"clean_当前字段字段名称\"\n               # 虽然这个默认的是没有写的，但是这也就给我们提供了更多的可以定制的自定义的可能性\n               # 因为在Form表单那块只能写正则，比如要验证数据库数据可用性这个就做不到了。\n               # 因此这里会去判断是否有钩子函数，如果有就执行。\n               # 同时我们还发现如果条件满足以后，会更新cleaned_data中的对应字段的值。\n               # 这个value就是我们这个钩子函数的返回值。在自定义钩子的时候我们要注意。\n               if hasattr(self, \'clean_%s\' % name):\n                   value = getattr(self, \'clean_%s\' % name)()\n                   self.cleaned_data[name] = value\n           # 在匹配过程中捕获异常，如果没有匹配成功，会在error中加对应的字段以及报错内容。\n           # 并且报错以后后面的代码就不执行了。\n           except ValidationError as e:\n               self.add_error(name, e)\n   ```\n\n   **self._clean_form**\n\n   但凡上一步执行完了以后，如果没问题，那么`self.cleaned_data`就已经有数据了，如果之前验证有异常，那么这就是一个空字典，取而代之的是报错会被放到errors中去。\n\n   ```python\n   def _clean_form(self):\n       try:\n           # 在这里看到cleaned_data是self.clean的返回值\n           # 而self.clean的本身又是django预留的一个钩子函数预留给用户自定制功能。\n           # 因此如果你想要造成影响就返回值就可以了。\n           # 这个方法可以直接定义在我们的Form组件中，当所有正则执行完成以后执行clean方法\n           # 因为如果验证成功以后此时cleaned_data已经有所有的数据了，因此适合做整体的验证。\n           # 不用担心数据有没有的问题。\n           # clean有返回值，cleaned_data=clean的返回值，否则等于原来的值。\n           cleaned_data = self.clean()\n       except ValidationError as e:\n           self.add_error(None, e)\n       else:\n           # 当self.clean()返回内容不为空的时候才会重新赋值(造成影响)\n           if cleaned_data is not None:\n               self.cleaned_data = cleaned_data\n               \n   # 多看一步clean方法的内容\n   def clean(self):\n       \"\"\"\n       Hook for doing any extra form-wide cleaning after Field.clean() has been\n       called on every field. Any ValidationError raised by this method will\n       not be associated with a particular field; it will have a special-case\n       association with the field named \'__all__\'.\n       \"\"\"\n       return self.cleaned_data\n   ```\n\n   **self._post_clean**\n\n   最后再看这个`self._post_clean`方法，可以看到这个同样是一个钩子函数，也是给用户预留功能。这个功能一般使用的不多。这个和clean功能使用一个就行了。\n\n   ```python\n   def _post_clean(self):\n       \"\"\"\n       An internal hook for performing additional cleaning after form cleaning\n       is complete. Used for model validation in model forms.\n       \"\"\"\n       pass\n   ```\n\n## Form实例应用\n\n示例：可以关注一下下面的执行顺序。\n\n```python\nfrom django.core.exceptions import ValidationError\n# 有如下的代码\nclass TestForm(Form):\n    user = fields.CharField()  # 执行顺序1\n    pwd = fileds.CharField()   # 执行顺序3\n    \n    # 这个函数会在内部被调用，如果有这个方法就执行没有就不执行，内部通过反射去判断的。\n    # 上面只能是正则判断，在方法中就可以进行进一步的高级验证了，比如数据库判断\n    # 如果正则表达式都没有通过，那么这里的函数就不会执行了。所以在正则没有验证成功后\n    # 会抛出一个异常ValidationError然后，加入一个错误\n    # self.add_error(name, e)\n    # 所以这个扩展函数没有通过的时候我们也可以抛出一个异常添加到error中\n    def clean_user(self):   # 执行顺序2\n        # clean_user中不能取pwd的值，因为这回pwd的值还不在字典里呢\n        # 因此最好只取自己的值，除非在你执行这一部分的时候其他的值已经加进去了。\n        v = self.cleand_data[\'user\']\n        from django.core.exceptions import ValidationError\n        if models.Student.objects.filter(name=v).count():\n            # 这里的code就是之前定制的error_message的key\n            # 默认不写就是invalid\n            raise ValidationError(\'User exists\', code=\'invalid\')\n        # 一定要返回一个值，因为django内部要重新赋值，否则会赋值为None\n        return xxx\n    \n    def clean_pwd(self):   # 执行顺序4\n        return self.cleaned_data[\'pwd\']\n```\n\n验证通过后走下一句self._clean_form(self)，此时self_cleaned_data有值了，否则就是一个空字典→cleaned_data = self.clean()→找到这个self.clean()方法，可以看到注释说明这是一个钩子，用户扩展的。这个我们自己也可以进行自定义:\n\n```python\n# 有如下的代码\nclass TestForm(Form):\n    user = fields.CharField()  # 执行顺序1\n    pwd = fileds.CharField()   # 执行顺序3\n\n    def clean_user(self):   \n        v = self.cleand_data[\'user\']\n        from django.core.exceptions import ValidationError\n        if models.Student.objects.filter(name=v).count():\n            raise ValidationError(\'User exists\', code=\'invalid\')\n        return xxx\n    \n    def clean_pwd(self):   # 执行顺序4\n        return self.cleaned_data[\'pwd\']\n    \n    def clean(self):\n        # 举例子做一个联合唯一的判断，对用户和密码做整体判断\n        user = self.cleaned_data.get(\'user\')\n        email = self.cleaned_data.get(\'email\')\n        # 数据库验证\n        if models.Student.objects.filter(user=user,email=email).count():\n            # 整体存在就别添加了。\n            raise ValidationErrors(\'用户名已经存在\')\n        return self.cleaned_data\n```\n\n最后一个self._post_clean(self)也是用来自定义的。\n\n```python\n# 有如下的代码\nclass TestForm(Form):\n    user = fields.CharField()  # 执行顺序1\n    pwd = fileds.CharField()   # 执行顺序3\n\n    def clean_user(self):   \n        v = self.cleand_data[\'user\']\n        from django.core.exceptions import ValidationError\n        if models.Student.objects.filter(name=v).count():\n            raise ValidationError(\'User exists\', code=\'invalid\')\n        return xxx\n    \n    def clean_pwd(self):   # 执行顺序4\n        return self.cleaned_data[\'pwd\']\n    \n    def clean(self):\n        pass\n    \n    def _post_clean(self):\n        \"\"\"\n        也是自定制的内容，一般用不到这个内容\n        如果要用到的话记得自己加异常处理。\n        \"\"\"\n        pass\n```\n\n\n\n","timestamp":1531448340028},{"name":"07-Django模板.md","path":"06-Django/07-Django模板.md","content":"# Django中的模板\n\n> 为什么会有模板技术，即使没有模板我们也可以以字符串的形式将html代码嵌入到Python代码中去，但是考虑一下，这个明显是一个很麻烦的操作\n>\n> - 当改动的时候需要对Python代码进行改动\n> - Python和HTML前端是两种技术领域，应该有专业的技术去完成。耦合在一起明显加大了维护的难度。各司其职才是效率更高的体现。\n>\n> 也是因为如此，存在Django模版的技术，如下讲对Django的模板做简单的使用说明。\n\n## 1、特殊标记语言\n\n假如说我们在后台给前台render一段模板内容，第一个参数是request，第二个参数就是模板文件，第三个就是一个字典它可以结合模板语言去替换模板中的特殊标记的字符串。\n\n```python\nrender(request, \'login.html\', {\n    \'name\': \'lamber\',\n    # 在模板中取的时候用{{ users.1 }}这种形式，1表示索引值\n    \'users\': [\'user1\',\'user2\'],\n    # 取的时候直接{{ user_dict.k1 }}\n    \'user_dict\': {\'k1\':\'v1\',\'k2\':\'v2\'},\n    \'user_list_dict\': [\n        {\'id\':1, \'name\':\'alex\', \'email\':\'22222@q.com\'},\n        {\'id\':2, \'name\':\'alex2\', \'email\':\'22222@q.com\'},\n    ]\n})\n```\n\n那么现在我想要在前端把users这个key中的内容取出来应该使用什么方式去获取呢？\n\n```python\n# 在模板中使用for循环去取用users这个key的数据\n{% for item in users %}\n\t<h3>{{ item }}</h3>\n{% endfor %}\n这样的话在前段模板中就会显示两个html标签，分别为：\n<h3>user1</h3>\n<h3>user2</h3>\n\n# 或者嵌套进别的html标签中去写也是可以的。\n<ul>\n\t{% for item in users %}\n    <li>{{ item }}</li>\n    {% endfor %}\n</ul>\n\n# 针对这个列表形式的我们还可以使用索引去取数据，只不过取的时候形式和python的不太一样\n# 索引也是从0开始的\n<h1>{{ users.0 }}</h1>\n<h2>{{ users.1 }}</h2>\n\n# 直接调用字典里的内容。\n{% for i in userinfo.items %} # userinfo.keys,userinfo.values\nprint something\n{% endfor %}\n```\n\n上文中的这个item是一个变量，通过for循环去users中取出来的一个临时变量，想要使用变量的话可以使用双花括号的形式去调用，比如`{{ item }}`。值得注意的这个特殊标记有开始有结束，比如for循环，那么最后要有一个endfor标签作为结束，如果是if标签，要有一个endif作为结束。\n\n```python\n# 循环user_list_dict，直接使用\".\"去取嵌套字典中的每一个数据，这个也python也不一样。\n<table>\n\t{% for row in user_list_dict %}\n    <tr>\n    \t<td>{{ row.id }}</td>\n        <td>{{ row.name }}</td>\n        <td>{{ row.email }}</td>\n    </tr>\n    {% endfor %}\n</table>\n```\n\n我们在模板中还可以进行if判断\n\n```python\n{% if status %}\n    <h1>{{ users.0 }}</h1>\n{% else %}\n    <h1>{{ users.1 }}</h1>\n{% endif %}\n```\n\n**关于Request**\n\n其实我们在render一个界面的时候，会隐式的去传递一个request供我们去调用部分信息。比如我有一个界面我要登录，那么登录以后显示“您好，xxx”，这个xxx其实是保存在session中的一个字段，我们就可以这样去取用。\n\n```python\ndef login(request):\n    if request.method == \'GET\':\n        return render(request, \'login.html\')\n    else:\n        username = request.POST.get(\'username\')\n        password = request.POST.get(\'password\')\n        if username == \'lamber\' and password == \'12345\':\n            # 走到这里代表认证成功\n            request.session[\'username\'] = username\n            request.session[\'password\'] = password\n            return redirect(\'/admin/main/\')\n        else:\n            return render(request, \'login.html\', {\n                \'msg\': \'账号或者密码错误\',\n            })\n```\n\n模板对应的部分：\n\n```html\n<div id=\"header\">\n    欢迎您：{{ request.session.username }}\n</div>\n```\n\n## 2、母版\n\n其实就是把通用的部分写一遍就够了，其他地方在调用的时候直接继承一下就行了。比如我们说的后台里面有顶部导航栏，侧边栏，底部栏，但是内容区域的内容可能是不同的页面经常变化的，我们并不用每一次都把侧边栏，导航栏，底部栏重写一遍。\n\n**注意：一个子板只能有一个母版**\n\n```django\n# 我们设置一个通用页面，然后把变化的部分以一个block来封闭起来。\n{% block xx %}\n\t……………………各种变化的内容\n{% endblock %}\n```\n\n需要调用的时候直接使用\n\n```django\n# 先继承，在渲染的时候会先把公共部分extends过来，然后直接放到一起进行渲染\n{% extends \'layout.html\' %}\n\n{% block xx %}\n# 自己写模块，然后这个叫xx的block会集成到你的模板指定的位置。这个block也可以多加几个\n{% endblock %}\n```\n\n一般来讲会写三个block\n\n```html\n# 在head部分\n写一个block叫css\n\n# 内容部分\n写一个content是用来替换变化的内容的。\n\n# JS部分\n写一个block叫js模块，用来独立的调用某个页面的JS\n```\n\n目的是为了针对不同的部分做不同的css和js的区分，因为并不是一个css适用于所有的页面。母版里面应该放的内容是所有页面都要用的东西。\n\n## 3、模板中的函数\n\n在模板里面写上一个函数名是自动执行的，但是这个函数不能加参数，要加参数需要其他的操作去执行的。\n\n```jinja2\n# 这个upper实质上是一个带装饰器的函数，这个是由模板提供的函数\n{{ name|upper }}\n```\n\n这个当然是可以由我们自己来定义的，其中一种就叫simple_filter，另外一种叫做simple_tag。\n\n**自定义simple_filter**\n\n1. 在app中创建一个叫templatetags的模块（Python Package），名字必须是这个。\n\n2. 随便创建一个py文件，名字叫xx.py，自定义函数就放在这里。\n\n3. 写自定义函数\n\n   ```python\n   from django import template\n   register = template.Library()  # 这个是Django固定好的格式，必须这么写\n\n   @register.filter      # 只有加上这个装饰器才能在模板中使用\n   def my_upper(value):\n       return value.upper()\n   ```\n\n4. 在模板中使用\n\n   ```html\n   # 在页面顶部导入咱们自定义的内容\n   {% load xx %}\n   ```\n\n   模板中调用\n\n   ```python\n   {{ name|my_upper }}\n   ```\n\n5. settings中需要注册这个app才能够使用，不然无法使用。\n\n**如何给模板函数传递参数？**\n\n如果要给函数给传递多个参数的话要在函数后面用冒号接参数：\n\n```python\n{{ name|my_upper:\"666\" }}\n最多只支持两个参数，函数前面一个，后面一个，而且冒号不能有空格。不然会报错。\n```\n\n如果装饰器是simple_tag的话使用方法还不一样：\n\n```python\n@register.simple_tag      \ndef my_upper(value):\n    return value.upper()\n\n# 调用，这个是没有参数限制的。\n{% my_upper \"ALEX\" \"x\" \"SB\" \"V\" %}\n```\n\nfilter可以作为if的条件，但是simple_tag是无法作为if的条件语句\n\n```python\n{% if name|my_bool %}\n   <h3>hahah</h3>\n{% else %}\n   <h3>hehehehehe</h3>\n{% endif %}\n```\n\n反向生成URL就是使用的simple_tag的方法，因为参数无限制。一般情况下，filter用不到，所以作为了解就可以了。\n\n## 4、模板之Include\n\n> 模板之include，include单独的小组件。\n\n```python\n{% include \'pub.html\' %}\n```\n\n小组件和母版功能类似，但是又不一致。母版是用来继承的，而include是用来导入小组件的。同时小组件也是支持书写模板语言的。\n\ninclude会找到小组件把小组件的内容读取过来然后替换掉。因此这些模板语言也是支持的。比如我写了一个小模块，我在很多页面都用到了，那么我就可以直接把这个小页面或者说小模块单独拿过来在页面中引用。\n\n## 5、模板的简单实现原理：\n\n1. 创建一个 Template 对象，将模板代码放入一个 string 中作为参数。\n2. 调用模板(template)对象的 render() 方法，把一组变量作为上下文(context)传入。这么做将会把模板(template)展开，将所有变量(variables)和标签(tags)都赋予相应的值，并作为 string 返回。\n\n```python\n# 终端切换到项目目录下，在终端运行如下命令：\npython3 manage.py shell\n# 这个不要在终端直接引入，要通过manage.py，不然配置文件等相关内容不会被加载直接报错。\n# 或者直接在.bash_profile中手动添加 DJANGO_SETTINGS_MODULE这个环境变量，设为mysite.settings，前提是这个mysite的路径在环境变量里。\n>>> from django import template\n# 通过实例化创建一个Template的对象，构造函数接收一个参数，初始化模板代码\n>>> t = template.Template(\'My name is {{name}}\')\n>>> c = template.Context({\'name\':\'lamber\'})\n>>> print(t.render(c))\nMy name is lamber\n```","timestamp":1531448340028},{"name":"08-Cookie和Session.md","path":"06-Django/08-Cookie和Session.md","content":"# Cookie & Session\n\n## Cookie\n\n- cookie是保存在浏览器上的键值对。可以放多对，敏感信息不放在这里。\n- 服务端可以向用户浏览器端写cookie\n- 客户端每次发送请求的时候，会携带cookie去。Cookie是携带在请求头中的。\n- Cookie一般情况下是用来做用户登录的。\n- 在发送HTTP请求的时候，在请求中携带当前所有可访问的cookie\n\n首先去请求的cookie中获取凭证：tk\n\n```python\ntk = request.COOKIES.get(\'ticket\')\nif not tk:\n    return render(xxxxx)\n\n\n# 登录成功之后\n判断密码正确以后：\nobj = redirect(\'classes\')\n# obj = render(\'xxxxx\')\n# obj = HttpResponse(\'xxx\')\n# max_age 超时时间是10s,expires是具体的超时日期，和max_age二者择其一就可以\n# 推荐使用max_age\nfrom datetime import datatime, timedelta\nct = datetime.utcnow()\ninterval = timedelta(seconds=10)\nnew_time = ct + v\nobj.set_cookie(\'ticket\', \'xxxxxxx\', max_age = 10，expires=new_time, path=\'/\', domain=None, secure=False, httponly=\'False\')\n# path 可以指定cookie在某个指定url下使用，某些url下不使用。比如指定/classses/，那么其他的路径下就获取不到这个cookie了。默认是/也就是所有的url都能读取到。\n# domain表示指的是在访问某个域名的时候才能获取到这个cookie。默认就是当前域名，一般多用于SSO单点登录。\n# secure是给https提供的功能。如果是https网站要改为true\n# httponly表示只能自http请求中传入，js代码无法获取到。\nreturn obj\n\n在检查元素中的network 找到cookie就可以查看cookie的内容了\n\n\n```\n\nDjango扩展签名cookie\n\n```django\nobj.set_signed_cookie(\'ticket\', \'xxxx\', salt=\'jjjj\')\n\n# 读取的时候要按照如下的方式，下面获取到的内容是去掉签名的字符串\nrequest.get_signed_cookie(\'ticket\', salt=\'jjjj\')\n\n自定义加密方法，django默认不是走的md5：\nSIGNING_BACKEND = \'模块.定义类\'\n```\n\n\n\n装饰器实现cookie的判断\n\n```python\ndef get_cookie(*args, **kwargs):\n    def wrapper(func)\n    \n \n```\n\n作业：\n\n- 布局+代码\n- 登录cookie+装饰器实现登录\n- 布局页面的HTML+CSS\n\nCookie是什么？\n\n```\n保存在客户端浏览器上的键值对\n```\n\nSession\n\n```shell\n保存在服务器端的数据，本质也是键值对。\n应用：依赖cookie，因为给客户端的字符串是保存在cookie中的\n作用：会话保持(Web网站)\n好处：敏感信息不会直接给客户。\n\n用户信息保存在服务器端，以键值对形式，key为随机字符串，value为用户数据，仅给客户端发随机字符串。以后谁拉着随机字符串来，那么对应的值就可以取到。\n\n# 登录设置session\n1.生成随机字符串\n2.通过cookie发送给客户端\n3.服务端保存[随机字符串：{当前用户字典信息}]\nrequest.session[\'username\'] = \'alex\'  # 这一句话就上面三件事全做了。\nrequest.session[\'email\'] = \'1020561033@qq.com\'\n# 下面的这种写法可以针对不同种类的键值对进行分类\nrequest.session[\'userinfo\'] = {\n  \'user_id\': obj.id,\n  \'gender\': gender,\n  ……\n}\n对应的用户字典信息就生成了。\n\n那么程序里对应的内容放在哪里呢？\n在Django里默认没放在字典里，而是放在数据库表里，放到django_session这张表里了。\n对应的key就是生成的随机字符串，session_data就是键值对的value\nDjango内部针对这个value做了一个加密\n\n# 登录页判断(敏感信息不给用户，只给字符串，我再服务器想存什么就存什么)\n1、获取客户端cookie中的随机字符串  #Django内部帮你去cookie中取值了。\n2、去session中查找有没有对应的随机字符串\n3、去session对应的key的value中看看有没有对应的username\n\ndef index(request):\n\tv = request.session.get(\'username\')\n\tif v:\n\t\treturn HttpResponse(\'登录成功：%s\' %v)\n\telse:\n\t\treturn redirect(\'/login/\')\n```\n\n```\ndel request.session[\'k1\']\n这个删除的k1是cookie的随机字符串对应的session_data中的k1，而不是删除随机字符串。\n\ndef index(request):\n        # 获取、设置、删除Session中数据\n        request.session[\'k1\']\n        request.session.get(\'k1\',None)\n        request.session[\'k1\'] = 123\n        request.session.setdefault(\'k1\',123) # 存在则不设置\n        del request.session[\'k1\']\n \n        # 所有 键、值、键值对\n        request.session.keys()\n        request.session.values()\n        request.session.items()\n        request.session.iterkeys()\n        request.session.itervalues()\n        request.session.iteritems()\n \n \n        # 用户session的随机字符串\n        request.session.session_key\n \n        # 将所有Session失效日期小于当前日期的数据删除\n        request.session.clear_expired()\n \n        # 检查 用户session的随机字符串 在数据库中是否\n        request.session.exists(request.session.session_key)\n \n        # 删除当前用户的所有Session数据\n        request.session.delete(request.session.session_key)\n \n        request.session.set_expiry(value)\n            * 如果value是个整数，session会在些秒数后失效。\n            * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n            * 如果value是0,用户关闭浏览器session就会失效。\n            * 如果value是None,session会依赖全局session失效策略。\n```\n\n根据Django的规定，默认的情况下cookie会在浏览器保存两周\n\n```\na. 配置 settings.py\n \n    SESSION_ENGINE = \'django.contrib.sessions.backends.cache\'  # 引擎\n    SESSION_ENGINE = \'django.contrib.sessions.backends.db\'\n    SESSION_CACHE_ALIAS = \'default\'                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置\n \n \n    SESSION_COOKIE_NAME ＝ \"sessionid\"                        # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\n    SESSION_COOKIE_PATH ＝ \"/\"                                # Session的cookie保存的路径\n    SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名\n    SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie\n    SESSION_COOKIE_HTTPONLY = True                            \n    # 是否Session的cookie只支持http传输\n    \n    SESSION_COOKIE_AGE = 1209600                              \n    # Session的cookie失效日期（2周）\n    \n    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   \n    # 是否关闭浏览器使得Session过期\n    \n    SESSION_SAVE_EVERY_REQUEST = False                        \n    # 是否每次请求都保存Session，默认修改之后才保存\n    # False从一开始，这个时间段后超时。\n    # True每次请求都会计算，规定时间以内就不会超时。最好设置成True，让他每次都更新。\n    \n    \n    \n    \nSESSION_FILE_PATH = None\n# 如果缓存文件路径为None，那么就使用tempfile模块获取一个临时地址\n# tempfile.gettempdir()\n\nSESSION_ENGINE = \'django.crotrib.sessions.backends.signed_cookies\'\n这个不要用，这相当于给cookies加了个签名，相当于不用session了。\n\n\n```\n\nDjango指定session存放的位置，默认是存放在数据库。\n\n\n\n装饰器判断session存在不存在\n\n\n\n前端模板默认能拿到request这个模板变量\n\n比如：request.session.userinfo.nickname\n\n\n\n# 开工第一天\n\n```python\nfrom django.db import models\n\n\n# Create your models here.\nclass Boy(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n\n\nclass Girl(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n\n\nclass B2G(models.Model):\n    \"\"\"\n    默认情况下这个to是省略的，默认就是对应的表\n    默认情况下这个to_field也是省略的，默认就是id字段。\n    \"\"\"\n    b = models.ForeignKey(to=\'Boy\', to_field=\'id\', on_delete=models.CASCADE)\n    g = models.ForeignKey(to=\'Girl\', to_field=\'id\', on_delete=models.CASCADE)\n    \n当然这个是可以进行进一步优化的，男孩和女孩本质来讲其实都是用户，不需要拆开来看，只要构建一个新的用户表，加一个字段来控制性别就可以了。\ngender_choices = (\n\t(1, \'男\'),\n    (2, \'女\'),\n)\ngender = models.IntegerField(choices=gender_choices)\n\n比如：\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    gender_choices = (\n\t\t(1, \'男\'),\n    \t(2, \'女\'),\n\t)\n\tgender = models.IntegerField(choices=gender_choices)\n    \n    \nclass U2U(models.Model):\n  # related_query_name可以让对象在反向查找的时候不用表名而是使用a或者b。相当于a_set.all()\n  # 如果不带query，反向查找就不带set了，就是直接a.all()，b.all()\n  g = models.ForeignKey(\'Userinfo\', related_query_name=\'a\')\n  b = models.ForeignKey(\'UserInfo\', related_query_name=\'b\')\n  \n这个在添加数据的时候又两种写法\n1、在能获取明确的id的值的时候就可以这么用。\nmodels.U2U.objects.create(b_id=2, g_id=6)\n2、如果可以拿到对象的化django也是可以支持插入对象的。\nboy = models.UserInfo.objects.filter(xxxx)\ngirl = models.UserInfo.objects.filter(xxx)\nmodels.U2U.objects.create(b=boy, g=girl)\n\n或者：\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    gender_choices = (\n\t\t(1, \'男\'),\n    \t(2, \'女\'),\n\t)\n\tgender = models.IntegerField(choices=gender_choices)\n    m = models.ManyToManyField(\'UserInfo\')\n    \n如果设定的是manytomany的方式的话那么取数据的时候先后也有区别。\n上面的这个m在数据库中生成的字段名是from_userinfo_id和to_userinfo_id\n我们定前面的是男生的，后面的是女生的。那么取数据的时候就应该做如下修改：\n# 男生对象\nobj = models.UserInfo.objects.filter(id=1).first()\n# 根据男生id=1查找关联的所有女生\nobj.m.all()\n\n# 女生对象\nobj = models.UserInfo.objects.filter(id=4).first()\n# 根据女生id=4查找关联的所有男生\nobj.userinfo_set.all()\n```\n\n用户的注销：\n\n```python\n# 删除服务端的session数据，用户带着cookie来的话查不到数据\nrequest.session.delete(request.session.session_key)\n或者\n# 设置cookie超时\nrequest.session.clear()\n```\n\nForeign自关联\n\n```python\nclass Comment(models.Model):\n    \"\"\"评论表\"\"\"\n    news_id = models.IntegerField() # 新闻id\n    content = models.CharField(max_length=32) # 评论的内容\n    user = models.CharField(max_length=32)   # 评论用户的id\n    # 首先这个评论的新闻是要存在的，这个要在已经存在的数据中去确认。\n    # 因此ForeignKey关联的表是自己。这个叫做ForeignKey的自关联\n    reply = models.ForeignKey(\'Comment\', null=True, blank=True, related_name=\'xxxxx\') # 评论回复\n```\n\n一般情况下的自关联是用不到的。\n\n\n\nDjango:\n\n- 路由\n  - 单一路由\n  - 正则\n  - 可命名（反向生成）\n  - include分发\n- 视图\n  - CBV\n    - request\n    - render\n    - HttpResponse\n    - methodDecrators\n  - FBV\n- 数据库\n  - 基本数据库操作（增删改查）\n  - ​\n- 模板\n- 其他：\n  - CSRF\n  - Cookie\n  - Session\n  - 分页\n\nDjango请求的生命周期：\n\ndjango默认使用的wsgi是wsgiref\n\n\n\nmvc & mtv(models（模型类）, templates（模板）,views（业务逻辑）)","timestamp":1531448340028},{"name":"09-Django安全.md","path":"06-Django/09-Django安全.md","content":"# Django安全\n\n## XSS跨站脚本攻击\n\n> Django在内部已经屏蔽了xss，如果说手贱给内容加了一个 \" content | safe\"就会进行解析，这样就不是字符串了。所以一般情况下不要加safe，如果一定要加safe要记得对特殊字符做过滤。\n>\n> 或者我们也可以在后台逻辑将用户传递过来的字符串进行判断是否有违规内容。\n>\n> 当然在django后台也可以标记，但是需要单独导入模块\n>\n> ```python\n> from django.utils.safestring import mark_safe\n> temp = \"<a>test</a>\"\n> # 把newtemp传递到前端模板的时候就会标记为安全的了。\n> # 因此标记为安全有前台和后台两种方式\n> newtemp = mark_safe(temp)\n> ```\n\n**要点**：\n\n- 慎用safe和mark_safe\n- 非要用，那务必过滤关键字。\n\n## CSRF（跨站请求的伪造）\n\n> django为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。\n>\n> 更多：https://docs.djangoproject.com/en/dev/ref/csrf/#ajax\n\n配置文件中应该打开，默认也是打开的：\n\n```python\nMIDDLEWARE = [\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n]\n```\n\n在这个选项打开的时候，如果没有传递token字符串的话怎么提交也是不生效的。\n\n全局：\n\n　　中间件 django.middleware.csrf.CsrfViewMiddleware\n\n局部（为函数添加如下的特殊装饰器就可以了）：\n\n```python\nfrom django.views.decorator import csrf_exempt或者csrf_protect\n```\n\n- @csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。\n- @csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。\n\n当然直接加装饰器我们这是针对FBV，如果说是针对CBV的时候我们还要做特殊处理：\n\n```python\nfrom django.views.decorator import csrf_protect\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\n\n# 装饰器是CBV中是不可以直接使用的，要调用Django提供的方法才行。\n@method_decorator(csrf_protect) # 给类下的所有绑定方法加装饰器\n# @method_decorator(csrf_protect, name=\'post\') # 给类下的post方法加装饰器，name是谁就是给谁装饰,可以写多个，写多行就行了，多个装饰器。\nclass Foo(View):\n    def get(self, request):\n        pass\n    \n    def post(self, request):\n        pass\n    \n    def dispatch(self,request,*args,**kwargs):\n        return xxx\n    \n# 如果是给dispatch加这个装饰器的话也相当于给所有的加了，因为dispatch是一个入口函数，有dispatch的时候是优先找到dispatch然后通过反射找的POST或者GET方法。\n@method_decorator(csrf_protect, name=\'dispatch\')\n\n# 针对CSRF的装饰器只能给CBV的类加，不能给CBV类下的方法加，这是csrf种一个比较变态的规定。我们自己自定义的装饰器应该是ok的\n```\n\n### 应用\n\n普通表单\n\n```python\nveiw中设置返回值：\n　　return render_to_response(\'Account/Login.html\',data,context_instance=RequestContext(request))　　\n     或者\n     return render(request, \'xxx.html\', data)\n  \n# html中设置Token:\n# 会在页面生成一个隐藏的input的标签\n# 同时也会在cookie中插入csrftoken\n　　{% csrf_token %}\n```\n\nAjax\n\n```python\n# 对于传统的form，可以通过表单的方式将token再次发送到服务端，而对于ajax的话，使用如下方式。\n\n#view.py\nfrom django.template.context import RequestContext\n# Create your views here.\n  \n  \ndef test(request):\n  \n    if request.method == \'POST\':\n        print request.POST\n        return HttpResponse(\'ok\')\n    return  render_to_response(\'app01/test.html\',context_instance=RequestContext(request))\n```\n\ntext.html\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    {% csrf_token %}\n  \n    <input type=\"button\" onclick=\"Do();\"  value=\"Do it\"/>\n  \n    <script src=\"/static/plugin/jquery/jquery-1.8.0.js\"></script>\n    <script src=\"/static/plugin/jquery/jquery.cookie.js\"></script>\n    <script type=\"text/javascript\">\n        // var csrftoekn = $(\'input[name=\"csrfmiddlewaretoken\"]\').val()\n        var csrftoken = $.cookie(\'csrftoken\');\n        // 不仅如此还可以用这个插件设置cookie\n        // $.cookie(\'key\',\'value\')\n        // 这样document.cookie就会发现多了一个。\n        // 一个是在请求头，一个是在data中带，注意cookie和csrfmiddlewaretoken中的值是不一样的\n        // 在请求体中设置csrfmiddletoken设置为{{ csrf_token }}这样取直接就行。\n  \n        function csrfSafeMethod(method) {\n            // these HTTP methods do not require CSRF protection\n            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n        }\n        $.ajaxSetup({\n            beforeSend: function(xhr, settings) {\n                if (!csrfSafeMethod(settings.type) && !this.crossDomain) {\n                    xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n                }\n            }\n        });\n        function Do(){\n  \n            $.ajax({\n                url:\"/app01/test/\",\n                data:{id:1},\n                type:\'POST\',\n                success:function(data){\n                    console.log(data);\n                }\n            });\n  \n        }\n    </script>\n</body>\n</html>\n```\n\n","timestamp":1531448340028},{"name":"01-RBAC.md","path":"06-Django/10-RBAC/01-RBAC.md","content":"# RBAC\n\n> Role-Basiced Access Control基于角色的访问控制，RBAC认为权限的过程可以抽象概括为：判断【Who是否可以对What进行How的访问操作（Operator）】这个逻辑表达式的值是否为True的求解过程。即将权限问题转换为Who、What、How的问题。who、what、how构成了访问权限三元组。这样极大的简化了权限的管理，这样管理都是层级相互依赖的，权限赋予角色，然后又把角色赋予用户，这样的权限设计清晰管理起来也方便。\n>\n> **参考资料**\n>\n> - https://www.cnblogs.com/lamp01/p/6576432.html\n\n## RBAC介绍\n\nRBAC有什么优势？它简化了用户和权限的关系，并且易于扩展和维护。比如用户直接关联权限明细的话，不同的用户可能存在大量重复的权限，这样当权限和用户比较多的时候要维护的内容量是巨大的，现在将角色与具体的权限进行关联，而用户和角色进行挂钩。\n\n![图源：https://www.cnblogs.com/lamp01/p/6576432.html](http://omk1n04i8.bkt.clouddn.com/18-6-12/82751409.jpg)\n\n赋予角色不同的权限，针对不同的权限还应该有不同的操作（actions），比如针对用户列表，有的就只有查看用户的功能，有的权限能添加，有的权限甚至可以删除和修改，这就是针对不同权限（permission）的不同操作（actions）。我们可以更细致的去把控。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-6-12/44715052.jpg)\n\n根据如上说明的功能，可以抽象出如下功能模块：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-6-12/31584515.jpg)\n\n对应权限控制的逻辑流程如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-6-12/33797457.jpg)\n\n## RBAC数据库设计\n\n基于角色的访问控制，根据角色来决定用户的访问权限有哪些。首先看数据表设计，把这个内容作为一个单独的app来进行调用，为以后的通用做准备。具体内容如下：\n\n- 用户表，标识用户，内含有用户的基本信息等。\n- 角色表，标识角色，用户要与角色进行关联，角色和用户是一个多对多的关系。一个用户可以拥有多个角色，比如xx同时担任了总监和经理的工作。角色也会同时被多个用户所有。\n- 用户与角色关联表：将用户与角色进行关联。两个字段都是外键的关系\n- 菜单表：这里加了一个菜单表，这个菜单表表示的是功能菜单，如果我们要设计这样的一个权限系统的话，最终的权限是要挂靠到菜单上去的。比如一个系统里面，可能会有A、B、C三个菜单，A菜单下可能会有用户管理，订单管理等等，这是权限，具体到用户管理下面又有添加用户，删除用户，修改用户等等。这是权限对应的actions操作。菜单与菜单之间也存在层级关系，比如一级菜单，一级菜单下面还有二级菜单，二级菜单还有三级甚至更多。但是菜单都是一个menu表，每一个菜单明细都是一个menu对象。因此有一个自关联的关系，在进行自关联的时候要写`\'self\'`你不能说直接写menu这个类，因为这现在是在定义的过程当中，这个类还没被定义完呢，你不能直接用，所以要用引号引起来的一个self，这个是django为我们提供的一个功能点。\n- 权限表：有具体的权限内容，挂靠到菜单表上。\n- 动作表：每一个权限对应着一个url action表示执行的方法，比如get，post，edit，del等等。\n\n- 最后我们说权限是基于角色来的，因此角色对应什么权限，对应什么操作。因此最后需要一个角色x权限x动作的这么一个关系表。\n\n具体表内容设计如下：\n\n```python\nfrom django.db import models\n\n# Create your models here.\nfrom django.db import models\n\nclass User(models.Model):\n    \"\"\"\n    用户表\n    \"\"\"\n    username = models.CharField(verbose_name=\'用户名\', max_length=32)\n    password = models.CharField(verbose_name=\'密码\', max_length=64)\n    email = models.EmailField(verbose_name=\'邮箱\')\n\n    def __str__(self):\n        return self.username\n\n\nclass Role(models.Model):\n    \"\"\"\n    角色表\n    \"\"\"\n    caption = models.CharField(verbose_name=\'角色\', max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass User2Role(models.Model):\n    \"\"\"\n    用户角色关系表\n    \"\"\"\n    user = models.ForeignKey(User, verbose_name=\'用户\', related_name=\'roles\', on_delete=models.CASCADE)\n    role = models.ForeignKey(Role, verbose_name=\'角色\', related_name=\'users\', on_delete=models.CASCADE)\n\n    def __str__(self):\n        return \'%s-%s\' % (self.user.username, self.role.caption,)\n\n\nclass Menu(models.Model):\n    \"\"\"\n    菜单表\n    \"\"\"\n    caption = models.CharField(verbose_name=\'菜单名称\', max_length=32)\n    parent = models.ForeignKey(\'self\', verbose_name=\'父菜单\', related_name=\'p\', null=True, blank=True, on_delete=models.CASCADE)\n\n    def __str__(self):\n        prev = \"\"\n        parent = self.parent\n        while True:\n            # 如果有父级菜单\n            if parent:\n                prev = prev + \'-\' + str(parent.caption)\n                parent = parent.parent\n            else:\n                break\n        return \'%s-%s\' % (prev, self.caption,)\n\n\nclass Permission(models.Model):\n    \"\"\"\n    权限\n    \"\"\"\n    caption = models.CharField(verbose_name=\'权限\', max_length=32)\n    url = models.CharField(verbose_name=\'URL正则\', max_length=128)\n    menu = models.ForeignKey(Menu, verbose_name=\'所属菜单\', related_name=\'permissions\',null=True,blank=True,  on_delete=models.CASCADE)\n\n    def __str__(self):\n        return \"%s-%s\" % (self.caption, self.url,)\n\n\nclass Action(models.Model):\n    \"\"\"\n    操作：增删改查\n    \"\"\"\n    caption = models.CharField(verbose_name=\'操作标题\', max_length=32)\n    code = models.CharField(verbose_name=\'方法\', max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass Permission2Action2Role(models.Model):\n    \"\"\"\n    权限操作关系表\n    \"\"\"\n    permission = models.ForeignKey(Permission, verbose_name=\'权限URL\', related_name=\'actions\',  on_delete=models.CASCADE)\n    action = models.ForeignKey(Action, verbose_name=\'操作\', related_name=\'permissions\',  on_delete=models.CASCADE)\n    role = models.ForeignKey(Role, verbose_name=\'角色\', related_name=\'p2as\',  on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\n            (\'permission\', \'action\', \'role\'),\n        )\n\n    def __str__(self):\n        return \"%s-%s-%s\" % (self.permission, self.action, self.role,)\n```\n\n生成对应的关系表，生成表内容以后不要忘了注册app：\n\n```python\npython manage.py makemigrations\npython manage.py migrate\n```\n\n在这个app02下开始写视图函数，首先测试一下内容：\n\n```python\nfrom app02 import models\ndef test(request):\n    # 首先拿到一个用户对象\n    obj = models.User.objects.filter(username=\'alex\').first()\n    # 然后我要拿用户的角色的时候可以这么去拿\n    # models.User2Role.objects.filter(user_id=obj.id)\n    # 不过这样拿到的其实是一个user2role的一个对象，而不是拿到的角色对象，处理起来其实很不方便\n    # 那么我们现在要拿一个role的对象，relate_name=users然后跨表到user表中获取。\n    # 那么现在的这个role_list就是拿到的这个用户的角色对象的列表，这是拿到的一个query_set。\n    role_list = models.Role.objects.filter(users__user_id=obj.id)\n    \n    # 有了用户角色以后现在其实就可以通过角色去拿用户权限了，但是有一个问题哈，比如管理员有添加用户的权限，超级管理员也有添加用户的权限，那么就存在说拿到的权限可能存在重复的现象。因此我们需要对取回来的数据去重，去重我们可以使用distinct，或者使用annotate去重，不同的地方就是annotate会给你多加一列，distinct的执行效率稍微低了点。\n    permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(\'permission__url\', \'action__code\').distinct()\n    # 那么这样拿到的数据也是一个query-set，只不过是列表套字典，因为我们是用values取的，我们拿到的数据是权限表里的url和action操作表里的code。格式基本类似如下：\n    \"\"\"\n    [\n        {\'permission__url\':\'/index.html\', \'action__code\':\"GET\"},\n        {\'permission__url\':\'/edit.html\', \'action__code\':\"POST\"},\n        {\'permission__url\':\'/index.html\', \'action__code\':\"GET\"},\n        ……\n    ]\n    \"\"\"\n    # 现在拿到的数据中，同一个permission_url可能会存在多个的，比如A权限，对应action为get的这是一条，A权限对应action为delete又有一条，action有多个就会存在多个同样的permission_url的记录。现在将对这个记录进一步的进行优化，达到一个最后一个目标类似如下的结构，把结果放到一个字典里去，key是我们的permission_url，value是一个以action为内容的列表：\n    \"\"\"\n    {\n        \'index.html\': [GET, POST, EDIT, DELETE],\n        \'order.html\': [GET, POST]\n    }\n    \"\"\"\n    # 首先初始化一个空字典\n    user_permission = {}\n    # 遍历我们拿到的权限列表(query_set)\n\tfor item in permission_list:\n    \tif not user_permission.__contains__(item[\'permission__url\']):\n        \tuser_permission[item[\'permission__url\']] = item[\'action__code\'].split()\n            continue\n    \tuser_permission[item[\'permission__url\']].append(item[\'action__code\'])\n    # 做到这一步，我们就把用户独有的权限，以及action都拿到了，那么接下来如何处理呢。接下来其实就可以把这个取到的内容放到用户的session中去，以后访问其他的页面的时候都会以这个为参考，取不到对应的页面权限和actions就不让他们访问就可以了。\n    # 不过如果说临时添加了新功能，那么这个功能是没有机制去更新到session中去，也就是说不会立即生效，需要用户重新登录才行。\n    # 上面就是对用户的内容做了一个简单的获取和规整。\n    return HttpResponse(\'...\')\n```\n\n现在模拟一个很low的登录过程：\n\n```python\ndef login(request):\n    if request.method == \'GET\':\n        return render(request, \'app02/login2.html\')\n    else:\n        obj = models.User.objects.filter(username=\'lamber\').first()\n        if not obj:\n            return HttpResponse(\'用户不存在！\')\n        role_list = models.Role.objects.filter(users__user_id=obj.id)\n        permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(\'permission__url\', \'action__code\').distinct()\n        user_permission = {}\n        for item in permission_list:\n            if not user_permission.__contains__(item[\'permission__url\']):\n                user_permission[item[\'permission__url\']] = item[\'action__code\'].split()\n                continue\n            user_permission[item[\'permission__url\']].append(item[\'action__code\'])\n        # 把用户的权限列表扔到session中。\n        request.session[\'user_permission_dict\'] = user_permission\n        return HttpResponse(\'Login Successfully\')\n```\n\n这样session中就已经存储了用户的权限信息了。然后现在在浏览器输入不同的页面地址去模拟访问权限控制的结果。这个操作应该每一次的访问都应该要取执行，而且涉及的页面众多，因此不能把这个判定逻辑写到每一个视图函数中，最好是放到中间件中去进行预先的处理。因此这里将所有的权限的逻辑判断内容扔到一个中间件中去。\n\n在项目目录下新建一个middleware的目录，然后新建一个中间件的py文件名称拟定为md.py，将这个中间件在全局配置文件中进行注册一下，加上这么一条：\n\n```python\n\'middleware.md.M1\',\n```\n\n中间件内容如下：\n\n```python\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.shortcuts import HttpResponse\nimport re\n\n# 固定的要继承一个中间件的基类。\nclass M1(MiddlewareMixin):\n\n    def process_request(self, request, *args, **kwargs):\n\n        # 不能针对所有的请求，比如登录，因此要过滤掉一部分的页面，否则你登录都没法登陆就别提拿到用户权限了，相当于你永远都没法访问这个网站了，因此要放行一些地址。\n        # 定义个需要过滤的列表，放行一部分不需要做权限把控的页面。\n        valid = [\n            \'/rbac/auth-login.html\',\n            \'/rbac/index.html\',\n            \'admin\',\n        ]\n        # 这个request.path_info只包含访问的路径不包含后面接的参数什么的。\n        if request.path_info not in valid:\n            # 把action拿到手\n            action = request.GET.get(\'md\')\n            # 我首先看你这个权限列表有没有，如果没有，不好意思，直接不能访问。\n            user_permission_dict = request.session.get(\'user_permission_dict\')\n            if not user_permission_dict:\n                return HttpResponse(\'无权限\')\n            # 然后看看在权限列表里你有没有权限URL，如果没有，抱歉，你没有权限访问\n\t\t\t# 遇到带正则表达式的请求url该怎么办？因此这个url应该是一个正则，代表一类或者一系列的URL\n            # 这个时候就不是一个固定的地址了，而是一个带正则的地址。这个时候就需要做正则匹配了。\n            # 首先设置一个标记位为false，如果认证通过就改成true\n            flag = False\n            for k, v in user_permission_dict.items():\n                # request_path没问题\n                if re.match(k, request.path_info):\n                    # 并且请求的action在列表中存在，那么认证通过，否则认证失败\n                    if action in v:\n                        flag = True\n                        break\n            if not flag:\n                return HttpResponse(\'无权限\')\n```\n\n## 菜单的获取\n\n下面的代码其实是一个权限菜单挂靠和菜单挂靠菜单的过程。\n\n```python\ndef menu(request):\n    \n    # 所有菜单：处理成当前用户关联的菜单，这些菜单就都是类似下面这种格式的：\n    \"\"\"\n    [\n          {\'id\': 1, \'caption\': \'1.0\', \'parent_id\': None}, \n          {\'id\': 2, \'caption\': \'2.0\', \'parent_id\': None}, \n          {\'id\': 3, \'caption\': \'3.0\', \'parent_id\': None}, \n          {\'id\': 4, \'caption\': \'1.1\', \'parent_id\': 1}, \n          {\'id\': 5, \'caption\': \'2.1\', \'parent_id\': 2}, \n          {\'id\': 6, \'caption\': \'3.1\', \'parent_id\': 3},\n          ……\n    ]\n    \"\"\"\n    # 先把所有的菜单拿出来\n    all_menu_list = models.Menu.objects.all().values(\'id\', \'caption\', \'parent_id\')\n    \n    # 首先获取一个用户对象，比如获取username为mxy的用户对象，并且把这个用户的所有权限都拿到。\n    # 这里的权限只取了四个字段，分别是权限的id，url，菜单id，权限的名称。\n    user = models.User.objects.filter(username=\'mxy\').first()\n    role_list = models.Role.objects.filter(users__user=user)\n    # 拿到当前指定用户的所有的权限\n    permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(\'permission__id\',\'permission__url\', \'permission__menu_id\',\'permission__caption\').distinct()\n\n    # 最后你有什么权限，是要在菜单上体现的。所以需要将权限挂靠到菜单上\n    # 首先初始化一个all_meuu_dict的字典\n    # 遍历所有的菜单。给每一个菜单添加一个必要的字段\n    # 其中child表示当前菜单的子节点，status表示是否显示这个菜单，opened表示这个菜单是否默认为打开状态\n    # 我整个字典拼完了以后大概是下面这么个样子\n    \"\"\"\n    {\n        1:{\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[]},\n        2:{\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:False,opened:False,child:[]},\n        3:{\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:False,opened:False,child:[]},\n        5:{\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},\n    }\n    \"\"\"\n    all_menu_dict = {}\n    for row in all_menu_list:\n        row[\'child\'] = []  # 添加孩子节点。\n        row[\'status\'] = False  # 是否显示菜单\n        row[\'opened\'] = False  # 是否默认打开\n        # 重新构造这个menu的这个字典，这样拼接完了以后就是上面那个形式了。\n        # 这里有一个值得注意的点就是，这个新的字典内容是根据之前的all_menu_list构建而来的，对于这个薪资点来说，保存的是列表内容中的引用，因此下向字典的中value中的row[\'child\']插入数据的时候，之前的all_menu_dict也是跟着发生变化的。注意这一点。\n        all_menu_dict[row[\'id\']] = row\n        \n    for per in permission_list:\n        if not per[\'permission__menu_id\']:\n            continue\n\n        # 规范显示名称，对应的字段使用字典做映射，为什么要做映射？因为我们取出来的权限列表里，都是permission__id，permission__url这种的，最后它是要挂载到菜单上的，有些子菜单也是要被挂载到一些菜单上的，因此在这里把权限和菜单的属性名做一下统一，这个权限的permission__menu_id其实就相当于菜单的parent_id，因此做下面的操作。\n        item = {\n            \'id\': per[\'permission__id\'],\n            \'caption\': per[\'permission__caption\'],\n            \'parent_id\': per[\'permission__menu_id\'],\n            # 针对具体的权限一定要有一个可以操作跳转的url地址。\n            \'url\': per[\'permission__url\'],\n            # 是否显示菜单，如果菜单下有权限跳转的话，那么这个菜单应该显示出来，同理它的上级菜单应该是可以显示的，递归这个的上级的上级菜单也是可以显示的，以此类推。\n            # 是否默认打开：只有当前URL和用户请求的URL匹配上了才会变成True，所以默认False\n            # 这个菜单是否默认应该被打开呢？当然不是，需要根据URL的正则去判断是否为True。\n            \'status\': True,\n            \'opened\': False\n        }\n        # 如果我当前点的就是这个权限url，那么就应该被展开。\n        if re.match(per[\'permission__url\'],request.path_info):\n            item[\'opened\'] = True\n        pid = item[\'parent_id\']\n        # 开始挂靠工作，把权限挂到菜单上，等所有的权限循环完毕了，操作完了所有的菜单都挂靠完毕了，当然有些权限是可以挂到菜单，有些是不需要挂载的，比如上传图片，不需要体现到菜单上，之后做拓展，比如menu-id为none的时候就允许不挂到菜单上。\n        all_menu_dict[pid][\'child\'].append(item)\n\n\n        # 如果说这个菜单下有权限，那么这个菜单的父级status就等于true，应该被显示出来，这个父级菜单的父级菜单也应该被显示出来，同样应该将status设置为true。\n        temp = pid  # 1.父亲ID\n        # 递归的出口：当父级id=None的时候那么就证明找到头了。\n        # 同时为了避免已经改过的再次去执行，判断一下，如果不是true再改。少循环点\n        while not all_menu_dict[temp][\'status\']:\n            all_menu_dict[temp][\'status\'] = True\n            temp = all_menu_dict[temp][\'parent_id\']\n            if not temp:\n                break\n\n        # 将当前权限前辈opened=True\n        if item[\'opened\']:\n            temp1 = pid  # 1.父亲ID\n            while not all_menu_dict[temp1][\'opened\']:\n                all_menu_dict[temp1][\'opened\'] = True\n                temp1 = all_menu_dict[temp1][\'parent_id\']\n                if not temp1:\n                    break\n\n    # ############ 处理菜单和菜单之间的等级关系，菜单挂靠子菜单。 ############\n    \"\"\"\n    all_menu_dict = {\n        1:{\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[{\'permission__url\':\'/order.html\',\'permission__caption\': \'订单管理\',\'permission__menu_id\': 1 },]},\n        2:{\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:False,opened:False,child:[]},\n        3:{\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:False,opened:False,child:[]},\n        5:{\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},\n    }\n\n\n    all_menu_list= [\n        {\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[{\'permission__url\':\'/order.html\',\'permission__caption\': \'订单管理\',\'permission__menu_id\': 1 }, {\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},]},\n        {\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:False,opened:False,child:[]},\n        {\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:False,opened:False,child:[]},\n\n    ]\n    \"\"\"\n\n    result = []\n    for row in all_menu_list:\n        pid = row[\'parent_id\']\n        if pid:\n            all_menu_dict[pid][\'child\'].append(row)\n        else:\n            # 上面的子菜单挂靠完成以后，然后把所有的跟菜单扔到result这个列表里，这就是我们想要的结果了。\n            result.append(row)\n\n    ##################### 结构化处理结果 #####################\n    for row in result:\n        print(row[\'caption\'], row[\'status\'], row[\'opened\'], row)\n\n    ##################### 通过结构化处理结果，生成菜单开始 #####################\n    \"\"\"\n    result = [\n        {\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[5:{\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},2:{\'id\':2, \'caption\':\'菜单2\', parent_id:1,status:False,opened:False,child:[]},]}\n        {\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:True,opened:False,child:[]},\n        {\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:true,opened:False,child:[url...]},\n    ]\n    \"\"\"\n\n    # status=False ,不生产成\n    # opened=True  ,true不加hide，false，加hide，也就是隐藏的意思。\n    \n    \"\"\"\n\t# 希望生成一个这样的html结果。\n    <div class=\'menu-item\'>\n        <div class=\'menu-header\'>菜单1</div>\n        <div class=\'menu-body %s\'>\n            <a>权限1</a>\n            <a>权限2</a>\n             <div class=\'menu-item\'>\n                <div class=\'menu-header\'>菜单11</div>\n                <div class=\'menu-body hide\'>\n                    <a>权限11</a>\n                    <a>权限12</a>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div class=\'menu-item\'>\n        <div class=\'menu-header\'>菜单2</div>\n        <div class=\'menu-body hide\'>\n            <a>权限1</a>\n            <a>权限2</a>\n        </div>\n    </div>\n    <div class=\'menu-item\'>\n        <div class=\'menu-header\'>菜单3</div>\n        <div class=\'menu-body hide\'>\n            <a>权限1</a>\n            <a>权限2</a>\n        </div>\n    </div>\n\n\n    \"\"\"\n\n    def menu_tree(menu_list):\n        tpl1 = \"\"\"\n            <div class=\'menu-item\'>\n                <div class=\'menu-header\'>{0}</div>\n                <div class=\'menu-body {2}\'>{1}</div>\n            </div>\n            \"\"\"\n        tpl2 = \"\"\"\n            <a href=\'{0}\' class=\'{1}\'>{2}</a>\n            \"\"\"\n\n        menu_str = \"\"\n        for menu in menu_list:\n            # 如果不该显示，直接pass就可以了。\n            if not menu[\'status\']:\n                continue\n            # menu: 可能是菜单，可能是权限（url）\n            if menu.get(\'url\'):\n                # 权限\n                menu_str += tpl2.format(menu[\'url\'], \'active\' if menu[\'opened\'] else \"\", menu[\'caption\'])\n            else:\n                # 菜单\n                if menu[\'child\']:\n                    child_html = menu_tree(menu[\'child\'])\n                else:\n                    child_html = \"\"\n                menu_str += tpl1.format(menu[\'caption\'], child_html, \"\" if menu[\'opened\'] else \'hide\')\n\n        return menu_str\n\n    menu_html = menu_tree(result)\n\n    return render(request, \'menu.html\', {\'menu_html\': menu_html})\n```\n\n## 作为组件来使用\n\n组件：作为一个公共的app\n\n- 权限的限制\n- 生成菜单\n- 仍然是涉及到七张表\n\n单独起一个app，这个插件并不做展示。结合session和中间件做操作。\n\n运行步骤：\n\n- 引入中间件，利用权限控制\n- 创建菜单功能，调用service控件。 \n\n```python\n# 其他app引用这个rbac的model内容\nfrom django.db import models\nfrom rbac.models import User as RabcUser\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    user = models.OneToOneField(RbacUser)\n```\n\n三种情况会调用\n\n- 登录成功，写session，sevice.permission_session(userid，request)\n- 做检测，在配置文件中注册中间件。\n- 生成菜单，调用service里面的menu，css，js方法。如果要实现动态菜单的话就把这个菜单的信息放到session里面去。只要从session中获取到就可以了。可以通过simple_tag来实现。\n\n### 用户权限采集\n\n首先用户模型的定义是不变的，仍然和上述一样，首先把用户的权限采集标准化，在rbac的app中新建一个service文件，用来存放这一部分的逻辑。\n\n首先在系统settings文件中添加一下内容，后面的操作会逐一用到并做说明：\n\n```python\nRBAC_NO_AUTH_URL = [\n    \'/index.html\',\n    \'/login.html\',\n    \'/register.html\',\n    \'/admin.*\',\n    \'/rbac.*\',\n]\nRBAC_PERMISSION_SESSION_KEY = \"rbac_permission_session_key\"\n\n# 把菜单放在session中，这一个取的是权限的session的key\nRBAC_MENU_PERMISSION_SESSION_KEY = \"rbac_menu_permission_session_key\"\n# 菜单key\nRBAC_MENU_KEY = \"rbac_menu_key\"\n# 权限信息\nRBAC_MENU_PERMISSION_KEY = \"rbac_menu_permission_key\"\n\n\"\"\"\nsession[RBAC_MENU_PERMISSION_SESSION_KEY] = {\n    RBAC_MENU_KEY:菜单信息,\n    RBAC_MENU_PERMISSION_KEY:权限信息\n}\n\"\"\"\n# RBAC的默认主题\nRBAC_THEME = \"default\"\nRBAC_QUERY_KEY = \"md\"\nRBAC_DEFAULT_QUERY_VALUE = \"look\"\n# 无权访问的时候提示的消息\nRBAC_PERMISSION_MSG = \"无权限访问\"\n```\n\n初始化用户权限逻辑\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport re\n# 一部分配置项我们保存在了django的settings文件中，通过引入文件可以拿到我们定义的全局env\nfrom django.conf import settings\n\nfrom . import models\n\n\ndef initial_permission(request, user_id):\n    \"\"\"\n    初始化权限，获取当前用户权限并添加到session中\n    将当前用户权限信息转换为以下格式，并将其添加到Session中\n        {\n            \'/index.html\': [\'GET\',\'POST\',\'DEL\',\'EDIT],\n            \'/detail-(\\d+).html\': [\'GET\',\'POST\',\'DEL\',\'EDIT],\n        }\n    \n    :param request: 请求对象\n    :param user_id: 当前用户id\n    :return: \n    \"\"\"\n\n    \"\"\"初始化权限信息\"\"\"\n    roles = models.Role.objects.filter(users__user_id=user_id)\n    p2a = models.Permission2Action2Role.objects.filter(role__in=roles).values(\'permission__url\',                                                                        \"action__code\").distinct()\n    user_permission_dict = {}\n    for item in p2a:\n        if item[\'permission__url\'] in user_permission_dict:\n            user_permission_dict[item[\'permission__url\']].append(item[\'action__code\'])\n        else:\n            user_permission_dict[item[\'permission__url\']] = [item[\'action__code\'], ]\n\t# 将拼接好的权限数据结构扔到session中，key我们在配置文件中进行了定义，可以灵活的定制。\n    request.session[settings.RBAC_PERMISSION_SESSION_KEY] = user_permission_dict\n\n    \"\"\"初始化菜单信息，将菜单信息和权限信息添加到session中\"\"\"\n    # queryset类型没法直接写到session中，需要变成列表，因为在放到session的时候如果你给我的是一个对象\n    # 它会优先把这个对象序列化然后再放到session里，但是默认的queryset不能做序列化。所以要先list一下。\n    menu_list = list(models.Menu.objects.values(\'id\', \'caption\', \'parent_id\'))\n\n    menu_permission_list = list(models.Permission2Action2Role.objects.filter(role__in=roles,                                                                   permission__menu__isnull=False).values(\n        \'permission_id\',\n        \'permission__url\',\n        \'permission__caption\',\n        \'permission__menu_id\').distinct())\n    request.session[settings.RBAC_MENU_PERMISSION_SESSION_KEY] = {\n        settings.RBAC_MENU_KEY: menu_list,\n        settings.RBAC_MENU_PERMISSION_KEY: menu_permission_list\n    }\n\n\ndef fetch_permission_code(request, url):\n    \"\"\"\n    根据URL获取该URL拥有的权限，如：[\"GET\",\"POST\"]\n    :param request: \n    :param url: \n    :return: \n    \"\"\"\n    user_permission_dict = request.session.get(settings.RBAC_PERMISSION_SESSION_KEY)\n    if not user_permission_dict:\n        return []\n    for pattern, code_list in user_permission_dict.items():\n        if re.match(pattern, url):\n            return code_list\n    return []\n\n```\n\n### 新建一个工单应用\n\n> 现在要新建一个工单的应用。然后把rbac结合进去\n\n#### models模型类\n\n```python\nfrom django.db import models\n# 引入RBAC模块中的RBAC的用户相关内容\nfrom rbac.models import User as RbacUser\n# import datetime\n\n\n# Create your models here.\nclass UserInfo(models.Model):\n\n    nickname = models.CharField(max_length=16)\n    # 使用的话直接和RBAC里的user做一个OneToOne就行了。\n    # 其他的用户名啊，密码啊，在这里其实就根本不用体现了。\n    user = models.OneToOneField(RbacUser, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.nickname\n\n\nclass Order(models.Model):\n    # nid = models.IntegerField(primary_key=True, )\n    # uuid也是生成一个随机字符串扔进来\n    # uid = models.UUIDField()\n    \"\"\"报障单\"\"\"\n    title = models.CharField(max_length=32, verbose_name=\'报障标题\')\n    detail = models.TextField(verbose_name=\'报事详细\')\n    # 有多个字段外键连接到同一个表的时候记得加relate name否则反向查询的时候根本不知道找的谁。\n    create_user = models.ForeignKey(UserInfo, on_delete=models.CASCADE, related_name=\'aaa\')\n    # Tip：记住这里如果要加一个默认值的话需要加一个方法，而是方法执行后的结果，否则数据就一直不变了，因此去掉括号，不去调用。\n    # ctime = models.DateTimeField(auto_now_add=True, default=datetime.datetime.now)\n    ctime = models.DateTimeField(auto_now_add=True)\n    # 时间也可以是float类型，放一个时间戳\n    # ctime = models.FloatField()\n    status_choice = (\n        (1, \'未处理\'),\n        (2, \'处理中\'),\n        (3, \'已处理\'),\n    )\n    status = models.IntegerField(choices=status_choice, default=1)\n    processor = models.ForeignKey(UserInfo, on_delete=models.CASCADE, related_name=\'bbb\', null=True, blank=True)\n    solution = models.TextField(null=True, blank=True)\n    ptime = models.DateTimeField(null=True, blank=True)\n\n    def __str__(self):\n        return \'%s-%s\' % (self.title, self.create_user)\n```\n\n#### 中间件层\n\n在到视图函数之前还要过一层中间件，记得中间件要在全局配置文件里注册一下：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport re\n# 配置文件这回我扔到全局配置文件里去了。\nfrom django.conf import settings\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.shortcuts import HttpResponse\n\n\nclass RbacMiddleware(MiddlewareMixin):\n    def process_request(self, request, *args, **kwargs):\n        \"\"\"\n        检查用户是否具有权限访问当前URL\n        :param request: \n        :param args: \n        :param kwargs: \n        :return: \n        \"\"\"\n\n        \"\"\"跳过无需权限访问的URL，比如登录界面，这个从全局配置文件直接取。\"\"\"\n        for pattern in settings.RBAC_NO_AUTH_URL:\n            if re.match(pattern, request.path_info):\n                return None\n\n        \"\"\"获取当前用户session中的权限信息\"\"\"\n        permission_dict = request.session.get(settings.RBAC_PERMISSION_SESSION_KEY)\n        if not permission_dict:\n            return HttpResponse(settings.RBAC_PERMISSION_MSG)\n\n        \"\"\"当前URL和session中的权限进行匹配\"\"\"\n\n        flag = False\n        for pattern, code_list in permission_dict.items():\n            # 把所有的code_list给转换成大写\n            upper_code_list = [item.upper() for item in code_list]\n            if re.match(pattern, request.path_info):\n                # 我去拿这个请求后面带的参数，如果没带参数的话那么就给一个默认的并且给大写了。\n                request_permission_code = request.GET.get(settings.RBAC_QUERY_KEY, settings.RBAC_DEFAULT_QUERY_VALUE).upper()\n                if request_permission_code in upper_code_list:\n                    # 用户当前访问的权限，为了方便以后在视图函数中调用。比如=GET\n                    request.permission_code = request_permission_code\n                    # 当前用户的所有权限，为了方便以后在视图函数中调用。\n                    request.permission_code_list = upper_code_list\n                    flag = True\n                    break\n\n        if not flag:\n            return HttpResponse(settings.RBAC_PERMISSION_MSG)\n\n```\n\n#### 视图函数\n\n```python\n\n```\n\n","timestamp":1531448340028},{"name":"11-Django-auth模块.md","path":"06-Django/11-Django-auth模块.md","content":"# Django Auth\n\n```python\n# session添加过程\n1.生成特殊字符串\n2.以生成的特殊字符串为key，在数据库的session表中对应一个session value\n3.在响应中向浏览器写了一个cookie，cookie的值就是这个特殊的字符串\n\n# 登录校验装饰器\nfrom functools import wraps\ndef check_login(f):\n    # 装饰器修复技术\n    @wraps(f)\n    def inner(request, *args, **kwargs):\n        if request.session.get(\'is_login\') == \'1\':\n            return f(request, *args, **kwargs)\n        else:\n            return redirect(\"/login\")\n```\n\n## Auth模块的简单实用\n\n- 创建用户，这样创建的用户其实是会扔到django为我们默认创建的初始表中的auth_user这张表中。\n\n  ```shell\n  python manage.py createsuperuser\n  ```\n\n  \n\n```python\nclass AuthenticationMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        assert hasattr(request, \'session\'), (\n            \"The Django authentication middleware requires session middleware \"\n            \"to be installed. Edit your MIDDLEWARE%s setting to insert \"\n            \"\'django.contrib.sessions.middleware.SessionMiddleware\' before \"\n            \"\'django.contrib.auth.middleware.AuthenticationMiddleware\'.\"\n        ) % (\"_CLASSES\" if settings.MIDDLEWARE is None else \"\")\n        request.user = SimpleLazyObject(lambda: get_user(request))\n```\n\n\n\n\n\n## 扩展自带的auth_user表\n\n1. 新建一个表，然后一对一关联上面的auth_user表，就可以进行关联了。\n\n2. 自己写一个类，继承这个auth_user类，然后自己再写一些自定义类。\n\n   ```python\n   # 注意继承的类不是User试AbstractUser\n   class UserInfo(AbstractUser):\n       ……………………\n       \n   # 如果使用继承的方式使用了内置的auth，这个时候要在settings里配置，设置一下用户认证的时候默认使用的是哪一张表，因为一旦继承了以后其实相当于覆盖了原来的表\n   AUTH_USER_MODEL = \'app01.UserInfo\'\n   ```\n\n   \n\n\n\n# 表结构设计\n\n\n\n\n\n\n\n## 验证码\n\n使用极验：https://docs.geetest.com/install/deploy/server/python\n\n","timestamp":1531448340028},{"name":"01-CMDB-1.md","path":"06-Django/97-CMDB/01-CMDB-1.md","content":"# CMDB\n\n> 配置管理数据库\n\n## CMDB介绍\n\n运维愿景：\n\n\t1. 自动装机\n\t2. 配置管理\n\t3. 监控\n\t4. 堡垒机\n\t\n\t必备：资产管理\n\n目前状况：\n目前状况：\n\t手动维护Excel表格\n\t资产自动采集并汇报入库，少了块硬盘多了个内存自动记录汇报\n\t\n\tCMDB - 配置管理数据库（资产管理）\n\n如何实现自动采集？\n如何实现自动采集？\n\tsubprocess\n\tLinux基本命令\n\tv = subprocess.getoutput(\'ls\')\n\t1. Agent\n\t\n\t2. SSH类，paramiko，(机器少的时候用paramiko，因为ssh本身存在性能瓶颈)\n\t\tpip3 install paramiko\n\t\t\n\t3. saltstack(Python开发)\n\t\tmaster\n\t\t\tyum install salt-master\n\t\t\t\n\t\t\t配置：1.1.1.1\n\t\t\tservice salt-master start\n\t\t\t\n\t\tsalve\n\t\t\tyum install salt-minion\n\t\t\t配置：\n\t\t\t\tmaster: 1.1.1.1\n\t\t\tservice salt-master start\n\t\tsalve\n\t\t\tyum install salt-minion\n\t\t\t配置：\n\t\t\t\tmaster: 1.1.1.1\n\t\t\tservice salt-master start\n\t\n\t\n\t\t授权：\n\n​\t\t\n​\t\t\n​\t\t\n\t\t执行命令：\n\t\t\t在master上执行： salt \"*\" cmd.run \"ifconfig\"\n\t\n\t4. puppet(ruby)\n\n目标：兼容三种采集方式软件\n目标：兼容三种采集方式软件\n​\t\n​\t\t\n任务：\n\t1. Agent方式\n\n\t\tAPI：Django接收数据并入库\n\t\n\t\t程序：放置在每台服务器\n\t\n\t2. SSH类\n\t\n\t\tAPI：Django接收数据并入库\n\t\n\t\t程序：放在中控机\n\t\n\t3. saltstack\n\t\n\t\thttp://www.cnblogs.com/wupeiqi/articles/6415436.html\n\t\n\t\tAPI：Django接收数据并入库\n\t\n\t\tmaster:\n\t\t\tv = subprocess.getoutput(\'salt \"*\" cmd.run \"ls\"\')\n\t\n\t\t前提：\n\t\t\t两个虚拟机：\n\t\t\t\t安装：\n\t\t\t\t\tmaster\n\t\t\t\t\tminion\n\t\t\t\t\n\t\t\t\t配置：\n\t\t\t\t\t...\n\t\t\t\t授权：\n\t\t\t\t\t...\n\t\t\t\t\t\n\t发送：\n\t\t# url = \"http://127.0.0.1:8000/asset.html\"\n\t\t# import requests\n\t\t#\n\t\t# response = requests.post(url,data={\'k1\':value1,\'k2\':value2})\n\t\t# print(response.text)\n\t\n\nCMDB资产采集：\nCMDB资产采集：\nCMDB资产采集：\n\n- 采集资产：执行命令，正则或字符串方法获取想要的数据\n- 兼容性\n- 汇报数据\n\n```python\n# 使用字符串导入模块，下面就是从a模块下的b模块下导入c\nimportlib.import_model(\'a.b.c\')\n\nm = importlib.import_model(\'a.b.c\')\ncls = getattr(m, \'d\')\ncls()\n```\n\n面向对象：\n\n```python\nclass Foo:\n    def __init__(self, xxx):\n        pass\n    @classmethod\n    def instance(cls):\n        return cls()\n    def process(self):\n        pass\nif hasattr(Foo, \'instance\'):\n    obj = Foo.instance()\nelse:\n    obj = Foo()\n```\n\n面向对象2：\n\n```python\nclass A:\n    def f1(self):\n        self.f2()\n    def f2(self):\n        print(\'A.f2\')\n\nclass B(A):\n    def f2(self):\n        print(\"B.f2\")\nobj = B()\nobj.f1()  # B.f2\n```\n\n\n\n\n\n项目目录：\n\n```python\n(cmdb) ➜  cmdb > tree -L 1 .\n.\n├── bin             # 可执行的程序文件\n├── config          # 配置目录\n├── lib             # 类库，可以使用的各种工具类\n└── src             # 业务代码\n```\n\n>CMDB资产采集：www.cnblogs.com/wupeiqi/articles/6415436.html\n\n\n\n\n\n\n\n## 中控客户端设计（AutoClient）\n\n### 配置文件设计\n\n> 很多应用程序在运行的时候不需要加任何参数就可以直接跑起来，或者说使用很少的参数就可以跑起来。其实并不是因为不需要参数，而是因为程序内部就包含了很多内置的参数供我们调用，当我们自己进行单独指定配置文件的参数项以后，程序又会按照我们指定的参数进行运行，因此配置文件设计思路有两点：\n>\n> 1. 程序包含一套内置的默认配置文件\n> 2. 用户可以自己定制配置文件的值，用户定制的配置优先权重要高于默认的\n\n首先按照以下的规则进行创建配置文件：\n\n```shell\n(cmdb) ➜  cmdb > tree . -L 2\n.\n├── bin\n│   ├── __init__.py\n│   └── start.py\n├── config\n│   ├── __init__.py\n│   └── settings.py              # 用户可以进行配置定义的配置文件\n├── lib\n│   ├── __init__.py\n│   └── conf\n│       ├── __init__.py\n│       ├── config.py            # 配置文件加载脚本\n│       └── global_settings.py   # 全局默认的配置文件\n├── src\n```\n\n为了方便测试，我们在全局配置文件和用户配置文件中添加一些配置项：\n\n```python\n# global_settings.py\nUSER = \'lamber\'\nPASSWORD = \'123456\'\nEMAIL = \'1020561033@qq.com\'\nBANNER = \'Hello World!\'\n\n# settings.py\nMODE = \"AGENT\"\n```\n\n在配置脚本的py文件中进行加载配置项：\n\n```python\n# -*- coding: utf-8\n\nimport os\nimport importlib\n\n# 分别引入默认文件和用户配置文件\nfrom . import global_settings\n\n\nclass Settings(object):\n    \n    def __init__(self):\n\n        # 找到默认配置，默认配置的优先级是要低于自定义的\n        # 因此默认配置先执行，通过dir属性拿到global_settings模块中的属性值\n        for name in dir(global_settings):\n            # 配置文件的每一个选项必须是大写的。\n            if name.isupper():\n                # 注意这里拿到的其实只不过是字符串而已，如果要想取属性值要利用到反射\n                value = getattr(global_settings, name)\n                # 通过setattr将对象的name属性设置为value的值\n                setattr(self, name, value)\n\n        # 随后找到自定义配置，从全局环境变量中拿USER_SETTINGS的值\n        # settings_module = os.environ[\'USER_SETTINGS\']\n        # 替换成get要优于上面的写法，如果没有的话不会报错而会返回None\n        # USER_SETTINGS是在start入口文件进行设置的，内容为用户自定义配置\n        settings_module = os.environ.get(\'USER_SETTINGS\')\n        if not settings_module:\n            return\n        # 根据字符串导入模块，返回的m其实就是对应的模块\n        m = importlib.import_module(settings_module)\n        for name in dir(m):\n            # 配置文件的每一个选项必须是大写的。\n            if name.isupper():\n                # 因为对应的用户自定义的选项在后面，因此如果有同名的name的话默认的会被自定义的覆盖\n                value = getattr(m, name)\n                setattr(self, name, value)\n\n\n# 只要以后导入这个settings就可以进行使用了。\nsettings = Settings()\n```\n\n调用：\n\n```python\n# bin/start.py\nimport os\n\n# 引用集成的文件就可以拿到对应的配置文件了。\nfrom lib.conf.config import settings\n\n# 全局变量做赋值，这个只在当前的运行的应用程序的环境变量里\n# 运行完了就没了，这个并不影响其他的程序。\nos.environ[\'USER_SETTINGS\'] = \'config.settings\'\n\nprint(settings.USER)\nprint(settings.EMAIL)\nprint(settings.MODE)\nprint(settings.BANNER)\n\n# 执行结果：\nlamber\n1020561033@qq.com\nAGENT\nHello World!\n```\n\n这样我们就可以取到想要的默认配置和用户配置了。\n\n### 可插拔式插件\n\n> 作为数据采集和cmdb数据录入的中间人的中控机来讲，中控机具有采集客户端各个指标的功能，我们把这些采集指标的功能叫做功能插件，这个插件应该可以是灵活的进行管控的，就好像Django中的INSTALLED_APP，允许我们自己进行添加和删除。针对这个需求进行可插拔式插件的设计。\n\n可插拔式的插件对于用户来说是可以进行自己控制和定义的。因此可以在用户自定义配置文件中去进行配置。在项目根目录的src目录下新建一个plugins目录用于保存我们的自定义插件，每一个插件就是一个一个小的监控脚本，比如：\n\n```python\n➜  plugins > tree\n.\n├── __init__.py\n└── basic.py\n```\n\n既然是允许用户可以自定义的，那么就允许用户在setting配置文件中进行配置的。我们可以构造一个字典，其中key为要监控的对应的指标，value为对应插件所在路径，比如如下样式：\n\n```python\nPLUGINS_DICT = {\n    \'basic\': \"src.plugins.basic.Basic\",\n}\n```\n\nPython Package中的`__init__.py`文件会在模块被导入的时候执行，为了保证导入模块的时候，我们的组件全部加载执行并获取到数据，我们可以把对应的内容获取脚本写到plugins目录下的`__init__.py`中去。\n\n```python\nimport importlib\nimport subprocess\nimport paramiko\n# 将用户配置的可插拔插件的配置项导入\nfrom lib.conf.config import settings\n\n\nclass PluginManager(object):\n\n    def __init__(self, hostname=None):\n        \"\"\"\n        把用到的内容都放到构造方法里清晰明了\n        因为采集方式不一样，那么有的需要主机名，有的也就不需要\n        需要的话就传递，不需要的话就默认为None\n        \"\"\"\n        self.hostname = hostname\n        # 先把可插拔配置项拿到\n        self.plugin_dict = settings.PLUGINS_DICT\n        # 获取的方式有agent，ssh或者salt三种，这个是允许用户在配置文件里配置的。\n        self.mode = settings.MODE\n        self.debug = settings.DEBUG\n        # 如果当方式为ssh的模式，那么就需要ssh所必须的地址，端口，密码，或者是密钥\n        if self.mode == \"SSH\":\n            self.ssh_user = settings.SSH_USER\n            self.ssh_port = settings.SSH_PORT\n            self.ssh_pwd = settings.SSH_PWD\n            self.ssh_key = settings.SSH_KEY\n\n    def exec_plugin(self):\n        \"\"\"\n        获取所有的插件，执行并获取插件的返回值\n        :return: 插件的返回值\n        \"\"\"\n        # 构造一个空字典\n        response = {}\n        for k, v in self.plugin_dict.items():\n            \"\"\"\n            循环遍历可插拔配置中的每一条记录项目，内容示例如下：\n            k = \'basic\'，v = \"src.plugins.basic.Basic\",\n            需要导入模块然后运行再拿到模块的返回值，因此需要我们进行拆分\n            \"\"\"\n            # rsplit表示从右面才是切割，1表示切一次，如此切割可以将模块路径和模块名切开\n            module_path, class_name = v.rsplit(\'.\', 1)\n            m = importlib.import_module(module_path)\n            # 根据模块名去找类。\n            cls = getattr(m, class_name)\n            if cls:\n                # 根据v获取类，并执行其对应的process方法采集资产\n                # 这里直接把命令执行方法的内存地址传递了过去，供插件进行调用。\n                # 拿到插件的返回值以后更新字典\n                result = cls().process(self.command)\n                response[k] = result\n        return response\n\n    def command(self, cmd):\n\t\t\"\"\"\n\t\t对应的执行命令的方法，我们知道获取数据有三种方案，agent，ssh或者是salt\n\t\t那么难道每次执行都要重新写一遍这三种方法么？当然不用。我们可以定义一个基类，在基类\n\t\t中去实现这三种方法，然后后面的所有插件都继承这个基类就可以了，就可以在插件类中直接调用\n\t\t这里没有采用继承的方案，而是自己去构造了一个内部的方法去实现。根据配置文件中设置的不同\n\t\tMODE，我们判断去执行不同的方法。\n\t\t\"\"\"\n        if self.mode == \"AGENT\":\n            \"调用subprocess\"\n            return self.__agent(cmd)\n        elif self.mode == \"SSH\":\n            return self.__ssh(cmd)\n        elif self.mode == \"SALT\":\n            return self.__salt(cmd)\n        else:\n            raise Exception(\'模式只能是AGENT/SSH/SALT\')\n\n    def __agent(self, cmd):\n        \"\"\"\n        单下划线：私有的，外部不能访问，外部也无需关心。\n        :param cmd:\n        :return:\n        \"\"\"\n        output = subprocess.getoutput(cmd)\n        return output\n\n    def __ssh(self, cmd):\n        # private_key = paramiko.RSAKey.from_private_key_file(self.ssh_key)\n        # ssh = paramiko.SSHClient()\n        # ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        # ssh.connect(hostname=self.hostname, port=self.ssh_port, username=self.ssh_user, pkey=private_key)\n        # stdin, stdout, stderr = ssh.exec_command(cmd)\n        # result = stdout.read()\n        # ssh.close()\n\t\t\"\"\"\n\t\tssh存在两种方式，一种为账号密码端口，一种直接采用密钥。\n\t\t\"\"\"\n        ssh = paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        ssh.connect(hostname=self.hostname, port=self.ssh_port, username=self.ssh_user, password=self.ssh_pwd)\n        stdin, stdout, stderr = ssh.exec_command(cmd)\n        result = stdout.read()\n        ssh.close()\n        return result\n\n    def __salt(self, cmd):\n        \"\"\"\n        salt只能运行在python2中。python3支持不是很好。\n        所以在python3中可以使用subprocess来仿制一下salt\n        :param cmd:\n        :return:\n        \"\"\"\n        # import salt.client\n        # local = salt.client.LocalClient()\n        # result = local.cmd(self.hostname, \'cmd.run\', [cmd])\n        # return result[self.hostname]\n        salt_cmd = \"salt \'%s\' cmd.run \'%s\'\" % (self.hostname, cmd,)\n        output = subprocess.getoutput(salt_cmd)\n        return output\n```\n\n到此为止，整个插件调用的过程就写完了。最后exec_plugins会给我们把数据获取的所有字典给返回过来。接下来就是插件的具体实现。配置文件中我们配置了basic，我们就可以先来实现这个内容。假定MODE目前为agent模式，我们采用subprocess去调用。\n\n从插件调用的过程中，我们知道插件内部需要存在一个process方法。这里首先模拟一个数据，查看是否能够真正的拿到数据，最后真实的数据要通过subprocess模块动态的去获取。\n\n```python\nclass Basic(object):\n    def __init__(self):\n        pass\n\n    def process(self, command_func, debug):\n        if debug:\n            output = {\n                \'os_platform\': \"linux\",\n                \'os_version\': \"CentOS release 6.6 (Final)\\nKernel \\r on an \\m\",\n                \'hostname\': \'c1.com\'\n            }\n        return output\n```\n\n在入口文件进行调用：\n\n```python\nimport os\nimport sys\n\n# 全局变量做赋值，这个只在当前的运行的应用程序的环境变量里\n# 运行完了就没了，这个并不影响其他的程序。\nos.environ[\'USER_SETTINGS\'] = \'config.settings\'\n# 因为要导入的src在start.py的上级目录下，因此首先将整个项目目录添加到path中。\nBASEDIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.append(BASEDIR)\n\n\n# 引用集成的文件就可以拿到对应的配置文件了。\nfrom lib.conf.config import settings\n# 在导入的plugins模块的时候__init__.py文件会自动执行然后加载所有模块并拿到对应的返回值。\nfrom src.plugins import PluginManager\n\nif __name__ == \'__main__\':\n    server_info = PluginManager().exec_plugin()\n    print(server_info)\n```\n\n最后打印出来的结果如下，假如说我们添加了其他的插拔式组件的话，其他的组件内容也会被假如到这里面来。：\n\n```python\n{\n    \'basic\': {\n        \'os_platform\': \'linux\', \n        \'os_version\': \'CentOS release 6.6 (Final)\\nKernel \\r on an \\\\m\', \n        \'hostname\': \'c1.com\'\n    }\n}\n```\n\n#### 针对可插拔插件预留钩子\n\n> 在上面的入口文件我们可以发现我们直接去实例化PluginManager然后调用exec_plugin方法，在这个过程中是依次去实例化每一个插件类，然后调用插件类的process方法。如果以后有这么一个需求，在实例化之前先去做一些什么操作的话这样现在的逻辑就不支持了。因此针对这个问题预留一个钩子。\n\n在每一个插件类中定义一个initial的类方法，通过这个方法实现实例化之前的一系列操作。\n\n```python\nclass Basic(object):\n    def __init__(self):\n        pass\n\n    @classmethod\n    def initial(cls):\n        \"这里可以写点实例化之前要做的操作。方便入口拓展\"\n        return cls()\n\n    def process(self, command_func, debug):\n        …………………………\n        return output\n```\n\n然后在plugins中的`__init__.py`文件中进行判断对应的模块类中是否有这个方法。如下为对PluginManager中的exec_plugins方法的改进：\n\n```python\ndef exec_plugin(self):\n    \"\"\"\n    获取所有的插件，执行并获取插件的返回值\n    :return: 插件的返回值\n    \"\"\"\n    response = {}\n    for k, v in self.plugin_dict.items():\n        # k = \'basic\'\n        # v = \"src.plugins.basic.Basic\",\n        # rsplit表示从右面才是切割，1表示切一次\n        module_path, class_name = v.rsplit(\'.\', 1)\n        m = importlib.import_module(module_path)\n        # 根据模块名去找类。\n        cls = getattr(m, class_name)\n        if hasattr(cls, \'initial\'):\n            obj = cls.initial()\n        else:\n            # 根据v获取类，并执行其对应的process方法采集资产\n            obj = cls()\n        result = obj.process(self.command, self.debug)\n        response[k] = result\n    return response\n```\n\n#### 资产采集之错误堆栈信息\n\n上面的资产采集插件内容我们都是写死的，而实际过程中我们是需要去动态的获取的，比如这样：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport os\n\n\nclass Basic(object):\n    def __init__(self):\n        pass\n\n    @classmethod\n    def initial(cls):\n        return cls()\n\n    def process(self, command_func, debug):\n        if debug:\n            output = {\n                \'os_platform\': command_func(\"uname\").strip(),\n                \'os_version\': \"Darwin 马晓雨的MBP 17.4.0 Darwin Kernel Version 17.4.0: Sun Dec 17 09:19:54 PST 2017; root:xnu-4570.41.2~1/RELEASE_X86_64 x86_64\",\n                \'hostname\': \'马晓雨的MBP\'\n            }\n        else:\n            output = {\n                \'os_platform\': command_func(\"uname\").strip(),\n                \'os_version\': command_func(\"cat /etc/issue\").strip().split(\'\\n\')[0],\n                \'hostname\': command_func(\"hostname\").strip(),\n            }\n        return output\n```\n\n这里设置一个debug其实就是方便调试，也就是拿我们写死的数据，如果非调试模式就是直接通过subprocess去执行命令拿返回值。那么执行命令就有可能存在执行失败报错，那么我们就需要捕获这个报错，因此针对执行命令的入口，PluginManager的exec_plugins方法进行修改：\n\n```python\ndef exec_plugin(self):\n    response = {}\n    for k, v in self.plugin_dict.items():\n        # 在这里再套一个字典，设置data和status命令执行状态，默认执行成功，status为true\n        ret = {\'status\': True, \'data\': None}\n        # 在结果获取的过程中设置try except去捕获可能出现的报错\n        try:\n            module_path, class_name = v.rsplit(\'.\', 1)\n            m = importlib.import_module(module_path)\n            # 根据模块名去找类。\n            cls = getattr(m, class_name)\n            if hasattr(cls, \'initial\'):\n                obj = cls.initial()\n            else:\n                obj = cls()\n            result = obj.process(self.command, self.debug)\n            ret[\'data\'] = result\n        except Exception as e:\n            # 如果捕获到报错的话，那么获取结果状态设置为false，并且将错误堆栈信息记录到ret\n            ret[\'status\'] = False\n            ret[\'data\'] = \"[%s][%s] 采集数据出现错误 : %s\" %(self.hostname if self.hostname else \"AGENT\", k, traceback.format_exc())\n        response[k] = ret\n    return response\n```\n\n这里针对记录的错误堆栈信息不是单纯的打印exception捕获的e，这个e仅仅是错误内容，而我们需要的是把捕获到的整个堆栈信息全部都捕获到，确保用户知道出错了以后定位到某一个文件的具体某一个位置。\n\n#### 通过API获取采集的信息\n\n> - Agent模式\n>\n>   针对agent客户端模式，向API发送报告资产信息，比如agent多久采集一次，然后给api发送信息就可以了。发送过去直接采集入库。\n>\n> - SSH、SALT，存在中控机。\n>\n>   1. 首先来获取采集的主机列表\n>   2. 循环主机列表，采集资产，发送到API\n\n实现一个工具类，src/client.py。在书写这个之前，针对ssh和salt模式，当机器比较多的时候比如100台甚至更多的时候，如果通过for循环去一台一台的获取的话效率是很低的，因为这个过程是串行的，执行完一个再执行下一个，因此针对这个问题，可以采用多线程或者多进程去提高并发去处理，由于这个操作是IO（网络IO）密集型的，而不是计算密集型的，因此我们使用线程池就可以了。\n\n即使是多线程也不能无限制的开启，因为多线程的上下文切换也会有很多的损耗。因此我们要设置一个限制，使用线程池去控制开启的现成数量。针对python2和python3来说，python2只有进程池没有线程池，python3是既有线程池，也有进程池。来看一下线程池示例代码\n\n```python\nimport time\n# 线程池和进程池的切换也很方便，切换个单词就行了\nfrom concurrent.futures import ThreadPoolExecutor\n# from concurrent.futures import ProcessPoolExecutor\n\n\ndef task(i):\n    time.sleep(1)\n    print(i)\n\n\n# 最多开10个线程\np = ThreadPoolExecutor(10)\nfor row in range(100):\n    # 在线程池拿一个线程去执行，接收两个参数，一个任务名称，一个执行任务接收的参数\n    # 看打印结果我们就可以看到是十个十个出来的\n    p.submit(task, row)\n```\n\n将线程池应用到API获取工具类的SSHSALT部分。\n\n##### API实现代码\n\n```python\nimport requests\nimport json\nfrom src.plugins import PluginManager\nfrom lib.conf.config import settings\nfrom concurrent.futures import ThreadPoolExecutor\n\n\nclass Base(object):\n\t\"\"\"定义一个基类，定义基础向远程发送资产信息的方法，通过requests发送\"\"\"\n    def post_asset(self, server_info):\n        # 向远程地址发其实就是向API发，这个API可以先定义在settings配置文件中。\n        # 发什么？发server的数据，写json的话他会给你在内部做一个json.dumps转换成字符串\n        # request.body就是请求的原生值，request.post就是根据特殊的请求头部拿出来的内容\n        requests.post(settings.API, json=server_info)\n        # 因此我们发送的内容就放到了请求体里，同时设置了header请求头\n        # 这个时候request.post是没有值的，request.post只有在请求头是\n        # application/x-www-form-urlencoded的时候才会把内容放到request.post\n        # 并且在ajax提交的时候，key对应的value可以是字符串，数字，数组，但是不能是字典格式。\n        # 因此不能把我们提交的这个数据扔到request.post里去。\n        \n        # body: json.dumps(server_info)\n        # headers= {\'content-type\':\'application/json\'}\n        \n        # 那么再django后台取数据的时候只能用下面这种方法来取。\n        # request.body\n        # json.loads(request.body)\n\nclass Agent(Base):\n\n    def execute(self):\n        server_info = PluginManager().exec_plugin()\n        self.post_asset(server_info)\n\nclass SSHSALT(Base):\n    def get_host(self):\n        # 获取未采集的主机列表：\n        response = requests.get(settings.API)\n        # \"{status:\'True\',data: [\'c1.com\',\'c2.com\']}\"\n        result = json.loads(response.text) \n        if not result[\'status\']:\n            return\n        return result[\'data\']\n    \n    def run(self,host):\n        # 定义发送API信息的任务\n        server_info = PluginManager(host).exec_plugin()\n        self.post_asset(server_info)\n\n    def execute(self):\n\t\t# 获取主机列表\n        host_list = self.get_host()\n        # 建立一个线程池，池子大小为10\n        pool = ThreadPoolExecutor(10)\n        for host in host_list:\n            # 循环并发执行采集信息任务\n            pool.submit(self.run, host)\n```\n\n使用一个脚本去调用api工具类：\n\n```python\n# src/script.py\nfrom lib.conf.config import settings\nfrom .client import Agent\nfrom .client import SSHSALT\n\n\ndef run():\n    if settings.MODE == \"AGENT\":\n        obj = Agent()\n    else:\n        obj = SSHSALT()\n    obj.execute()\n```\n\n最后在入口文件start.py去调用：\n\n```python\nfrom src import script\nif __name__ == \'__main__\':\n    script.run()\n```\n\n**高内聚,低耦合**\n\n- 高内聚：一个功能在它自己内部全部完成。\n\n\n- 低耦合：插件和其他的没有关系，它自己是一个独立的整体。\n\n## 主机唯一标识\n\n认为主板的SN号，是唯一标识，不过针对的这个是物理机，也就是说如果是物理机的话那么就可以认为这个SN号是唯一的。如果是虚拟机的话分为虚要采集和不需要采集，如果需要采集的话那么就不能用SN号了，不然采集出来的SN号都是一样的。一堆虚拟机都是一样的SN号，这样做不到唯一的标识。\n\n**因此需要做标准化：**\n\n- 主机名的标准化：主机名不能重复，需要依赖本地文件\n  1. 新机装系统初始化软件，运行CMDB。\n     - 通过命令获取主机名\n     - 写入本地的指定的文件\n  2. 将资产信息发送给api\n  3. 获取资产信息\n     - 本地文件主机名 ≠ 命令获取的主机名（按照文件的主机名）\n     - 本地文件主机名 == 命令获取的文件主机名\n- 流程的标准化：\n  - 装机的时候，需要将服务信息录入CMDB\n    - 资产录入，机房，机柜，机柜位置\n    - 装机的时候，需要将服务信息录入CMDB，可以利用cobbler，这个时候已经知道主机名\n    - 资产采集，获取主机名，从cmdb找到然后添加数据。有就操作，没有就忽略操作。\n\n**最终流程：**\n\n- 标准化：主机名不重复，流程的标准化（装机的同时，主机名在cmdb中设置）\n\n**服务器资产采集（Agent）：**\n\n1. 第一次：文件不存在，或内容为空：\n2. 资产采集：\n   - 主机名写入文件\n   - 发送API\n3. 第n次：采集资产，主机名，从文件中获取。\n\n**SSH或者SALT（有中控机存在）：**\n\n- 中控机：获取未采集主机名列表：拿到主机名，采集主机信息然后返回。\n\n### 唯一标识的实现代码\n\n```python\n# 修改采集用户api信息工具类的Agent工具类部分\nclass Agent(Base):\n\n    def execute(self):\n        server_info = PluginManager().exec_plugin()\n        # 首先获取到第一次的唯一标识，也就是主机名，这个就是新装系统的时第一次获取用于唯一标识\n        hostname = server_info[\'basic\'][\'data\'][\'hostname\']\n        # 获取到的内容拟放在config目录下的cert文件中保存\n        certname = open(settings.CERT_PATH,\'r\',encoding=\'utf-8\').read().strip()\n        # 如果打开的cert文件没有内容我们就把内容写进去\n        if not certname:\n            with open(settings.CERT_PATH,\'w\',encoding=\'utf-8\') as f:\n                f.write(hostname)\n        else:\n            # 如果有内容还涉及到本地文件主机名和命令获取的主机名一致不一致的问题，\n            # 默认以文件获取的为准，因此就直接等于文件读取到的certname\n            # 所以你手动改了主机名也没事。因为有唯一的标准参考\n            server_info[\'basic\'][\'data\'][\'hostname\'] = certname\n\n        self.post_asset(server_info)\n```\n\n\n\n","timestamp":1531448340028},{"name":"02-CMDB-2.md","path":"06-Django/97-CMDB/02-CMDB-2.md","content":"# CMDB AutoServer设计\n\n## API部分\n\n在上一节的AutoClient设计中，已经可以通过API向服务端发送消息了，现在可以简单的测试一下服务端接收消息了。\n\n### API部分模拟测试\n\n- 首先新建AutoServer端项目\n\n  ```python\n  # 进入虚拟环境\n  workon cmdb\n  # 创建django project\n  cd workspace\n  django-admin startproject autoserver\n  # 新建两个django的app项目，一个用来做api，一个用来做server的后台\n  python manage.py startapp api\n  python manage.py startapp backend\n  ```\n\n- 在全局url路径中引入api项目的路由\n\n  ```python\n  from django.contrib import admin\n  from django.urls import path, include\n\n  urlpatterns = [\n      path(\'admin/\', admin.site.urls),\n      path(\'api/\', include(\'api.urls\'))\n  ]\n  ```\n\n- 书写api路由\n\n  ```python\n  from django.urls import path, re_path\n  from api import views\n\n  urlpatterns = [\n      re_path(\'asset.html$\', views.asset),\n  ]\n  ```\n\n- 书写视图函数，先简单一点。\n\n  ```python\n  from django.shortcuts import render, HttpResponse\n\n\n  # Create your views here.\n  def asset(request):\n      if request.method == \"POST\":\n          print(request.POST)\n          print(request.body)\n\n      return HttpResponse(\'...\')\n\n  ```\n\n- 在client端发送数据，当前client端的mode为agent，那么会将采集的内容，发送过来，这里我们打印了request.POST和request.body，由于在client端发送的时候，header为`application/json`的，因此这里的request.POST是拿不到数据的，可以发现第一个querydict为空。\n\n  ```python\n  <QueryDict: {}>\n  b\'{\"basic\": {\"status\": true, \"data\": {\"os_platform……………………………………略\n  ```\n\n### Server端数据库设计\n\napi采集的信息要入库，api要使用这些表，后台同时也会使用这些表，那么数据库表的模型应该放在哪一个app下呢？其实放在哪一个下面都对。放在api中比较好，当然拆出来也是可以的，因此把数据库模型这块单独拆出来，作为一个数据库访问层单独来提供数据的访问来进行统一管理。\n\n```python\n# MTV中的Model层\npython manage.py startapp repository\n```\n\n### 资产入库\n\n\n\n\n\n\n\n### API验证\n\n> 首先为什么要做API验证？主要就是为了防止别随便来一个人都能从我这个接口这里拿数据，随便来一个人访问我的接口都能给我提交数据。保证数据一定的安全性。\n\n为了验证来访者是我们认识的，一个可用方案是可以让来访问的人带着一个我能认识的东西来访问这样就可以彼此达成共识。\n\n####静态token\n\n这个静态的token串是预先存在client和server端的，彼此预先做好交互的暗号。比如在客户端新建一个py文件做如下的操作：\n\n```python\n#!/usr/local/bin/python3\n\nimport requests\nkey = \"asdfasdfasdfasdf098712sdfs\"\nresponse = requests.get(\"http://127.0.0.1:8000/api/asset.html\",headers={\'OpenKey\':key})\nprint(response.text)\n```\n\n这里我们把这个key放到请求头里去，那么在server端应该如何去取呢？\n\n```python\n# 在视图函数中进行操作\ndef asset(request):\n    if request.method == \"GET\":\n        for k, v in request.META.items():\n            print(k, v)\n```\n\nrequest中有一个META数据，这个包含了发过来的请求的所有信息，通过查看内容我们就可以发现里面有一个键值对是`HTTP_OPENKEY`对应`asdfasdfasdfasdf098712sdfs`。value对应的正好就是我们发过来的字符串，但是key前面多了一个http，这个http是django为我们添加上的。然后我们把这个key和server端的key进行比较就可以，server端可以把这key扔到settings然后通过`from django.conf import settings`，然后通过settings进行调用。\n\n不过这种静态的认证字符串是有问题的，如果中间有第三者比如黑客截获以后你这个key是静态的不变的，那么黑客就可以拿过来自己写一个去为所欲为了。因此我们要对这个认证方案进行改进，改为动态的认证key。\n\n#### 动态token\n\n如果需要实现动态的token，可以采用两种方案，可以随着时间动起来，或者随着uuid动起来。这两个都能够成为唯一的辨识信息。因此对client端做如下的改动（以时间为唯一标准）：\n\n```python\nimport time\n# import uuid\nimport requests\nimport hashlib\n\n# 获取当前的时间戳，把key和time结合起来，首先让它动态起来。\nctime = time.time()\nkey = \"asdfasdfasdfasdf098712sdfs\"\nnew_key = \"%s|%s\" %(key, ctime,)\n\n# 避免内容是明文的，因此需要对这些内容需要一个加密\nm = hashlib.md5()\n# 在python3中，update后面接的内容是一个字节字符串，因此我们需要按照一定的编码转换一下\nm.update(bytes(new_key,encoding=\'utf-8\'))\n# 这个就是拿到的加密后的新key，这个key客户端在每一次调用的时候都是不一样的！因为时间戳在变。\n# 这里考虑一个问题，这个动态的内容是时刻在变的，那么服务端我怎么知道呢？服务端我只有一个key啊\n# 不可能这边加密操作一遍，然后在服务端再利用时间戳加密一遍，因为网络io是有时差的，加密后的值必定是不一样的，因此这里我们要把这个当前加密的时间戳给服务端发送过去才可以。\nmd5_key = m.hexdigest()\n\n# 将加密的key和时间戳拼接一下发送给服务端\nmd5_time_key = \"%s|%s\" %(md5_key,ctime)\n\nprint(md5_time_key)\nresponse = requests.get(\"http://127.0.0.1:8000/api/asset.html\",headers={\'OpenKey\':md5_time_key})\nprint(response.text)\n```\n\n在服务端处理\n\n```python\ndef asset(request):\n    \n    if request.method == \"GET\":\n        # 从META数据中拿到客户端封装到请求头的数据，一个是加密的key另外一个是客户端的时间戳\n        client_md5_key, client_ctime = request.META.get(\'HTTP_OPENKEY\').split(\'|\')\n        # 通过客户端的时间戳和服务端本地的key进行和客户端一样的加密认证，然后对比加密后值\n        auth_str = \"%s|%s\" % (settings.AUTH_KEY, client_ctime)\n        m = hashlib.md5()\n        m.update(bytes(auth_str, encoding=\'utf-8\'))\n        auth_code = m.hexdigest()\n        if auth_code == client_md5_key:\n            print(\'auth ok\')\n        else:\n            print(\'auth failed\')\n```\n\n经过上面这一番处理以后，我们的token也动态变化起来了。但是仍然存在bug的，假如说在发送过程中被截获的话，截获者拿到的就是`dfb9bb5f3b5ac49360eb3336b73ae043|1526372746.1284108`这样的一个内容，那么这个截获者带着这一串内容去请求我们的接口的话你会发现仍然是可以的，虽然我们的key对外部不是透明的，但是经过和时间戳加密后的值是可以对应上的，截获者不需要知道你的key的值就能通过接口拿到数据。\n\n不仅如此，现在可以访问接口的key变为无限制多个了，随便截获一个这个字符串都是有效的，可以认证成功，因此还需要改。需要添加上这些内容的时效性。让这些内容不是永久有效的。\n\n#### 为动态token添加时效\n\n首先说客户端其实每次发请求的时候都是结合自己的时间戳做字符串加密的，因此客户端每次发过来的加密的key应该都是不一样的。为了避免被\n\n\n\n\n\nAES加密：www.cnblogs.com/wupeiqi/articles/6746744.html\n\n\n\n\n\n后台序列化操作:\n\n有两种，一种是django内置的，另外一种是重写json方法。\n\n","timestamp":1531448340028},{"name":"01-需求分析&DB设计.md","path":"06-Django/98-Django Blog/01-需求分析&DB设计.md","content":"","timestamp":1531448340028},{"name":"02-首页.md","path":"06-Django/98-Django Blog/02-首页.md","content":"","timestamp":1531448340028},{"name":"08-文件的上传.md","path":"06-Django/98-Django Blog/08-文件的上传.md","content":"# 文件上传\n\n## 基于Form表单的上传\n\n> 基于Form表单的上传一个典型的特点就是提交就会刷新\n\n文件上传其实就是一个input的type为file的input框，在文件上传的时候值得注意的一点就是要指定form的`enctype=multipart/form-data`，否则后台拿不到对应的文件对象的。\n\n```python\nimport os\nfrom django.forms import Form\n\nclass F1Form(Form):\n    user = fields.CharField()\n    fafafa = fields.FileField()\n    \n    \ndef f1(request):\n    if request.method == \'GET\':\n        obj = F1Form()\n        return render(request, \'f2.html\',{\'obj\':obj})\n    else:\n        # 当发送POST请求的时候，我们就可以获取到用户提交的数据了。\n        # 这里拿到的也是一个文件对象，有name和size等其他属性，可以直接用file_obj.name获取\n        file_obj = request.FILE.get(\'fafafa\')\n        # 把文件一点一点的获取到，一块一块的。那么就可以像迭代器一样一块一块的去取\n        # 使用os.path.join拼一个路径出来，放到对应的目录下\n        f = open(os.path.join(\'static\',file_obj.name), \'wb\')\n        # chunk的size可以自定义，默认chunk_size为64*2**10，DEFAULT_CHUNK_SIZE\n        # chunk_size直接定义值就可以了。在调用的时候直接传参\n        for chunk in file_obj.chunks():\n           f.write(chunk)\n        f.close()\n        return render(request, \'f2.html\')\n\n# 这个enctype=\"multipart/form-data\"是要加的，否则后台获取到的数据字典是空的。\n# 这个和上传协议有关，加上以后会按照文件的编码进行上传。\n<form method=\"POST\" action=\'/xxx/\' enctype=\"multipart/form-data\">\n\t………………\n</form>\n```\n\n结合Form表单使用：\n\n```python\nfrom django.forms import Form\nfrom django.forms import fields, widgets\n\nclass F2Form(Form):\n    user = fields.CharField()\n    fafafa = fields.FileField()\n    \n    \ndef f2(request):\n    if request.method == \'GET\':\n        obj = F2Form()\n        return render(request, \'f2.html\',{\'obj\':obj})\n    else:\n        # 文本用data接收，文件用files接收。类型不一样\n        obj = F2Form(data=request.POST, files=request.FILES)\n        if obj.is_vaild():\n            # 文件获取到的是一个文件对象，有文件名啊，文件大小啊等各种属性\n            obj.cleaned_data.get(\'fafafa\')\n        return render(request, \'f2.html\', {\'obj\': obj})\n```\n\n","timestamp":1531448340028},{"name":"09-验证码.md","path":"06-Django/98-Django Blog/09-验证码.md","content":"# 验证码\n\n> 如何使用python来处理登录或者注册界面的验证码\n>\n> 武Sir博客参考：http://www.cnblogs.com/wupeiqi/articles/5812291.html\n\n环境准备：\n\n```python\n# 依托于PIL库，因此首先要去安装，就和php用gd库一样\npip install pillow\n```\n\n## 基本使用\n\n### 创建图片\n\n```python\nfrom PIL import Image\n# 创建一张画布图片，模式为RGB，大小宽高，颜色为这三个颜色\nimg = Image.new(mode=\'RGB\', size=(120, 30), color=(255, 255, 255))\n \n# 在图片查看器中打开\n# img.show() \n \n# 保存在本地\nwith open(\'code.png\',\'wb\') as f:\n    img.save(f,format=\'png\')\n```\n\n### 创建画笔在图片上绘画\n\n```python\n# 使用ImageDraw.Draw创建一只画笔用来绘画\nimg = Image.new(mode=\'RGB\', size=(120, 30), color=(255, 255, 255))\ndraw = ImageDraw.Draw(img, mode=\'RGB\')\n\n# 画点，第一个参数：表示坐标；第二个参数：表示颜色，颜色可以使用单词，可以使用rgb颜色\ndraw.point([100, 100], fill=\"red\")\ndraw.point([300, 300], fill=(255, 255, 255))\n\n# 画线，两个点确定一个线\n# 第一个参数：表示起始坐标和结束坐标\n# 第二个参数：表示颜色\ndraw.line((10, 10, 100, 20), fill=\'red\')\ndraw.line((10, 10, 100, 30), fill=(255, 255, 255))\n\n# 画圆，与其说画圆不如说是画扇形，确定两个坐标点，然后以这两个坐标点为对角线画出一个长方形，在这个长方形里面画圈。\n# 第一个参数：表示起始坐标和结束坐标（圆要画在其中间）\n# 第二个参数：表示开始角度\n# 第三个参数：表示结束角度\n# 第四个参数：表示颜色\ndraw.arc((10,10,30,30),0,90,fill=\"red\")\n\n# 写字\n# 第一个参数：表示起始坐标\n# 第二个参数：表示写入内容\n# 第三个参数：表示颜色\ndraw.text([0,0],\'python\',\"red\")\n\n# 写入特殊字体的文字\n# 第一个参数：表示字体文件路径\n# 第二个参数：表示字体大小\nfrom PIL import ImageFont\nfont = ImageFont.truetype(\"kumo.ttf\", 28)\n# 第一个参数：表示起始坐标\n# 第二个参数：表示写入内容\n# 第三个参数：表示颜色\n# 第四个参数：表示颜色\ndraw.text([0, 0], \'python\', \"red\", font=font)\n```\n\n## 通过PIL制作图片验证码\n\n> Httpresponse可以返回字符串也可以返回自己留，因此可以动态的去生成图片去显示。\n>\n> 直接返回内容为：`return HttpResponse(data)`其中data为字节流，那么生成的验证码图片应该放到什么位置呢？首先不能放到磁盘中。我们可以直接在内存中开辟一块空间用来保存这个内容。\n\n### 随机字符串\n\n首先要写字，如何生成随机字符串呢？\n\n```python\n# 文件名：random_check_code.py\n# 生成随机字符串，可以使用列表生成式的形式生成随机字符串，但是为了可以对每一个\n# 字符做单独的处理，因此不这么处理\n# char_list = \'\'.join([chr(random.randint(65, 90)) for i in range(5)])\nimport random\nchar_list = []\nfor i in range(5):\n    char = chr(random.randint(65, 90))\n    char_list.append(char)\n    font = ImageFont.truetype(\'static/font/kumo.ttf\', 28)\n    draw.text([i * 24, 0], char, (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)), font=font)\ncode = \'\'.join(char_list)\n```\n\n### 保存位置\n\n上面说到图片是不能保存到服务器的存储中的，所以可以临时在内存开辟一块空间去保存这个临时的验证码，需要引用的包如下：\n\n```python\nfrom io import BytesIO\n# 这个其实和打开文件很相似，创建一个文件句柄stream\nsteam = BytesIO()\n# 将图片内容保存到文件句柄中(字节流)，这里format可以省略，直接写成png\nimg.save(stream, format=\'png\')\n# 读取写到内存的内容\ndata = steam.getvalue()\n\n\n/---------Py3和py2写入内存的方式不太一样---------------/\n1. 写入内存(Python3)\nfrom io import BytesIO\nstream = BytesIO()\nimg.save(stream, \'png\')\nstream.getvalue()\n\n2. 写入内存（Python2）\nimport StringIO\nstream = StringIO.StringIO()\nimg.save(stream, \'png\')\nstream.getvalue()\n```\n\n### 封装成一个组件工具\n\n```python\nimport random\n# ImageFilter加滤镜，让色差更强一点\nfrom PIL import Image, ImageDraw, ImageFont, ImageFilter\n\n\ndef rd_check_code(width=120, height=30, char_length=5, font_file=\'static/font/kumo.ttf\', font_size=28):\n    \"\"\"\n    图片宽高，字符长度，字体路径，字体大小。\n    \"\"\"\n    code = []\n    img = Image.new(mode=\'RGB\', size=(width, height), color=(255, 255, 255))\n    draw = ImageDraw.Draw(img, mode=\'RGB\')\n\n    def rndchar():\n        \"\"\"\n        生成随机字母\n        :return:\n        \"\"\"\n        return chr(random.randint(65, 90))\n\n    def rndColor():\n        \"\"\"\n        生成随机颜色\n        :return:\n        \"\"\"\n        return (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255))\n\n    # 写文字\n    font = ImageFont.truetype(font_file, font_size)\n    for i in range(char_length):\n        char = rndchar()\n        code.append(char)\n        h = random.randint(0, 4)\n        draw.text([i * width / char_length, h], char, font=font, fill=rndColor())\n\n    # 写干扰点\n    for i in range(40):\n        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())\n\n    # 写干扰圆圈\n    for i in range(40):\n        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())\n        x = random.randint(0, width)\n        y = random.randint(0, height)\n        draw.arc((x, y, x + 4, y + 4), 0, 90, fill=rndColor())\n\n    # 画干扰线\n    for i in range(5):\n        x1 = random.randint(0, width)\n        y1 = random.randint(0, height)\n        x2 = random.randint(0, width)\n        y2 = random.randint(0, height)\n\n        draw.line((x1, y1, x2, y2), fill=rndColor())\n    # 设置色差\n    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)\n    return img, \'\'.join(code)\n```\n\n这样我们就可以把这个工具类放到一个工具目录下，用到的时候直接调用就可以了，比如说放到utils目录下\n\n```python\n# views.py\nfrom io import BytesIO\nfrom utils.random_check_code import rd_check_code\n\ndef check_code(request):\n    img, code = rd_check_code()\n    stream = BytesIO()\n    img.save(stream, \'png\')\n    request.session[\'code\'] = code\n    # 把内存中读取到的图片内容返回就可以了。\n    return HttpResponse(stream.getvalue())\n```\n\n那么在前端我们可以如何去使用呢？\n\n```html\n# src的实质其实也是把图片读取后放到内存中然后再呈现给用户\n# 那么我们可以直接把放到内存中的内容放到这里显示就可以了。\n<div class=\"col-sm-5\">\n    <img id=\'i1\' title=\'点击更新\' onclick=\"changeCode(this);\" src=\"/check_code\" alt=\"\" style=\"width: 120px;height: 30px;\">\n</div>\n```\n\n路由配置：\n\n```python\npath(\'check_code/\', views.check_code),\n```\n\n\n\n\n\n## 使用第三方验证码工具\n\n> 这里使用的是极验的验证码工具，我们在网上经常看到的将一个拼图的一块挪到指定位置进行验证的过程就是通过这个来做到的。\n>\n> - 极验官网：http://www.geetest.com/\n> - 极验文档中心：https://docs.geetest.com/\n\n在文档中心我可以看到极验对接各种语言的一个sdk，找到我们的python的sdk，按照提示的内容`git clone https://github.com/GeeTeam/gt3-python-sdk.git`下载对应的sdk，在这里我们还可以看到demo示例，有基于django，flask，toronado三种框架的示例版本可供我们参考学习。\n\n既然使用第三方的验证码，那么验证码的生成工作其实就不用我们来做了，可以直接从第三方拿就行了。\n\n","timestamp":1531448340028},{"name":"10-上传头像.md","path":"06-Django/98-Django Blog/10-上传头像.md","content":"# 头像的上传\n\n> 用户在注册的时候或者注册以后允许用户上传自己的头像并且允许头像的实时预览，目前有两种方案：\n>\n> - 将图片上传到服务端通过ajax将图片的内容返回给前端\n> - 直接在浏览器预览，没问题后上传\n>\n> 第一种存在一种明显的问题就是上传以后服务器其实就有这个内容了，假如我只是上传了但是我不修改了或者页面被关掉了那么其实更新内容并没有更新上去，但是图片已经保存在服务器了。针对这个问题可以将图片放到一个临时的位置定期删除。\n>\n> 第二种问题相对来说要优秀很多，但是也存在一个浏览器兼容性的问题，也就是很多新版浏览器都是支持的，但是遇到ie这个老祖宗基本就会出现不兼容的情况。因此针对这个问题可以多方面的去做处理。根据条件去判断到底该使用什么办法从而达到一个全方面兼容的效果。\n\n","timestamp":1531448340028},{"name":"99-Django常见小问题.md","path":"06-Django/99-Django常见小问题.md","content":"# Django常见小问题汇总\n\n","timestamp":1531448340028}]