if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m04']=[{"name":"01-验证码.md","path":"04-Django/00-常用组件/01-验证码.md","content":"# 验证码\n\n> 如何使用python来处理登录或者注册界面的验证码\n>\n> 武Sir博客参考：http://www.cnblogs.com/wupeiqi/articles/5812291.html\n\n环境准备：\n\n```python\n# 依托于PIL库，因此首先要去安装，就和php用gd库一样\npip install pillow\n```\n\n## 基本使用\n\n### 创建图片\n\n```python\nfrom PIL import Image\n# 创建一张画布图片，模式为RGB，大小宽高，颜色为这三个颜色\nimg = Image.new(mode=\'RGB\', size=(120, 30), color=(255, 255, 255))\n \n# 在图片查看器中打开\n# img.show() \n \n# 保存在本地\nwith open(\'code.png\',\'wb\') as f:\n    img.save(f,format=\'png\')\n```\n\n### 创建画笔在图片上绘画\n\n```python\n# 使用ImageDraw.Draw创建一只画笔用来绘画\nimg = Image.new(mode=\'RGB\', size=(120, 30), color=(255, 255, 255))\ndraw = ImageDraw.Draw(img, mode=\'RGB\')\n\n# 画点，第一个参数：表示坐标；第二个参数：表示颜色，颜色可以使用单词，可以使用rgb颜色\ndraw.point([100, 100], fill=\"red\")\ndraw.point([300, 300], fill=(255, 255, 255))\n\n# 画线，两个点确定一个线\n# 第一个参数：表示起始坐标和结束坐标\n# 第二个参数：表示颜色\ndraw.line((10, 10, 100, 20), fill=\'red\')\ndraw.line((10, 10, 100, 30), fill=(255, 255, 255))\n\n# 画圆，与其说画圆不如说是画扇形，确定两个坐标点，然后以这两个坐标点为对角线画出一个长方形，在这个长方形里面画圈。\n# 第一个参数：表示起始坐标和结束坐标（圆要画在其中间）\n# 第二个参数：表示开始角度\n# 第三个参数：表示结束角度\n# 第四个参数：表示颜色\ndraw.arc((10,10,30,30),0,90,fill=\"red\")\n\n# 写字\n# 第一个参数：表示起始坐标\n# 第二个参数：表示写入内容\n# 第三个参数：表示颜色\ndraw.text([0,0],\'python\',\"red\")\n\n# 写入特殊字体的文字\n# 第一个参数：表示字体文件路径\n# 第二个参数：表示字体大小\nfrom PIL import ImageFont\nfont = ImageFont.truetype(\"kumo.ttf\", 28)\n# 第一个参数：表示起始坐标\n# 第二个参数：表示写入内容\n# 第三个参数：表示颜色\n# 第四个参数：表示颜色\ndraw.text([0, 0], \'python\', \"red\", font=font)\n```\n\n## 通过PIL制作图片验证码\n\n> Httpresponse可以返回字符串也可以返回字节流，因此可以动态的去生成图片去显示。\n>\n> 直接返回内容为：`return HttpResponse(data)`其中data为字节流，那么生成的验证码图片应该放到什么位置呢？首先不能放到磁盘中。我们可以直接在内存中开辟一块空间用来保存这个内容。\n\n### 随机字符串\n\n首先要写字，如何生成随机字符串呢？\n\n```python\n# 文件名：random_check_code.py\n# 生成随机字符串，可以使用列表生成式的形式生成随机字符串，但是为了可以对每一个\n# 字符做单独的处理，因此不这么处理\n# char_list = \'\'.join([chr(random.randint(65, 90)) for i in range(5)])\nimport random\nchar_list = []\nfor i in range(5):\n    char = chr(random.randint(65, 90))\n    char_list.append(char)\n    font = ImageFont.truetype(\'static/font/kumo.ttf\', 28)\n    draw.text([i * 24, 0], char, (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)), font=font)\ncode = \'\'.join(char_list)\n```\n\n### 保存位置\n\n上面说到图片是不能保存到服务器的存储中的，所以可以临时在内存开辟一块空间去保存这个临时的验证码，需要引用的包如下：\n\n```python\nfrom io import BytesIO\n# 这个其实和打开文件很相似，创建一个文件句柄stream\nsteam = BytesIO()\n# 将图片内容保存到文件句柄中(字节流)，这里format可以省略，直接写成png\nimg.save(stream, format=\'png\')\n# 读取写到内存的内容\ndata = steam.getvalue()\n\n\n/---------Py3和py2写入内存的方式不太一样---------------/\n1. 写入内存(Python3)\nfrom io import BytesIO\nstream = BytesIO()\nimg.save(stream, \'png\')\nstream.getvalue()\n\n2. 写入内存（Python2）\nimport StringIO\nstream = StringIO.StringIO()\nimg.save(stream, \'png\')\nstream.getvalue()\n```\n\n### 封装成一个组件工具\n\n```python\nimport random\n# ImageFilter加滤镜，让色差更强一点\nfrom PIL import Image, ImageDraw, ImageFont, ImageFilter\n\n\ndef rd_check_code(width=120, height=30, char_length=5, font_file=\'static/font/kumo.ttf\', font_size=28):\n    \"\"\"\n    图片宽高，字符长度，字体路径，字体大小。\n    \"\"\"\n    code = []\n    img = Image.new(mode=\'RGB\', size=(width, height), color=(255, 255, 255))\n    draw = ImageDraw.Draw(img, mode=\'RGB\')\n\n    def rndchar():\n        \"\"\"\n        生成随机字母\n        :return:\n        \"\"\"\n        return chr(random.randint(65, 90))\n\n    def rndColor():\n        \"\"\"\n        生成随机颜色\n        :return:\n        \"\"\"\n        return (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255))\n\n    # 写文字\n    font = ImageFont.truetype(font_file, font_size)\n    for i in range(char_length):\n        char = rndchar()\n        code.append(char)\n        h = random.randint(0, 4)\n        draw.text([i * width / char_length, h], char, font=font, fill=rndColor())\n\n    # 写干扰点\n    for i in range(40):\n        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())\n\n    # 写干扰圆圈\n    for i in range(40):\n        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())\n        x = random.randint(0, width)\n        y = random.randint(0, height)\n        draw.arc((x, y, x + 4, y + 4), 0, 90, fill=rndColor())\n\n    # 画干扰线\n    for i in range(5):\n        x1 = random.randint(0, width)\n        y1 = random.randint(0, height)\n        x2 = random.randint(0, width)\n        y2 = random.randint(0, height)\n\n        draw.line((x1, y1, x2, y2), fill=rndColor())\n    # 设置色差\n    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)\n    return img, \'\'.join(code)\n```\n\n这样我们就可以把这个工具类放到一个工具目录下，用到的时候直接调用就可以了，比如说放到utils目录下\n\n```python\n# views.py\nfrom io import BytesIO\nfrom utils.random_check_code import rd_check_code\n\ndef check_code(request):\n    img, code = rd_check_code()\n    stream = BytesIO()\n    img.save(stream, \'png\')\n    request.session[\'code\'] = code\n    # 把内存中读取到的图片内容返回就可以了。\n    return HttpResponse(stream.getvalue())\n```\n\n那么在前端我们可以如何去使用呢？\n\n```html\n# src的实质其实也是把图片读取后放到内存中然后再呈现给用户\n# 那么我们可以直接把放到内存中的内容放到这里显示就可以了。\n<div class=\"col-sm-5\">\n    <img id=\'i1\' title=\'点击更新\' onclick=\"changeCode(this);\" src=\"/check_code\" alt=\"\" style=\"width: 120px;height: 30px;\">\n</div>\n```\n\n路由配置：\n\n```python\npath(\'check_code/\', views.check_code),\n```\n\n## 使用第三方验证码工具\n\n> 这里使用的是极验的验证码工具，我们在网上经常看到的将一个拼图的一块挪到指定位置进行验证的过程就是通过这个来做到的。\n>\n> - 极验官网：http://www.geetest.com/\n> - 极验文档中心：https://docs.geetest.com/\n> - 极验Python API：https://docs.geetest.com/install/deploy/server/python\n\n在文档中心我可以看到极验对接各种语言的一个sdk，找到我们的python的sdk，按照提示的内容`git clone https://github.com/GeeTeam/gt3-python-sdk.git`下载对应的sdk，在这里我们还可以看到demo示例，有基于django，flask，toronado三种框架的示例版本可供我们参考学习。\n\n既然使用第三方的验证码，那么验证码的生成工作其实就不用我们来做了，可以直接从第三方拿就行了。\n\n### 前端页面的引用\n\nGeetest在官方的git上其实提供了有关django，flask以及toronado的demo文件，我们可以在模板中把对应我们需要的内容拿过来就可以了，有弹出式的还有嵌入式的验证码，根据自己的需要在模板中找代码就可以了。\n\n```python\n# 前端界面需要引入的内容\n<!-- 引入封装了failback的接口--initGeetest -->\n<script src=\"http://static.geetest.com/static/tools/gt.js\"></script>\n\n# 在我们需要显示验证码的地方放一个固定的div，验证码会在这个id为popup-captcha的位置生成\n<div id=\"popup-captcha\"></div>\n\n# JS处理向后端发送post请求\n/* 极验验证码登录 */\nvar handlerPopup = function (captchaObj) {\n    // 成功的回调\n    captchaObj.onSuccess(function () {\n        var validate = captchaObj.getValidate();\n        // 首先获取用户填写的用户名和密码，直接从input框取就行。\n        var username = $(\'#loginname\').val();\n        var password = $(\'#loginpass\').val();\n        $.ajax({\n            url: \"/login/\", // 进行二次验证\n            type: \"post\",\n            dataType: \"json\",\n            data: {\n                username: username,\n                password: password,\n                csrfmiddlewaretoken: $(\"[name=\'csrfmiddlewaretoken\']\").val(),\n                geetest_challenge: validate.geetest_challenge,\n                geetest_validate: validate.geetest_validate,\n                geetest_seccode: validate.geetest_seccode\n            },\n            success: function (data) {\n                if (data.status) {\n                    // 有错误，需要在页面上显示\n                    $(\'.login-error\').text(data.msg);\n                } else {\n                    // 没有问题登录成功\n                    location.href = data.msg;\n                }\n            }\n        });\n    });\n\n    $(\"#popup-submit\").click(function () {\n        captchaObj.show();\n    });\n    // 将验证码加到id为captcha的元素里\n    captchaObj.appendTo(\"#popup-captcha\");\n    // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html\n};\n\n# JS处理，获取验证码\n$.ajax({\n        url: \"/pc-geetest/register?t=\" + (new Date()).getTime(), // 加随机数防止缓存\n        type: \"get\",\n        dataType: \"json\",\n        success: function (data) {\n            // 使用initGeetest接口\n            // 参数1：配置参数\n            // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件\n            initGeetest({\n                gt: data.gt,\n                challenge: data.challenge,\n                product: \"popup\", // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效\n                offline: !data.success // 表示用户后台检测极验服务器是否宕机，一般不需要关注\n                // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html #config\n            }, handlerPopup);\n       }\n});\n```\n\n### 后端接收\n\n```python\n\n```\n\n\n\n","timestamp":1540354517190},{"name":"02-Django-auth.md","path":"04-Django/00-常用组件/02-Django-auth.md","content":"# Django Auth\n\n> 内容参考：www.cnblogs.com/liwenzhou/p/9030211.html\n\n```python\n# session添加过程\n1.生成特殊字符串\n2.以生成的特殊字符串为key，在数据库的session表中对应一个session value\n3.在响应中向浏览器写了一个cookie，cookie的值就是这个特殊的字符串\n\n# 登录校验装饰器\nfrom functools import wraps\ndef check_login(f):\n    # 装饰器修复技术\n    @wraps(f)\n    def inner(request, *args, **kwargs):\n        if request.session.get(\'is_login\') == \'1\':\n            return f(request, *args, **kwargs)\n        else:\n            return redirect(\"/login\")\n```\n\n## Auth模块的简单实用\n\n创建超级用户，这样创建的用户其实是会扔到django为我们默认创建的初始表中的auth_user这张表中。\n\n```shell\npython manage.py createsuperuser\n```\n\n使用这个Auth模块：\n\n```python\nfrom django.contrib import auth\n```\n\nauth模块中提供了很多实用的方法，接下来看一下这些方法是如何使用的：\n\n1. authenticate()：提供了用户认证的功能，也就是验证用户名和密码是否正确，一般需要username和password两个关键字参数，如果认证成功，也就是用户名和密码都有效的话，就会返回一个user对象。authenticate()会在该 User 对象上设置一个属性来标识后端已经认证了该用户，且该信息在后续的登录过程中是需要的。\n\n   ```python\n   user = authenticate(username=\'theuser\',password=\'thepassword\')\n   ```\n\n2. login(HttpRequest,user)：该函数接受一个HttpRequest对象，以及一个经过认证的User对象。该函数实现一个用户登录的功能。它本质上会在后端为该用户生成相关session数据。然后我们就可以使用request.user了\n\n   ```python\n   from django.contrib.auth import authenticate, login\n      \n   def my_view(request):\n     username = request.POST[\'username\']\n     password = request.POST[\'password\']\n     user = authenticate(username=username, password=password)\n     if user is not None:\n       login(request, user)\n       # Redirect to a success page.\n       ...\n     else:\n       # Return an \'invalid login\' error message.\n       ...\n   ```\n\n3. logout(request)：该函数接受一个HttpRequest对象，无返回值。当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。\n\n   ```python\n   from django.contrib.auth import logout\n      \n   def logout_view(request):\n     logout(request)\n     # Redirect to a success page.\n   ```\n\n4. is_authenticated()：用来判断当前请求是否通过了认证。记住这个是返回来的user对象的方法\n\n   ```python\n   def my_view(request):\n     if not request.user.is_authenticated():\n       return redirect(\'%s?next=%s\' % (settings.LOGIN_URL, request.path))\n   ```\n\n5. login_required()：auth 给我们提供的一个装饰器工具，用来快捷的给某个视图添加登录校验。\n\n   ```python\n   from django.contrib.auth.decorators import login_required\n         \n   @login_required\n   def my_view(request):\n     ...\n   ```\n\n   若用户没有登录，则会跳转到django默认的 登录URL \'/accounts/login/ \' 并传递当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。\n\n   如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。\n\n   ```python\n   LOGIN_URL = \'/login/\'  # 这里配置成你项目登录页面的路由\n   ```\n\n6. create_user()：auth 提供的一个创建新用户的方法，需要提供必要参数（username、password）等。\n\n   ```python\n   from django.contrib.auth.models import User\n   # 记住不是create而是create_user，这个在密码部分做了加密处理，前者存的是明文，后者存的是密文\n   user = User.objects.create_user（username=\'用户名\',password=\'密码\',email=\'邮箱\',...）\n   ```\n\n7. create_superuser()：auth 提供的一个创建新的超级用户的方法，需要提供必要参数（username、password）等。\n\n   ```python\n   from django.contrib.auth.models import User\n   user = User.objects.create_superuser（username=\'用户名\',password=\'密码\',email=\'邮箱\',...）\n   ```\n\n8. check_password(password)：auth 提供的一个检查密码是否正确的方法，需要提供当前请求用户的密码。密码正确返回True，否则返回False。\n\n   ```python\n   ok = user.check_password(\'密码\')\n   ```\n\n9. set_password(password)：auth 提供的一个修改密码的方法，接收 要设置的新密码 作为参数。\n\n   注意：设置完一定要调用用户对象的save方法！！！\n\n   ```python\n   user.set_password(password=\'\')\n   user.save()\n   ```\n\n   **一个修改密码功能的简单案例**\n\n   ```python\n   @login_required\n   def set_password(request):\n       user = request.user\n       err_msg = \'\'\n       if request.method == \'POST\':\n           old_password = request.POST.get(\'old_password\', \'\')\n           new_password = request.POST.get(\'new_password\', \'\')\n           repeat_password = request.POST.get(\'repeat_password\', \'\')\n           # 检查旧密码是否正确\n           if user.check_password(old_password):\n               if not new_password:\n                   err_msg = \'新密码不能为空\'\n               elif new_password != repeat_password:\n                   err_msg = \'两次密码不一致\'\n               else:\n                   user.set_password(new_password)\n                   user.save()\n                   return redirect(\"/login/\")\n           else:\n               err_msg = \'原密码输入错误\'\n       content = {\n           \'err_msg\': err_msg,\n       }\n       return render(request, \'set_password.html\', content)\n   ```\n\n## User对象属性\n\nUser对象属性：username， password\n\nis_staff ： 用户是否拥有网站的管理权限.\n\nis_active ： 是否允许用户登录, 设置为 False，可以在不删除用户的前提下禁止用户登录。\n\n## Auth中间件\n\n```python\nclass AuthenticationMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        assert hasattr(request, \'session\'), (\n            \"The Django authentication middleware requires session middleware \"\n            \"to be installed. Edit your MIDDLEWARE%s setting to insert \"\n            \"\'django.contrib.sessions.middleware.SessionMiddleware\' before \"\n            \"\'django.contrib.auth.middleware.AuthenticationMiddleware\'.\"\n        ) % (\"_CLASSES\" if settings.MIDDLEWARE is None else \"\")\n        request.user = SimpleLazyObject(lambda: get_user(request))\n```\n\nget_user：\n\n```python\ndef get_user(request):\n    if not hasattr(request, \'_cached_user\'):\n        request._cached_user = auth.get_user(request)\n    return request._cached_user\n```\n\nauth模块中的get_user方法：\n\n```python\ndef get_user(request):\n    \"\"\"\n    返回与给定request session相关的user模型示例，如果取不到用户就返回一个匿名用户类AnonymousUser\n    的实例。\n    \"\"\"\n    from .models import AnonymousUser\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            # Verify the session\n            if hasattr(user, \'get_session_auth_hash\'):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = session_hash and constant_time_compare(\n                    session_hash,\n                    user.get_session_auth_hash()\n                )\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n\n    return user or AnonymousUser()\n```\n\n然后通过`user = backend.get_user(user_id)`去数据库获取数据。\n\n找到Django Auth的中间件，我们可以发现内容如上，只写了一个process_request，内部就是一个断言，内容意思也就是说这个Django的认证组件是依赖于session的中间件的，有了session以后再讲最终封装的结果复制给request.user。\n\n## 扩展自带的auth_user表\n\n> 扩展的目的是因为原本的auth_user表中的字段并不能满足我们的需求，因此需要定制。那么在引用原来的基础model上再进行拓展有几种办法呢？\n>\n> - 新建一张表，通过一对一和内置auth_user表关联，系统中的auth_user表我们也是可以拿到的，直接通过from引用即可\n>\n>   ```python\n>   from django.contrib.auth.models import User\n>   \n>   class UserDetail(models.Model):\n>       phone = models.CharField(max_length=11)\n>       user = models.OneToOneField(to=User)\n>   ```\n>\n> - 通过继承的方式继承User表。只不过在Django Auth Module中继承的不是User表而是一个特殊的表，名字叫AbstractUser。\n\n自己写一个类，继承这个auth_user类，然后自己再写一些自定义类。\n\n```python\n# 注意继承的类不是User试AbstractUser\nclass UserInfo(AbstractUser):\n    nid = models.AutoField(primary_key=True)\n    phone = models.CharField(max_length=11, null=True, unique=True)\n    \n    def __str__(self):\n        return self.username\n    \n# 如果使用继承的方式使用了内置的auth，这个时候要在settings里配置，设置一下用户认证的时候默认使用的是哪一张表，因为一旦继承了以后其实相当于覆盖了原来的表\nAUTH_USER_MODEL = \'app01.UserInfo\'\n```\n\n一旦我们指定了新的认证系统所使用的表，我们就需要重新在数据库中创建该表，而不能继续使用原来默认的auth_user表了。所以说创建的时候也要使用`models.Userinfo.object.create_user`这里注意在创建的时候还要遵循之前的规则，只不过模型类是变换成我们自定制的模型类了。注意即使变成了我们自己定义的类，这个auth模块的方法依然是可以正常使用的。\n\n","timestamp":1540354517190},{"name":"03-分页.md","path":"04-Django/00-常用组件/03-分页.md","content":"# 分页\n\n> www.cnblogs.com/wupeiqi/articles/5246483.html\n\n## Django内置分页\n\n```python\n# 分批获取数据\nmodels.Userinfo.objects.all()[0:10]\nmodels.Userinfo.objects.all()[11:20]\n\nfrom django.core paginator import Paginator, Page\nuser_list = model.UserInfor.object.all()\npaginator = Paginator(user_list, 10)\n# 这个对象可以找到以下属性\n# - per_page: 每页显示条目数量\n# - count： 数据总个数\n# - num_pages: 总页数，可以用来显示出页数\n# - page_range： 总页数的索引范围，比如(1,10),(1,200)\n# - page： page对象，可以指定当前显示第几页\nposts = paginator.page(2)\n这个posts有以下方法：\n\nposts = paginator.page(current_page)\n        # has_next              是否有下一页\n        # next_page_number      下一页页码\n        # has_previous          是否有上一页\n        # previous_page_number  上一页页码\n        # object_list           分页之后的数据列表\n        # number                当前页\n        # paginator             paginator对象\n        \n就把posts.object_list传递给前端的模板就可以了\n\n上下页：\n{% if posts.has_next %}\n\t<a href=\'index.html?page={{ posts.next_page_number}}\'>下一页</a>\n{% endif %}\n\nfrom django.shortcuts import render\nfrom django.core.paginator import Paginator, EmptyPage, PageNotAnInteger\n\n如果page参数不符合规则就默认显示第一页，比如page不是整形，其实就是try except捕获一下错误。\n\nL = []\nfor i in range(999):\n    L.append(i)\n\ndef index(request):\n    current_page = request.GET.get(\'p\')\n\n    paginator = Paginator(L, 10)\n    # per_page: 每页显示条目数量\n    # count:    数据总个数\n    # num_pages:总页数\n    # page_range:总页数的索引范围，如: (1,10),(1,200)\n    # page:     page对象\n    try:\n        posts = paginator.page(current_page)\n    except PageNotAnInteger:\n        posts = paginator.page(1)\n    # 空页，页数不存在。\n    except EmptyPage:\n        posts = paginator.page(paginator.num_pages)\n    return render(request, \'index.html\', {\'posts\': posts})\n```\n\n内置的分页器适合做上一页下一页，不适合做显示页码。而且限制django使用。因此有必要做一个通用的分页器。在日后的其他平台同样可以利用。\n\n## 自定义分页\n\n```python\ndef custom(request):\n    # 获取当前页面，表示用户当前想要访问的页码\n    current_page = request.GET.get(\'page\')\n    # 设置一下每一页显示的数目\n    per_page = 10\n    current_page = int(current_page)\n   \n\t# 设置起始位置\n    start = (current_page-1) * per_page\n    stop = current * per_page\n   \n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[start, stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list})\n```\n\n把上面的逻辑封装到一个类：\n\n```python\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    # 加一个html的前缀\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10, \'/custom.html\' )\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\nclass PageInfor(object):\n    # 接收位置参数调整一下\n    def __init__(self, current_page, all_count, per_page, base_url, show_page=11)\n        \"\"\"\n        current_page：当前的页码数\n        all_count：一共多少条数据\n        per_page：一页显示多少条\n        base_url：要跳转的连接前缀\n        show_page：规定当前页面显示的页码个数，一共1w页总不能都显示出来吧。\n        \"\"\"\n    \ttry:\n            # 页面需要是一个整型的，因此这里要int一下。\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        # 比如101条数据，一页10条，那么应该10页显示满了，最后一条放到11页。因此这里用取余。\n        pages, spare = divmod(self.all_count, self.per_page)\n        # 如果有余，那么pages+1就是所有的页数。\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        self.base_url = base_url\n    \n    @property\n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    @property\n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        # 定义显示的page_list\n        page_list = []\n        # 当前页的每一边有几个，这里取整，浮点数在for循环的时候会报错，要不你就int转一下。\n        half = (self.show_page-1)//2\n\t\t# 如果数据库的总页数小于咱们设置的显示的页数那就看这点吧，开始就是第一页，结束就是末页\n        if self.all_pager < self.show_page:\n            begin = 1\n            stop =  self.all_pager + 1\n        # 如果总页数大于show_page\n        else:\n            # 如果当前页小于等于half（基准），那么就永远显示到show_page页，末页始终是show_page\n            if current_page < half:\n            \tbegin = 1\n            \tstop = self.show_pager + 1\n            # 当越过那个中间基准值以后我们再开始向右挪游标\n            # 取基准值前面五个，基准值后面五个。\n            else:\n                # 如果基准值后面五个存在空页，举个例子，show_page=11，half就等于5，一共有12页。\n                # 假如现在一共有 页，我点第八页的时候，超过基准值了，此时基准值前应该显示3~7页\n                # 基准值后面显示8~13页，此时发现第13页其实是空页，不存在，因此也要做判断。\n                # 当后面存在空页的时候，即half+当前页大于总页数的时候\n                if (self.current_page + half) > self.all_pager: \n                    # 此时开始页是当前页-half还是最后一页往前推送show_page呢？\n                    # 其实这两种都是可以的，只不过显示的多少页而已，当减去half的时候整体显示的页数是\n                    # 越来越少的，因为左侧始终保持5个，而右侧越来越少，所以总体越来越少，最后只剩下\n                    # half+1个。如果begin改为all_pager-show_page的话，那么能保证页码始终是\n                    # show_page+1个。显示起来不会很难看。而current_page游标右移。\n                    begin = self.all_pager - self.show_page + 1\n                    stop = self.all_pager + 1\n                else:\n        \t\t\tbegin = self.current_page - half\n        \t\t\tstop = self.current_page + half + 1\n        \n        # begin和stop都能确认以后，开始在page_list的首尾加上上一页和下一页。\n        if self.current_page < = 1 :\n            # 此时没有上一页\n        \tprev = \"<li><a href=\'#\'>上一页</a></li>\"\n        else:\n        \tprev = \"<li><a href=\'%s?page=%s\'>上一页</a></li>\" % (self.base_url, self.current_page - 1)\n        \n        page_list.append(prev)\n        \n        for i in range(begin, stop):\n            if i == self.current_page:\n            \ttemp = \"<li class=\'active\'><a href=\'%s?page=%s\'>%s</a></li>\" % (self.base_url, i, i)\n            else:\n                temp = \"<li><a href=\'%s?page=%s\'>%s</a></li>\" % (self.base_url, i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n    \n    \tif self.current_page >= self.all_pager:\n            nxt = \"<li><a href=\'#\'>下一页</a></li>\"\n        else:\n        \tnxt = \"<li><a href=\'%s?page=%s\'>下一页</a></li>\" % (self.base_url, self.current_page + 1)\n        page_list.append(nxt)\n```\n\n结合bootstrap进行样式优化，然后就可以把类单独拿出来了;创建一个目录叫utils，用来存放工具类。把这个类拿过来，放到这个模块里就行了。\n\n```python\n# 如果模板端需要使用的话需要，加上safe表示是安全的，而不是xss跨站脚本攻击。如果是安全的话就会渲染成标签，而不是字符串。\n{{ page_info.pager|safe }}\n```\n\n","timestamp":1540354517190},{"name":"01-Web框架的本质.md","path":"04-Django/01-Web框架的本质.md","content":"数据库\n\n1. 安装\n2. 创建用户+授权\n3. 连接\n   - 数据库：终端创建数据库（字符编码）\n   - 数据表：终端，orm，pymysql（create……，engine innodb，charset）\n   - 数据行：增删改查\n\n\n\n问题：简述ORM原理\n\n浏览器的请求头：\n\n```html\nGET / HTTP/1.1\nHost: localhost:10020\nConnection: keep-alive\nCache-Control: max-age=0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36\\\nUpgrade-Insecure-Requests: 1\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8,en;q=0.7,zh-TW;q=0.6\nCookie: Pycharm-2f1c850a=df26fed3-d2a7-4be6-bfa1-4dc7a4831b46\n```\n\n服务器会返回对应的响应头和响应体。\n\n\n\n小结：\n\n```\n1、HTTP 短连接，无状态\n2、浏览器 socket客户端    网站 socket服务端\n3、自己写网站\n   a：socket服务端\n   b：根据URL不同返回不同的内容，路由系统：URL -- 函数\n   c：字符串返回给用户，末班引擎渲染，html充当模板(特殊自符)，自己创造任意数据。\n4、web框架：\n   框架种类：\n     - a,b,c                 ----- tornado\n     - 第三方的a,b,c          ------ wsgiref -> Django\n     - 第三方的a,b,第三方的c   ------ Flask\n   分类：\n     - Django框架(包含n多的web工具，是一个大家伙)\n     - 其他\n```\n\n## MVC\n\n- model：django中用来描述数据表的，运用这个类，可以通过简单的python代码来创建，检索，更新，删除数据库中的记录，而无需一条又一条的写sql语句。\n- views：业务层逻辑，视图函数\n- urls：什么样的url调用什么样的视图，\n- xxx.html：html模板，这个页面如何设计应该如何显示。\n\n这些部分松散的组合何在一起就是模型-视图-控制器（MVC）的设计模式，其实在diango中也可以叫MTV的设计模式（model-template-view）。mvc是一种软件开发的方法，它吧代码的定义和数据访问的模型与请求逻辑（controller）还有用户接口视图分开来。这样，每一个由django驱动的web应用都有着明确的目的，并且可独立更改而不影响到其他的部分。比如更改程序url而不改变程序底层实现，改变html不触碰python代码，数据库冲洗命名数据表只需要修改模型层，而不需要频繁的在多个文件中查找和替换。\n\n","timestamp":1540354517190},{"name":"02-Django开篇.md","path":"04-Django/02-Django开篇.md","content":"# Django\n\n## 1、初识Django\n\n### 1.1、安装\n\n```shell\npip3 install django\n```\n\n在终端新建一个django项目(记得跳转到指定的目录中去创建)：\n\n```bash\ndjango-admin startproject myfirstsite\n```\n\n目录结构：\n\n```bash\n➜  myfirstsite git:(master) ✗ > tree ./\n./\n├── manage.py        # 管理网站的使用，对当前Django程序的所有操作都可以基于 python manage.py runserver……等等来进行操作\n└── myfirstsite\n    ├── __init__.py\n    ├── settings.py  # 配置文件\n    ├── urls.py      # 路由系统，写的是url和函数的对应关系\n    └── wsgi.py      # web socket模块，用于定义Django用什么socket来实现。\n```\n\n启动django：\n\n```bash\n# 切换到项目目录，不加地址的话，默认监听的是本地的8000端口\npython3 manage.py runserver \n```\n\n**附：Pycharm创建Django项目**\n\n点击File→New Project→找到django→起名字→选择对应的Interrupter→点击确定：结束~\n\n### 1.2、第一个Django请求\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.shortcuts import HttpResponse\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容，在这里return的内容需要按照django的规则，\n    直接返回字符串的login或者是字节串都是不行的，如果想要原原本本的返回写的内容\n    需要from django.shortcuts import HttpResponse才可以\n    这里的参数request是一个对象。\n    :param request:\n    :return:\n    \"\"\"\n    # HttpResponse只加字符串\n    return HttpResponse(\'login\')\n\n\nurlpatterns = [\n    \"\"\"\n    做路由内容的匹配，要按照人家django的规则，注意后面调用的是函数的名字，记住不要加小括号\n    \"\"\"\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\n### 1.3、Django静态文件以及模板配置\n\n1.2小节是直接使用HttpResponse返回一个字符串，那么如果想要返回一个模板内容该怎么办呢？首先在template文件夹下新建一个html文件，然后要想django可以访问到这个模板文件的话还需要引入render模块：\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.shortcuts import HttpResponse, render\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容\n    :param request:\n    :return:\n    \"\"\"\n    return render(request, \'login.html\')\n\n\nurlpatterns = [\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\nrender需要两个参数，一个是request，另外一个就是模板文件，你在打的时候都可以给你提示，因为系统默认配置的会去templates文件夹下去找这个模板，如果想要换其他的模板的话可以在django的配置文件settings.py中进行配置：\n\n```python\nTEMPLATES = [\n    {\n        \'BACKEND\': \'django.template.backends.django.DjangoTemplates\',\n        \'DIRS\': [os.path.join(BASE_DIR, \'templates\')]\n        ,\n        \'APP_DIRS\': True,\n        \'OPTIONS\': {\n            \'context_processors\': [\n                \'django.template.context_processors.debug\',\n                \'django.template.context_processors.request\',\n                \'django.contrib.auth.context_processors.auth\',\n                \'django.contrib.messages.context_processors.messages\',\n            ],\n        },\n    },\n]\n```\n\n其实render的本质还是调用了HTTPResponse：\n\n```python\ndef render(request, template_name, context=None, content_type=None, status=None, using=None):\n    \"\"\"\n    Return a HttpResponse whose content is filled with the result of calling\n    django.template.loader.render_to_string() with the passed arguments.\n    \"\"\"\n    content = loader.render_to_string(template_name, context, request, using=using)\n    return HttpResponse(content, content_type, status)\n```\n\n那么静态文件应该放在那里呢？比如我们在项目的根目录下新建一个static文件夹。静态文件无外乎css，js和img图片文件夹：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-8/70769756.jpg)\n\n新建一个样式文件，然后渲染刚才的那个login.html\n\n```html\n<link rel=\"stylesheet\" href=\"/static/css/style.css\">\n```\n\n结果就会发现html并没有发生更改，其实主要原因是这个时候，样式的调用也是通过django去调用的。因此这个静态文件的目录也是需要配置的，找到settings.py文件，找到最后一行：\n\n```python\nSTATIC_URL = \'/static/\'\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \'static\'),\n)\n```\n\n我们要添加的内容是`STATICFILES_DIRS`，注意，这里是一个元组，因此一个元素后面必须要跟逗号，不然会被默认为一个元素，肯定会报错的。\n\n其实这里`STATIC_URL`只不过是一个前缀而已，当调用static下的css的时候那么它会去找`STATICFILES_DIRS`中的路径，你这个路径是啥都行，只要添加到对应的路径下，每当访问static前缀的时候就会去找这个路径。\n\n### 1.4、Django创建程序步骤\n\n- 创建project，pycharm还是terminal都可以。\n\n- 配置：\n\n  - 模板路径：给render用\n  - 静态文件路径：css，js，img\n\n- 额外配置：\n\n  ```python\n  # 暂时先将MIDDLEWARE中的csrf注释掉。\n  MIDDLEWARE = [\n      \'django.middleware.security.SecurityMiddleware\',\n      \'django.contrib.sessions.middleware.SessionMiddleware\',\n      \'django.middleware.common.CommonMiddleware\',\n      # \'django.middleware.csrf.CsrfViewMiddleware\',\n      \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n      \'django.contrib.messages.middleware.MessageMiddleware\',\n      \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n  ]\n  ```\n\n### 1.5、用户登录示例\n\n模板界面：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <link rel=\"stylesheet\" href=\"/static/css/style.css\">\n    <title>login_test</title>\n</head>\n<body>\n    <form method=\"POST\" action=\"\">\n        <h1>登录测试</h1>\n        <!--这里我们用name进行pist提交，那么在服务端其实会收到一个QueryDict字典\n\t\t\t这里的username和password就是key值，我们输入的内容就是value值-->\n        <input type=\"text\" name=\"username\">\n        <input type=\"password\" name=\"password\">\n        <input type=\"submit\">\n      \t{{ msg }}\n    </form>\n</body>\n</html>\n```\n\nurl路由配置：\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\n# 引入redirect用户重定向使用，其中redirect跳转第三方网站域名要写全，但是如果要跳转自己地的网站的话我们可以直接写后缀比如 \"redirect(\'/index/\')\"，它会自动去找urlpatterns进行匹配，Django会为你自动拼接.\nfrom django.shortcuts import HttpResponse, render, redirect\n\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容\n    :param request:\n    :return:\n    \"\"\"\n    # 通过request.method来获取用户请求的方式\n    if request.method == \'GET\':\n        return render(request, \'login.html\')\n    else:\n        # 用户post提交的数据（请求体的内容），那么request.GET就是get请求的数据。获取到的\n        # 是一个字典内容，比如xx/?p=123，结果就为{\'p\': \'123\'}\n        # 这里其实可以使用request.POST[\'username\']这样去取数据，但是如果说name不是这个\n        # 那么就会报错，因此我们可以使用get方法，如果name不是这个的话不会报错，会返回空\n        user = request.POST.get(\'username\')\n        password = request.POST.get(\'password\')\n        if user == \'root\' and password == \'123123\':\n            print(\'登录成功\')\n            return redirect(\'http://bbs.dcgamer.top\')\n        else:\n            print(\'====验证失败====\')\n            # render可以接受的第三个参数是一个字典，Django的模板引擎会根据你传递的\n            # 内容替换对应的特殊字符，比如下面的字典的key是msg，它就会替换模板中的\n            # {{ msg }}字段的值。\n            return render(request, \'login.html\', {\'msg\': \'用户名或密码错误\'})\n\n\nurlpatterns = [\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\n- redirect：相当于浏览器发起一次新的请求，记住是重新发起一次新的请求。后端会把重定向的内容告诉浏览器，浏览器知道以后会自己再去发起请求。其实对应的是一个叫location的响应头。\n\n### 1.6、小结\n\n- 发get请求的时候，只有request.GET有值\n\n- 发post请求的时候，request.GET和request.POST是都可能有值的，因为你在发POST请求的时候，你请求的内容是可以带参数的。比如：\n\n  ```html\n  <form method=\'POST\' action=\"/login/?p=123\"></form>\n  ```\n\n","timestamp":1540354517190},{"name":"01-Django_orm初识.md","path":"04-Django/03-Django ORM/01-Django_orm初识.md","content":"# Django ORM\n\n> 首先针对ORM不做太对的赘述，ORM不仅仅是Python有，其他的语言也有。比较重要的就是记住其中的映射关系。类对应数据表，字段对应属性，类的对象对应表中的每一条记录。\n>\n> - 数据库操作：事先创建好数据库\n> - 数据表操作：创建表，修改表，删除表\n> - Django Query_set的链式操作\n>\n> django的orm没办法直接连接数据库，需要pymysql等第三方工具去连接数据库。默认连接mysql的时候用的是 MysqlDB模块，py3中没有。因此需要修改默认连接mysql的方式。\n\n## 1、配置Django连接数据库\n\nDjango里面默认连接sqlite，那么修改的花其实就是修改settings的配置啦\n\n```python\n# http://www.cnblogs.com/wupeiqi/articles/5237704.html\n# 由sqlite变为mysql\nDATABASES = {\n    \'default\': {\n    \t\'ENGINE\': \'django.db.backends.mysql\',\n    \t\'NAME\':\'dbname\',  # 数据库的名称，要先创建好数据库\n    \t\'USER\': \'root\',\n    \t\'PASSWORD\': \'xxx\',\n    \t\'HOST\': \'localhost\',\n    \t\'PORT\': \'3306\',\n    }\n}\n\n# 在project同名的__init__.py中引入一下pymysql\n# 由于Django内部连接MySQL时使用的是MySQLdb模块，而python3中还无此模块，所以需要使用pymysql来代替\n# 如下设置放置的与project同名的配置的 __init__.py文件中\n  \nimport pymysql\npymysql.install_as_MySQLdb()\n```\n\n**踩坑记录~**\n\n```python\n# 因为我学习的时候django2.0刚发布没多久，因此默认安装的就是2.0的django。在使用过程中遇到如下报错，报我的mysql版本太低：\ndjango.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None\n\n找到对应使用的python版本的site-packages下django下db下banckends下mysql下的base.py\n我的位置是在如下的位置，win，mac，或者其他的linux版本位置可能不一样自己确定好位置再改。\n/usr/local/lib/python3.6/site-packages/django/db/backends/mysql\n\n在base.py中有这么一句，给注释掉就可以了，否者都不能创建django app\nif version < (1, 3, 3):\n    raise ImproperlyConfigured(\"mysqlclient 1.3.3 or newer is required; you have %s\" % Database.__version__)\n```\n\n**扩展：查看Django ORM执行的原生SQL**\n\n```python\n# 在settings中添加这些语句，这样重启项目以后我们就可以在终端查看到执行的所有语句了，调试的时候可以打开查看进行调试学习使用。\nLOGGING = {\n    \'version\': 1,\n    \'disable_existing_loggers\': False,\n    \'handlers\': {\n        \'console\':{\n            \'level\':\'DEBUG\',\n            \'class\':\'logging.StreamHandler\',\n        },\n    },\n    \'loggers\': {\n        \'django.db.backends\': {\n            \'handlers\': [\'console\'],\n            \'propagate\': True,\n            \'level\':\'DEBUG\',\n        },\n    }\n}\n\n当然这个不一定打开，因为打开以后实在是有点烦，你可以用对象的query方法，比如print(ob.query)进行单独查看。\n```\n\n## 2、Django数据表的创建\n\n> Django的ORMD是data_first类型的ORM，使用前必须先创建数据库\n\n### 2.1、建表流程\n\ndjango orm之创建数据表，在app的models类，创建一个类，这个类就是表（对应文件为小的项目下的models.py文件），表中的一行就是一个对象。\n\n```python\n# 表类创建示例\nclass Userinfo(models.Model):\n    # AutoField()就是自增的，在内部生成的是Int类型，还有一个BigAutoField，就是bigint\n    # 在django里，这一列可以不写，在内部会默认生成一列叫id，是int类型的，并且自增的，是PrimaryKey\n    # 当然这一列你写了就用你的。\n    nid = models.AutoField(primary_key = True)\n    # CharField就是字符串类型\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    \n# 表的修改\n直接修改models中的class数据模型类就行了。在已经有数据的表里添加字段的时候要添加默认值\nage = models.IntergerField(null=True)\n或者\nage = models.IntergerField(default=1)\n```\n\n表与表可以通过外键之间建立关系，但是表之间的关系Django提供了更多的处理方式\n\n```python\n# 下面这条命令是和UserGroup进行建立关系，关系建立后并不会在当前的表生成一个叫group_id的字段而是会\n# 自动生成一个group_id_id的这么一列，生成外键的关系。也就是说我们创建的外键在实际的表中会生成一个我们创建# 的名字_id形式的名字字段，因此如果说向这个表中添加数据的时候，指定的字段名应该是，外键_id的形式。\ngroup_id = models.ForeignKey(\"UserGroup\", null=False)\n\n示例：\nclass Userinfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(max_length=16)\n    age = models.IntegerField()\n    ut = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n    \n    那么结果会有id，name，age，ut_id字段，共4个字段\n```\n\n### 2.2、注册你的项目\n\n```python\n# 在settings中注册app\nINSTALLED_APPS = [\n    \'django.contrib.admin\',\n    \'django.contrib.auth\',\n    \'django.contrib.contenttypes\',\n    \'django.contrib.sessions\',\n    \'django.contrib.messages\',\n    \'django.contrib.staticfiles\',\n    \'app01\',  # 把你自己的小项目给加上\n]\n```\n\n### 2.3、创建数据表：\n\n```python\n# 最后创建数据库表\npython manage.py makemigrations  # 生成配置文件\n# 通过配置文件进行操作数据库，每一次都有一个配置文件，保存在app中的migrations文件夹中，修改的依据也是这个文件夹的操作配置的记录的配置文件。我们其实可以理解为一个数据库修改操作的记录表\npython manage.py migrate         \n\n# django自己会创建很多表\nmysql> show tables;\n+----------------------------+\n| Tables_in_study            |\n+----------------------------+\n| auth_group                 |\n| auth_group_permissions     |\n| auth_permission            |\n| auth_user                  |\n| auth_user_groups           |\n| auth_user_user_permissions |\n| backend_userinfo           |\n| django_admin_log           |\n| django_content_type        |\n| django_migrations          |\n| django_session             |\n+----------------------------+\n11 rows in set (0.00 sec)\n\n# 只有这个backend_userinfo才是我们自己的表，其他的都是django默认创建的。\n# Django通过自身的ORM为我们生成的表名默认是以appname_小写的类名。\n# 比如app名称是backend，那么对应的class UserInfo这个类生成的orm就是：backend_userinfo\n```\n\n## 3、Django Admin\n\n> Django为我们提供了一个内置的后台，我们可以使用\n\n登录后台是需要账号密码的，不过我们一开始也不知道，因此要重新设置一下密码\n\n```python\npython3 manage.py createsuperuser\n```\n\n按照命令行的提示输入账号和密码就可以啦~\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/1250519.jpg)\n\n主界面：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/37524661.jpg)\n\n假如说Django Admin的密码忘了怎么办？\n\n```python\npython manage.py changepassword <username>\n```\n\n通过Django Admin注册model实现数据插入：\n\n```python\n# 在对应的app的admin.py下引入models模块进行注册\nfrom django.contrib import admin\nfrom main import models\n\n# Register your models here.\nadmin.site.register(models.Article)\nadmin.site.register(models.Category)\nadmin.site.register(models.Tag)\nadmin.site.register(models.User)\n```\n\n再访问admin界面的时候我们就可以使用Django Admin进行数据添加了。\n\n","timestamp":1540354517190},{"name":"02-Django Model.md","path":"04-Django/03-Django ORM/02-Django Model.md","content":"# Django Model\n\n## 常用Model\n\n### 数字类型\n\n- AutoField(Field)\n\n  ```python\n  int自增列，必须填入参数 primary_key = True\n  ```\n\n- BigAutoField(AutoField)\n\n  ```python\n  这是bigint的自增列，必须填入参数primary_key=True\n  注：当model中如果没有自增列，则自动会创建一个列名为id的列\n\n  from django.db import models\n\n  class UserInfo(models.Model):\n      # 自动创建一个列名为id的且为自增的整数列\n      username = models.CharField(max_length=32)\n\n  class Group(models.Model):\n      # 当然我们可以自定义自增列\n      nid = models.AutoField(primary_key=True)\n      name = models.CharField(max_length=32)\n  ```\n\n- SmallIntegerField(IntegerField)\n\n  ```python\n  - 小整数 -32768 ～ 32767\n  ```\n\n- PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\n\n  ```python\n  - 正小整数 0 ～ 32767\n  ```\n\n- IntegerField(Field)\n\n  ```python\n  - 整数列(有符号的) -2147483648 ～ 2147483647\n  ```\n\n- PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\n\n  ```python\n  - 正整数 0 ～ 2147483647\n  ```\n\n- BigIntegerField(IntegerField):\n\n  ```python\n  - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807\n\n  自定义无符号整数字段\n\n  class UnsignedIntegerField(models.IntegerField):\n      def db_type(self, connection):\n          return \'integer UNSIGNED\'\n  ```\n\n- FloatField(Field)\n\n  ```python\n  浮点型\n  ```\n\n- DecimalField(Field)\n\n  ```python\n  - 10进制小数,精确浮点\n  - 参数：\n     max_digits，总长度\n     decimal_places，小数位长度\n  ```\n\n### 字符串类型\n\n- CharField(max_length=255)\n\n  ```python\n  字符类型，必须提供max_length参数，max_length表示字符长度\n  ```\n\n- EmailField(CharField)\n\n  ```python\n  也是字符串类型，在Django Admin以及Model Form中可以提供邮箱格式的验证，但是直接create增加数据这样是并不能够提供验证功能的\n  ```\n\n- IPAddressField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制\n  ```\n\n- URLField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 URL\n  ```\n\n- SlugField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）\n\n  Slug这个Field是用在文章的URL的，比如一个文章标题是i love django，那么可以把slug设置成i-love-django，然后这样这篇文章的url可以是www.example.com/article/i-love-django，每一篇文章都是唯一的，所以slug也要唯一，unique要设置为True。当然你可以不这么用，单纯的用文章的id也行。\n  ```\n\n- UUIDField(Field)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证\n  ```\n\n- GenericIPAddressField(Field)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6；参数1：protocol，用于指定Ipv4或Ipv6， \'both\',\"ipv4\",\"ipv6\"；参数2：unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\"both\"\n  ```\n\n- FilePathField(Field)\n\n  ```python\n  字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能。\n  参数如下：path（文件夹路径）,match=None（正则匹配）,recursive=False（是否递归下面的文件夹）,allow_files=True（允许文件）,allow_folders=False（允许文件夹）\n  ```\n\n- FileField(Field)\n\n  ```python\n  字符串，路径保存在数据库，文件上传到指定目录，可以在Django Admin中，直接进行使用。\n  参数1：upload_to = \"\"表示上传文件的保存路径；\n  参数2：storage = None表示存储组件，默认：django.core.files.storage.FileSystemStorage\n  ```\n\n- ImageField(FileField)\n\n  ```python\n  字符串，路径保存在数据库，文件上传到指定的目录；\n  参数如下：\n  - upload_to=\"\"（表示上传文件的保存路径）；\n  - storage=None(表示存储组件，默认的是django.core.files.storage.FileSystemStorage)；\n  - width_field=None（上传图片的高度保存的数据库字段名，字符串形式）；\n  - height_field=None（ 上传图片的宽度保存的数据库字段名，字符串形式）；\n\n  这个字段依赖于PIL库，因此确保你使用的时候安装了这个库，如果没有安装的话可以使用pip安装一下：pip install PIL否则是会报错的哦~\n  ```\n\n- CommaSeparatedIntegerField(CharField)\n\n  ```python\n  字符串类型，格式必须为逗号分割的数字\n  ```\n\n- TextField(Field)\n\n  ```python\n  - 文本类型\n  ```\n\n### 时间类型\n\n- DateTimeField(DateField)\n\n  ```python\n  - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]\n  ```\n\n- DateField(DateTimeCheckMixin, Field)\n\n  ```python\n  - 日期格式      YYYY-MM-DD\n  ```\n\n- TimeField(DateTimeCheckMixin, Field)\n\n  ```python\n  - 时间格式      HH:MM[:ss[.uuuuuu]]\n  ```\n\n- DurationField(Field)\n\n  ```python\n  - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型\n  ```\n\n关于时间类型，Django提供的model有DateTimeField，DateField，TimeField三种类型。分别对应的datetime()，date()，time()三种对象。这三个field有相同的参数，一个事auto_now，一个是auto_now_add。\n\n1. auto_now：这个字段属性值默认是false的，在保存数据对象的时候，将其设置为当前时间，然后当你修改的时候这个时间会随着你修改的时间变化而变化。简单来说，这个对象的时间会一直是最新的时间，你没办法为这个字段进行手动的赋值。\n2. auto_now_add：这个字段默认也是false的，如果设置为True以后其实和auto_now差不多，只不过这个时间不会因为你后续的修改而进行改变，而是只保存第一次创建的时间。比如说用户创建时间，这个不应该随着用户信息变化而发生改变，但是论坛发的帖子，可以有一个最后的修改时间可以随着修改而改变。\n\nauto_now和auto_now_add被设置为True后，这样做会导致字段成为editable=False和blank=True的状态。editable=False将导致字段不会被呈现在admin中，blank=True表示允许在表单中不输入值。此时，如果在admin的fields或fieldset中强行加入该日期时间字段，那么程序会报错，admin无法打开；如果在admin中修改对象时，想要看到日期和时间，可以将日期时间字段添加到admin类的readonly_fields中：\n\n```python\nclass YourAdmin(admin.ModelAdmin):\n    readonly_fields = (\'save_date\', \'mod_date\',)\nadmin.site.register(Tag, YourAdmin)\n```\n\n实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？\n\ndjango中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：\n\n```python\nfrom django.db import models\nimport django.utils.timezone as timezone\nclass Doc(models.Model):\n    add_date = models.DateTimeField(\'保存日期\',default = timezone.now)\n    mod_date = models.DateTimeField(\'最后修改日期\', auto_now = True)\n```\n\nhtml页面从数据库中读出DateTimeField字段时，显示的时间格式和数据库中存放的格式不一致，比如数据库字段内容为2016-06-03 13:00:00，但是页面显示的却是Apr. 03, 2016, 1 p.m.\n\n为了页面和数据库中显示一致，需要在页面格式化时间，需要添加如下类似的过滤器。刷新页面，即可正常显示。\n\n```python\n<td>{{ **infor.updatetime|date:\"Y-m-d H:i:s\" **}}</td>\n```\n\n### 布尔类型\n\n- BooleanField(Field)：布尔值类型\n- NullBooleanField(Field)：可以为空的布尔值类型\n\n### 枚举类型\n\n```python\nchoice=(\n        (1,\'male\'),\n        (2,\'female\'),\n        (3,\'other\')\n    )\nlover=models.IntegerField(choices=choice) #枚举类型\n\n# 在数据库存储枚举类型，比外键有什么优势？\n1、无需连表查询性能高一些，省硬盘空间(选项不固定时用外键)\n2、在model文件里不能动态增加（选项一成不变用Django的choice），选项固定的时候可以使用枚举，如果需要动态增加的时候建议使用外键。\n3、在Django Admin中可以直接结合枚举生效，生成下拉框。\n```\n\n### 二进制类型\n\n- BinaryField(Field)：二进制类型\n\n## Model中的其他参数\n\n```python\n# 字段参数\nnull                数据库中字段是否可以为空\ndb_column           数据库中字段的列名\ndefault             数据库中字段的默认值\nprimary_key         数据库中字段是否为主键\ndb_index            数据库中字段是否可以建立索引\nunique              数据库中字段是否可以建立唯一索引\nunique_for_date     数据库中字段【日期】部分是否可以建立唯一索引\nunique_for_month    数据库中字段【月】部分是否可以建立唯一索引\nunique_for_year     数据库中字段【年】部分是否可以建立唯一索引\n\n# 设置是否为空，设置默认值\nxxx = models.CharField.(max_length=32, null=True, default=\'111\')\nxxx = models.CharField.(max_length=32, db_index=True, unique=True)\n# unique_for_month,unique_for_day,unique_for_year，指定日期类型中的哪一端为索引，在数据库中我们添加索引的时候可以指定prefix长度为多少，这里可以指定年月日。\nxxx = models.DateTimeField(null=True, unique_for_data=True)\n\n# 联合唯一索引\nclass Meta:\n\tunique_together = (\n \t\t(\'email\',\'ctime\'),\n\t)\n    \n# 联合索引，不唯一（不做限制）\n\tindex_together = (\n\t\t(\'email\',\'ctime\'),\n\t)\n    \n# 联合唯一约束\nclass Love(models.Model):\n    b = models.ForeignKey(\'Boy\')\n    g = models.ForeignKey(\'Girl\')\n    \n    class Meta:\n        unique_together = [\n            (\'b\',\'g\'),\n        ]\n```\n\n### 元数据中可以填些啥？\n\n> 官方参考：https://docs.djangoproject.com/en/1.10/ref/models/options/\n\n```python\nclass UserInfo(models.Model):\n    nid = models.AutoField(primary_key=True)\n    username = models.CharField(max_length=32)\n    class Meta:\n        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名\n        db_table = \"table_name\"\n\n        # 联合索引\n        index_together = [\n            (\"pub_date\", \"deadline\"),\n        ]\n\n        # 联合唯一索引\n        unique_together = ((\"driver\", \"restaurant\"),)\n\n        # admin中显示的表名称\n        verbose_name\n\n        # verbose_name加s\n        verbose_name_plural\n```\n\n## 模型类在数据库中的对照参考\n\n```python\n# 以下为Django模型创建的字段值，在数据库中的属性体现\n\n\'AutoField\': \'integer AUTO_INCREMENT\',\n\'BigAutoField\': \'bigint AUTO_INCREMENT\',\n # 只能存储字节数据，无法作为过滤选项\n\'BinaryField\': \'longblob\',\n\'BooleanField\': \'bool\',\n\'CharField\': \'varchar(%(max_length)s)\',\n # 存储由逗号分隔的数字，实质为字符串\n\'CommaSeparatedIntegerField\': \'varchar(%(max_length)s)\',\n\'DateField\': \'date\',\n\'DateTimeField\': \'datetime\',\n\'DecimalField\': \'numeric(%(max_digits)s, %(decimal_places)s)\',\n\'DurationField\': \'bigint\',\n\'FileField\': \'varchar(%(max_length)s)\',\n\'FilePathField\': \'varchar(%(max_length)s)\',\n\'FloatField\': \'double precision\',\n\'IntegerField\': \'integer\',\n\'BigIntegerField\': \'bigint\',\n\'IPAddressField\': \'char(15)\',\n\'GenericIPAddressField\': \'char(39)\',\n\'NullBooleanField\': \'bool\',\n\'OneToOneField\': \'integer\',\n\'PositiveIntegerField\': \'integer UNSIGNED\',\n\'PositiveSmallIntegerField\': \'smallint UNSIGNED\',\n\'SlugField\': \'varchar(%(max_length)s)\',\n\'SmallIntegerField\': \'smallint\',\n\'TextField\': \'longtext\',\n\'TimeField\': \'time\',\n\'UUIDField\': \'char(32)\',\n```","timestamp":1540354517190},{"name":"03-表间关系.md","path":"04-Django/03-Django ORM/03-表间关系.md","content":"# 表与表之间的关系\n\n>- 一对多：当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）\n>  *例如：创建用户信息时候，需要选择一个用户类型【普通用户】【金牌用户】【铂金用户】等。*\n>- 多对多：在某表中创建一行数据是，有一个可以多选的下拉框\n>  *例如：创建用户信息，需要为用户指定多个爱好*\n>- 一对一：在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了\n>  *例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据*\n\n- 一对一：OneToOneField\n- 一对多（多对一）：ForeignKey\n- 多对多：ManyToManyField\n\n## 表间关系说明\n\n### 一对多（ForeignKey）\n\n创建测试表，然后用Django Admin创建点测试数据：\n\n```python\nclass UserType(models.Model):\n    caption = models.CharField(max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass UserInfo(models.Model):\n    username = models.CharField(max_length=32)\n    age = models.IntegerField()\n    user_type = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.username\n```\n\n比如现在我要从UserInfo表跨表去查拿到用户所属的用户分类的分类名称，我可以这样取：\n\n```python\nobj = models.UserInfo.objects.filter(username=\'马晓雨\').values(\'id\', \'username\', \'user_type__caption\')\n```\n\n通过UserInfo表去跨表找到对应分类的用户：\n\n```python\nobj = models.UserInfo.objects.filter(user_type__caption=\'2B用户\')\n```\n\n上面都是在查的时候直接跨表，通过用户对象跨表就不使用双下划线的写法了，直接使用“.”：\n\n```python\n# 注意是通过设置的外键跳过去的。\nobj = models.UserInfo.objects.filter(username=\'马晓雨\').first()\nprint(obj.user_type.caption)\n```\n\n而且也可以通过UserType进行逆向查询：\n\n```python\nobj = models.UserType.objects.filter(userinfo__username=\'齐茂森\')\nprint(obj)\n\n# 使用表名_set的前提是拿到一个UserType的对象才会有userinfo_set的方法\n# obj2.userinfo_set拿到的是一个relatemanager对象\nobj2 = models.UserType.objects.filter(caption=\'2B用户\').first()\nprint(obj2.userinfo_set.all())\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 字段以及相关参数\n\n```python\nForeignKey(ForeignObject) # ForeignObject(RelatedField)\n        to,               # 要进行关联的表名，这个默认可以不写，直接写个表名就是to=\'表名\'\n        to_field=None,    # 要关联的表中的字段名称，默认关联到主键字段。\n        on_delete=None,   # 当删除关联表中的数据时，当前表与其关联的行的行为，下面是其他属性值\n            - models.CASCADE，删除关联数据，与之关联也删除\n            - models.DO_NOTHING，删除关联数据，引发错误IntegrityError\n            - models.PROTECT，删除关联数据，引发错误ProtectedError\n            - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）\n            - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）\n            - models.SET，删除关联数据，\n                a. 与之关联的值设置为指定值，设置：models.SET(值)\n                b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)\n                Example：\n                    def func():\n                        return 10\n\n                    class MyModel(models.Model):\n                        user = models.ForeignKey(\n                                   to=\"User\",\n                                   to_field=\"id\"\n                                   on_delete=models.SET(func),\n                        )\n        related_name=None,  # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\n        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(\'表名__字段名\')\n        limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件：\n                               # 如：\n                                   - limit_choices_to={\'nid__gt\': 5}\n                                   - limit_choices_to=lambda : {\'nid__gt\': 5}\n\n                                   from django.db.models import Q\n                                   - limit_choices_to=Q(nid__gt=10)\n                                   - limit_choices_to=Q(nid=8) | Q(nid__gt=10)\n                                   - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption=\'root\')\n        db_constraint=True          # 是否在数据库中创建外键约束\n        parent_link=False           # 在Admin中是否显示关联数据\n\n\nOneToOneField(ForeignKey)\n        to,                         # 要进行关联的表名\n        to_field=None               # 要关联的表中的字段名称\n        on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为\n\n                                    ###### 对于一对一 ######\n                                    # 1. 一对一其实就是 一对多 + 唯一索引\n                                    # 2. 当两个类之间有继承关系时，默认会创建一个一对一字段\n                                    # 如下会在A表中额外增加一个c_ptr_id列且唯一：\n                                    class C(models.Model):\n                                        nid = models.AutoField(primary_key=True)\n                                        part = models.CharField(max_length=12)\n\n                                    class A(C):\n                                        id = models.AutoField(primary_key=True)\n                                        code = models.CharField(max_length=1)\n\nManyToManyField(RelatedField)\n        to,                         # 要进行关联的表名\n        related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\n        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(\'表名__字段名\')\n        limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：\n                                    # 如：\n                                            - limit_choices_to={\'nid__gt\': 5}\n                                            - limit_choices_to=lambda : {\'nid__gt\': 5}\n\n                                            from django.db.models import Q\n                                            - limit_choices_to=Q(nid__gt=10)\n                                            - limit_choices_to=Q(nid=8) | Q(nid__gt=10)\n                                            - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption=\'root\')\n        symmetrical=None,           # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段\n                                    # 做如下操作时，不同的symmetrical会有不同的可选字段\n                                        models.BB.objects.filter(...)\n\n                                        # 可选字段有：code, id, m1\n                                            class BB(models.Model):\n\n                                            code = models.CharField(max_length=12)\n                                            m1 = models.ManyToManyField(\'self\',symmetrical=True)\n\n                                        # 可选字段有: bb, code, id, m1\n                                            class BB(models.Model):\n\n                                            code = models.CharField(max_length=12)\n                                            m1 = models.ManyToManyField(\'self\',symmetrical=False)\n\n        through=None,               # 自定义第三张表时，使用字段用于指定关系表\n        through_fields=None,        # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表\n                                        from django.db import models\n\n                                        class Person(models.Model):\n                                            name = models.CharField(max_length=50)\n\n                                        class Group(models.Model):\n                                            name = models.CharField(max_length=128)\n                                            members = models.ManyToManyField(\n                                                Person,\n                                                through=\'Membership\',\n                                                through_fields=(\'group\', \'person\'),\n                                            )\n\nclass Membership(models.Model):\n    group = models.ForeignKey(Group, on_delete=models.CASCADE)\n    person = models.ForeignKey(Person, on_delete=models.CASCADE)\n    inviter = models.ForeignKey(\n          Person,\n                                                on_delete=models.CASCADE,\n                                                related_name=\"membership_invites\",\n                                            )\n                                            invite_reason = models.CharField(max_length=64)\n        db_constraint=True,         # 是否在数据库中创建外键约束\n        db_table=None,              # 默认创建第三张表时，数据库中表的名称\n```\n\n\n\n## 针对Django Admin生效的参数\n\n有一些Django提供的字段模型比如EmailField或者IPAddressField等都可以在Django Admin中提供字段验证的功能（Module Form也可以生效），但是这些功能对于直接create创建添加并不会起到验证的效果。\n\n如何在Django Admin中注册我们自己的模型类：\n\n```python\n# 在我们自己创建的app下的admin.py中进行注册\nfrom django.contrib import admin\nfrom backend import models\nadmin.site.register(models.DjangoAdmin_test)\n```\n\n再次查看后台主界面的时候就会发现我们注册的表已经添加进去了：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/33506367.jpg)\n\n点击Django admin_tests，进入到内部，点击右上方的ADD Django ADMIN_TEST我们其实就可以向绑定的这个表内添加数据了。在这里我们就可以看到Django提供的那些特殊字段的验证效果了，比如EmailField会验证是不是邮箱。\n\n- FileFeild()：在Django Admin中会变成上传的组件\n\n- DateTimeField()：时间类型，可以传入2017-10-11类似的。\n\n- 枚举类型，Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作，体现出来就是一个下拉菜单。如果不在Django Admin中使用的话，我们自己通过for循环取也是完全没有问题的。\n\n  ```python\n  # example1：\n  color_list = (\n      (1, \'black\'),\n      (2, \'white\'),\n      (3, \'blue\')\n  )\n  color = models.IntegerField(choices=color_list)\n\n  # example2：\n  gf = models.IntegerField(choices=[(0, \'何穗\'),(1, \'大表姐\'),],default=1)\n  ```\n\n- verbose_name：Admin中显示的字段名称，或者说使用model组件的时候显示的名称\n\n- blank：Admin中是否允许用户输入为空。\n\n- editable：Admin中是否可以编辑，如果为false你在页面上就直接看不到了。\n\n- help_text：Admin中显示该字段的提示信息\n\n- error_messages：自定义错误信息（字典类型），从而定制想要显示的错误信息；结合validators使用。\n\n  ```python\n  # 这个error_messages优先级是比较低的。错误信息会在Module Form中找的。\n  字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date                        如：{\'null\': \"不能为空.\", \'invalid\': \'格式错误\'}\n  ```\n\n- validators：自定义错误验证（列表类型），从而定制想要的验证规则\n\n  ```python\n  from django.core.validators import RegexValidator\n  from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\\                      MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator\n  # 如：\n  test = models.CharField(\n  \tmax_length=32,\n      error_messages={\n          # 这里的错误信息会优先于下面的validators中的错误进行显示。\n      \t\'c1\': \'优先错信息1\',\n          \'c2\': \'优先错信息2\',\n          \'c3\': \'优先错信息3\',\n      },\n      validators=[\n           RegexValidator(regex=\'root_\\d+\', message=\'错误了\', code=\'c1\'),\n           RegexValidator(regex=\'root_112233\\d+\', message=\'又错误了\', code=\'c2\'),\n           EmailValidator(message=\'又错误了\', code=\'c3\'), ]\n  )\n  ```\n\n\n\n\n#### \n\n小结：\n\n- Django Admin定制型太强，一般不会用很多，或者根本不用\n\n\n\n\n\n```python\n# ########### 基础函数 ###########\n\n    # 1. Concat，用于做类型转换\n    # v = models.UserInfo.objects.annotate(c=Cast(\'pwd\', FloatField()))\n\n    # 2. Coalesce，从前向后，查询第一个不为空的值\n    # v = models.UserInfo.objects.annotate(c=Coalesce(\'name\', \'pwd\'))\n    \"\"\"\n    上面内容的意思是，新加一列列名为c，当查询到每一行数据的时候如果name部位空，那么c这一列就为name，如果name为空，那么c就为pwd\n    \"\"\"\n    # v = models.UserInfo.objects.annotate(c=Coalesce(Value(\'666\'),\'name\', \'pwd\'))\n\n    # 3. Concat，拼接\n    # models.UserInfo.objects.update(name=Concat(\'name\', \'pwd\'))\n    \"\"\"如果要加单纯的字符串而不是字段的话需要用value渲染一下\"\"\"\n    # models.UserInfo.objects.update(name=Concat(\'name\', Value(\'666\')))\n    # models.UserInfo.objects.update(name=Concat(\'name\', Value(\'666\'),Value(\'999\')))\n\n    # 4.ConcatPair，拼接（仅两个参数）\n    # v = models.UserInfo.objects.annotate(c=ConcatPair(\'name\', \'pwd\'))\n    # v = models.UserInfo.objects.annotate(c=ConcatPair(\'name\', Value(\'666\')))\n\n    # 5.Greatest，获取比较大的值;least 获取比较小的值;\n    # v = models.UserInfo.objects.annotate(c=Greatest(\'id\', \'pwd\',output_field=FloatField()))\n\n    # 6.Length，获取长度\n    # v = models.UserInfo.objects.annotate(c=Length(\'name\'))\n\n    # 7. Lower,Upper,变大小写\n    # v = models.UserInfo.objects.annotate(c=Lower(\'name\'))\n    # v = models.UserInfo.objects.annotate(c=Upper(\'name\'))\n\n    # 8. Now，获取当前时间\n    # v = models.UserInfo.objects.annotate(c=Now())\n\n    # 9. substr，子序列\n    # 取name字段，第一个1是起始位置，2表示取多长的长度\n    # v = models.UserInfo.objects.annotate(c=Substr(\'name\',1,2))\n    # 下面是在数据库实际的操作，可以使用v.query查看。\n    select *,Concat(\'nid\',\'title\') from table_name \n\n    # ########### 时间类函数 ###########\n    # 1. 时间截取，不保留其他：Extract, ExtractDay, ExtractHour, ExtractMinute, ExtractMonth,ExtractSecond, ExtractWeekDay, ExtractYear,\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractYear(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractMonth(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractDay(\'ctime\'))\n    #\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'year\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'month\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'year_month\'))\n    \"\"\"\n    MICROSECOND\n    SECOND\n    MINUTE\n    HOUR\n    DAY\n    WEEK\n    MONTH\n    QUARTER\n    YEAR\n    SECOND_MICROSECOND\n    MINUTE_MICROSECOND\n    MINUTE_SECOND\n    HOUR_MICROSECOND\n    HOUR_SECOND\n    HOUR_MINUTE\n    DAY_MICROSECOND\n    DAY_SECOND\n    DAY_MINUTE\n    DAY_HOUR\n    YEAR_MONTH\n    \"\"\"\n\n    # 2. 时间截图，保留其他：Trunc, TruncDate, TruncDay,TruncHour, TruncMinute, TruncMonth, TruncSecond, TruncYear\n    # v = models.UserInfo.objects.annotate(c=functions.TruncHour(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.TruncDate(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Trunc(\'ctime\',\'year\'))\n```\n\n自定义Func\n\n```python\nfrom django.db.models.functions.base import Func\nclass CustomFunc(Func):\n    function = \'DATE_FORMAT\'\n    \n    template = \'%(function)s(%(exporessions)s,%(format)s)\'\n    \n    def __init__(self, expression, **extra):\n        expressions = [expression]\n        super(CustomFunc, self).__init__(*expressions, ** extra)\n        \nCustomFunc(\'create_time\', \'%Y-%m\')\n# DATE_FORMAT(\'create_time\',\'%Y-%m\')\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-6/17906939.jpg)\n\n### 多对多\n\n> 比如一个老师可以任教多个班级，一个班级可以被多个老师任教，这就是一个多对多的关系\n\n```python\nclass Class(models.Model):\n    name = models.CharField(max_length=32, verbose_name=\"班级名\")\n    course = models.CharField(verbose_name=\"课程\", max_length=32)\n\n    def __str__(self):\n        return self.name\n\n\nclass Teacher(models.Model):\n    name = models.CharField(max_length=23, verbose_name=\"姓名\")\n    classes = models.ManyToManyField(verbose_name=\"所属班级\", to=\"Class\")\n\n    def __str__(self):\n        return self.name\n```\n\n针对多对多的关系就可以直接使用ManyToManyField进行声明。Django会为我们分别生成appname_class和appname_teacher这两个表，其中appname指的是你的app的名称。但是并不会在你的teacher的表中生成classes这么一个字段，而是单独的为你创建一个class和teacher的关系表。\n\n不过这个m2m的表只会为你创建三个字段，一个id，还有两个字段分别关联到class的主键字段和teacher的主键字段，如果我们还有其他的需求的话，这个Django默认是无法为我们完成的。因此这个表我们也可以自己进行定义的。\n\n\n\n\n\n## 多对多关系\n\nDjango自动生成多对多关联表：\n\n```python\nclass Boy(models.Model):\n    name = models.CharField(max_length=32)\n    # 为你生成一张多对多的关联表，表名app_boy_m\n    m = models.ManyToManyField(\'Girl\')\n    \n# 但是这张表是django为我们生成的，models里没有模型的定义，那么该如何操作呢？\n# 答案是无法直接对第三张表操作，但是可以通过这个m进行间接的操作。\n\nobj = models.Boy.objects.filter(name=\'user1\').first()\nobj.m.add(xxx)\nobj.m.add(xxx,xxx)\nobj.m.add(*list)\n# 删数据\nobj.m.remove(xxx)\nobj.m.remove(xxx,xxx)\nobj.m.remove(*list)\n# 修改，传值传入一个列表，set会进行重置。\nobj.m.set([1,])\n# 获取，因为没有第三张表的类定义，因为返回的内容并不是关系表的对象，而是关联表的对象\n# 比如A表和B关联，C表示A和B的关系表，通过A.m.all()这个取出来的不是c的对象而是B的对象\nobj.m.all()\n# 还可以进行二次筛选 obj.m.filter(xxx=xxx)\n# 删除\nobj.m.clear()\n# 逆向查找，关系表在Boy表中定义的，那么如何在Girl的对象中拿到呢？\nobj = models.Girl.objects.filter(nick=\'小鱼\').first\n# 可以使用_set进行逆向查找，这个下划线set同样有all，filter，add等操作\nobj.boy_set.all()\n\n# ManyToMany自动生成的关系表只能有三列，如果要有其他的列的时候，就得自己写了。\n# 比如男女相亲，还要记录相亲时间等等其他的字段这个就超出了Django默认能做的范畴了。\n# 所以到底选用什么方法要根据自己的需要进行选择，推荐自己去写，相对来讲更灵活。\n```\n\n如果说manytomany也用了，也自己定义了关系表了，那么按照原则来讲，Django会替我们创建一张关系表。我们可以通过配置让着两种用法同事存在并且不创建新表，让Django默认我们创建的就是那张关系表。\n\n```python\n# 这样可以用之前提到的manytomany的obj.m.clear()属性和obj.m.all()属性，其他的不能用\nclass Boy(models.Model):\n    name = models.CharField(max_length=32)\n    m = models.ManyToManyField(\"Girl\", through=\"Love\", through_fields=(\'b\',\'g\'))\n```\n\n","timestamp":1540354517190},{"name":"04-ORM数据操作.md","path":"04-Django/03-Django ORM/04-ORM数据操作.md","content":"# Django数据操作\n\n## 增&删&改\n\n针对于增删改来讲，相对来说是很简单的，\n\n```python\nfrom app01 import models\n\n# 增加数据\nmodels.UserGroup.objects.create(title=\'销售部\')\nmodels.UserInfo.objects.create(x,x,x,ut_id=1) # 虽然外键是ut，但是在数据表中生成的是ut_id\n\n# 使用字典形式添加数据\nuser_dict = {\"name\": \"chenchao\", \"age\": \"18\", \"user_type_id\": 1}\nmodels.UserInfo.objects.create(**user_dict)\n\n# 通过传递对象的方式添加数据，这里的ut就是我们添加的外键而不是表中实际的字段，实际字段为ut_id\nuser_type_obj = models.UserType.objects.get(id=1)   #先获取外键表中的数据对象\nuser_dict = {\"username\": \"chenchao\", \"age\": \"18\", \"ut\": user_type_obj} # 对象传入字典\nuser_type_obj.save() 或者 models.UserType.objects.create(**user_dict)\n或者\nobj = models.UserInfo(name=\'lamber\',age=15,ut_id=\'2\')\nobj.save()\n\nmodels.UserInfo.objects.create(**user_dict)\n\n# 删除\nmodels.UserGroup.objects.filter(id=2).delete()\n\n# 更新\nmodels.UserGroup.objects.filter(id=2).update(title=\'new_str\')\nmodels.UserGroup.objects.filter(id=2).update(**dict)\n```\n\n## 查\n\n查表的其实也是数据库里比较麻烦的，对应到orm操作内容也就相对来讲多一些。在查询的时候需要铭记于心的就是下面的两条：\n\n- **在联表操作过滤查找数据时用双下划线 \"__\"**\n- **在取数据时用点 \".\"**\n\n### 简单的查询\n\n```python\n# 简单的查\nret = models.UserGroup.objects.all().first()\nret = models.UserGroup.objects.all()\n- 返回的也是一个结果集（QuerySet），结果集我们可以看做是一个列表。列表中的每一个数据数一个数据对象。可以使用对应的对象.属性的方法去调用属性值。形如：\n<QuerySet [<Class: Class object (1)>, <Class: Class object (2)>, <Class: Class object (3)>, <Class: Class object (4)>, <Class: Class object (5)>]>\n\nQuerySet特点：\n<1>  可迭代的 \n<2>  可切片\n- books=models.Book.objects.all()[:10]  #切片 应用分页\n- books = models.Book.objects.all()[::2]\n- book= models.Book.objects.all()[6]    #索引\n<3>  惰性计算和缓存机制\n- 所谓惰性计算，就是查询返回的QuerySet（查询结果集对象），它并不会马上执行sql，而是当调用QuerySet的时候才执行。相当于一个生成器，不应用返回的Query_Set不会执行任何SQL操作。\n- query_set缓存机制：1次数据库查询结果query_set都会对应一块缓存，再次使用该query_set时，不会发生新的SQL操作；这样减小了频繁操作数据库给数据库带来的压力;\n\n# 取个数\nret = models.UserGroup.objects.all().count()\n\n# 根据查询方式的不同，返回的数据类型也是不一样的\n返回对象对象 UserInfo.objects.all()\n返回字典 UserInfo.objects.values(\"name\",\"age\").all()\n返回元组 User.objects.values_list(\"name\",\"age\").all()\n\n# 如果取出来的数据太大的话有可能会撑爆内存，这个时候只要迭代器就可以优雅的解决这个问题\nret = models.UserInfo.objects.all().iterator()\n```\n\n### 带条件的查询：\n\n如果没查到数据的话会返回一个空的Query_set（列表）\n\n```python\n# where条件，条件之间默认是and关系，下面这个就是相当于where id=1 and title=\'xx\'\nret = models.UserGroup.objects.filter(id=1,title=xx)\n\n# where条件大于和小于1，我们可以使用带双下划线的操作来获取(__gt&__lt)\nret = models.UserGroup.objects.filter(id__gt=1)\nret = models.UserGroup.objects.filter(id__lt=1)\n\n# 根据字典去过滤\ncondition = {\n    \'id\': 1,\n    \'name\': lamber\n}\nmodels.UserInfo.objects.filter(**condition)\n```\n\n### 联表\n\n多表连接操作涉及到多种对应关系，比如一对多，多对多等。首先看一个简单的例子：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-26/80257083.jpg)\n\n```python\n# Create your models here.\nclass UserType(models.Model):\n    \"\"\"用户类型\"\"\"\n    title = models.CharField(max_length=32)\n\n\nclass Userinfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(max_length=16)\n    age = models.IntegerField()\n    ut = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n```\n\n#### 通过外键正向联表查找\n\n```python\n# foreign key 就代指对应关联表的一行数据，如下是在取数据的时候才跨表查询数据   \nresult = models.Userinfo.objects.all()\nfor user in result:\n    print(user.id, user.name, user.age, user.ut_id, user.ut.title)\n    \n# 在取数据的时候跨表查询数据，记住这种双下划线的使用方法。不同于在查的时候跨表\nmodels.Userinfo.objects.all.values(\'id\',\'name\', \'ut__title\')\n    \n# userinfo表里有一个外键叫ut，虽然生成的字段叫ut_id，但是可以直接调用ut，ut代表的是usertype里的一行数据，因此可以直接通过“.”把属性获取到，借由这个特性，我们可以横跨多张表。这个跨表操作是django帮我们做的。假如说我们这里的usertyle还有一个和其他表的外键关联，那么我们还可以继续多张表关联。比如\n\n现在有三张表A，B，C\nA有一个外键b指向B表的id\nb = models.ForeignKey(\'B\', on_delete=models.CASCADE)\nB有一个外键c指向C表的id\nc = models.ForeignKey(\'C\', on_delete=models.CASCADE)\n那么按照说的，A表实际生成的是一个叫b_id的字段，B表实际生成的是一个c_id的字段\n\n外键分别为b何c，根据上面的结论，我们创建的外键其实指代的就是指向表的一行数据，那么我们可以通过A表跨到C表去查数据：\nret = models.A.objects.all().first()\n那么我就可以这样取到C表的数据，假设C表有一个字段叫column_c\nret2 = ret.b.c.column_c   # 这样就可以获取到我们想要的数据了。\n\n# 在filter中也是可以进行跨表的，正向跨表实例：\nmodels.UserInfo.objects.filter(\'ut__title=\'超级用户\').values(\'id\', \'name\', \'ut__title\')\n```\n\n**Tip**\n\n```python\n# 这里有一个需要注意的点，在 Django 2.0 后，models.ForeignKey() 函数 和 models.OneToOneField() 中的 on_delete 参数不再默认为 CASCADE ，而是必须参数，因此在用：\n\nut = models.ForeignKey(\'UserType\')\n\n# 这样写的时候是会直接报错的，会报错说少一个参数，但是在django2.0之前是没有问题的。\n```\n\n#### 逆向查找\n\n```python\n# 如果有人和我做了外键，纵使我这边看不见，但是仍然是有一个隐含的字段。比如我userinfo和我usertype字段做了外键，我usertype是看不到的，但是会有一个隐含的字段，如下：\nobj = models.UserType.objects.all().first()  # 获取一个usertype的对象\nprint(obj.id, obj.title)\nfor row in obj.userinfo_set.all():  # 通过usertype的对象去逆向的查userinfo的数据\n  # 每一个row是一个userinfo对象，这里其实就是把type=obj.title的所有用户取出来了\n  print(row.name, row.age)\n  \n# 含表名小写_set.all()，反向操作。针对反向操作，我们还可以进行过滤等其他的操作\nobj.userinfo_set.all().filter(age__gt=20)\n\n# 在取的时候逆向查找。相当于UserType left join Userinfo谁在前面以谁为准，这就和left join让谁在前面一样，根据自己的需求去选择。跨表字段是小写的表名进行跨表。重要！！！\n# 如果要取表的字段可以使用双下划线，比如：userinfo__name\nret = models.UserType.objects.values(\'id\', \'title\', \'userinfo\')\n- 我们可以打开django的sql执行日志，看看sql内部执行了什么：\nSELECT `app_usertype`.`id`, `app_usertype`.`title`, `app_userinfo`.`name` FROM `app_usertype` LEFT OUTER JOIN `app_userinfo` ON (`app_usertype`.`id` = `app_userinfo`.`ut_id`);\n\n# 使用filter实现反向跨表\n# 在filter中也是可以进行跨表的，正向跨表实例：\nmodels.UserType.objects.filter(\'userinfo__name=\'lamber\').values(\'id\', \'title\', \'userinfo__name\')\n```\n\n### 其他查询操作\n\n首先来讲我们查询到的如果返回的是一个query_set的话里面的内容其实是一个一个的对象，但是我们并不知道这些里面是什么内容，因此我们可以改写一下models模型类，比如：\n\n```python\nclass Class(models.Model):\n\n    title = models.CharField(max_length=255)\n    \n    def __str__(self):  ## 如果是python2的话要协程__unicode__\n        return self.title\n# 这个时候我们再去排查的时候，比如print一下返回的return值就可以大概了解都是什么内容了，其实这个还可以根据我们的需求进行深度的定制，显示更加全面的信息，比如查询班级表中的所有内容：\n<QuerySet [<Class: 全栈4期>, <Class: 全栈5期>, <Class: php培训班>, <Class: java培训班>, <Class: mysql实战班>]>\n```\n\n#### order by\n\n```python\n# 按照id排序，从小到大\nmodels.UserInfo.objects.all().order_by(\'id\')\n# 按照id逆向排序\nmodels.UserInfo.objects.all().order_by(\'-id\')\n# 多个条件判定排序，先按照id从大到小，再按照name从小到大\nmodels.UserInfo.objects.all().order_by(\'-id\', \'name\')\n```\n\n#### 分组\n\n```python\nfrom django.db.models import Count, Sum, Max, Min\nret = models.UserInfo.objects.values(\'ut_id\').annotate(xxx=Count(\'id\'))\nprint(ret.query)   # 查看生成的sql语句\n# select “app_userinfo”.\"ut_id\",COUNT(\"app_userinfo\".\"id\") as xxx FROM \"app_userinfo\" GROUP BY \"app_userinfo\".\"ut_id\"\n简单来说就是不加annotate的话前面的语句就是直接select ut_id from userinfo，如果加上了annotate的话，那么values的内容即使group by的条件，后面的xxx是select count(app_userinfo.id)的别名。\n\n# having的使用，filter在annotate之前就是where，在annotate之后就是having\nret = models.UserInfo.objects.values(\'ut_id\').annotate(xxx=Count(\'id\')).filter(xxx__gt=2)\n```\n\n#### 其他\n\n```python\nmodels.UserInfo.objects.filter(id__gt=1) # 大于1\nmodels.UserInfo.objects.filter(id__lt=1) # 小于1\nmodels.UserInfo.objects.filter(id__gte=1) # 大于等于1\nmodels.UserInfo.objects.filter(id__lte=1) # 小于等于1\nmodels.UserInfo.objects.exclude(id=1)   # id不等于1\nmodels.UserInfo.objects.filter(id__in=[1,2,3]) # where in\nmodels.UserInfo.objects.filter(id__range=[1,2]) # 范围\nmodels.UserInfo.objects.filter(name__startswith=\'xxx\') # startwith\nmodels.UserInfo.objects.filter(name__endswith=\'xxx\')  # endwith\nmodels.UserInfo.objects.filter(name__contains=\'xxx\')  # 包含\nmodels.UserInfo.objects.filter(name__isnull=True)  # 判断是否为空\n```\n\n## Django中神奇的F和Q\n\n### 神奇的F\n\n```python\nfrom django.db.models import F\n\n# 比如我要把用户表的age字段的所有年龄自加一，F可以让你获取基础值\nmodels.UserInfo.objects.all().update(age=F(\'age\')+1)\n```\n\n### 神奇的Q\n\nQ可以用于构造复杂的查询条件\n\n```python\nfrom django.db.models import Q\n# 一个Q对象就是一个条件\nmodels.Userinfo.objects.filter(Q(id=1))\n# 多个Q对象实现或(or)的关系\nmodels.Userinfo.objects.filter(Q(id=1) | Q(id=2))\n# 多个Q对象实现与(and)的关系\nmodels.Userinfo.objects.filter(Q(id=1) & Q(id=2))\n\n# 第二种q的用法\ncon = Q()\nq1 = Q()\nq1.connector = \'OR\'  # q1的内部条件是什么，OR就是用或来连接，AND就是与\nq1.children.append((\'id\', 1)) # 通过append来添加不同的条件按照如上的条件进行or\nq1.children.append((\'id\', 10))\nq1.children.append((\'id\', 9))\nq2 = Q()\nq2.connector = \'OR\'\nq2.children.append((\'c1\', 1))\nq2.children.append((\'c1\', 10))\nq2.children.append((\'c1\', 9))\ncon.add(q1, \'AND\')   # 将q1和q2通过AND将两个大条件连接起来\ncon.add(q2, \'AND\')\n# 相当于\n(id=1 or id=10 or id=9) and (c1=1 or c1=10 or c1=9)\n# 按照上面的条件进行筛选\nmodels.Table_class.objects.filter(con)\n```\n\n这个可以应对来自前端页面传递过来的复杂查询：\n\n```python\n# 比如前端有很多条件要进行匹配查询，我们可以在前端把对应的数据拼成一个字典格式的json传递过来\n# 每一个大的过滤条件是一个key+value\ncondition_dict = {\n    \'k1\': [1,2,3,4],\n    \'k2\':[1,],\n}\ncon = Q()\nfor k, v in condition_dict.items():\n    q = Q()\n    # 每一个大条件之间的条件用or来匹配\n    q.connector = \'OR\'\n    for i in v:\n        q.children.appeend((\'id\', i))\n    # 大条件之前用AND来匹配，根据自己的需要。\n    con.add(q, \'AND\')\nmodels.UserInfo.objects.filter(con)\n```\n\n## Extra\n\n> 在使用mysql的时候经常会出现使用临时表的语句，比如：\n>\n> ```mysql\n> select id,name,(select count(1) from app_usertype where id>1) as count) from app_userinfo;\n> ```\n>\n> 这种临时表在ORM的操作中也是可以实现的，就是使用extra。\n>\n> 额外查询条件及相关表操作\n\n使用extra添加额外的查询，其中字典中的key n可以充当我们取出来的内容\n\n```python\n# select_params中的是按位置一个一个占位的。\nret = models.UserInfo.objects.all().extra(\n    select={\n        \'n\': \"select count(1) from app_usertype where id>%s and id < %s\",\n        \'m\': \"select count(1) from app_usertype where id>%s and id < %s\",\n    },\n    select_params=[1,3,4,6],\n)\n\nfor obj in ret:\n    print(obj.id, obj.name, obj.n)\n```\n\nextra中还可以使用where：\n\n```python\n# where后面接一个列表，列表中的元素以and连接\nmodels.UserInfo.objects.extra(\n    where=[\"id=1\",\"name=\'alex\'\"]\n)\n\n# 列表中的每个元素内部可以用or\nmodels.UserInfo.objects.extra(\n    where=[\"id=1 or id=%s\",\"name=%s\"],\n    params=[1,\'alex\']\n)\n```\n\ntables的应用\n\n```python\n# 相当于笛卡尔积:select * from app_userinfo,app_usertype\nmodels.UserInfo.objects.extra(\n    tables=[\'app_usertype\'],\n)\n\n# 使用where条件:select * from app_userinfo,app_usertype where app_usertype.id=app_userinfo.ut_id\nmodels.UserInfo.objects.extra(\n    tables=[\'app_usertype\'],\n    where=[\'app_usertype.id = app_userinfo.ut_id\']\n)\n```\n\n排序的使用：\n\n```python\n# 按照nid倒序排\nmodels.UserInfo.objects.extra(select={\'new_id\': \"select id from tb where id > %s\"}, select_params=(1,), order_by=[\'-nid\'])\n```\n\n当然上面四中条件还是可以混在一起写的：\n\n```python\nmodels.UserInfo.objects.extra(\n    select={\'newid\':select count(1) from tb1 where id>%s},\n    select_params=[1,],\n    where=[\'age>%s\'],\n    params=[18,],\n    order_by=[\'-age\',],\n    tables=[\'app_usertype\']\n)\n转换为sql以后就是如下的内容：\n\"\"\"\nselect \n\tapp_userinfo.id,  # 隐含的会取到\n\t(select count(1) from tb1 where id>1) as newid\nfrom app_userinfo,app_usertype\n\twhere \n\t\tapp_userinfo.age>18\n\torder_by\n\t\tapp_userinfo.age desc\n\t\n\"\"\"\n```\n\n## 执行原生SQL\n\n针对非常复杂的sql，django orm也是支持使用原生sql的。\n\n```python\nfrom django.db import connection, connections\n\ncursor = connection.cursor()\ncursor.execute(\'sql语句，和pymysql一样\')\nrow = cursor.fetchall()   # fetchall也有\nconnection.close()\n\n# 我们还可以使用connections去创建cursor\ncursor = connections[\'db_setting_name\'].cursor()\n\n# 在connections中可以填一个db设置的名称，这个设置的名称就是在配置文件中DATABASE部分设置的字典的key，如果存在多个数据库的话，那么我们可以配置连接不同的数据库。只要填上不同的db的配置文件的key就可以了。默认的就是default的数据。\nDATABASES = {\n    \'default\': {\n        \'ENGINE\': \'django.db.backends.mysql\',\n        \'NAME\': \'django_test\',\n        \'USER\': \'lamber\',\n        \'PASSWORD\': \'13082171785\',\n        \'HOST\': \'47.94.132.15\',\n        \'PORT\': \'3306\',\n    }\n    \'db2\': {\n\t\t……………………\n    }\n}\n\n比如：cursor = connections[\'db2\'].cursor()\n```\n\n## Django ORM细节梳理\n\n```python\n##################################################################\n# PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n##################################################################\n\ndef all(self)\n    # 获取所有的数据对象\n\ndef filter(self, *args, **kwargs)\n    # 条件查询\n    # 条件可以是：参数，字典，Q\n\ndef exclude(self, *args, **kwargs)\n    # 条件查询\n    # 条件可以是：参数，字典，Q\n\ndef select_related(self, *fields)\n     # 性能相关：表之间进行join连表操作，一次性获取关联的数据。\n     model.tb.objects.all().select_related()\n     # 会把外键字段关联的表连起来去取，相当于两个表inner join，相当于一次性查询到\n     # 如果外键存在多个的话用逗号分隔，比如select_related(\'fk1\',\'fk2\')\n     # 避免发起多次查询请求。\n     # select * from tb1 inner join tb2 on ……\n     # 有Foreign Key数据较少的时候，联表性能下降也不是很大，就可以使用这个\n     model.tb.objects.all().select_related(\'外键字段\')\n     model.tb.objects.all().select_related(\'外键字段__外键字段\')\n\ndef prefetch_related(self, *lookups)\n    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。\n    # 不做联表，多次查询\n    # 获取所有用户表\n    # 获取用户类型表where id in (用户表中的查到的所有用户ID)\n    # select * from UserInfo;\n    # Django内部：把这张表的所有\"外键字段_id\"去重，然后取到\n    # 第二次查询：select * from user_type where id in 上面取到的外键字段的id。\n    # Django会将这两个结果集整合到一起\n    # 有外键，数据很多，查询次数频繁就可以用这个。进行单表查询提高性能。\n    models.UserInfo.objects.prefetch_related(\'外键字段\')\n\n\n\n    from django.db.models import Count, Case, When, IntegerField\n    Article.objects.annotate(\n        numviews=Count(Case(\n            When(readership__what_time__lt=treshold, then=1),\n            output_field=CharField(),\n        ))\n    )\n\n    students = Student.objects.all().annotate(num_excused_absences=models.Sum(\n                models.Case(\n                    models.When(absence__type=\'Excused\', then=1),\n                default=0,\n                output_field=models.IntegerField()\n            )))\n\ndef annotate(self, *args, **kwargs)\n    # 用于实现聚合group by查询\n\n    from django.db.models import Count, Avg, Max, Min, Sum\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\'))\n    # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\')).filter(uid__gt=1)\n    # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\',distinct=True)).filter(uid__gt=1)\n    # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1\n\ndef distinct(self, *field_names)\n    # 用于distinct去重，在不同的数据源上用法不一样\n    # 比如mysql或者sqlite是不能传递参数的。\n    # 如果使用的是PG(PostGreSQL)就要这么写：\n    # models.UserInfo.objects.distinct(\'nid\')\n    \n    models.UserInfo.objects.values(\'nid\').distinct()\n    # select distinct nid from userinfo\n\n    注：只有在PostgreSQL中才能使用distinct进行去重\n\ndef order_by(self, *field_names)\n    # 用于排序\n    models.UserInfo.objects.all().order_by(\'-id\',\'age\')\n\ndef extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)\n    # 构造额外的查询条件或者映射，如：子查询\n\n    Entry.objects.extra(select={\'new_id\': \"select col from sometable where othercol > %s\"}, select_params=(1,))\n    Entry.objects.extra(where=[\'headline=%s\'], params=[\'Lennon\'])\n    Entry.objects.extra(where=[\"foo=\'a\' OR bar = \'a\'\", \"baz = \'a\'\"])\n    Entry.objects.extra(select={\'new_id\': \"select id from tb where id > %s\"}, select_params=(1,), order_by=[\'-nid\'])\n\n def reverse(self):\n    # 倒序，只有前面有order_by的时候，reverse才有用。reverse会反转order_by的所有条件\n    # 比如order_by(\'-col1\',\'col2\')，反转以后就是order_by(\'col1\',\'-col2\')\n    models.UserInfo.objects.all().order_by(\'-nid\').reverse()\n    # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序\n\n\n def defer(self, *fields):\n    models.UserInfo.objects.defer(\'username\',\'id\')\n    或\n    models.UserInfo.objects.filter(...).defer(\'username\',\'id\')\n    #映射中排除某列数据，如上即取除了username和id以外的数据。主键一定会取的。所以写不写无所谓\n\n def only(self, *fields):\n    #仅取某个表中的数据\n     models.UserInfo.objects.only(\'username\',\'id\')\n     或\n     models.UserInfo.objects.filter(...).only(\'username\',\'id\')\n     等价于：\n\t models.UserInfo.objects.filter(...).values(\'username\',\'id\')\n     # 只不过返回的依然是一个对象而不是一个元组，这个是和values不一样的地方\n     # 当然返回的obj依然可以用“.”去访问我们取的之外的字段，但是会引发新的sql查询\n     # 因此当使用only的时候你取谁了，就用谁，不要多余的去访问其他的字段属性，会造成额外查询降低sql的性能。不要多拿，要是多拿还不如不写，或者你干脆多取就的了。\n       \n def using(self, alias):\n     # 指定使用的数据库，参数为别名（setting中的设置，事先得有这个表。\n     models.UserInfo.objects().all.using(\'db2\')\n\n\n##################################################\n# PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #\n##################################################\n\ndef raw(self, raw_query, params=None, translations=None, using=None):\n    # 执行原生SQL，返回的内容是userinfo的对象\n    models.UserInfo.objects.raw(\'select * from userinfo\')\n\n    # 如果SQL是其他表时，必须将列名字设置为当前UserInfo对象的主键列名\n    models.UserInfo.objects.raw(\'select id as nid from 其他表\')\n\n    # 为原生SQL设置参数\n    models.UserInfo.objects.raw(\'select id as nid from userinfo where nid>%s\', params=[12,])\n\n    # 将获取的到列名转换为指定列名\n    name_map = {\'first\': \'first_name\', \'last\': \'last_name\', \'bd\': \'birth_date\', \'pk\': \'id\'}\n    # 相当于first as first_name;last as last_name\n    Person.objects.raw(\'SELECT * FROM some_other_table\', translations=name_map)\n\n    # 指定数据库\n    models.UserInfo.objects.raw(\'select * from userinfo\', using=\"default\")\n\n    ################### 原生SQL ###################\n    from django.db import connection, connections\n    cursor = connection.cursor()  # cursor = connections[\'default\'].cursor()\n    cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1])\n    row = cursor.fetchone() # fetchall()/fetchmany(..)\n\n\ndef values(self, *fields):\n    # 获取每行数据为字典格式\n\ndef values_list(self, *fields, **kwargs):\n    # 获取每行数据为元祖\n\ndef dates(self, field_name, kind, order=\'ASC\'):\n    # 根据时间进行某一部分进行去重查找并截取指定内容\n    # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日）\n    # order只能是：\"ASC\"  \"DESC\"\n    # 并获取转换后的时间\n        - year : 年-01-01\n        - month: 年-月-01\n        - day  : 年-月-日\n\t# ctime字段名，day上面的格式（只能写上面三个），desc倒序。\n    models.DatePlus.objects.dates(\'ctime\',\'day\',\'DESC\')\n\ndef datetimes(self, field_name, kind, order=\'ASC\', tzinfo=None):\n    # field name就是时间字段\n    # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间\n    # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"\n    # order只能是：\"ASC\"  \"DESC\"\n    # tzinfo时区对象\n    models.DDD.objects.datetimes(\'ctime\',\'hour\',tzinfo=pytz.UTC)\n    models.DDD.objects.datetimes(\'ctime\',\'hour\',tzinfo=pytz.timezone(\'Asia/Shanghai\'))\n\n    \"\"\"\n    # 时区的转换需要安装这个模块\n    pip3 install pytz\n    import pytz\n    pytz.all_timezones\n    pytz.timezone(‘Asia/Shanghai’)\n    \"\"\"\n\ndef none(self):\n    # 空QuerySet对象，什么都不取。\n\n\n####################################\n# METHODS THAT DO DATABASE QUERIES #\n####################################\n\ndef aggregate(self, *args, **kwargs):\n   # 聚合函数，获取字典类型聚合结果\n   # 计算整个表的聚合结果(分组)\n   from django.db.models import Count, Avg, Max, Min, Sum\n   # 如果包含distinct的话会先进行去重，然后再进行聚合\n   result = models.UserInfo.objects.aggregate(k=Count(\'ut_id\', distinct=True), n=Count(\'nid\'))\n   ===> {\'k\': 3, \'n\': 4}\n\ndef count(self):\n   # 获取个数\n\ndef get(self, *args, **kwargs):\n   # 获取单个对象\n   models.UserInfo.objects.get(id=1)\n\ndef create(self, **kwargs):\n   # 创建对象，会有一个返回值，这个返回值就是增加的这条数据\n   obj = models.UsetType.objects.create(title=\'xxx\')\n   obj = models.UsetType.objects.create(**dict_data)\n  \n   # 使用save提交\n   obj = models.UserType(title=\'xxx\')\n   obj.save()\n\ndef bulk_create(self, objs, batch_size=None):\n    # 批量插入\n    # batch_size表示一次插入的个数\n    objs = [\n        models.DDD(name=\'r11\'),\n        models.DDD(name=\'r22\')\n    ]\n    # 这里的10指的是一次最多提交10个对象，最多不要超过999\n    models.DDD.objects.bulk_create(objs, 10)\n\ndef get_or_create(self, defaults=None, **kwargs):\n    # 如果存在，则获取，否则，创建\n    # defaults 指定创建时，其他字段的值\n    # 如果能找到username=root1的，那么就直接返回对象，忽略后面的参数。\n    # 否则就创建，并按照defaults中的内容填充其他字段数据。\n    # obj返回查询的对象，created返回创建的结果，返回true或者false\n    obj, created = models.UserInfo.objects.get_or_create(username=\'root1\', defaults={\'email\': \'1111111\',\'u_id\': 2, \'t_id\': 2})\n\ndef update_or_create(self, defaults=None, **kwargs):\n    # 如果存在，则更新，否则，创建\n    # defaults 指定创建时或更新时的其他字段\n    obj, created = models.UserInfo.objects.update_or_create(username=\'root1\', defaults={\'email\': \'1111111\',\'u_id\': 2, \'t_id\': 1})\n\ndef first(self):\n   # 获取第一个\n\ndef last(self):\n   # 获取最后一个\n\ndef in_bulk(self, id_list=None):\n   # 根据主键ID进行查找，相当于in操作。不同于__in的就是是根据主键查找\n   id_list = [11,21,31]\n   models.DDD.objects.in_bulk(id_list)\n\ndef delete(self):\n   # 删除\n\ndef update(self, **kwargs):\n    # 更新\n\ndef exists(self):\n   # 是否有结果\n```\n\n## 总结\n\nDjango执行原生sql的三种方法：\n\n- 原生sql\n- extra\n- raw","timestamp":1540354517190},{"name":"04-Django 中间件.md","path":"04-Django/04-Django 中间件.md","content":"# MiddleWare\n\n> 中间件，首先这个东西不是特有的，在其他的系统中也是存在的，比如在数据库架构中的proxysql，mycat都属于中间件，它们的存在使得在原来的基础上又新增了一层，这一层可以允许数据在交互传递的过程中做更多的操作，而且你无须对之前的组件做什么修改。\n>\n> 下面说django 中的中间件（middleware），在django中，中间件其实就是一个类，在请求到来和结束后，django会根据自己的规则在合适的时机执行中间件中相应的方法。总结一下中间件的特点然后在如下的内容中逐一说明。\n>\n> 1. 每一个中间件其实就是一个类\n> 2. 中间件的执行有顺序的依赖\n> 3. 自定义的中间件需要继承Django为我们提供的特殊的类\n> 4. 中间件的启用会影响所有的请求和响应\n> 5. 中间件可插拔，可以启用，也可以不启用。\n> 6. 中间件应该仅作为数据过滤器的角色对数据进行过滤，转换和清洗。而对数据的业务处理应该在视图函数中去体现，即中间件是作为额外功能来影响整个响应和请求的流程，和业务处理应该是解耦的。\n\n## 了解中间件\n\n![](http://tuku.dcgamer.top/1381809-20181012102613988-1476135912.jpg)\n\n\n\n 中间件中可以定义五个方法，分别是：\n\n - process_request(self,request)\n - process_view(self, request, callback, callback_args, callback_kwargs)\n - process_template_response(self,request,response)\n - process_exception(self, request, exception)\n - process_response(self, request, response)\n\n```python\n# Django的Settings文件。\nMIDDLEWARE = [\n    \'django.middleware.security.SecurityMiddleware\',\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.middleware.common.CommonMiddleware\',\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    \'django.contrib.messages.middleware.MessageMiddleware\',\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n]\n```\n\n对应到Django中其实就是一个个的类，请求进来是一套方法，请求返回又是一套方法。在每一层中间件的时候如果遇到了错误，就不会继续执行了而是直接返回，根本到达不了视图函数。\n\n以上方法的返回值可以是None和HttpResonse对象，如果是None，则继续按照django定义的规则向下执行，如果是HttpResonse对象，则直接将该对象返回给用户。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/45908211.jpg)\n\n比如我们在这里做一个黑名单的功能，拦下一些ip地址。\n\n```python\n# 自定义中间件\nfrom django.utils.deprecation import MiddlewareMixin\n\nclass M1(MiddlewareMixin):\n    def process_request(self, request):\n \t\tpass\n    \n    def process_response(self, request, response):\n        # 在response的时候要返回给下一个中间件\n        # request不用return，因为django内部帮忙操作了。添上反而有问题。\n        # 你如果在request部分返回值，中间件就不继续往下执行了。\n        return response\n```\n\n在配置文件中，中间件是一个有序列表，因此中间件也是按照顺序进行执行的。\n\n- 类\n  - process_request：django为你做了返回，如果自己添加的话中间件不会进一步运行\n  - process_response：需要有一个返回值\n- 注册中间件\n\n## 中间件的执行流程\n\n### process_request&process_response\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/35856559.jpg)\n\n中间绿色块是中间件层，每一个橙色的方块代表一个中间件，正常来讲是这样一个流程，当process_request有返回值的时候，就会停止请求下一个，找到自己的process_response返回。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/6924732.jpg)\n\n不过上面这个是django1.10以后的一个流程，在1.10之前的流程并不是这样的。稍微有些小小的不同，在较低版本，如果说某一个中间件的process_request有了返回值的话，它会找到最后一个中间件的process_response然后返回。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/94437225.jpg)\n\n### process_view\n\n中间件除了request和response外还有一个process_view方法\n\n```python\ndef process_view(self, request, callback, callback_args, callback_kwargs):\n    pass\n\ncallback是路由匹配对应的url函数的函数名。\n```\n\n那么这个process_view的执行顺序又是如何的呢？来看一下这个例子：\n\n```python\n# app01/md.py\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass M1(MiddlewareMixin):\n\n    def process_request(self, request):\n        print(\'M1-process-request\')\n\n    def process_response(self, request, response):\n        print(\"M1-process-response\")\n        return response\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        print(\'M1-process-view\')\n\n\nclass M2(MiddlewareMixin):\n\n    def process_request(self, request):\n        print(\'M2-process-request\')\n\n    def process_response(self, request, response):\n        print(\"M2-process-response\")\n        return response\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        print(\'M2-process-view\')\n```\n\n然后再settings中注册一下这两个中间件的组件：\n\n```python\n# settings.py\nMIDDLEWARE = [\n    \'django.middleware.security.SecurityMiddleware\',\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.middleware.common.CommonMiddleware\',\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    \'django.contrib.messages.middleware.MessageMiddleware\',\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n    \'middleware.md.M1\',\n    \'app01.md.M1\',\n    \'app01.md.M2\'\n]\n```\n\n我们随便定义个url去访问然后看终端控制台print的值结果为：\n\n```python\nM1-process-request\nM2-process-request\nM1-process-view\nM2-process-view\nM2-process-response\nM1-process-response\n```\n\n可以发现顺序是这样的：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/10046146.jpg)\n\n从上面的代码可以看到目前的process_view是没有返回值的。没有返回值的情况下，目前是这么个流程。我们发现process_view的参数多了很多，打印一下callback可以发现这个其实返回的就是我们的视图函数的地址。其实也就是说执行到process_view的时候我们已经可以拿到视图函数了，就是通过这个callback去拿就可以。那么现在加以改造上面的中间件写法，单独修改一下M1：\n\n```python\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass M1(MiddlewareMixin):\n\n    def process_request(self, request):\n        print(\'M1-process-request\')\n\n    def process_response(self, request, response):\n        print(\"M1-process-response\")\n        return response\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n        print(\'M1-process-view\')\n        response = callback(request, *callback_args, **callback_kwargs)\n        return response\n```\n\n我们为process_view添加上返回值。再次观察终端输出的值\n\n```python\nM1-process-request\nM2-process-request\nM1-process-view\nM2-process-response\nM1-process-response\n```\n\n可以发现执行了M1的process_view，但是跳过了M2的process_view，我们在M1的process_view中去主动的调用视图函数了，所以流程可以归结如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/32736201.jpg)\n\n1. 先依次走完每个中间件的process_request\n2. 然后折返到最初的中间件去执行对应的各个中间件的process_view，当没有返回值的时候会依此执行每个中间件的process_view，当有返回值的时候，从这个中间件往下的其他中间件的process_view不会继续执行，而是直接去调用视图函数。\n3. 从最后一个中间件的process_response逐个返回。\n\n### process_exception\n\n这个方法会捕获视图函数中的错误，默认并不会执行，只有视图函数中报错的时候才会执行。执行流程如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-4-18/51116656.jpg)\n\n遇到视图函数报错以后会从最后一个中间件的exception依次执行到第一个，然后再折返到最后一个中间件去执行process_response然后返回。形状就像一个鸡爪或者两个闪电~，目前是exception没有返回值，一旦exception有返回值的时候那么就不会继续往下执行了。就算是谁把错误处理了以后就不会继续往下执行了。而是直接折返到最后一个中间件去执行process_response依次执行到第一个。\n\n### process_template_response(self, request, response)\n\n针对视图函数的返回值做一个要求，如果有render方法才会被调用，其他情况下是不会被调用的。这个render函数我们可以自己去定义，只要是名称为render：\n\n```python\n# 在视图函数中\nfrom django.shortcuts import render,HttpResponse\nimport json\n\nclass Foo:\n    def __init__(self,req,status,msg):\n        self.req = req\n        self.status = status\n        self.msg = msg\n    def render(self):\n        ret = {\n            \'status\':self.status,\n            \'msg\':self.msg\n        }\n        return HttpResponse(json.dumps(ret))\n    \ndef test(request):\n    return Foo(request,True,\"错误信息\")\n```\n\n相当于我们做一个类将信息封装成json格式给用户返回，而且我们定义了一个render方法，这样就会触发中间件的process_template_response方法（返回的对象中有render方法），然后通过这个方法可以再对返回内容做一定的规范和要求。\n\n## 小结\n\n到底什么时候开始应用中间件：\n\n- 适用于对所有请求或者一部分请求做批量处理。（比如针对所有的用户请求做日志统计）\n- 可以应用于请求做判断进行缓存应用的处理。","timestamp":1540354517190},{"name":"01-01-Form组件.md","path":"04-Django/05-Django Form/01-01-Form组件.md","content":"# Form组件\n\n[TOC]\n\n>Form组件能为我们做什么呢？\n>\n>- 根据用户请求对数据做验证\n>- 根据用户的输入还可以输出对应的错误信息\n>- 获取到数据然后进行验证，验证通过后对正确的信息进行打包并提交。\n>- 保留上一次的输入内容\n>- Form组件还可以创建HTML标签，通过挂件指定样式。\n>\n>在数据库操作之前进行一些规则的验证。\n\n问题：\n\n- 无法记住上次提交的内容，因此页面刷新数据消失\n- 重复的进行用户数据的校验：正则，长度，是否为空。\n\n## Form组件的简单使用\n\n### 定义组件\n\n```python\n# 首先简单定义一个Form组件，用于登录验证\n# 我们在app下新建一个form.py文件用于我们定义的Form验证规则\nfrom django.forms import fields, Form\n\nclass LoginForm(Form):\n    username = fields.CharField(\n        max_length=18,\n        min_length=6,\n        required=True,\n    )\n    password = fields.CharField(\n        max_length=16,\n        min_length=6,\n        required=True\n    )\n```\n\n### 组件的应用\n\n```python\n# 在views视图中直接调用，直接添加一个url路由用于匹配\nform main import form\n\ndef login(request):\n    if request.method == \'GET\':\n        # 当我直接访问的时候就直接返回登录页面\n        return render(request, \'login.html\')\n    else:\n        # 生成一个LoginForm的对象，要将用户在前端输入的账号密码传入\n        obj = form.LoginForm(request.POST)\n        # 调用对象的is_vaild方法进行规则的校验\n        # 返回值为True or False，因此直接调用is_valid()就可以\n        # 这个是由Django内部提供的一个验证机制。\n        if obj.is_valid():\n            # obj.cleaned_data是一个字典，就是验证通过后，用户提交的数据\n            # 这样如果遇到注册的时候创建用户直接使用create(**kwargs)就行了\n            print(obj.cleaned_data)\n            # 我们先让他说验证规则通过以后重定向到百度\n            return redirect(\'https://www.baidu.com\')\n        else:\n            # 如果验证不通过应该打印错误信息，Django内部也为我们提供了这种机制。\n            # obj.errors是所有的错误信息\n            # 这是一个对象，但是内部有一个__str__方法因此我们看到的是一大串html字符串\n            # 假如说用户没有输入错误的话那么就直接拿不到了会报错，这个其实我们不用太关心，因为我们不会在后台用，而是直接扔到前端里去。我拿不到顶多不显示就完了。\n            print(obj.errors)\n            print(obj.errors[\'username\'])\n            # 错误可以是存在多个的\n            # 拿多个错误信息的第一个，只要错误信息没满足就有问题，我们永远拿第一个就行了\n            print(obj.errors[\'password\'][0])\n            return render(request, \'login.html\', {\n                \'obj\': obj\n            })\n```\n\n### 校验的报错\n\n假如说没有满足验证规则的话就会进行报错，报错的内容如下：\n\n```html\n# 这个是obj.errors的内容，这里包含了所有的错误信息。\n# 本身这是一个对象，但是因为实现了__str__方法因此我们可以看到一大堆的字符串。\n<ul class=\"errorlist\">\n    <li>\n        username\n        <ul class=\"errorlist\">\n            <li>Ensure this value has at least 6 characters (it has 1).</li>\t\t</ul>\n    </li>\n    <li>password\n        <ul class=\"errorlist\">\n            <li>Ensure this value has at least 6 characters (it has 2).</li>\t\t</ul>\n    </li>\n</ul>\n```\n\n同样我们可以使用`obj.errors[\'username\']`单独拿某一个name属性的报错。\n\n```html\n<ul class=\"errorlist\">\n    <li>Ensure this value has at least 6 characters (it has 1).</li>\n</ul>\n```\n\n对应的前端界面如下：\n\n```html\n<form  method=\"post\">\n    {% csrf_token %}\n    <!--或者只取第一个{{ obj.errors.username.0 }}，因为有可能你这个输入的内容好多条规则都没有匹配，那么错误信息就应该有多个，我们没有必要在前端把所有的报错都显示出来，只需要显示报错就行了，因此只要你有报错我只让你显示第一个就好，如果没有报错的话，那就不需要显示了。-->\n    <p>用户名：<input type=\"text\" name=\"username\" />{{ obj.errors.username }}</p>\n    <p>密码：<input type=\"password\" name=\"password\" />{{ obj.errors.password }}</p>\n    <p><input type=\"submit\" value=\"提交\"></p>\n</form>\n```\n\n效果如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-26/5961066.jpg)\n\n### 自定义错误信息\n\n通过上图可以发现，这个报错是英文的，那么可不可以进行自定义呢？当然是可以的。\n\n```python\n# 修改我们的form文件\nclass LoginForm(Form):\n    username = fields.CharField(\n        max_length=18,\n        min_length=6,\n        required=True, # 这个默认是必填项，就算你不写出来也会包含这个默认项\n        error_messages={\n            \'required\': \'不能为空\',\n            \'min_length\': \'太短了！\',\n            \'max_length\': \'太长了！！！！\',\n        }\n    )\n    password = fields.CharField(\n        max_length=16,\n        required=True,\n        min_length=6,\n    )\n```\n\n添加上error_message参数就可以了，error_message对应的是一个字典，key是对应的我们添加的约束项目，比如min_length最小长度，max_length最大长度啊，required是否必填不能为空什么的，对应的value就是要报错的值，这样的话就可以将原来的内容替换成我们想写的内容了。\n\n一般来说，如果格式不对的话对应的error_message的key是`invalid`，针对其他的fields还有其他的属性，比如数字Integer属性，有数字的最大值`max_value`，最小值`min_value`等一些特殊的属于自己的属性。具体的可以参考下面的Django Form字段属性。\n\n## Django Form字段属性\n\n> 针对Django Form中不同的类型都有什么属性，比如Integer和CharField都是继承fields，因此它们都可以使用fields中的属性，emailField继承自CharField，那么它也可以把CharField中的属性继承下来，我们知道EmailField本质其实就是CharField。IntegerField会主动的调用父类的构造方法，CharField也是。如下，可以看到IntegerField主动的去调用父类的Field了，父类的构造方法还有一堆参数。\n>\n> ```python\n> def __init__(self, *, max_value=None, min_value=None, **kwargs):\n>     self.max_value, self.min_value = max_value, min_value\n>     if kwargs.get(\'localize\') and self.widget == NumberInput:\n>         # Localized number input is not well supported on most browsers\n>         kwargs.setdefault(\'widget\', super().widget)\n>     super().__init__(**kwargs)\n> ```\n>\n> 具体都有什么属性可以查看下面的内容\n\n- fields\n\n  ```python\n  required=True,               是否允许为空，默认的都是True，可以不用写\n  widget=None,                 HTML插件\n  label=None,                  用于生成Label标签或显示内容\n  initial=None,                初始值\n  help_text=\'\',                帮助信息(在标签旁边显示)\n  error_messages=None,         错误信息 {\'required\': \'不能为空\', \'invalid\': \'格式错误\'}\n  show_hidden_initial=False,   是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直）\n  validators=[],               自定义验证规则，在原有的规则上继续添加正则\n  localize=False,              是否支持本地化，比如时间的时区。\n  disabled=False,              是否可以编辑\n  label_suffix=None            Label内容后缀\n  ```\n\n- URLField(Field)\n\n- BooleanField(Field)  \n\n- NullBooleanField(BooleanField)\n\n- CharField\n\n  ```python\n  max_length=None,             最大长度\n  min_length=None,             最小长度\n  strip=True                   是否移除用户输入空白，strip属性是默认的，默认为true。\n  \n  UUIDField(CharField)         uuid类型\n  SlugField(CharField)         数字，字母，下划线，减号（连字符）\n  ```\n\n- IntegerField\n\n  ```python\n  max_value=None,              最大值\n  min_value=None,              最小值\n  \n  # FloatField(IntegerField)\n  ```\n\n- DecimalField(IntegerField)\n\n  ```python\n  max_value=None,              最大值\n  min_value=None,              最小值\n  max_digits=None,             总长度\n  decimal_places=None,         小数位长度\n  ```\n\n- BaseTemporalField(Field)\n\n  ```python\n  input_formats=None               时间格式化\n  # 其他继承BaseTemporalField的\n  DateField(BaseTemporalField)     格式：2015-09-01\n  TimeField(BaseTemporalField)     格式：11:12\n  DateTimeField(BaseTemporalField) 格式：2015-09-01 11:12\n  ```\n\n- DurationField(Field)            时间间隔：%d %H:%M:%S.%f\n\n- RegexField(CharField)    如果提供的不够用，支持自己书写正则表达式\n\n  ```python\n  regex,                      自定制正则表达式\n  max_length=None,            最大长度\n  min_length=None,            最小长度\n  error_message=None,         忽略，错误信息使用 error_messages={\'invalid\': \'...\'}\n  ```\n\n- EmailField(CharField)\n\n- FileField(Field)              \n\n  ```python\n  allow_empty_file=False     是否允许空文件\n  ```\n\n- ImageField(FileField) \n\n  ```python\n  注：需要PIL模块，pip3 install Pillow\n  以上两个字典使用时，需要注意两点：\n      - form表单中 enctype=\"multipart/form-data\"\n      - view函数中 obj = MyForm(request.POST, request.FILES)\n  ```\n\n- ChoiceField(Field)\n\n  ```python\n  choices=(),                选项，如：choices = ((0,\'上海\'),(1,\'北京\'),)\n  required=True,             是否必填\n  widget=None,               插件，默认select插件\n  label=None,                Label内容\n  initial=None,              初始值\n  help_text=\'\',              帮助提示\n  ```\n\n- MultipleChoiceField(ChoiceField)\n\n- ModelChoiceField(ChoiceField)\n\n  ```python\n  ...                        django.forms.models.ModelChoiceField\n  queryset,                  # 查询数据库中的数据\n  empty_label=\"---------\",   # 默认空显示内容\n  to_field_name=None,        # HTML中value的值对应的字段\n  limit_choices_to=None      # ModelForm中对queryset二次筛选\n  ```\n\n- ModelMultipleChoiceField(ModelChoiceField)\n\n  ```python\n  ...                        django.forms.models.ModelMultipleChoiceField\n  ```\n\n- TypedChoiceField(ChoiceField)\n\n  ```python\n  coerce = lambda val: val   对选中的值进行一次转换\n  empty_value= \'\'            空值的默认值\n  ```\n\n- TypedMultipleChoiceField(MultipleChoiceField)\n\n  ```python\n  coerce = lambda val: val   对选中的每一个值进行一次转换\n  empty_value= \'\'            空值的默认值\n  ```\n\n- ComboField(Field)，多个验证规则组合\n\n  ```python\n  fields=()                  \n  # 使用多个验证，如下：即验证最大长度20，又验证邮箱格式\n  fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])\n  ```\n\n- MultiValueField(Field)\n\n  ```python\n  PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用\n  ```\n\n- SplitDateTimeField(MultiValueField)\n\n  ```python\n  input_date_formats=None,   格式列表：[\'%Y--%m--%d\', \'%m%d/%Y\', \'%m/%d/%y\']\n  input_time_formats=None    格式列表：[\'%H:%M:%S\', \'%H:%M:%S.%f\', \'%H:%M\']\n  ```\n\n- FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中\n\n  ```python\n  path,                      文件夹路径\n  match=None,                正则匹配\n  recursive=False,           递归下面的文件夹\n  allow_files=True,          允许文件\n  allow_folders=False,       允许文件夹\n  required=True,\n  widget=None,\n  label=None,\n  initial=None,\n  help_text=\'\'\n  ```\n\n- GenericIPAddressField\n\n  ```python\n  protocol=\'both\',           both,ipv4,ipv6支持的IP格式\n  unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，\n              \t\t\t   可解析为192.0.2.1， PS：protocol必须为both才能启用\n  ```\n\n### 自定制正则表达式\n\n举个🌰：\n\n```python\n# regexfield继承charfield，可以使用是否为空，最长最短，还有自己写的，一共4种\nt = fields.RegexField(\'139\\d+\', error_messages={\'invalid\': \'格式错误\'})\n```\n\n### 自定义验证规则\n\n**方式一**\n\n```python\nfrom django.forms import Form\nfrom django.forms import widgets\nfrom django.forms import fields\nfrom django.core.validators import RegexValidator\n \nclass MyForm(Form):\n    user = fields.CharField(\n        validators=[RegexValidator(r\'^[0-9]+$\', \'请输入数字\'), RegexValidator(r\'^159[0-9]+$\', \'数字必须以159开头\')],\n    )\n```\n\n**方式二**\n\n```python\nimport re\nfrom django.forms import Form\nfrom django.forms import widgets\nfrom django.forms import fields\nfrom django.core.exceptions import ValidationError\n \n \n# 自定义验证规则\ndef mobile_validate(value):\n    mobile_re = re.compile(r\'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$\')\n    if not mobile_re.match(value):\n        raise ValidationError(\'手机号码格式错误\')\n \n \nclass PublishForm(Form):\n    title = fields.CharField(max_length=20,min_length=5,\n                            error_messages={\'required\': \'标题不能为空\',\n                                            \'min_length\': \'标题最少为5个字符\',\n                                            \'max_length\': \'标题最多为20个字符\'},\n                            widget=widgets.TextInput(attrs={\'class\': \"form-control\",\n                                                          \'placeholder\': \'标题5-20个字符\'}))\n \n \n    # 使用自定义验证规则\n    phone = fields.CharField(validators=[mobile_validate, ],\n                            error_messages={\'required\': \'手机不能为空\'},\n                            widget=widgets.TextInput(attrs={\'class\': \"form-control\",\n                                                          \'placeholder\': u\'手机号码\'}))\n \n    email = fields.EmailField(required=False,\n                            error_messages={\'required\': u\'邮箱不能为空\',\'invalid\': u\'邮箱格式错误\'},\n                            widget=widgets.TextInput(attrs={\'class\': \"form-control\", \'placeholder\': u\'邮箱\'}))\n```\n\n\n\n## 简单实现原理\n\nfields本质就是验证规则，说验证规则实质就是正则表达式验证。可以说我们写的这个Form类似一个校验的模板。下面来看一下内部是如何实现验证的（is_valid的实现过程）。\n\n1. 每一次实例化Form组件类的时候，会先执行一个操作，就是把当前定义的字段放到self.fields中来。\n\n   ```python\n   # 实例化的时候：obj = LoginForm(request.POST)找到对应的Form组件类中的所有字段\n   # 把这些字段放到self.fields中\n   self.fields = {\n       \'username\': fields.CharField(xxxxx) # 包含正则表达式\n       \'password\': 正则2\n   }\n   ```\n\n2. 循环self.fields：\n\n   ```python\n   flag = True\n   errors = xxx  # 当数据校验失败的时候，将内容放到errors中来\n   cleand_data = xxx  # 当数据校验成功的时候，将内容放到cleand_data中。\n   for k, v in self.fields.items():\n     # k就是每个name属性字段，比如username，password，v就是对应的正则表达式\n     # 获取到用户输入的内容\n     input_value = request.POST.get(k)\n     # 通过正则表达式和用户输入的内容按照正则表达式进行匹配。\n     # 如果说校验成功，就返回True的flag并发成功的数据放入到cleaned_data\n     # 如果说校验失败了，返回一个False的flag，并把数据放到errors\n     # 注意这里是但凡有一条校验失败都会返回false\n     if not 正则校验，用re.match(xxxxx):\n    \tflag = False\n     return flag标志位\n   ```","timestamp":1540354517190},{"name":"02-02-Form生成HTML.md","path":"04-Django/05-Django Form/02-02-Form生成HTML.md","content":"# 使用Form生成HTML\n\n[TOC]\n\n## 简单实现\n\n> widget,label,disabled,label_suffix,initial,help_text其实是放在一起使用的，他可以帮你自动生成html标签。生成html标签不是目的，\n\n先写一个测试的form类：\n\n```python\n# 实质就是返回fields.CharField内部的__str__方法返回一串html代码字符串\nclass TestForm(Form):\n    t1 = fields.CharField(\n        max_length=10,\n        required=True, \n        label=\"用户名\",\n        help_text=\"我是这个输入框的帮助信息\",\n        # 表单的默认值\n        initial=\'666\',\n    )\n```\n\n然后在视图函数中调用\n\n```python\ndef testform(request):\n    if request.method == \"GET\":\n        obj = form.TestForm()\n        return render(request, \'testform.html\', {\n            \'obj\': obj,\n        })\n    else:\n        pass\n```\n\n在前端视图模板中进行调用：\n\n```html\n<form method=\"post\" id=\"f1\">\n    {% csrf_token %}\n    {{ obj.t1.label }}  # 这样调用只是简单的显示出来\n    {{ obj.t1 }}\n    {{ obj.t1.help_text }}   # 这样调用只是简单显示，但是并不是这么用的。\n    <input type=\"submit\">\n</form>\n```\n\n在前端界面就会生成如下的input输入框，这个就是form为我们生成的。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-27/6070256.jpg)\n\n其实比起上面的这种调用方式还有一种更为简单的调用方式：\n\n```python\n# 这种方式的实现原理是去对象把所有的字段找到，然后生成html标签，对应的参数也会应用上，比如help_text，label_suffix这种参数都会被应用。这种方法其实不太灵活\n{{ obj.as_p }}\n{{ obj.as_ul }}\n{{ obj.as_table }}\n\n# 使用ul的时候记得在外层套一个ul标签，生成table的时候在外面套一个table标签；这俩内容只生成标签内部的东西。\n```\n\n两种方法都可以使用，一个简单，一个控制灵活，因此如果真要用的话建议使用控制更为灵活的。范例如下\n\n```python\nlabel = \'xxxxx\'\n\n<form method=\"POST\" enctype=\"multipart/form-data\">\n    {% csrf_token %}\n    \n        {{ form.xxoo.label }} # 可以把class中定义的label内容显示出来\n        {{ form.xxoo.id_for_label }}\n        {{ form.xxoo.label_tag }}\n        {{ form.xxoo.errors }}\n        <p>{{ form.user }} {{ form.user.errors }}</p>\n        <input type=\"submit\" />\n</form>\n\n# 这里注意一下这个id_for_label的用法\n<form>\n    <div class=\"form-group\">\n        <label for=\"{{ obj.username.id_for_label }}\">用户名</label>\n        {{ obj.username }}\n    </div>\n</form>\n\n# 会生成如下的html，实现label和input的捆绑\n<div class=\"form-group\">\n    <label for=\"id_username\">用户名</label>\n    <input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"请输入您的用户名\" maxlength=\"32\" minlength=\"6\" required=\"\" id=\"id_username\">\n</div>\n```\n\n## 保存用户上次的数据\n\n```python\ndef testform(request):\n    if request.method == \"GET\":\n        # 在这里生成的是一个不带value值的input标签\n        obj = form.TestForm()\n        return render(request, \'testform.html\', {\'obj\': obj,})\n    else:\n        # 先别管用户数据对不对，用户提交的数据肯定是过来了\n        # 那么就会生成一个input标签带着value值，值为用户输入的值(因为传递了用户的POST数据)\n        obj = form.TestForm(request.POST)\n        if obj.is_valid():\n            # 数据验证部分\n            print(obj.cleaned_data)\n        else:\n            # 数据验证失败\n            print(obj.errors)\n        return render(request, \'testform.html\', {\'obj\': obj})\n```\n\nForm生成html标签，单独使用意义不大，结合POST请求生成HTML标签更有意义。会携带value属性，带着数据。解决Form上次输入内容。目前为止比较流行的浏览器都会为我们做一部分验证，我们在学习调试的过程中为了避免干扰可以在form表单中添加`novalidate`属性来规避这个问题。当然实际生产中当然是不要加这个参数，白给的一个验证为什么不加，对吧~\n\n## 修改数据\n\n> 一般修改数据的时候，要显示原来的数据，那么怎么让数据在修改的时候显示初始化的一个原来的值呢？\n\n```python\n# 这个字典就是你从数据库取出来的一个原来的数据，那么你在数据库取数据的时候你就得考虑一下怎么取数据了，应该用values给取出来一个字典放在这里\n# 默认也可以直接在这放一个字典，因为默认的就是data=字典，你不写这个data的时候默认就是data，系统会默认给你补上。而且这种方式会默认进行校验，也就是你这个默认初始值不对的话可是会报错的。放到obj.errors中。\nobj = ClassForm(data = 字典) \n```\n\n如果想要默认不进行校验的话需要传递另外一个参数，initial参数。这样就不会进行校验了。\n\n```python\nobj = ClassForm(initial = 字典) # 内部不会进行校验，让页面显示初始值\n\n# 示例\nrow = models.Student.objects.filter(id=nid).values(\'name\',\'email\',\'age\',\'cls_id\').first()\nobj = StudentForm(initial=row)\n# 体现预先选中的效果，value为1，2，3的会被提前默认选中\n# obj = xxxForm(initial={\'name\':xxxx, \'多选框字段\': [1,2,3])\n```\n\n## 数据的更新\n\n当修改后的数据提交过来以后，如何进行更新，和create的时候差不多，注意的是，针对更新的是针对某一个数据更新，记得要做一次内容的过滤（filter）：\n\n```python\n# 同样支持传递一个字典的方式进行更新。\nmodels.Classes.objects.filter(id=nid).update(**obj.cleand_data)\n```\n\n### Tips\n\n**添加数据的小技巧**\n\n小提醒，一般要插入数据库的一些内容，我们在定制Form组件的时候，我们的字段名称要和数据库中的字段名称是一致的，因为orm在create数据的时候是允许填入一个字典的，比如：\n\n```python\nmodels.xxx.objects.create(**obj.cleaned_data)\n```\n\n这样我们就可以方便的去添加用户数据了，这样插入数据就方便很多了。\n\n## widget挂件\n\n> 上面说了这么多，又有label，又有什么help_text，其实这一堆东西都是不建议使用，当然除了widget，widget其实是用来定制生成怎样的html的。\n\n用widget来指定生成的html标签是哪一种\n\n```python\nfrom django.forms import widgets\n\n# 指定生成的html标签是哪一种\nwidget = widgets.Select\n```\n\n### 单选下拉框\n\n单选下拉菜单，虽然这里显示的是名称，但是提交的却是id，所以可以直接更新或者修改数据库。\n\n```python\n# 这里其实choices接收的是一个列表（元组），列表中是一个个的小元组，那么我们就可以利用orm的values_list来取出来对应的格式。\n\"\"\"\nwidget = widgets.Select(choices=(\n\t(xx,xx),(xx,xx)\n))\n\"\"\"\nclass xxxForm(Form):\n    gender = fields.IntegerField(\n        widget=widgets.Select(choices=models.xxx.objects.values_list(\'id\', \'other_colume\'))\n    )\n    \n# 单选还可以使用ChoiceField，并且ChoiceField也只能搞单选。搞单选的时候IntergerField和ChoiceField本质一致，区别不大，因此都可以用来生成单选下拉框。\nxx = fields.ChoiceField(\n\tchoice=models.Classes.objects.values_list(\'id\',\'title\'),\n    widget=widgets.Select(attrs={\'class\': \'classxxxx\'})\n)\n```\n### 应用样式属性\n\n让我们的组件应用css的样式\n\n```python\n# 当然attrs里面可以写很多属性，class只是其中之一而已。\nwidget = widget.TextInput(attrs={\n    \'class\': \'form-control\',\n})\n```\n### 多选下拉框\n\n```python\n# 因为是多选的，是以widget要使用SelectMultiple，而不是Select，一旦使用了Select那么就说明我要生成的是单选的，即使你在widget中添加一个attr为\'multiple\'的属性也是不可以的。异常的表现就是不管你前端多选了一个，最后在后台获取到的提交的数据之后一个。\n# 因为它在内部是使用request.POST.get(\'xx\')去获取的，那么只能获取到一个\n# 要获取多个是request.POST.get_list，因此这里拿到的是一个数据。\n# 修改为以下的写法\nclass xxxForm(Form):\n    teacher = fields.CharField(widget=widgets.SelectMultiple(choice=models.xxx.objects.values_list(\'id\', \'title\')))\n\n    \n# 显示到前端以后查看的话其实显示是正常的，但是提交的时候我们会发现一个问题。比如我选了id为1号和2号的，根据我们的理解应该提交上来一个列表里，包含着1和2。但是到这里还不对。\n# 得到的值是形如：\"[\'1\',\'2\']\"这样列表形式的字符串，是str格式的，[\'1\',\'2\']是selectMultiple得到的，转换成字符串是CharField给我们多此一举。这种情况下针对单选的时候用CharField其实是没什么问题的，但是针对多选的话就有问题了。因此就不能使用CharField了。\n# 因此使用多选的时候要使用MultipleChoiceFiled+choices结合使用。\nxx = fields.MultipleChoiceField(\n\tchoices=models.Classes.objects.values_list(\'id\',\'title\'),\n    widget=widgets.SelectMultiple\n)\n```\n\n如果数据正确的话那么就应该添加数据了，有的时候可能要多表添加，或者你获取的字段并不是所有字段都需要作为添加的内容，因此有时候一个提交过来的大字典里要剔除去一些字段就可以使用pop\n\n```python\n# pop可以单独把其中一个数据拿出来。假如有这么一个关系，比如添加老师的时候，在前台填写的时候肯定是把老师以及老师任教班级这个关系都写上，但是如果是一个新老师的话还得添加新老师，所以应该先加老师，但是提交过来的任教班级又不能添加到老师表里，因此我们把选择的老师班级拿出来。\nxx = obj.cleaned_data.pop(\'xx\')\nrow = models.Teacher.objects.create(**obj.cleaned_data)\n# 然后再操作老师上课的关系表\nrow.c2t.add(*xx)  # xx = [\'1\',\'2\']\n```\n\n#### 解决静态字段不能实时显示的bug\n\n> 问题背景：比如我们要维护一个教务系统，要添加老师，添加老师的时候除了有老师的基本信息外，还有老师的所属班级，班级有一个单独的班级表，老师表是外键过去的。现在程序启动起来以后我实时的添加班级，但是发现在添加老师的时候在多选列表中并没有显示我们之前新添加的内容。这就是我们这里说到的一个实时显示的bug问题。\n\n首先回顾一下静态方法\n\n```python\nIn [1]: class FormTest2:\n    ...:     a = \'bbb\'\n    ...:     def __init__(self, name):\n    ...:         self.name = name        \n\nIn [2]: a = FormTest2(\'lamber\')\n\nIn [3]: b = FormTest2(\'mxy\')\n\nIn [4]: a.name\nOut[4]: \'lamber\'\n\nIn [5]: b.name\nOut[5]: \'mxy\'\n\nIn [6]: id(a.name)\nOut[6]: 4332738072\n\nIn [7]: id(b.name)\nOut[7]: 4336020872\n\nIn [8]: a.a\nOut[8]: \'bbb\'\n\nIn [9]: id(a.a)\nOut[9]: 4310928608\n\nIn [10]: b.a\nOut[10]: \'bbb\'\n\nIn [11]: id(b.a)\nOut[11]: 4310928608\n```\n\n通过上面的例子可以发现，其中这个变量a属于类的静态数据，实例化以后的内存地址也都是指向的同一块。我们在书写Form组件的时候，其实每一个字段都是这个Form组件类的一个静态字段。看一下我们这个多选的静态字段是如何实现的：\n\n```python\nxx = fields.MultipleChoiceField(\n    choices=models.Classes.objects.values_list(\'id\', \'title\'),\n    widget=widgets.SelectMultiple\n)\n```\n\n那么我们在实例化调用的时候：\n\n```python\n# 这些字段都是属于类的静态对象\nobj = teacherForm()\n1.找到所有字段\n2.放到self.fields = {\n    # 只执行一遍，tname后面的内容在创建对象的时候仅仅会执行一遍。\n    # 以后再使用永远是使用的启动的时候的数据。\n    \'tname\': fields.CharField(min_length=2)\n}\n```\n\n因为这个班级属于静态字段，再次实例化的时候使用的一直是启动时候的数据，因此添加班级的时候，老师关联的班级并不会刷新，因此我们针对这个问题要对这个Form类做一下改造。\n\n```python\nclass TeacherForm(Form):\n    tname = fields.CharFields(min_length=2)\n    xx = fields.MultipleChoiceField(\n\t# choice=models.Classes.objects.values_list(\'id\',\'title\'),\n    widget=widgets.SelectMultiple\n\t)\n    \n    def __init__(self, *args, **kwargs):\n        # 执行完父类的构造方法以后其实就是什么也没执行，但是多了一个self.fields属性\n        super(TeacherForm, self).__init__(*args, **kwargs)\n        # 每一次实例化的时候都重新取一次\n        # 这样处理更加灵活，可以使列表，又可以是字典等。\n        self.fields[\'xx\'].choice = models.Classes.objects.values_list(\'id\', \'title\')\n\n        可以通过查看父类Form来查看构造方法\n```\n\n解决动态显示还有另外一个办法，使用django提供的ModelChoiceField和ModelMultipleChoiceField字段来实现。但是并不推荐这个方法：\n\n```python\nfrom django import forms\nfrom django.forms import fields\nfrom django.forms import widgets\nfrom django.forms import models as form_model\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import RegexValidator\n \nclass FInfo(forms.Form):\n    # 这个方法需要对应的model的classes类加一个__str__方法然后return self.title，因为默认显示的其实是对象，而不是这个数据的名称，value是值。所以要单独加__str__方法。\n    xx = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())\n    # xx = form_model.ModelChoiceField(queryset=models.Classes.objects.all()) 单选\n    # 但是这种方法并不推荐使用，适用于代码量比较少或者小的时候可以使用，因为必须结合model使用（比如给model加一个__str__方法），耦合性略高。简单的程序可以去使用，推荐使用上面的上面的去操作self.fields的方式。\n    # 毕竟我们自己取数据字段值不依赖于__str__方法，相对更加也灵活性，因此继承也是推荐的方法。\n```\n\n### 其他常用插件\n\n```python\nclass TestForm(Form):\n    t1 = fields.CharField(\n        # widget = widgets.PasswordInput\n        widget = widgets.Textarea(attr=字典)\n    )\n    t2 = fields.CharField(\n        # checkbox单选框\n        widget=widgets.CheckboxInput\n    )\n    t3 = fields.MultipleChoiceField(\n        # checkbox多选框\n        choices = [(1,\'basketball\')，(2，\'soccer\')],\n        widget=widgets.CheckboxSelectMultiple\n    )\n    \ndef test(request):\n    obj = TestForm(initial={\'t3\': [2,3]})\n    return render(request, \'test.html\', {\'obj\': obj})\n\n\n# radio，默认取回来的值只可能有一个，因此使用ChoiceField就可以了。\nt4 = fileds.ChoiceField(\n    choice=[(1,\'basketball\')，(2，\'soccer\')],\n    widget=widgets.RadioSelect\n)\n\n# 文件上传，提交过来的内容就是Bytes，返回值是一个文件对象。里面包含文件的属性\nt5 = fileds.FileField(\n    widget=widgets.FileInput\n)\n```\n\n### 内置插件\n\n```python\nTextInput(Input)\nNumberInput(TextInput)\nEmailInput(TextInput)\nURLInput(TextInput)\nPasswordInput(TextInput)\nHiddenInput(TextInput)\nTextarea(Widget)\nDateInput(DateTimeBaseInput)\nDateTimeInput(DateTimeBaseInput)\nTimeInput(DateTimeBaseInput)\nCheckboxInput\nSelect\nNullBooleanSelect\nSelectMultiple\nRadioSelect\nCheckboxSelectMultiple\nFileInput\nClearableFileInput\nMultipleHiddenInput\nSplitDateTimeWidget\nSplitHiddenDateTimeWidget\nSelectDateWidget\n```\n\n## 小结\n\n- 多对多\n  - ChoiceField（可被替代）\n  - MultipleChoiceField\n- 常用插件\n  - CheckBox\n  - radio\n  - input\n  - textarea\n  - File\n- 扩展Extra（比如跟数据库相关的，跟文件相关的）","timestamp":1540354517190},{"name":"03-03-数据的提交.md","path":"04-Django/05-Django Form/03-03-数据的提交.md","content":"# 数据的提交\n\n> - Form表单的方式提交：Form表单自身会刷新页面，因此提交的信息如果有误的话是不会被保留的\n> - Ajax方式的提交：页面不会刷新，偷偷的给服务器传递数据。上次内容自动保留，可以手动js刷新\n\n比如说现在的Form组件我定义了两个字段规则，一个username，一个password，然后反应在前端的代码是这样的：\n\n```html\n<!--提交我用一个a按钮代替，绑定一个onclick事件-->\n<form id=\"f1\" method=\"post\">\n    {% csrf_token %}\n    <p>用户名：<input type=\"text\" name=\"username\" />{{ obj.errors.username }}</p>\n    <p>密码：<input type=\"password\" name=\"password\" />{{ obj.errors.password }}</p>\n    <p><a onclick=\"submitForm();\">提交</a></p>\n</form>\n```\n\n对应的JS代码：\n\n```js\n# 引入Jquery\n<script src=\"/static/js/jquery-3.2.1.min.js\"></script>\n<script>\n    function submitForm() {\n    \t# 在执行这个方法开始将标签的样式还原，其实就是找到标签，然后remove掉。别让他重复显示\n        $(\'.c1\').remove();\n        $.ajax({\n            # 提交的地址，这个要在django的路由中加上\n            url: \"/ajax_login/\",\n            # 提交方式为POST\n            type: \'POST\',\n            # 通过上面的表单可以看到我们提交的内容有三个，用户名，密码，还有csrf_token\n            # 通过serialize方法可以获取打包后的数据将我们要提交的数据一起打包\n            # 打包后的格式为：“user=xxx&pwd=xxx&csrf_token=xxx”的字符串\n            data: $(\'#f1\').serialize(), \n            # 预期服务器返回的数据类型，我们返回类型为JSON\n            dataType: \"JSON\",\n            success: function (arg) {\n                if(arg.status){\n\t\t\t\t\tconsole.log(arg.msg)\n                }else{\n                    # 如果说验证失败其实是会返回错误的，如果username和password都有问题\n                    # 那么就是返回两个，如果其中有一个有问题就是返回一个，因此一个两个不确定\n                    # 为了处理这个问题，我们对返回的数据进行遍历\n                    $.each(arg.msg, function(index, value){\n            \t\t\t# index是key，value就是对应的报错内容\n                        console.log(index, value);\n            \t\t\t# 创建一个span标签\n                        var tag = document.createElement(\'span\');\n                        # 设置span标签的值为对应的报错信息，只显示第一个报错就行。\n                        tag.innerHTML = value[0];\n            \t\t\t# 在设置的时候设置一个类，用于重置显示内容\n                        # 因为页面没刷新，如果不做这个操作，每次触发onclick事件\n                        # 会不断的在后面添加内容。\n                        tag.className = \'c1\';\n            \t\t\t# 在form中找到属性name为对应的“index”属性的标签，在它后面加上tag\n                        # 这里用到了字符串的拼接。拼接结果为\"input[name=\"username\"]\"样\n                        $(\'#f1\').find(\'input[name=\"\' + index + \'\"]\').after(tag)\n                    })\n                }\n            }\n\n        })\n    }\n</script>\n```\n\n后端处理视图函数：\n\n```python\nimport json\ndef ajax_login(request):\n    # 初始化一个字典\n    ret = {\n        # 初始化验证后状态\n        \'status\': True,\n        \'msg\': None\n    }\n    if request.method == \"POST\":\n        obj = form.LoginForm(request.POST)\n        if obj.is_valid():\n            # 如果验证合法其实就应该要插入数据库了。\n            # print(obj.cleaned_data)\n            插入数据库等操作\n            ret[\'msg\'] = \"验证成功\"\n        else:\n            # 验证失败会把对应的失败报错内容放到errors中去。\n            # print(obj.errors)\n            # 对数据字典重新赋值\n            ret[\'status\'] = False\n            # 注意这里的obj.errors不是字符串是一个对象，对象是不能直接放到httpresponse里面直接进行返回的，但是可以序列化以后然后再进行返回。这就是这里要进行json.dump的原因。\n            ret[\'msg\'] = obj.errors\n    # 记得导入json模块\n    v = json.dumps(ret)\n    return HttpResponse(v)\n```\n\n## 到底要使用哪一种方式提交？\n\n今后两个一般只会用到一个\n\n- Ajax：仅用作验证功能（get+ajax）\n- Form：验证功能，生成HTML标签（get+post）。\n","timestamp":1540354517190},{"name":"04-04-Form组件内部原理.md","path":"04-Django/05-Django Form/04-04-Form组件内部原理.md","content":"# Form组件内部实现原理\n\n### Form验证执行流程以及钩子\n\n1. 验证字段`is_vaild`→`return self.is_bound and not self.errors`。这个`self.is_bound`是什么意思？当实例化Form对象的时候为data就是绑定数据会做校验，如果是initial那么is_bound就是false。做不做校验的时候最主要的这一个`is_bound`是True还是False。如果`self.is_bound`是true就做绑定，否则就返回false。不做验证。\n\n   ```python\n   def is_valid(self):\n       \"\"\"Return True if the form has no errors, or False otherwise.\"\"\"\n       return self.is_bound and not self.errors\n   ```\n\n2. 知道了`self.is_bound`我们通过`self.errors`进一步往下看。我们看到如果`self._errors`为空的时候也就是一开始验证时候是并没有错误信息的，会走入这个if的条件进行验证执行`self.full_clean()`函数。\n\n   ```python\n   @property\n   def errors(self):\n       \"\"\"Return an ErrorDict for the data provided for the form.\"\"\"\n       if self._errors is None:\n           self.full_clean()\n       return self._errors\n   ```\n\n3. `self.full_clean()`开始验证，到这里我们就看到了我们熟悉的`cleaned_data`，一上来就是一个默认的空字典。然后就是分别执行了`self._clean_fields,self._clean_form,self._post_clean`这三个函数。我们来一个一个的看。\n\n   ```python\n   def full_clean(self):\n       \"\"\"\n       Clean all of self.data and populate self._errors and self.cleaned_data.\n       \"\"\"\n       self._errors = ErrorDict()\n       if not self.is_bound:  # Stop further processing.\n           return\n       self.cleaned_data = {}\n       # If the form is permitted to be empty, and none of the form data has\n       # changed from the initial data, short circuit any validation.\n       if self.empty_permitted and not self.has_changed():\n           return\n   \n       self._clean_fields()\n       self._clean_form()\n       self._post_clean()\n   ```\n\n   **self._clean_fields**\n\n   遍历fields中的所有字段；value = fields.clean(value) 把值按照正则做校验。验证成功后：self.cleaned_data[name] = value填充cleaned_data。执行完这一条代码的时候相当于把所有的字段都已经执行完一遍了。\n\n   ```python\n   def _clean_fields(self):\n       # self.fields就是一个字典，其中key就是我们写的字段名，value就是插件还有正则的验证规则。\n       for name, field in self.fields.items():\n           # value_from_datadict() gets the data from the data dictionaries.\n           # Each widget type knows how to retrieve its own data, because some\n           # widgets split data over several HTML fields.\n           # 获取用户提交过来数据\n           if field.disabled:\n               value = self.get_initial_for_field(field, name)\n           else:\n               value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name))\n           # 根据正则进行数据的校验\n           try:\n               if isinstance(field, FileField):\n                   initial = self.get_initial_for_field(field, name)\n                   value = field.clean(value, initial)\n               else:\n                   value = field.clean(value)\n               # 验证通过以后更新字典，其中name为字段值，value就是用户提交过来的值。\n               self.cleaned_data[name] = value\n               # 执行钩子函数，这个钩子函数的命名规则为\"clean_当前字段字段名称\"\n               # 虽然这个默认的是没有写的，但是这也就给我们提供了更多的可以定制的自定义的可能性\n               # 因为在Form表单那块只能写正则，比如要验证数据库数据可用性这个就做不到了。\n               # 因此这里会去判断是否有钩子函数，如果有就执行。\n               # 同时我们还发现如果条件满足以后，会更新cleaned_data中的对应字段的值。\n               # 这个value就是我们这个钩子函数的返回值。在自定义钩子的时候我们要注意。\n               if hasattr(self, \'clean_%s\' % name):\n                   value = getattr(self, \'clean_%s\' % name)()\n                   self.cleaned_data[name] = value\n           # 在匹配过程中捕获异常，如果没有匹配成功，会在error中加对应的字段以及报错内容。\n           # 并且报错以后后面的代码就不执行了。\n           except ValidationError as e:\n               self.add_error(name, e)\n   ```\n\n   **self._clean_form**\n\n   但凡上一步执行完了以后，如果没问题，那么`self.cleaned_data`就已经有数据了，如果之前验证有异常，那么这就是一个空字典，取而代之的是报错会被放到errors中去。\n\n   ```python\n   def _clean_form(self):\n       try:\n           # 在这里看到cleaned_data是self.clean的返回值\n           # 而self.clean的本身又是django预留的一个钩子函数预留给用户自定制功能。\n           # 因此如果你想要造成影响就返回值就可以了。\n           # 这个方法可以直接定义在我们的Form组件中，当所有正则执行完成以后执行clean方法\n           # 因为如果验证成功以后此时cleaned_data已经有所有的数据了，因此适合做整体的验证。\n           # 不用担心数据有没有的问题。\n           # clean有返回值，cleaned_data=clean的返回值，否则等于原来的值。\n           cleaned_data = self.clean()\n       except ValidationError as e:\n           self.add_error(None, e)\n       else:\n           # 当self.clean()返回内容不为空的时候才会重新赋值(造成影响)\n           if cleaned_data is not None:\n               self.cleaned_data = cleaned_data\n               \n   # 多看一步clean方法的内容\n   def clean(self):\n       \"\"\"\n       Hook for doing any extra form-wide cleaning after Field.clean() has been\n       called on every field. Any ValidationError raised by this method will\n       not be associated with a particular field; it will have a special-case\n       association with the field named \'__all__\'.\n       \"\"\"\n       return self.cleaned_data\n   ```\n\n   **self._post_clean**\n\n   最后再看这个`self._post_clean`方法，可以看到这个同样是一个钩子函数，也是给用户预留功能。这个功能一般使用的不多。这个和clean功能使用一个就行了。\n\n   ```python\n   def _post_clean(self):\n       \"\"\"\n       An internal hook for performing additional cleaning after form cleaning\n       is complete. Used for model validation in model forms.\n       \"\"\"\n       pass\n   ```\n\n### 原理图\n\n![](http://omk1n04i8.bkt.clouddn.com/18-7-18/84998839.jpg)\n\n## Form实例应用\n\n示例：可以关注一下下面的执行顺序。\n\n```python\nfrom django.core.exceptions import ValidationError\n# 有如下的代码\nclass TestForm(Form):\n    user = fields.CharField()  # 执行顺序1\n    pwd = fileds.CharField()   # 执行顺序3\n    \n    # 这个函数会在内部被调用，如果有这个方法就执行没有就不执行，内部通过反射去判断的。\n    # 上面只能是正则判断，在方法中就可以进行进一步的高级验证了，比如数据库判断\n    # 如果正则表达式都没有通过，那么这里的函数就不会执行了。所以在正则没有验证成功后\n    # 会抛出一个异常ValidationError然后，加入一个错误\n    # self.add_error(name, e)\n    # 所以这个扩展函数没有通过的时候我们也可以抛出一个异常添加到error中\n    def clean_user(self):   # 执行顺序2\n        # clean_user中不能取pwd的值，因为这回pwd的值还不在字典里呢\n        # 因此最好只取自己的值，除非在你执行这一部分的时候其他的值已经加进去了。\n        v = self.cleand_data[\'user\']\n        from django.core.exceptions import ValidationError\n        if models.Student.objects.filter(name=v).count():\n            # 这里的code就是之前定制的error_message的key\n            # 默认不写就是invalid\n            raise ValidationError(\'User exists\', code=\'invalid\')\n        # 一定要返回一个值，因为django内部要重新赋值，否则会赋值为None\n        return xxx\n    \n    def clean_pwd(self):   # 执行顺序4\n        return self.cleaned_data[\'pwd\']\n```\n\n验证通过后走下一句self._clean_form(self)，此时self_cleaned_data有值了，否则就是一个空字典→cleaned_data = self.clean()→找到这个self.clean()方法，可以看到注释说明这是一个钩子，用户扩展的。这个我们自己也可以进行自定义:\n\n```python\n# 有如下的代码\nclass TestForm(Form):\n    user = fields.CharField()  # 执行顺序1\n    pwd = fileds.CharField()   # 执行顺序3\n\n    def clean_user(self):   \n        v = self.cleand_data[\'user\']\n        from django.core.exceptions import ValidationError\n        if models.Student.objects.filter(name=v).count():\n            raise ValidationError(\'User exists\', code=\'invalid\')\n        return xxx\n    \n    def clean_pwd(self):   # 执行顺序4\n        return self.cleaned_data[\'pwd\']\n    \n    def clean(self):\n        # 举例子做一个联合唯一的判断，对用户和密码做整体判断\n        user = self.cleaned_data.get(\'user\')\n        email = self.cleaned_data.get(\'email\')\n        # 数据库验证\n        if models.Student.objects.filter(user=user,email=email).count():\n            # 整体存在就别添加了。\n            raise ValidationErrors(\'用户名已经存在\')\n        return self.cleaned_data\n```\n\n最后一个self._post_clean(self)也是用来自定义的。\n\n```python\n# 有如下的代码\nclass TestForm(Form):\n    user = fields.CharField()  # 执行顺序1\n    pwd = fileds.CharField()   # 执行顺序3\n\n    def clean_user(self):   \n        v = self.cleand_data[\'user\']\n        from django.core.exceptions import ValidationError\n        if models.Student.objects.filter(name=v).count():\n            raise ValidationError(\'User exists\', code=\'invalid\')\n        return xxx\n    \n    def clean_pwd(self):   # 执行顺序4\n        return self.cleaned_data[\'pwd\']\n    \n    def clean(self):\n        pass\n    \n    def _post_clean(self):\n        \"\"\"\n        也是自定制的内容，一般用不到这个内容\n        如果要用到的话记得自己加异常处理。\n        \"\"\"\n        pass\n```\n\n##  小结\n\n1. 先按照form类中定义的字段顺序，依次校验每一个字段（内置的校验规则）\n2. 每个字段先校验内置的规则，然后在校验clean_字段名开头的规则\n3. 整个for循环走完成以后，再调用form类中定义的clean()方法\n\n","timestamp":1540354517190},{"name":"01-Form组件定义.md","path":"04-Django/05-Django Form/05-05-Form注册实例/01-Form组件定义.md","content":"# Form组件定义\n\n> \n\n## Form类：\n\n```python\nfrom django.forms import fields, Form, widgets\nfrom django.core.exceptions import ValidationError\n\n\n# 用户注册相关Form组件定义\nclass RegisterForm(Form):\n    \"\"\"\n    RegisterForm的实例中的fields是一个有序的字典，简单来说也就是我们写的这字段都是有顺序的\n    一个一个往下的来匹配的。\n    \"\"\"\n\n    # 用户名form组件\n    username = fields.CharField(\n        label=\'用户名\',\n        max_length=32,\n        min_length=6,\n        required=True,\n        error_messages={\n            \'required\': \'用户名不能为空\',\n            \'max_length\': \'最大长度请不要超过32\',\n            \'min_length\': \'请输入至少6个字符\',\n        },\n        widget=widgets.TextInput(\n            attrs={\'class\': \'form-control\', \'placeholder\': \'请输入您的用户名\', })\n        )\n    # 用户昵称form组件\n    nickname = fields.CharField(\n        label=\'昵称\',\n        max_length=32,\n        min_length=6,\n        required=True,\n        error_messages={\n            \'required\': \'用户名不能为空\',\n            \'max_length\': \'最大长度请不要超过32个字符\',\n            \'min_length\': \'请输入至少6个字符\',\n        },\n        widget=widgets.TextInput(\n            attrs={\'class\': \'form-control\', \'placeholder\': \'请输入您的昵称\'}\n        )\n    )\n    # 用户邮箱字段\n    email = fields.EmailField(\n        label=\'邮箱\',\n        required=True,\n        widget=widgets.TextInput(\n            attrs={\'class\': \'form-control\', \'placeholder\': \'请输入您的密码\'}\n        )\n    )\n\n    # 用户密码form组件\n    password = fields.CharField(\n        label=\'密码\',\n        max_length=32,\n        min_length=10,\n        required=True,\n        error_messages={\n            \'required\': \'密码为必填字段，请不要留空\',\n            \'max_length\': \'最大长度请不要超过32个字符\',\n            \'min_length\': \'密码长度不要小于10个字符\',\n        },\n        widget=widgets.PasswordInput(\n            attrs={\'class\': \'form-control\', \'placeholder\': \'请输入您的密码\'}\n        )\n    )\n    # 确认密码form组件\n    re_password = fields.CharField(\n        label=\'确认密码\',\n        max_length=32,\n        min_length=10,\n        required=True,\n        error_messages={\n            \'required\': \'密码为必填字段，请不要留空\',\n            \'max_length\': \'最大长度请不要超过32个字符\',\n            \'min_length\': \'密码长度不要小于10个字符\',\n        },\n        widget=widgets.PasswordInput(\n            attrs={\'class\': \'form-control\', \'placeholder\': \'请再次输入您的密码\'},\n        ),\n    )\n    # 头像字段\n    avatar = fields.FileField(\n        required=False,\n        widget=widgets.FileInput(\n            attrs={\'id\': \'imgSelect\', },\n        )\n    )\n    # 验证码字段\n    auth_code = fields.CharField(\n        label=\'验证码\',\n        error_messages={\n            \'required\': \'验证码不能为空\'\n        },\n        widget=widgets.TextInput(\n            attrs={\'class\': \'form-control\', \'placeholder\': \'验证码\', },\n        ),\n    )\n```\n\n如上代码所示，分别定义了用户名，昵称，密码，确认密码，邮箱字段，头像以及验证码的字段。需要注意的就是在使用widget挂件的时候，要指定对应的挂件类型，比如密码就是`widgets.PasswordInput`文件类型的就是`widgets.FileInput`；为了让form类在前端调用的时候能够携带对应的BootStrap样式，我们这里就给每个form类属性加上了widget挂件通过设置attr，设置对应input的标签的css类。那么如何放到对应的前端页面呢，其实很简单。\n\n## 视图函数\n\n这里我们默认发送get请求的时候就给客户端返回一个前端页面\n\n```python\ndef register(request):\n    \"\"\"\n    注册相关视图函数\n    :param request:\n    :return:\n    \"\"\"\n    if request.method == \"GET\":\n        obj = RegisterForm(request)\n        return render(request, \'register.html\', {\'obj\': obj})\n```\n\n对应的html页面，值得注意的几个点如下：\n\n- 不要忘记写csrf_token\n- 因为我们的上传还要上传头像，头像图片属于稳健所以要指定enctype，不能用默认的。\n- label和对应的input框进行绑定，注意label的for的值为`obj.xxx.id_for_label`。因为对应的这个input的框的require id是随机生成的。\n- errors中对应的字段不一定有值，也就是这个字段不一定出错，因此要判断一下，是否显示这个包含错误的span标签。\n- 目前使用的是上下模式的form表单，label显示在上，input框显示在下，BootStrap还提供了水平模式的（.form-horizontal），在`.form-control`中的input是`width:100%`撑开的，因此当我们要设置验证码的时候如果要让验证码的输入框和验证码显示在同一行，需要再设置input框的宽度减小一些，否则验证码就会被挤到下一行。将input的宽度百分比减小，向左浮动，验证码向右浮动，父级清除浮动即可。\n- 头像是通过绝对定位定位到最上面的，通过一个img标签和一个type为file的input框联合实现的，很简单把img和input设置一样的宽高，然后通过定位让这俩标签重合在一起，最后把input的透明度设置为0，这个时候，就只能看到img，但是input仍然存在，就会实现一种点击img实际上是触发一个上传的操作。\n\n```html\n<div id=\"register\">\n    <form novalidate action=\"/register/\" method=\"post\" enctype=\"multipart/form-data\">\n        {% csrf_token %}\n        <div class=\"form-group\">\n            <label for=\"{{ obj.username.id_for_label }}\">{{ obj.username.label }}</label>\n            {{ obj.username }}\n            {% if obj.errors.username %}\n                <span>{{ obj.errors.username.0 }}</span>\n            {% endif %}\n        </div>\n        <div class=\"form-group\">\n            <label for=\"{{ obj.nickname.id_for_label }}\">{{ obj.nickname.label }}</label>\n            {{ obj.nickname }}\n            {% if obj.errors.nickname %}\n                <span>{{ obj.errors.nickname.0 }}</span>\n            {% endif %}\n        </div>\n        <div class=\"form-group\">\n            <label for=\"{{ obj.email.id_for_label }}\">{{ obj.email.label }}</label>\n            {{ obj.email }}\n            {% if obj.errors.email %}\n                <span>{{ obj.errors.email.0 }}</span>\n            {% endif %}\n        </div>\n        <div class=\"form-group\">\n            <label for=\"{{ obj.password.id_for_label }}\">{{ obj.password.label }}</label>\n            {{ obj.password }}\n            {% if obj.errors.password %}\n                <span>{{ obj.errors.password.0 }}</span>\n            {% endif %}\n        </div>\n        <div class=\"form-group\">\n            <label for=\"{{ obj.re_password.id_for_label }}\">{{ obj.re_password.label }}</label>\n            {{ obj.re_password }}\n            {% if obj.errors.re_password %}\n                <span>{{ obj.errors.re_password.0 }}</span>\n            {% endif %}\n        </div>\n        <div class=\"form-group\">\n            <label for=\"{{ obj.auth_code.id_for_label }}\">{{ obj.auth_code.label }}</label>\n            <div class=\"authcode clearfix\">\n                {{ obj.auth_code }}\n                {% if obj.errors.auth_code %}\n                    <span>{{ obj.errors.auth_code.0 }}</span>\n                {% endif %}\n                <img src=\"/auth_code/\" alt=\"\" title=\"点击更新\">\n            </div>\n        </div>\n        <button type=\"submit\" class=\"btn btn-primary btn-block\">注册</button>\n        <div class=\"avatar\">\n            <img id=\'previewimg\' src=\"/static/imgs/head/default/default1.jpg\" alt=\"\">\n            {{ obj.avatar }}\n        </div>\n    </form>\n\n</div>\n```\n\n**CSS**\n\n```less\n@charset \"utf-8\";\n\n/* css reset reference https://cssreset.com/ */\n// 这里的这个html和body都要设置高度，不设置html只设置body是不会生效的。\nhtml, body {\n  height: 100%;\n}\n\ndiv#register {\n  position: relative;\n  border: 1px solid #000;\n  border-radius: 6px;\n  padding: 50px 15px 20px;\n  width: 400px;\n  left: 50%;\n  top: 50%;\n  margin-left: -200px;\n  margin-top: -250px;\n  .form-group{\n    position: relative;\n    span{\n      text-indent: 1em;\n      width:250px;\n      height: 30px;\n      line-height: 30px;\n      font-size: 14px;\n      position: absolute;\n      top: 26px;\n      left: 400px;\n      border-radius: 4px;\n      background-color: #c1e2b3;\n      &:before{\n        position: absolute;\n        content: \"\";\n        width: 0;\n        height: 0;\n        right: 100%;\n        top: 10px;\n        border-top: 5px solid transparent;\n        border-right: 10px solid #c1e2b3;\n        border-bottom: 5px solid transparent;\n      }\n    }\n  }\n  .avatar {\n    width: 100px;\n    height: 100px;\n    border: 1px solid lightgray;\n    border-radius: 50px;\n    box-shadow: 0 0 3px gray;\n    overflow: hidden;\n    background: red;\n    position: absolute;\n    top: -60px;\n    left: 160px;\n    img {\n      width: 100px;\n      height: 100px;\n      position: absolute;\n    }\n    input {\n      width: 100px;\n      height: 100px;\n      position: absolute;\n      opacity: 0;\n    }\n  }\n  .authcode {\n    input {\n      /* \n      Bootstrap默认会使form-control下的所有input的width为100%，为了让input和这个验证码\n      在一行显示，因此单独设置一下这个input框的占用宽度的百分比。\n       */\n      width: 65%;\n      float: left;\n    }\n    img{\n      float: right;\n      border: 1px solid #000000;\n    }\n  }\n}\n```\n\n\n\n\n\n","timestamp":1540354517190},{"name":"06-ModelForm.md","path":"04-Django/05-Django Form/06-ModelForm.md","content":"# ModelForm\n\n> Model：用于操作数据库\n>\n> Form：生成HTML标签以及对请求的数据做数据校验。\n>\n> ModelForm：上述两者功能的合集\n>\n> 但是ModelForm由于集合和Model和Form因此适用场景就变小了，如果是大型的应用程序是不适合适用ModelForm的，在大场景的时候数据库和前端展示以及后端验证会作为单独的模块单独出去会有不同的基础平台来实现，而不是全部都耦合在一起，也不互相依赖。因此ModelForm虽然一定程度上要好用一些，但是同时也限制了它的应用场景。\n\n## 简单使用\n\n```python\nclass UserGroup(models.Model):\n    title = models.CharField(max_length=32)\n    \n    def __str__(self):\n        return self.title\n    \nclass Role(models.Model):\n    name = models.CharField(max_length:32)\n    \n    def __str__(self):\n        return self.name\n\nclass UserInfo(models.Model):\n    user = models.CharField(max_length=32)\n    email = models.EmailField()\n    ug = models.ForeignKey(UserGroup, null=True, blank=True)\n    \n    m2m = models.ManyToManyField(\'Role\')\n    \n    def __str__(self):\n        return self.user\n```\n\n\n\n\n\n```python\nfrom django.forms import Form, fields, widgets\nclass TestForm(Form):\n    user = fields.CharField(required=True)\n    email = fields.EmailField(required=True)\n    ug_id = fields.ChoiceField(\n        widget=widgets.Select,\n        choices=[]\n    )\n    \n    def __init__(self, *args, **kwargs):\n        super(TestForm, self).__init__(*args, **kwargs)\n        self.fields[\'ug_id\'].choices = models.UserGroup.objects.values_list(\'id\', \'title\')\n```\n\n\n\n\n\n```python\ndef test(request):\n    if request.method == \'GET\':\n        form = TestForm()\n        context = {\n            \'form\': form\n        }\n        return render(request, \'test.html\', context)\n    else:\n        form = TestForm(request.POST)\n        if form.is_vaild():\n            # 提交过来的外键字段是ug，这个ug必须是一个对象，如果把提交的内容改成ug_id就可以直接提交了。\n            models.UserInfo.objects.create(**form.cleaned_data)\n            return redirect(\'http://www.baidu.com\')\n        context = {\n            \'form\': form\n        }\n        return render(request, \'test.html\', context)\n```\n\n\n\n\n\n简单的写法：\n\n```python\nform django.forms import ModelForm\n\nclass TestModelForm(ModelForm)：\n    class Meta:\n        model = models.UserInfo\n        fields = \"__all__\"\n        error_messages = {\n            # 字典的key就是字段名，按照如下形式就可以定制我们的错误信息\n            \'user\': {\'required\': \'用户名不能为空\'}\n            \'email\': {\'required\': \'邮箱不能为空\', \'invalid\': \'邮箱不能为空\'}\n        }\n        \ndef test(request):\n    if request.method == \'GET\':\n        form = TestModelForm()\n        context = {\n            \'form\': form\n        }\n        return render(request, \'test.html\', context)\n    else:\n        form = TestModelForm(request.POST)\n        if form.is_vaild():\n            # ModelForm不用你分门别类的去保存，直接一个save就能搞定。\n            # 其他的关系表也为你自动加进去了。\n            form.save()\n            return redirect(\'http://www.baidu.com\')\n        context = {\n            \'form\': form\n        }\n        return render(request, \'test.html\', context)\n    \n在前端把对应的model字段写上就可以了。省了写什么select，省了写什么多对多，全都省了。\n```\n\n\n\n```python\ndef edit(request, nid):\n    obj = models.UserInfo.objects.filter(id=nid).first()\n    if request.method == \'GET\':\n        # 使用instance=obj就可以进行数据的填充\n        form = TestModelForm(instance=obj)\n        context = {\n            \'form\': form\n        }\n        return render(request, \'edit.html\', context)\n    else:\n        # 编辑的时候必须带着这个instance\n        form = TestModelForm(instance=obj, data=request.POST, files=request.FILES)\n        if form.is_valid():\n            form.save()\n            return redirect(\'/\')\n        return render(request, \'edit.html\', context)\n```\n\n\n\nwww.cnblogs.com/wupeiqi/articles/6229414.html\n\n```python\nModelForm\n    a.  class Meta:\n            model,                           # 对应Model的，只能对应一个，\n            fields=None,                     # 字段，可以__all__所有，也可以接一个元组写上字段名\n            exclude=None,                    # 排除字段\n            labels=None,                     # 提示信息，一般用不到，form.as_p的时候会用到，labels是一个字典，字段名对应label名称。，下面的help_texts同理。\n            help_texts=None,                 # 帮助提示信息\n            widgets=None,                    # 自定义插件同Form的widgets，接收一个字典，key是字段名，比如\'user\': fwigets.Textarea(attrs={\'class\':\'c1\'})，注意这个widgets重名了，所以我们导入的要重命名一下。\n            error_messages=None,             # 自定义错误信息（整体错误信息from django.core.exceptions import NON_FIELD_ERRORS）\n            field_classes=None               # 自定义字段类 （也可以自定义字段）一般不用。一般默认生成的时候比如用户名是input框，email也是input框，但是email有一个type为email的验证规则，如果你也想让这个username有email的验证规则，就可以用fields_classes = {\'user\': ffields.EmailField}注意后面括号都不能加，因此很有局限性，还有一个就是注意这里的fields和Meta上面的fields重名了，记得给这个重命名一下。\n            localized_fields=(\'birth_date\',) # 本地化，如：根据不同时区显示数据\n            如：\n                数据库中\n                    2016-12-27 04:10:57\n                setting中的配置\n                    TIME_ZONE = \'Asia/Shanghai\'\n                    USE_TZ = True\n                则显示：\n                    2016-12-27 12:10:57\n    b. 验证执行过程\n        is_valid -> full_clean -> 钩子 -> 整体错误\n \n    c. 字典字段验证\n        def clean_字段名(self):\n            # 可以抛出异常\n            # from django.core.exceptions import ValidationError\n            return \"新值\"\n    d. 用于验证\n        model_form_obj = XXOOModelForm()\n        model_form_obj.is_valid()\n        model_form_obj.errors.as_json()\n        model_form_obj.clean()\n        model_form_obj.cleaned_data\n    e. 用于创建\n        model_form_obj = XXOOModelForm(request.POST)\n        #### 页面显示，并提交 #####\n        # 默认保存多对多\n            obj = form.save(commit=True)\n        # 不做任何操作，内部定义 save_m2m（用于保存多对多）\n            obj = form.save(commit=False)\n            obj.save()      # 保存单表信息\n            obj.save_m2m()  # 保存关联多对多信息\n \n    f. 用于更新和初始化\n        obj = model.tb.objects.get(id=1)\n        model_form_obj = XXOOModelForm(request.POST,instance=obj)\n        ...\n \n        PS: 单纯初始化\n            model_form_obj = XXOOModelForm(initial={...})\n```\n\n![image-20181016154200464](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20181016154200464.png)\n\n咱们自己写的优先级更高。","timestamp":1540354517190},{"name":"07-Django模板.md","path":"04-Django/07-Django模板.md","content":"# Django中的模板\n\n> 为什么会有模板技术，即使没有模板我们也可以以字符串的形式将html代码嵌入到Python代码中去，但是考虑一下，这个明显是一个很麻烦的操作\n>\n> - 当改动的时候需要对Python代码进行改动\n> - Python和HTML前端是两种技术领域，应该有专业的技术去完成。耦合在一起明显加大了维护的难度。各司其职才是效率更高的体现。\n>\n> 也是因为如此，存在Django模版的技术，如下讲对Django的模板做简单的使用说明。\n\n## 1、特殊标记语言\n\n假如说我们在后台给前台render一段模板内容，第一个参数是request，第二个参数就是模板文件，第三个就是一个字典它可以结合模板语言去替换模板中的特殊标记的字符串。\n\n```python\nrender(request, \'login.html\', {\n    \'name\': \'lamber\',\n    # 在模板中取的时候用{{ users.1 }}这种形式，1表示索引值\n    \'users\': [\'user1\',\'user2\'],\n    # 取的时候直接{{ user_dict.k1 }}\n    \'user_dict\': {\'k1\':\'v1\',\'k2\':\'v2\'},\n    \'user_list_dict\': [\n        {\'id\':1, \'name\':\'alex\', \'email\':\'22222@q.com\'},\n        {\'id\':2, \'name\':\'alex2\', \'email\':\'22222@q.com\'},\n    ]\n})\n```\n\n那么现在我想要在前端把users这个key中的内容取出来应该使用什么方式去获取呢？\n\n```python\n# 在模板中使用for循环去取用users这个key的数据\n{% for item in users %}\n\t<h3>{{ item }}</h3>\n{% endfor %}\n这样的话在前段模板中就会显示两个html标签，分别为：\n<h3>user1</h3>\n<h3>user2</h3>\n\n# 或者嵌套进别的html标签中去写也是可以的。\n<ul>\n\t{% for item in users %}\n    <li>{{ item }}</li>\n    {% endfor %}\n</ul>\n\n# 针对这个列表形式的我们还可以使用索引去取数据，只不过取的时候形式和python的不太一样\n# 索引也是从0开始的\n<h1>{{ users.0 }}</h1>\n<h2>{{ users.1 }}</h2>\n\n# 直接调用字典里的内容。\n{% for i in userinfo.items %} # userinfo.keys,userinfo.values\n    print something\n{% endfor %}\n```\n\n上文中的这个item是一个变量，通过for循环去users中取出来的一个临时变量，想要使用变量的话可以使用双花括号的形式去调用，比如`{{ item }}`。值得注意的这个特殊标记有开始有结束，比如for循环，那么最后要有一个endfor标签作为结束，如果是if标签，要有一个endif作为结束。\n\n```python\n# 循环user_list_dict，直接使用\".\"去取嵌套字典中的每一个数据，这个也python也不一样。\n<table>\n\t{% for row in user_list_dict %}\n    <tr>\n    \t<td>{{ row.id }}</td>\n        <td>{{ row.name }}</td>\n        <td>{{ row.email }}</td>\n    </tr>\n    {% endfor %}\n</table>\n```\n\n我们在模板中还可以进行if判断\n\n```python\n{% if status %}\n    <h1>{{ users.0 }}</h1>\n{% else %}\n    <h1>{{ users.1 }}</h1>\n{% endif %}\n```\n\n**关于Request**\n\n其实我们在render一个界面的时候，会隐式的去传递一个request供我们去调用部分信息。比如我有一个界面我要登录，那么登录以后显示“您好，xxx”，这个xxx其实是保存在session中的一个字段，我们就可以这样去取用。\n\n```python\ndef login(request):\n    if request.method == \'GET\':\n        return render(request, \'login.html\')\n    else:\n        username = request.POST.get(\'username\')\n        password = request.POST.get(\'password\')\n        if username == \'lamber\' and password == \'12345\':\n            # 走到这里代表认证成功\n            request.session[\'username\'] = username\n            request.session[\'password\'] = password\n            return redirect(\'/admin/main/\')\n        else:\n            return render(request, \'login.html\', {\n                \'msg\': \'账号或者密码错误\',\n            })\n```\n\n模板对应的部分：\n\n```html\n<div id=\"header\">\n    欢迎您：{{ request.session.username }}\n</div>\n```\n\n## 2、母版\n\n其实就是把通用的部分写一遍就够了，其他地方在调用的时候直接继承一下就行了。比如我们说的后台里面有顶部导航栏，侧边栏，底部栏，但是内容区域的内容可能是不同的页面经常变化的，我们并不用每一次都把侧边栏，导航栏，底部栏重写一遍。\n\n**注意：一个子板只能有一个母版**\n\n```django\n# 我们设置一个通用页面，然后把变化的部分以一个block来封闭起来。\n{% block xx %}\n\t……………………各种变化的内容\n{% endblock %}\n```\n\n需要调用的时候直接使用\n\n```django\n# 先继承，在渲染的时候会先把公共部分extends过来，然后直接放到一起进行渲染\n{% extends \'layout.html\' %}\n\n{% block xx %}\n# 自己写模块，然后这个叫xx的block会集成到你的模板指定的位置。这个block也可以多加几个\n{% endblock %}\n```\n\n一般来讲会写三个block\n\n```html\n# 在head部分\n写一个block叫css\n\n# 内容部分\n写一个content是用来替换变化的内容的。\n\n# JS部分\n写一个block叫js模块，用来独立的调用某个页面的JS\n```\n\n目的是为了针对不同的部分做不同的css和js的区分，因为并不是一个css适用于所有的页面。母版里面应该放的内容是所有页面都要用的东西。\n\n## 3、模板中的函数\n\n在模板里面写上一个函数名是自动执行的，但是这个函数不能加参数，要加参数需要其他的操作去执行的。\n\n```jinja2\n# 这个upper实质上是一个带装饰器的函数，这个是由模板提供的函数\n{{ name|upper }}\n```\n\n这个当然是可以由我们自己来定义的，其中一种就叫simple_filter，另外一种叫做simple_tag。\n\n**自定义simple_filter**\n\n1. 在app中创建一个叫templatetags的模块（Python Package），名字必须是这个。\n\n2. 随便创建一个py文件，名字叫xx.py，自定义函数就放在这里。\n\n3. 写自定义函数\n\n   ```python\n   from django import template\n   register = template.Library()  # 这个是Django固定好的格式，必须这么写\n\n   @register.filter      # 只有加上这个装饰器才能在模板中使用\n   def my_upper(value):\n       return value.upper()\n   ```\n\n4. 在模板中使用\n\n   ```html\n   # 在页面顶部导入咱们自定义的内容\n   {% load xx %}\n   ```\n\n   模板中调用\n\n   ```python\n   {{ name|my_upper }}\n   ```\n\n5. settings中需要注册这个app才能够使用，不然无法使用。\n\n**如何给模板函数传递参数？**\n\n如果要给函数给传递多个参数的话要在函数后面用冒号接参数：\n\n```python\n{{ name|my_upper:\"666\" }}\n最多只支持两个参数，函数前面一个，后面一个，而且冒号不能有空格。不然会报错。\n```\n\n如果装饰器是simple_tag的话使用方法还不一样：\n\n```python\n@register.simple_tag      \ndef my_upper(value):\n    return value.upper()\n\n# 调用，这个是没有参数限制的。\n{% my_upper \"ALEX\" \"x\" \"SB\" \"V\" %}\n```\n\nfilter可以作为if的条件，但是simple_tag是无法作为if的条件语句\n\n```python\n{% if name|my_bool %}\n   <h3>hahah</h3>\n{% else %}\n   <h3>hehehehehe</h3>\n{% endif %}\n```\n\n反向生成URL就是使用的simple_tag的方法，因为参数无限制。一般情况下，filter用不到，所以作为了解就可以了。\n\n**使用inclusion_tag完成更复杂的操作**\n\n\n\n## 4、模板之Include\n\n> 模板之include，include单独的小组件。\n\n```python\n{% include \'pub.html\' %}\n```\n\n小组件和母版功能类似，但是又不一致。母版是用来继承的，而include是用来导入小组件的。同时小组件也是支持书写模板语言的。\n\ninclude会找到小组件把小组件的内容读取过来然后替换掉。因此这些模板语言也是支持的。比如我写了一个小模块，我在很多页面都用到了，那么我就可以直接把这个小页面或者说小模块单独拿过来在页面中引用。\n\n## 5、模板的简单实现原理：\n\n1. 创建一个 Template 对象，将模板代码放入一个 string 中作为参数。\n2. 调用模板(template)对象的 render() 方法，把一组变量作为上下文(context)传入。这么做将会把模板(template)展开，将所有变量(variables)和标签(tags)都赋予相应的值，并作为 string 返回。\n\n```python\n# 终端切换到项目目录下，在终端运行如下命令：\npython3 manage.py shell\n# 这个不要在终端直接引入，要通过manage.py，不然配置文件等相关内容不会被加载直接报错。\n# 或者直接在.bash_profile中手动添加 DJANGO_SETTINGS_MODULE这个环境变量，设为mysite.settings，前提是这个mysite的路径在环境变量里。\n>>> from django import template\n# 通过实例化创建一个Template的对象，构造函数接收一个参数，初始化模板代码\n>>> t = template.Template(\'My name is {{name}}\')\n>>> c = template.Context({\'name\':\'lamber\'})\n>>> print(t.render(c))\nMy name is lamber\n```\n\n## 6、CBV&FBV\n\n### CBV\n\n在视图函数匹配的时候，一个url可以对应一个函数，但是同时也可以对应一个类。\n\n```python\n# Login是一个类，其中as_view()是特殊的写法\nurl(r\'^login.html$\', views.Login.as_view())\n\n# 这个类需要继承这个Views\n# 看的是类里是不是getattr GET POST利用反射获取对应的方法\nfrom django.views import View\nclass Login(View):\n    \n    def get(self, request):\n        pass\n    \n    def post(self, request):\n        pass\n    \n    def dispath(self, request, *args, **kwargs):\n        # 可以对dispatch进行重写，先把父类的功能拿过来，先执行dispatch方法，然后dispatch去执行GET或者post方法，然后拿到返回值return才行\n        # 我们可以在执行dispatch的时候对一些方法进行统一的调用，或者循环操作等等，类似一个装饰器。\n        print(\'before\')\n        obj = super(Login, self).dispatch(self, request, *args, **kwargs)\n        print(\'after\')\n        # 接收的这个obj就是返回值。\n        return obj\n    \nGET和POST方法执行之前还执行了一个dispatch方法，这个即使利用反射获取GET还是POST，可以在父类Views里查看\n```\n\nfbv其实就是之前写的最多的函数的形式，就不过多赘述了。","timestamp":1540354517190},{"name":"08-Cookie和Session.md","path":"04-Django/08-Cookie和Session.md","content":"# Cookie & Session\n\n> 相关参考文档：http://www.cnblogs.com/wupeiqi/articles/5246483.html\n\n## Cookie\n\n- cookie是保存在浏览器上的键值对。可以放多对，敏感信息不放在这里。\n- 服务端可以向用户浏览器端写cookie\n- 客户端每次发送请求的时候，会携带cookie去。Cookie是携带在请求头中的。在浏览器的请求头中，可以存在多个cookie，每一个cookie键值对用分号隔开；\n- Cookie一般情况下是用来做用户登录的。\n- 在发送HTTP请求的时候，在请求中携带当前所有可访问的cookie\n\n首先去请求的cookie中获取凭证：tk\n\n```python\n# 如果获取不到cookie，就让它跳转到登录。\ntk = request.COOKIES.get(\'ticket\')\nif not tk:\n    return render(\'/login/\')\n\n# 登录成功之后，判断密码正确以后，我要给你的浏览器回写cookie。平常redirect都是直接用\n# 现在我要用redirect给你返回一个对象，这个对象有一个set_cookie方法用来给浏览器回写cookie。\n# 这里用redirect，Httpresponse，render其实都是没有问题的，当我们想要给请求响应头塞点东西的时候\n# 就要用到这样的写法了，obj = HttpResponse(\'xx\')，然后obj.set_cookie给头部塞内容。\nobj = redirect(\'classes\')\n\n# max_age 超时时间是10s,expires是具体的超时日期，和max_age二者择其一就可以\n# 推荐使用max_age，By the way，时间的加减可以使用timedelta。\nfrom datetime import datatime, timedelta\nct = datetime.utcnow()\ninterval = timedelta(seconds=10)\nnew_time = ct + v\nobj.set_cookie(\'ticket\', \'xxxxxxx\', max_age = 10，expires=new_time, path=\'/\', domain=None, secure=False, httponly=\'False\')\n# path 可以指定cookie在某个指定url下使用，某些url下不使用。比如指定/classses/，那么其他的路径下就获取不到这个cookie了。默认是/也就是所有的url都能读取到。\n# domain表示指的是在访问某个域名的时候才能获取到这个cookie。默认就是当前域名，一般多用于SSO单点登录。\n# secure是给https提供的功能。如果是https网站要改为true\n# httponly表示只能自http请求中传入，js代码无法获取到。\nreturn obj\n\n接下来，在检查元素中的network 找到cookie就可以查看cookie的内容了\n```\n\nDjango扩展签名cookie，解决写入的cookie是明文的问题。\n\n```python\n# 给我们的cookie加盐，进行加密操作。本质其实还是调用的set_cookie方法，只不过在调用之前多用了一步个步骤，针对value做了一个加密的操作。\nobj.set_signed_cookie(\'ticket\', \'xxxx\', salt=\'jjjj\')\n\n# 读取的时候要按照如下的方式，下面获取到的内容是去掉签名的字符串\nrequest.get_signed_cookie(\'ticket\', salt=\'jjjj\')\n\n# 看一下这个代码，这个是调用signing下的get_cookie_signer获取到一个对象，然后调用对象的value方法去获取最新的value返回值\ndef set_signed_cookie(self, key, value, salt=\'\', **kwargs):\n    value = signing.get_cookie_signer(salt=key + salt).sign(value)\n    return self.set_cookie(key, value, **kwargs)\n\n# 这个由singing的get_cookie_signer生成的是django.core.signing.TimestampSigner的对象\n# 这里看到的其实就是用的这样一个时间戳的签名类去做的签名方法。在这里可以看到sign方法的详细内容\nclass TimestampSigner(Signer):\n\n    def timestamp(self):\n        return baseconv.base62.encode(int(time.time()))\n\n    def sign(self, value):\n        value = \'%s%s%s\' % (value, self.sep, self.timestamp())\n        return super().sign(value)\n\n    def unsign(self, value, max_age=None):\n        \"\"\"\n        Retrieve original value and check it wasn\'t signed more\n        than max_age seconds ago.\n        \"\"\"\n        result = super().unsign(value)\n        value, timestamp = result.rsplit(self.sep, 1)\n        timestamp = baseconv.base62.decode(timestamp)\n        if max_age is not None:\n            if isinstance(max_age, datetime.timedelta):\n                max_age = max_age.total_seconds()\n            # Check timestamp is not older than max_age\n            age = time.time() - timestamp\n            if age > max_age:\n                raise SignatureExpired(\n                    \'Signature age %s > %s seconds\' % (age, max_age))\n        return value\n\n# 现在了解上面的签名逻辑以后，知道django默认的走的不是md5的加密，那么这个我们就可以自己定制了。\n# 自定义加密方法，修改全局配置文件。这个新定义的类就是我们自己写的一个加解密的过程。这里的这个类就相当于上面的那个TimestampSigner。\nSIGNING_BACKEND = \'模块.定义类\'\n\n# 在原基础上进行重写。\nfrom diango.core.signing import TimestampSigner\nclass MySigner(TimestampSigner):\n    def sign(self, value):\n        # 对原方法进行重写\n        \n    def unsign(self, value, max_age=None):\n        # 对原方法进行重写\n```\n\n学习完cookie以后，我们可能会在很多的视图函数中用到这个cookie的验证，去验证用户是否登录，是否有对应的cookie，针对这个操作不可能说在每一个视图函数中都写这个cookie的验证逻辑，因此可以装饰器来实现cookie的判断。\n\n## Session\n\n### Session使用\n\n保存在服务器端的数据，本质也是键值对。用户信息保存在服务器端，以键值对形式，key为随机字符串，value为用户数据，仅给客户端发随机字符串。以后谁拿着随机字符串来，那么对应的值就可以取到。\n\n- 应用：依赖cookie，因为给客户端的字符串是保存在cookie中的\n- 作用：会话保持(Web网站)\n- 好处：敏感信息不会直接给客户。\n\n```shell\n# 登录设置session\n1.生成随机字符串\n2.通过cookie发送给客户端\n3.服务端保存[随机字符串：{当前用户字典信息}]\n\nrequest.session[\'username\'] = \'alex\'  # 这一句话就上面三件事全做了。\nrequest.session[\'email\'] = \'1020561033@qq.com\'\n\n# 下面的这种写法可以针对不同种类的键值对进行分类，对应的用户字典信息就生成了。\nrequest.session[\'userinfo\'] = {\n  \'user_id\': obj.id,\n  \'gender\': gender,\n  ……\n}\n\n# 那么程序里对应的内容放在哪里呢？\n# 在Django里默认没放在字典里，而是放在数据库表里，放到django_session这张表里了。\n# 对应的key就是生成的随机字符串，session_data就是键值对的value\n# Django内部针对这个value做了一个加密\n# 登录页判断(敏感信息不给用户，只给字符串，我再服务器想存什么就存什么)\n# 在前端的模板可以直接通过request去调用，比如{{ request.session.username }}\n1、获取客户端cookie中的随机字符串  #Django内部帮你去cookie中取值了。\n2、去session中查找有没有对应的随机字符串\n3、去session对应的key的value中看看有没有对应的username\n\ndef index(request):\n\tv = request.session.get(\'username\')\n\tif v:\n\t\treturn HttpResponse(\'登录成功：%s\' %v)\n\telse:\n\t\treturn redirect(\'/login/\')\n```\n### Session常用操作\n\n```python\n# 获取、设置、删除Session中数据\nrequest.session[\'k1\']\n# 避免取不到报错的问题\nrequest.session.get(\'k1\',None)\nrequest.session[\'k1\'] = 123\nrequest.session.setdefault(\'k1\',123) # 存在则不设置\n\n# 这个删除的k1是cookie的随机字符串对应的session_data中的k1，而不是删除随机字符串。\ndel request.session[\'k1\'] \n \n# 所有 键、值、键值对，处理的都是对应的随机字符串的，不会影响到其他人的，我们不需要关注，因为django内部为我们做了系统的封装\nrequest.session.keys()\nrequest.session.values()\nrequest.session.items()\nrequest.session.iterkeys()\nrequest.session.itervalues()\nrequest.session.iteritems()\n\n# 用户session的随机字符串\nrequest.session.session_key\n\n# 我们知道django将session放在一个表中，数据库里不知道啥时候删除\n# 根据Django的规定，默认的情况下cookie会在浏览器保存两周。但是到期以后浏览器的cookie没了\n# 但是服务端的session还有啊，所以就得手动删除，其实在记录session的时候还会记录一个超时时间\n# 将所有Session失效日期小于当前日期的数据删除\nrequest.session.clear_expired()\n\n# 主动设置超时时间\nrequest.session.set_expiry(value)\n    * 如果value是个整数，session会在些秒数后失效。\n    * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n    * 如果value是0,用户关闭浏览器session就会失效。\n    * 如果value是None,session会依赖全局session失效策略。\n\n# 检查 用户session的随机字符串 在数据库中是否\nrequest.session.exists(request.session.session_key)\n\n# 删除当前用户的所有Session数据\nrequest.session.delete(request.session.session_key)\n```\n\n### 缓存Session\n\n```python\na. 配置 settings.py\n# Django指定session存放的位置，默认是存放在数据库，这里其实是指定引擎\nSESSION_ENGINE = \'django.contrib.sessions.backends.db\'\n\n# 放到文件里，这时候要多个参数，指定放的路径。\n# 如果缓存文件路径为None，那么就使用tempfile模块获取一个临时地址\n# tempfile.gettempdir()\nSESSION_ENGINE = \'django.contrib.sessions.backends.file\'\nSESSION_FILE_PATH = None\n\n# 放到cache里，比如memcached，redis等。\n# 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置\nSESSION_ENGINE = \'django.contrib.sessions.backends.cache\'\nSESSION_CACHE_ALIAS = \'default\'\n\n# 放到一个加密的cookie里。这个不要用，这相当于给cookies加了个签名，相当于不用session了。\nSESSION_ENGINE = \'django.crotrib.sessions.backends.signed_cookies\'     \n\n# 使用缓存+数据库的方式，数据库用于做持久化，缓存用于提高效率\nSESSION_ENGINE = \'django.contrib.sessions.backends.cached_db\'        \n \n# Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\nSESSION_COOKIE_NAME ＝ \"sessionid\"\nSESSION_COOKIE_PATH ＝ \"/\"               # Session的cookie保存的路径\nSESSION_COOKIE_DOMAIN = None             # Session的cookie保存的域名\nSESSION_COOKIE_SECURE = False            # 是否Https传输cookie\nSESSION_COOKIE_HTTPONLY = True           # 是否Session的cookie只支持http传输\nSESSION_COOKIE_AGE = 1209600             # Session的cookie失效日期（2周），单位为秒\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期\n\n# 是否每次请求都保存Session，默认修改之后才保存，False从一开始，这个时间段后超时。\n# True每次请求都会计算，规定时间以内就不会超时。最好设置成True，让他每次都更新。\n# 想当于计时器在设置为true的时候会不断的刷新。\nSESSION_SAVE_EVERY_REQUEST = False                       \n```\n\n装饰器可以判断session存在不存在，其实和cookie一个套路。\n\n## Tip\n\n前端模板默认能拿到request这个模板变量，注意这个用法。\n\n比如：request.session.userinfo.nickname\n\n","timestamp":1540354517190},{"name":"09-Django安全.md","path":"04-Django/09-Django安全.md","content":"# Django安全\n\n## XSS跨站脚本攻击\n\n> Django在内部已经屏蔽了xss，如果说手贱给内容加了一个 \" content | safe\"就会进行解析，这样就不是字符串了。所以一般情况下不要加safe，如果一定要加safe要记得对特殊字符做过滤。\n>\n> 或者我们也可以在后台逻辑将用户传递过来的字符串进行判断是否有违规内容。\n>\n> 当然在django后台也可以标记，但是需要单独导入模块\n>\n> ```python\n> from django.utils.safestring import mark_safe\n> temp = \"<a>test</a>\"\n> # 把newtemp传递到前端模板的时候就会标记为安全的了。\n> # 因此标记为安全有前台和后台两种方式\n> newtemp = mark_safe(temp)\n> ```\n\n**要点**：\n\n- 慎用safe和mark_safe\n- 非要用，那务必过滤关键字。\n\n## CSRF（跨站请求的伪造）\n\n> django为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。\n>\n> 更多：https://docs.djangoproject.com/en/dev/ref/csrf/#ajax\n\n配置文件中应该打开，默认也是打开的：\n\n```python\nMIDDLEWARE = [\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n]\n```\n\n在这个选项打开的时候，如果没有传递token字符串的话怎么提交也是不生效的。\n\n全局：\n\n　　中间件 django.middleware.csrf.CsrfViewMiddleware\n\n局部（为函数添加如下的特殊装饰器就可以了）：\n\n```python\nfrom django.views.decorator import csrf_exempt或者csrf_protect\n```\n\n- @csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。\n- @csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。\n\n当然直接加装饰器我们这是针对FBV，如果说是针对CBV的时候我们还要做特殊处理：\n\n```python\nfrom django.views.decorator import csrf_protect\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\n\n# 装饰器是CBV中是不可以直接使用的，要调用Django提供的方法才行。\n@method_decorator(csrf_protect) # 给类下的所有绑定方法加装饰器\n# @method_decorator(csrf_protect, name=\'post\') # 给类下的post方法加装饰器，name是谁就是给谁装饰,可以写多个，写多行就行了，多个装饰器。\nclass Foo(View):\n    def get(self, request):\n        pass\n    \n    def post(self, request):\n        pass\n    \n    def dispatch(self,request,*args,**kwargs):\n        return xxx\n    \n# 当然也可以给dispathch方法加，如果是给dispatch加这个装饰器的话也相当于给所有的加了，因为dispatch是一个入口函数，有dispatch的时候是优先找到dispatch然后通过反射找的POST或者GET方法。\n@method_decorator(csrf_protect, name=\'dispatch\')\n\n# 或者直接加载dispatch方法上\nclass xxx(View):\n    \n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        ……\n\n# 针对CSRF的装饰器只能给CBV的类加，不能给CBV类下的方法加，这是csrf种一个比较变态的规定。我们自己自定义的装饰器应该是ok的\n```\n\n### 应用\n\n普通表单\n\n```python\nveiw中设置返回值：\n　　return render_to_response(\'Account/Login.html\',data,context_instance=RequestContext(request))　　\n     或者\n     return render(request, \'xxx.html\', data)\n  \n# html中设置Token:\n# 会在页面生成一个隐藏的input的标签\n# 同时也会在cookie中插入csrftoken\n　　{% csrf_token %}\n```\n\nAjax\n\n```python\n# 对于传统的form，可以通过表单的方式将token再次发送到服务端，而对于ajax的话，使用如下方式。\n\n#view.py\nfrom django.template.context import RequestContext\n# Create your views here.\n  \n  \ndef test(request):\n  \n    if request.method == \'POST\':\n        print request.POST\n        return HttpResponse(\'ok\')\n    return  render_to_response(\'app01/test.html\',context_instance=RequestContext(request))\n```\n\ntext.html\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    {% csrf_token %}\n  \n    <input type=\"button\" onclick=\"Do();\"  value=\"Do it\"/>\n  \n    <script src=\"/static/plugin/jquery/jquery-1.8.0.js\"></script>\n    <script src=\"/static/plugin/jquery/jquery.cookie.js\"></script>\n    <script type=\"text/javascript\">\n        // var csrftoekn = $(\'input[name=\"csrfmiddlewaretoken\"]\').val()\n        var csrftoken = $.cookie(\'csrftoken\');\n        // 不仅如此还可以用这个插件设置cookie\n        // $.cookie(\'key\',\'value\')\n        // 这样document.cookie就会发现多了一个。\n        // 一个是在请求头，一个是在data中带，注意cookie和csrfmiddlewaretoken中的值是不一样的\n        // 在请求体中设置csrfmiddletoken设置为{{ csrf_token }}这样取直接就行。\n  \n        function csrfSafeMethod(method) {\n            // these HTTP methods do not require CSRF protection\n            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n        }\n        $.ajaxSetup({\n            beforeSend: function(xhr, settings) {\n                if (!csrfSafeMethod(settings.type) && !this.crossDomain) {\n                    xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n                }\n            }\n        });\n        function Do(){\n  \n            $.ajax({\n                url:\"/app01/test/\",\n                data:{id:1},\n                type:\'POST\',\n                success:function(data){\n                    console.log(data);\n                }\n            });\n  \n        }\n    </script>\n</body>\n</html>\n```\n\n","timestamp":1540354517190},{"name":"01-RBAC.md","path":"04-Django/10-RBAC/01-RBAC.md","content":"# RBAC\n\n> Role-Basiced Access Control基于角色的访问控制，RBAC认为权限的过程可以抽象概括为：判断【Who是否可以对What进行How的访问操作（Operator）】这个逻辑表达式的值是否为True的求解过程。即将权限问题转换为Who、What、How的问题。who、what、how构成了访问权限三元组。这样极大的简化了权限的管理，这样管理都是层级相互依赖的，权限赋予角色，然后又把角色赋予用户，这样的权限设计清晰管理起来也方便。\n>\n> **参考资料**\n>\n> - https://www.cnblogs.com/lamp01/p/6576432.html\n\n## RBAC介绍\n\nRBAC有什么优势？它简化了用户和权限的关系，并且易于扩展和维护。比如用户直接关联权限明细的话，不同的用户可能存在大量重复的权限，这样当权限和用户比较多的时候要维护的内容量是巨大的，现在将角色与具体的权限进行关联，而用户和角色进行挂钩。\n\n![图源：https://www.cnblogs.com/lamp01/p/6576432.html](http://omk1n04i8.bkt.clouddn.com/18-6-12/82751409.jpg)\n\n赋予角色不同的权限，针对不同的权限还应该有不同的操作（actions），比如针对用户列表，有的就只有查看用户的功能，有的权限能添加，有的权限甚至可以删除和修改，这就是针对不同权限（permission）的不同操作（actions）。我们可以更细致的去把控。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-6-12/44715052.jpg)\n\n根据如上说明的功能，可以抽象出如下功能模块：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-6-12/31584515.jpg)\n\n对应权限控制的逻辑流程如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-6-12/33797457.jpg)\n\n## RBAC数据库设计\n\n基于角色的访问控制，根据角色来决定用户的访问权限有哪些。首先看数据表设计，把这个内容作为一个单独的app来进行调用，为以后的通用做准备。具体内容如下：\n\n- 用户表，标识用户，内含有用户的基本信息等。\n- 角色表，标识角色，用户要与角色进行关联，角色和用户是一个多对多的关系。一个用户可以拥有多个角色，比如xx同时担任了总监和经理的工作。角色也会同时被多个用户所有。\n- 用户与角色关联表：将用户与角色进行关联。两个字段都是外键的关系\n- 菜单表：这里加了一个菜单表，这个菜单表表示的是功能菜单，如果我们要设计这样的一个权限系统的话，最终的权限是要挂靠到菜单上去的。比如一个系统里面，可能会有A、B、C三个菜单，A菜单下可能会有用户管理，订单管理等等，这是权限，具体到用户管理下面又有添加用户，删除用户，修改用户等等。这是权限对应的actions操作。菜单与菜单之间也存在层级关系，比如一级菜单，一级菜单下面还有二级菜单，二级菜单还有三级甚至更多。但是菜单都是一个menu表，每一个菜单明细都是一个menu对象。因此有一个自关联的关系，在进行自关联的时候要写`\'self\'`你不能说直接写menu这个类，因为这现在是在定义的过程当中，这个类还没被定义完呢，你不能直接用，所以要用引号引起来的一个self，这个是django为我们提供的一个功能点。\n- 权限表：有具体的权限内容，挂靠到菜单表上。\n- 动作表：每一个权限对应着一个url action表示执行的方法，比如get，post，edit，del等等。\n\n- 最后我们说权限是基于角色来的，因此角色对应什么权限，对应什么操作。因此最后需要一个角色x权限x动作的这么一个关系表。\n\n具体表内容设计如下：\n\n```python\nfrom django.db import models\n\n# Create your models here.\nfrom django.db import models\n\nclass User(models.Model):\n    \"\"\"\n    用户表\n    \"\"\"\n    username = models.CharField(verbose_name=\'用户名\', max_length=32)\n    password = models.CharField(verbose_name=\'密码\', max_length=64)\n    email = models.EmailField(verbose_name=\'邮箱\')\n\n    def __str__(self):\n        return self.username\n\n\nclass Role(models.Model):\n    \"\"\"\n    角色表\n    \"\"\"\n    caption = models.CharField(verbose_name=\'角色\', max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass User2Role(models.Model):\n    \"\"\"\n    用户角色关系表\n    \"\"\"\n    user = models.ForeignKey(User, verbose_name=\'用户\', related_name=\'roles\', on_delete=models.CASCADE)\n    role = models.ForeignKey(Role, verbose_name=\'角色\', related_name=\'users\', on_delete=models.CASCADE)\n\n    def __str__(self):\n        return \'%s-%s\' % (self.user.username, self.role.caption,)\n\n\nclass Menu(models.Model):\n    \"\"\"\n    菜单表\n    \"\"\"\n    caption = models.CharField(verbose_name=\'菜单名称\', max_length=32)\n    parent = models.ForeignKey(\'self\', verbose_name=\'父菜单\', related_name=\'p\', null=True, blank=True, on_delete=models.CASCADE)\n\n    def __str__(self):\n        prev = \"\"\n        parent = self.parent\n        while True:\n            # 如果有父级菜单\n            if parent:\n                prev = prev + \'-\' + str(parent.caption)\n                parent = parent.parent\n            else:\n                break\n        return \'%s-%s\' % (prev, self.caption,)\n\n\nclass Permission(models.Model):\n    \"\"\"\n    权限\n    \"\"\"\n    caption = models.CharField(verbose_name=\'权限\', max_length=32)\n    url = models.CharField(verbose_name=\'URL正则\', max_length=128)\n    menu = models.ForeignKey(Menu, verbose_name=\'所属菜单\', related_name=\'permissions\',null=True,blank=True,  on_delete=models.CASCADE)\n\n    def __str__(self):\n        return \"%s-%s\" % (self.caption, self.url,)\n\n\nclass Action(models.Model):\n    \"\"\"\n    操作：增删改查\n    \"\"\"\n    caption = models.CharField(verbose_name=\'操作标题\', max_length=32)\n    code = models.CharField(verbose_name=\'方法\', max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass Permission2Action2Role(models.Model):\n    \"\"\"\n    权限操作关系表\n    \"\"\"\n    permission = models.ForeignKey(Permission, verbose_name=\'权限URL\', related_name=\'actions\',  on_delete=models.CASCADE)\n    action = models.ForeignKey(Action, verbose_name=\'操作\', related_name=\'permissions\',  on_delete=models.CASCADE)\n    role = models.ForeignKey(Role, verbose_name=\'角色\', related_name=\'p2as\',  on_delete=models.CASCADE)\n\n    class Meta:\n        unique_together = (\n            (\'permission\', \'action\', \'role\'),\n        )\n\n    def __str__(self):\n        return \"%s-%s-%s\" % (self.permission, self.action, self.role,)\n```\n\n生成对应的关系表，生成表内容以后不要忘了注册app：\n\n```python\npython manage.py makemigrations\npython manage.py migrate\n```\n\n在这个app02下开始写视图函数，首先测试一下内容：\n\n```python\nfrom app02 import models\ndef test(request):\n    # 首先拿到一个用户对象\n    obj = models.User.objects.filter(username=\'alex\').first()\n    # 然后我要拿用户的角色的时候可以这么去拿\n    # models.User2Role.objects.filter(user_id=obj.id)\n    # 不过这样拿到的其实是一个user2role的一个对象，而不是拿到的角色对象，处理起来其实很不方便\n    # 那么我们现在要拿一个role的对象，relate_name=users然后跨表到user表中获取。\n    # 那么现在的这个role_list就是拿到的这个用户的角色对象的列表，这是拿到的一个query_set。\n    role_list = models.Role.objects.filter(users__user_id=obj.id)\n    \n    # 有了用户角色以后现在其实就可以通过角色去拿用户权限了，但是有一个问题哈，比如管理员有添加用户的权限，超级管理员也有添加用户的权限，那么就存在说拿到的权限可能存在重复的现象。因此我们需要对取回来的数据去重，去重我们可以使用distinct，或者使用annotate去重，不同的地方就是annotate会给你多加一列，distinct的执行效率稍微低了点。\n    permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(\'permission__url\', \'action__code\').distinct()\n    # 那么这样拿到的数据也是一个query-set，只不过是列表套字典，因为我们是用values取的，我们拿到的数据是权限表里的url和action操作表里的code。格式基本类似如下：\n    \"\"\"\n    [\n        {\'permission__url\':\'/index.html\', \'action__code\':\"GET\"},\n        {\'permission__url\':\'/edit.html\', \'action__code\':\"POST\"},\n        {\'permission__url\':\'/index.html\', \'action__code\':\"GET\"},\n        ……\n    ]\n    \"\"\"\n    # 现在拿到的数据中，同一个permission_url可能会存在多个的，比如A权限，对应action为get的这是一条，A权限对应action为delete又有一条，action有多个就会存在多个同样的permission_url的记录。现在将对这个记录进一步的进行优化，达到一个最后一个目标类似如下的结构，把结果放到一个字典里去，key是我们的permission_url，value是一个以action为内容的列表：\n    \"\"\"\n    {\n        \'index.html\': [GET, POST, EDIT, DELETE],\n        \'order.html\': [GET, POST]\n    }\n    \"\"\"\n    # 首先初始化一个空字典\n    user_permission = {}\n    # 遍历我们拿到的权限列表(query_set)\n\tfor item in permission_list:\n    \tif not user_permission.__contains__(item[\'permission__url\']):\n        \tuser_permission[item[\'permission__url\']] = item[\'action__code\'].split()\n            continue\n    \tuser_permission[item[\'permission__url\']].append(item[\'action__code\'])\n    # 做到这一步，我们就把用户独有的权限，以及action都拿到了，那么接下来如何处理呢。接下来其实就可以把这个取到的内容放到用户的session中去，以后访问其他的页面的时候都会以这个为参考，取不到对应的页面权限和actions就不让他们访问就可以了。\n    # 不过如果说临时添加了新功能，那么这个功能是没有机制去更新到session中去，也就是说不会立即生效，需要用户重新登录才行。\n    # 上面就是对用户的内容做了一个简单的获取和规整。\n    return HttpResponse(\'...\')\n```\n\n现在模拟一个很low的登录过程：\n\n```python\ndef login(request):\n    if request.method == \'GET\':\n        return render(request, \'app02/login2.html\')\n    else:\n        obj = models.User.objects.filter(username=\'lamber\').first()\n        if not obj:\n            return HttpResponse(\'用户不存在！\')\n        role_list = models.Role.objects.filter(users__user_id=obj.id)\n        permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(\'permission__url\', \'action__code\').distinct()\n        user_permission = {}\n        for item in permission_list:\n            if not user_permission.__contains__(item[\'permission__url\']):\n                user_permission[item[\'permission__url\']] = item[\'action__code\'].split()\n                continue\n            user_permission[item[\'permission__url\']].append(item[\'action__code\'])\n        # 把用户的权限列表扔到session中。\n        request.session[\'user_permission_dict\'] = user_permission\n        return HttpResponse(\'Login Successfully\')\n```\n\n这样session中就已经存储了用户的权限信息了。然后现在在浏览器输入不同的页面地址去模拟访问权限控制的结果。这个操作应该每一次的访问都应该要取执行，而且涉及的页面众多，因此不能把这个判定逻辑写到每一个视图函数中，最好是放到中间件中去进行预先的处理。因此这里将所有的权限的逻辑判断内容扔到一个中间件中去。\n\n在项目目录下新建一个middleware的目录，然后新建一个中间件的py文件名称拟定为md.py，将这个中间件在全局配置文件中进行注册一下，加上这么一条：\n\n```python\n\'middleware.md.M1\',\n```\n\n中间件内容如下：\n\n```python\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.shortcuts import HttpResponse\nimport re\n\n# 固定的要继承一个中间件的基类。\nclass M1(MiddlewareMixin):\n\n    def process_request(self, request, *args, **kwargs):\n\n        # 不能针对所有的请求，比如登录，因此要过滤掉一部分的页面，否则你登录都没法登陆就别提拿到用户权限了，相当于你永远都没法访问这个网站了，因此要放行一些地址。\n        # 定义个需要过滤的列表，放行一部分不需要做权限把控的页面。\n        valid = [\n            \'/rbac/auth-login.html\',\n            \'/rbac/index.html\',\n            \'admin\',\n        ]\n        # 这个request.path_info只包含访问的路径不包含后面接的参数什么的。\n        if request.path_info not in valid:\n            # 把action拿到手\n            action = request.GET.get(\'md\')\n            # 我首先看你这个权限列表有没有，如果没有，不好意思，直接不能访问。\n            user_permission_dict = request.session.get(\'user_permission_dict\')\n            if not user_permission_dict:\n                return HttpResponse(\'无权限\')\n            # 然后看看在权限列表里你有没有权限URL，如果没有，抱歉，你没有权限访问\n\t\t\t# 遇到带正则表达式的请求url该怎么办？因此这个url应该是一个正则，代表一类或者一系列的URL\n            # 这个时候就不是一个固定的地址了，而是一个带正则的地址。这个时候就需要做正则匹配了。\n            # 首先设置一个标记位为false，如果认证通过就改成true\n            flag = False\n            for k, v in user_permission_dict.items():\n                # request_path没问题\n                if re.match(k, request.path_info):\n                    # 并且请求的action在列表中存在，那么认证通过，否则认证失败\n                    if action in v:\n                        flag = True\n                        break\n            if not flag:\n                return HttpResponse(\'无权限\')\n```\n\n## 菜单的获取\n\n下面的代码其实是一个权限菜单挂靠和菜单挂靠菜单的过程。\n\n```python\ndef menu(request):\n    \n    # 所有菜单：处理成当前用户关联的菜单，这些菜单就都是类似下面这种格式的：\n    \"\"\"\n    [\n          {\'id\': 1, \'caption\': \'1.0\', \'parent_id\': None}, \n          {\'id\': 2, \'caption\': \'2.0\', \'parent_id\': None}, \n          {\'id\': 3, \'caption\': \'3.0\', \'parent_id\': None}, \n          {\'id\': 4, \'caption\': \'1.1\', \'parent_id\': 1}, \n          {\'id\': 5, \'caption\': \'2.1\', \'parent_id\': 2}, \n          {\'id\': 6, \'caption\': \'3.1\', \'parent_id\': 3},\n          ……\n    ]\n    \"\"\"\n    # 先把所有的菜单拿出来\n    all_menu_list = models.Menu.objects.all().values(\'id\', \'caption\', \'parent_id\')\n    \n    # 首先获取一个用户对象，比如获取username为mxy的用户对象，并且把这个用户的所有权限都拿到。\n    # 这里的权限只取了四个字段，分别是权限的id，url，菜单id，权限的名称。\n    user = models.User.objects.filter(username=\'mxy\').first()\n    role_list = models.Role.objects.filter(users__user=user)\n    # 拿到当前指定用户的所有的权限\n    permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(\'permission__id\',\'permission__url\', \'permission__menu_id\',\'permission__caption\').distinct()\n\n    # 最后你有什么权限，是要在菜单上体现的。所以需要将权限挂靠到菜单上\n    # 首先初始化一个all_meuu_dict的字典\n    # 遍历所有的菜单。给每一个菜单添加一个必要的字段\n    # 其中child表示当前菜单的子节点，status表示是否显示这个菜单，opened表示这个菜单是否默认为打开状态\n    # 我整个字典拼完了以后大概是下面这么个样子\n    \"\"\"\n    {\n        1:{\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[]},\n        2:{\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:False,opened:False,child:[]},\n        3:{\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:False,opened:False,child:[]},\n        5:{\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},\n    }\n    \"\"\"\n    all_menu_dict = {}\n    for row in all_menu_list:\n        row[\'child\'] = []  # 添加孩子节点。\n        row[\'status\'] = False  # 是否显示菜单\n        row[\'opened\'] = False  # 是否默认打开\n        # 重新构造这个menu的这个字典，这样拼接完了以后就是上面那个形式了。\n        # 这里有一个值得注意的点就是，这个新的字典内容是根据之前的all_menu_list构建而来的，对于这个薪资点来说，保存的是列表内容中的引用，因此下向字典的中value中的row[\'child\']插入数据的时候，之前的all_menu_dict也是跟着发生变化的。注意这一点。\n        all_menu_dict[row[\'id\']] = row\n        \n    for per in permission_list:\n        if not per[\'permission__menu_id\']:\n            continue\n\n        # 规范显示名称，对应的字段使用字典做映射，为什么要做映射？因为我们取出来的权限列表里，都是permission__id，permission__url这种的，最后它是要挂载到菜单上的，有些子菜单也是要被挂载到一些菜单上的，因此在这里把权限和菜单的属性名做一下统一，这个权限的permission__menu_id其实就相当于菜单的parent_id，因此做下面的操作。\n        item = {\n            \'id\': per[\'permission__id\'],\n            \'caption\': per[\'permission__caption\'],\n            \'parent_id\': per[\'permission__menu_id\'],\n            # 针对具体的权限一定要有一个可以操作跳转的url地址。\n            \'url\': per[\'permission__url\'],\n            # 是否显示菜单，如果菜单下有权限跳转的话，那么这个菜单应该显示出来，同理它的上级菜单应该是可以显示的，递归这个的上级的上级菜单也是可以显示的，以此类推。\n            # 是否默认打开：只有当前URL和用户请求的URL匹配上了才会变成True，所以默认False\n            # 这个菜单是否默认应该被打开呢？当然不是，需要根据URL的正则去判断是否为True。\n            \'status\': True,\n            \'opened\': False\n        }\n        # 如果我当前点的就是这个权限url，那么就应该被展开。\n        if re.match(per[\'permission__url\'],request.path_info):\n            item[\'opened\'] = True\n        pid = item[\'parent_id\']\n        # 开始挂靠工作，把权限挂到菜单上，等所有的权限循环完毕了，操作完了所有的菜单都挂靠完毕了，当然有些权限是可以挂到菜单，有些是不需要挂载的，比如上传图片，不需要体现到菜单上，之后做拓展，比如menu-id为none的时候就允许不挂到菜单上。\n        all_menu_dict[pid][\'child\'].append(item)\n\n\n        # 如果说这个菜单下有权限，那么这个菜单的父级status就等于true，应该被显示出来，这个父级菜单的父级菜单也应该被显示出来，同样应该将status设置为true。\n        temp = pid  # 1.父亲ID\n        # 递归的出口：当父级id=None的时候那么就证明找到头了。\n        # 同时为了避免已经改过的再次去执行，判断一下，如果不是true再改。少循环点\n        while not all_menu_dict[temp][\'status\']:\n            all_menu_dict[temp][\'status\'] = True\n            temp = all_menu_dict[temp][\'parent_id\']\n            if not temp:\n                break\n\n        # 将当前权限前辈opened=True\n        if item[\'opened\']:\n            temp1 = pid  # 1.父亲ID\n            while not all_menu_dict[temp1][\'opened\']:\n                all_menu_dict[temp1][\'opened\'] = True\n                temp1 = all_menu_dict[temp1][\'parent_id\']\n                if not temp1:\n                    break\n\n    # ############ 处理菜单和菜单之间的等级关系，菜单挂靠子菜单。 ############\n    \"\"\"\n    all_menu_dict = {\n        1:{\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[{\'permission__url\':\'/order.html\',\'permission__caption\': \'订单管理\',\'permission__menu_id\': 1 },]},\n        2:{\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:False,opened:False,child:[]},\n        3:{\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:False,opened:False,child:[]},\n        5:{\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},\n    }\n\n\n    all_menu_list= [\n        {\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[{\'permission__url\':\'/order.html\',\'permission__caption\': \'订单管理\',\'permission__menu_id\': 1 }, {\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},]},\n        {\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:False,opened:False,child:[]},\n        {\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:False,opened:False,child:[]},\n\n    ]\n    \"\"\"\n\n    result = []\n    for row in all_menu_list:\n        pid = row[\'parent_id\']\n        if pid:\n            all_menu_dict[pid][\'child\'].append(row)\n        else:\n            # 上面的子菜单挂靠完成以后，然后把所有的跟菜单扔到result这个列表里，这就是我们想要的结果了。\n            result.append(row)\n\n    ##################### 结构化处理结果 #####################\n    for row in result:\n        print(row[\'caption\'], row[\'status\'], row[\'opened\'], row)\n\n    ##################### 通过结构化处理结果，生成菜单开始 #####################\n    \"\"\"\n    result = [\n        {\'id\':1, \'caption\':\'菜单1\', parent_id:None,status:False,opened:False,child:[5:{\'id\':4, \'caption\':\'菜单1-1\', parent_id:1,status:False,opened:False,child:[]},2:{\'id\':2, \'caption\':\'菜单2\', parent_id:1,status:False,opened:False,child:[]},]}\n        {\'id\':2, \'caption\':\'菜单2\', parent_id:None,status:True,opened:False,child:[]},\n        {\'id\':3, \'caption\':\'菜单3\', parent_id:None,status:true,opened:False,child:[url...]},\n    ]\n    \"\"\"\n\n    # status=False ,不生产成\n    # opened=True  ,true不加hide，false，加hide，也就是隐藏的意思。\n    \n    \"\"\"\n\t# 希望生成一个这样的html结果。\n    <div class=\'menu-item\'>\n        <div class=\'menu-header\'>菜单1</div>\n        <div class=\'menu-body %s\'>\n            <a>权限1</a>\n            <a>权限2</a>\n             <div class=\'menu-item\'>\n                <div class=\'menu-header\'>菜单11</div>\n                <div class=\'menu-body hide\'>\n                    <a>权限11</a>\n                    <a>权限12</a>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div class=\'menu-item\'>\n        <div class=\'menu-header\'>菜单2</div>\n        <div class=\'menu-body hide\'>\n            <a>权限1</a>\n            <a>权限2</a>\n        </div>\n    </div>\n    <div class=\'menu-item\'>\n        <div class=\'menu-header\'>菜单3</div>\n        <div class=\'menu-body hide\'>\n            <a>权限1</a>\n            <a>权限2</a>\n        </div>\n    </div>\n\n\n    \"\"\"\n\n    def menu_tree(menu_list):\n        tpl1 = \"\"\"\n            <div class=\'menu-item\'>\n                <div class=\'menu-header\'>{0}</div>\n                <div class=\'menu-body {2}\'>{1}</div>\n            </div>\n            \"\"\"\n        tpl2 = \"\"\"\n            <a href=\'{0}\' class=\'{1}\'>{2}</a>\n            \"\"\"\n\n        menu_str = \"\"\n        for menu in menu_list:\n            # 如果不该显示，直接pass就可以了。\n            if not menu[\'status\']:\n                continue\n            # menu: 可能是菜单，可能是权限（url）\n            if menu.get(\'url\'):\n                # 权限\n                menu_str += tpl2.format(menu[\'url\'], \'active\' if menu[\'opened\'] else \"\", menu[\'caption\'])\n            else:\n                # 菜单\n                if menu[\'child\']:\n                    child_html = menu_tree(menu[\'child\'])\n                else:\n                    child_html = \"\"\n                menu_str += tpl1.format(menu[\'caption\'], child_html, \"\" if menu[\'opened\'] else \'hide\')\n\n        return menu_str\n\n    menu_html = menu_tree(result)\n\n    return render(request, \'menu.html\', {\'menu_html\': menu_html})\n```\n\n## 作为组件来使用\n\n组件：作为一个公共的app\n\n- 权限的限制\n- 生成菜单\n- 仍然是涉及到七张表\n\n单独起一个app，这个插件并不做展示。结合session和中间件做操作。\n\n运行步骤：\n\n- 引入中间件，利用权限控制\n- 创建菜单功能，调用service控件。 \n\n```python\n# 其他app引用这个rbac的model内容\nfrom django.db import models\nfrom rbac.models import User as RabcUser\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    user = models.OneToOneField(RbacUser)\n```\n\n三种情况会调用\n\n- 登录成功，写session，sevice.permission_session(userid，request)\n- 做检测，在配置文件中注册中间件。\n- 生成菜单，调用service里面的menu，css，js方法。如果要实现动态菜单的话就把这个菜单的信息放到session里面去。只要从session中获取到就可以了。可以通过simple_tag来实现。\n\n### 用户权限采集\n\n首先用户模型的定义是不变的，仍然和上述一样，首先把用户的权限采集标准化，在rbac的app中新建一个service文件，用来存放这一部分的逻辑。\n\n首先在系统settings文件中添加一下内容，后面的操作会逐一用到并做说明：\n\n```python\nRBAC_NO_AUTH_URL = [\n    \'/index.html\',\n    \'/login.html\',\n    \'/register.html\',\n    \'/admin.*\',\n    \'/rbac.*\',\n]\nRBAC_PERMISSION_SESSION_KEY = \"rbac_permission_session_key\"\n\n# 把菜单放在session中，这一个取的是权限的session的key\nRBAC_MENU_PERMISSION_SESSION_KEY = \"rbac_menu_permission_session_key\"\n# 菜单key\nRBAC_MENU_KEY = \"rbac_menu_key\"\n# 权限信息\nRBAC_MENU_PERMISSION_KEY = \"rbac_menu_permission_key\"\n\n\"\"\"\nsession[RBAC_MENU_PERMISSION_SESSION_KEY] = {\n    RBAC_MENU_KEY:菜单信息,\n    RBAC_MENU_PERMISSION_KEY:权限信息\n}\n\"\"\"\n# RBAC的默认主题\nRBAC_THEME = \"default\"\nRBAC_QUERY_KEY = \"md\"\nRBAC_DEFAULT_QUERY_VALUE = \"look\"\n# 无权访问的时候提示的消息\nRBAC_PERMISSION_MSG = \"无权限访问\"\n```\n\n初始化用户权限逻辑\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport re\n# 一部分配置项我们保存在了django的settings文件中，通过引入文件可以拿到我们定义的全局env\nfrom django.conf import settings\n\nfrom . import models\n\n\ndef initial_permission(request, user_id):\n    \"\"\"\n    初始化权限，获取当前用户权限并添加到session中\n    将当前用户权限信息转换为以下格式，并将其添加到Session中\n        {\n            \'/index.html\': [\'GET\',\'POST\',\'DEL\',\'EDIT],\n            \'/detail-(\\d+).html\': [\'GET\',\'POST\',\'DEL\',\'EDIT],\n        }\n    \n    :param request: 请求对象\n    :param user_id: 当前用户id\n    :return: \n    \"\"\"\n\n    \"\"\"初始化权限信息\"\"\"\n    roles = models.Role.objects.filter(users__user_id=user_id)\n    p2a = models.Permission2Action2Role.objects.filter(role__in=roles).values(\'permission__url\',                                                                        \"action__code\").distinct()\n    user_permission_dict = {}\n    for item in p2a:\n        if item[\'permission__url\'] in user_permission_dict:\n            user_permission_dict[item[\'permission__url\']].append(item[\'action__code\'])\n        else:\n            user_permission_dict[item[\'permission__url\']] = [item[\'action__code\'], ]\n\t# 将拼接好的权限数据结构扔到session中，key我们在配置文件中进行了定义，可以灵活的定制。\n    request.session[settings.RBAC_PERMISSION_SESSION_KEY] = user_permission_dict\n\n    \"\"\"初始化菜单信息，将菜单信息和权限信息添加到session中\"\"\"\n    # queryset类型没法直接写到session中，需要变成列表，因为在放到session的时候如果你给我的是一个对象\n    # 它会优先把这个对象序列化然后再放到session里，但是默认的queryset不能做序列化。所以要先list一下。\n    menu_list = list(models.Menu.objects.values(\'id\', \'caption\', \'parent_id\'))\n\n    menu_permission_list = list(models.Permission2Action2Role.objects.filter(role__in=roles,                                                                   permission__menu__isnull=False).values(\n        \'permission_id\',\n        \'permission__url\',\n        \'permission__caption\',\n        \'permission__menu_id\').distinct())\n    request.session[settings.RBAC_MENU_PERMISSION_SESSION_KEY] = {\n        settings.RBAC_MENU_KEY: menu_list,\n        settings.RBAC_MENU_PERMISSION_KEY: menu_permission_list\n    }\n\n\ndef fetch_permission_code(request, url):\n    \"\"\"\n    根据URL获取该URL拥有的权限，如：[\"GET\",\"POST\"]\n    :param request: \n    :param url: \n    :return: \n    \"\"\"\n    user_permission_dict = request.session.get(settings.RBAC_PERMISSION_SESSION_KEY)\n    if not user_permission_dict:\n        return []\n    for pattern, code_list in user_permission_dict.items():\n        if re.match(pattern, url):\n            return code_list\n    return []\n\n```\n\n### 新建一个工单应用\n\n> 现在要新建一个工单的应用。然后把rbac结合进去\n\n#### models模型类\n\n```python\nfrom django.db import models\n# 引入RBAC模块中的RBAC的用户相关内容\nfrom rbac.models import User as RbacUser\n# import datetime\n\n\n# Create your models here.\nclass UserInfo(models.Model):\n\n    nickname = models.CharField(max_length=16)\n    # 使用的话直接和RBAC里的user做一个OneToOne就行了。\n    # 其他的用户名啊，密码啊，在这里其实就根本不用体现了。\n    user = models.OneToOneField(RbacUser, on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.nickname\n\n\nclass Order(models.Model):\n    # nid = models.IntegerField(primary_key=True, )\n    # uuid也是生成一个随机字符串扔进来\n    # uid = models.UUIDField()\n    \"\"\"报障单\"\"\"\n    title = models.CharField(max_length=32, verbose_name=\'报障标题\')\n    detail = models.TextField(verbose_name=\'报事详细\')\n    # 有多个字段外键连接到同一个表的时候记得加relate name否则反向查询的时候根本不知道找的谁。\n    create_user = models.ForeignKey(UserInfo, on_delete=models.CASCADE, related_name=\'aaa\')\n    # Tip：记住这里如果要加一个默认值的话需要加一个方法，而是方法执行后的结果，否则数据就一直不变了，因此去掉括号，不去调用。\n    # ctime = models.DateTimeField(auto_now_add=True, default=datetime.datetime.now)\n    ctime = models.DateTimeField(auto_now_add=True)\n    # 时间也可以是float类型，放一个时间戳\n    # ctime = models.FloatField()\n    status_choice = (\n        (1, \'未处理\'),\n        (2, \'处理中\'),\n        (3, \'已处理\'),\n    )\n    status = models.IntegerField(choices=status_choice, default=1)\n    processor = models.ForeignKey(UserInfo, on_delete=models.CASCADE, related_name=\'bbb\', null=True, blank=True)\n    solution = models.TextField(null=True, blank=True)\n    ptime = models.DateTimeField(null=True, blank=True)\n\n    def __str__(self):\n        return \'%s-%s\' % (self.title, self.create_user)\n```\n\n#### 中间件层\n\n在到视图函数之前还要过一层中间件，记得中间件要在全局配置文件里注册一下：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport re\n# 配置文件这回我扔到全局配置文件里去了。\nfrom django.conf import settings\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.shortcuts import HttpResponse\n\n\nclass RbacMiddleware(MiddlewareMixin):\n    def process_request(self, request, *args, **kwargs):\n        \"\"\"\n        检查用户是否具有权限访问当前URL\n        :param request: \n        :param args: \n        :param kwargs: \n        :return: \n        \"\"\"\n\n        \"\"\"跳过无需权限访问的URL，比如登录界面，这个从全局配置文件直接取。\"\"\"\n        for pattern in settings.RBAC_NO_AUTH_URL:\n            if re.match(pattern, request.path_info):\n                return None\n\n        \"\"\"获取当前用户session中的权限信息\"\"\"\n        permission_dict = request.session.get(settings.RBAC_PERMISSION_SESSION_KEY)\n        if not permission_dict:\n            return HttpResponse(settings.RBAC_PERMISSION_MSG)\n\n        \"\"\"当前URL和session中的权限进行匹配\"\"\"\n\n        flag = False\n        for pattern, code_list in permission_dict.items():\n            # 把所有的code_list给转换成大写\n            upper_code_list = [item.upper() for item in code_list]\n            if re.match(pattern, request.path_info):\n                # 我去拿这个请求后面带的参数，如果没带参数的话那么就给一个默认的并且给大写了。\n                request_permission_code = request.GET.get(settings.RBAC_QUERY_KEY, settings.RBAC_DEFAULT_QUERY_VALUE).upper()\n                if request_permission_code in upper_code_list:\n                    # 用户当前访问的权限，为了方便以后在视图函数中调用。比如=GET\n                    request.permission_code = request_permission_code\n                    # 当前用户的所有权限，为了方便以后在视图函数中调用。\n                    request.permission_code_list = upper_code_list\n                    flag = True\n                    break\n\n        if not flag:\n            return HttpResponse(settings.RBAC_PERMISSION_MSG)\n\n```\n\n#### 视图函数\n\n```python\n\n```\n\n","timestamp":1540354517190},{"name":"100-开工第一天.md","path":"04-Django/100-开工第一天.md","content":"# 开工第一天\n\n```python\nfrom django.db import models\n\n\n# Create your models here.\nclass Boy(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n\n\nclass Girl(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n\n\nclass B2G(models.Model):\n    \"\"\"\n    默认情况下这个to是省略的，默认就是对应的表\n    默认情况下这个to_field也是省略的，默认就是id字段。\n    \"\"\"\n    b = models.ForeignKey(to=\'Boy\', to_field=\'id\', on_delete=models.CASCADE)\n    g = models.ForeignKey(to=\'Girl\', to_field=\'id\', on_delete=models.CASCADE)\n    \n当然这个是可以进行进一步优化的，男孩和女孩本质来讲其实都是用户，不需要拆开来看，只要构建一个新的用户表，加一个字段来控制性别就可以了。\ngender_choices = (\n\t(1, \'男\'),\n    (2, \'女\'),\n)\ngender = models.IntegerField(choices=gender_choices)\n\n比如：\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    gender_choices = (\n\t\t(1, \'男\'),\n    \t(2, \'女\'),\n\t)\n\tgender = models.IntegerField(choices=gender_choices)\n    \n    \nclass U2U(models.Model):\n  # related_query_name可以让对象在反向查找的时候不用表名而是使用a或者b。相当于a_set.all()\n  # 如果不带query，反向查找就不带set了，就是直接a.all()，b.all()\n  g = models.ForeignKey(\'Userinfo\', related_query_name=\'a\')\n  b = models.ForeignKey(\'UserInfo\', related_query_name=\'b\')\n  \n这个在添加数据的时候又两种写法\n1、在能获取明确的id的值的时候就可以这么用。\nmodels.U2U.objects.create(b_id=2, g_id=6)\n2、如果可以拿到对象的化django也是可以支持插入对象的。\nboy = models.UserInfo.objects.filter(xxxx)\ngirl = models.UserInfo.objects.filter(xxx)\nmodels.U2U.objects.create(b=boy, g=girl)\n\n或者：\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    gender_choices = (\n\t\t(1, \'男\'),\n    \t(2, \'女\'),\n\t)\n\tgender = models.IntegerField(choices=gender_choices)\n    m = models.ManyToManyField(\'UserInfo\')\n    \n如果设定的是manytomany的方式的话那么取数据的时候先后也有区别。\n上面的这个m在数据库中生成的字段名是from_userinfo_id和to_userinfo_id\n我们定前面的是男生的，后面的是女生的。那么取数据的时候就应该做如下修改：\n# 男生对象\nobj = models.UserInfo.objects.filter(id=1).first()\n# 根据男生id=1查找关联的所有女生\nobj.m.all()\n\n# 女生对象\nobj = models.UserInfo.objects.filter(id=4).first()\n# 根据女生id=4查找关联的所有男生\nobj.userinfo_set.all()\n```\n\n用户的注销：\n\n```python\n# 删除服务端的session数据，用户带着cookie来的话查不到数据\nrequest.session.delete(request.session.session_key)\n或者\n# 设置cookie超时\nrequest.session.clear()\n```\n\nForeign自关联\n\n```python\nclass Comment(models.Model):\n    \"\"\"评论表\"\"\"\n    news_id = models.IntegerField() # 新闻id\n    content = models.CharField(max_length=32) # 评论的内容\n    user = models.CharField(max_length=32)   # 评论用户的id\n    # 首先这个评论的新闻是要存在的，这个要在已经存在的数据中去确认。\n    # 因此ForeignKey关联的表是自己。这个叫做ForeignKey的自关联\n    reply = models.ForeignKey(\'Comment\', null=True, blank=True, related_name=\'xxxxx\') # 评论回复\n```\n\n一般情况下的自关联是用不到的。\n\n\n\nDjango:\n\n- 路由\n  - 单一路由\n  - 正则\n  - 可命名（反向生成）\n  - include分发\n- 视图\n  - CBV\n    - request\n    - render\n    - HttpResponse\n    - methodDecrators\n  - FBV\n- 数据库\n  - 基本数据库操作（增删改查）\n  - ​\n- 模板\n- 其他：\n  - CSRF\n  - Cookie\n  - Session\n  - 分页\n\nDjango请求的生命周期：\n\ndjango默认使用的wsgi是wsgiref\n\n\n\nmvc & mtv(models（模型类）, templates（模板）,views（业务逻辑）)","timestamp":1540354517190},{"name":"12-rabbitmq.md","path":"04-Django/12-rabbitmq.md","content":"# Rabbitmq\n\n>www.cnblogs.com/alex3714/articles/5248247.html\n\n**队列解决了两个问题**\n\n- 同步：同步的排队等待会造成资源的浪费，但是相对的有点就是能够保证任务被及时执行。\n\n- 解耦\n- 异步\n  - 优点：解决排队问题。相反的，同步的就是不能解决排队问题。解决了资源浪费的问题\n  - 缺点：不能保证任务被及时的执行。相反的，同步的优点就是能够保证被及时执行。我怎么判断内容是被正确的人拿走了，而不是被偷走了呢？事实上这个人拿了内容以后是有一个处理和确认机制的。\n  - 应用场景：比如买票和出票的过程，不是买了就能出票，整个过程是异步的。\n\n**队列的作用**\n\n1. 存储消息，数据\n2. 保证消息顺序\n3. 保证数据的交付\n\npv、uv：page view，user visit，uv的判定基准是什么；qps\n\n**为什么用Rabbitmq而不用Python的queue**\n\n- 因为Python的Queue不能跨进程\n\n## Rabbitmq\n\n### 安装\n\n**Erlang**\n\n> https://packages.erlang-solutions.com/erlang/\n\nrabbitmq-server依赖于erlang环境，因此在安装Rabbitmq之前先要确保你的epel源以及erlang环境是正常的。\n\n```shell\n# 安装repo\nwget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm\nrpm -Uvh erlang-solutions-1.0-1.noarch.rpm\n\n# 或者手动添加repo源也是可以的。这两种方式任选其一\nrpm --import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc\n# 添加到/etc/yum.repo.d/下\n[erlang-solutions]\nname=CentOS $releasever - $basearch - Erlang Solutions\nbaseurl=https://packages.erlang-solutions.com/rpm/centos/$releasever/$basearch\ngpgcheck=1\ngpgkey=https://packages.erlang-solutions.com/rpm/erlang_solutions.asc\nenabled=1\n\n# 安装erlang，选择其中一种方式就可以，具体区别可以在上面的连接查看详细内容\nyum install erlang -y\nyum install esl-erlang -y\n```\n\n**安装rabbitmq**\n\n```shell\n# 导入key\nrpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc\n\n# 更新repo\n[root@centos7test ~]# cat /etc/yum.repos.d/rabbitmq.repo \n[bintray-rabbitmq-server]\nname=bintray-rabbitmq-rpm\nbaseurl=https://dl.bintray.com/rabbitmq/rpm/rabbitmq-server/v3.7.x/el/7/\ngpgcheck=0\nrepo_gpgcheck=0\nenabled=1\n\n# 安装\nyum -y install rabbitmq-server\n\n# 创建rabbitmq-server的用户(记得先开启rabbitmq-server)\nsudo rabbitmqctl add_user lamber lamber123\n\n# 配置权限，允许从外面访问\nsudo rabbitmqctl set_permissions -p / lamber \".*\" \".*\" \".*\"\n\n- conf:允许用户修改配置信息\n- write:\n```\n\n**安装pika**\n\n```shell\n# pika是python用来连接rabbitmq的东西\npip install pika 或者 easy_install pika\n```\n\n###  \n\n> rabbitmq是一个独立的组件，可以起在一个端口上供使用者使用。rabbitmq中存在多个队列供不同的程序调用，因为每一个程序的消息是独立的；\n\n5672是rabbitmq的端口号，\n\n启动rabbitmq-server\n\n```shell\nrabbitmq-server\n```\n\n查看队列，显示当前的队列列表\n\n```shell\nrabbitmqctl list_queues\n```\n\nPython端的生产者源码：\n\n```python\n# 生产者\n# 1、端口，ip，认证信息\n# 2、创建队列\n# 3、往队列里发消息\n\nimport pika\n\ncredentials = pika.PlainCredentials(\'lamber\', \'lamber123\')\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=\'192.168.56.100\', credentials=credentials))\nchannel = connection.channel()\n\n# 声明queue，队列的名称为hello\nchannel.queue_declare(queue=\'hello\')\n\n# 可以开始发消息了。exchange，指定使用什么过滤器，因为消息插入队列必须经过过滤器，它不可能直接插入到队列中\n# 因此即使现在不适用也要指定一个，空指的是默认的exchange\n# routing_key是路由，其实就是走哪个队列，body即内容。\nchannel.basic_publish(exchange=\'\',\n                      routing_key=\'hello\',\n                      body=\'Hello World!\')\nprint(\" [x] Sent \'Hello World!\'\")\nconnection.close()\n\n\n\n[root@centos7test ~]# rabbitmqctl list_queues\nTimeout: 60.0 seconds ...\nListing queues for vhost / ...\nhello   1\n```\n\nPython端的消费者源码：\n\n```shell\n# 消费者\n# 1、端口，ip，认证信息\n# 2、从指定队列里获取消息\nimport pika\n\ncredentials = pika.PlainCredentials(\'lamber\', \'lamber123\')\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=\'192.168.56.100\', credentials=credentials))\nchannel = connection.channel()\n\n# 你可能会问为什么要再定义一次队列，如果你能够确定这个队列确实存在那么你应该避免再次定义。\n# 如果send.py程序之前运行过，但是我们还不能确认，哪个程序先运行的，假如你执行消费者的时候生产者没有存在，此时说明这个队列还没有被声明，这个时候是会报错的。这种情况下同时在两个程序里执行以下这个操作是不错的实践\n# 如果已经存在的队列重复声明的时候会进行检查，如果有的话就不会声明了，其实相当于一种确认机制。\nchannel.queue_declare(queue=\'hello\')\n\ndef callback(ch, method, properties, body):\n    \"\"\"\n    回调函数，当收到消息以后会调用的函数\n    :param ch: channel\n    :param method: 请求的方式\n    :param properties: 参数\n    :param body: 信息的内容\n    :return:\n    \"\"\"\n    # <BlockingChannel impl=<Channel number=1 OPEN conn=<SelectConnection OPEN socket=(\'192.168.56.1\', 54795)->(\'192.168.56.100\', 5672) params=<ConnectionParameters host=192.168.56.100 port=5672 virtual_host=/ ssl=False>>>>\n    # print(ch)\n    # <Basic.Deliver([\'consumer_tag=ctag1.1ad1df223f174bc8a98e170e750e5584\', \'delivery_tag=2\', \'exchange=\', \'redelivered=False\', \'routing_key=hello\'])>\n    # print(method)\n    # <BasicProperties>\n    # print(properties)\n    # print(\" [x] Received %r\" % body)\n    print(body)\n\n\nchannel.basic_consume(callback,\n                      queue=\'hello\',\n                      no_ack=True)\n\nprint(\' [*] Waiting for messages. To exit press CTRL+C\')\n# 开始取消息，出于阻塞模式\nchannel.start_consuming()\n```\n\n\n\n如何保证消息完整的交付或者被处理掉？这里用到了三个参数：\n\n1. no_ack：默认是确认机制，除非你设置为`no_ack=True`。\n\n2. 生产者这一段加上\n\n   ```python\n   channel.basic_publish(exchange=\'\',\n                         routing_key=\'hello\',\n                         # 消息持久化的操作\n                         properties=pika.BasicProperties(delivery_mode=2, ),\n                         body=\'Hello World!\')\n   ```\n\n3. 消费者端，消息处理完毕的时候，发送确认包\n\n   ```python\n   def callback(ch, method, properties, body):\n       print(body)\n       # 手动向rabbitmq-server进行确认，消费者确认以后，服务端才会删掉这条消息\n       ch.basic_ack(delivery_tag=method.delivery_tag)\n   ```\n\n\n\n如果rabbitmq-server宕了，该怎么办？生成队列的时候加上持久的参数\n\n```python\n# 队列持久化参数durable，队列一定要在第一次生成的时候设置durable\nchannel.queue_declare(queue=\'hello\', durable=True)\n```\n\n因此队列和消息要想重启的时候内容都存在，那么durable和delivery_mode就需要全部设置上才行。\n\n### 消息单播\n\n默认情况下，如果一个队列有多个消费者，那么多个消费者是轮询的去取消息的。一人一个这样的去取，不过这样其实不是很好的一个方式，因为没有考虑到消费者的处理能力，有的消费者处理快，有的消费者处理的慢，如果按照这样的轮询去分发的话那么就会造成处理慢的消费者的消息的积压而处理快的反而闲着没事做的情况。因此这里有一个消息公平分发的问题。\n\n针对这个分发的问题，我们可以在各个的消费者端配置`prefetch=1`，意思就是告诉rabbitmq在我这个消费者当前信息还没处理完的时候就不要给我发送新的消息了\n\n### 消息的发布与订阅\n\n之前的例子都基本都是1对1的消息发送和接收，即消息只能发送到指定的queue里，但有些时候你想让你的消息被所有的Queue收到，类似广播的效果，这时候就要用到exchange了，\n\nAn exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives. Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. The rules for that are defined by the *exchange type.*\n\nExchange在定义的时候是有类型的，以决定到底是哪些Queue符合条件，可以接收消息\n\n\n\n- fanout: 所有bind到此exchange的queue都可以接收消息\n\n- direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息\n\n- topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息\n\n  ```\n  表达式符号说明：#代表一个或多个字符，*代表任何字符\n  例：#.a会匹配a.a，aa.a，aaa.a等\n     *.a会匹配a.a，b.a，c.a等\n       注：使用RoutingKey为#，Exchange Type为topic的时候相当于使用fanout　\n  ```\n\n\nheaders: 通过headers 来决定把消息发给哪些queue，这个非常少用到。\n\n到目前为止，这个消息是单播，也就是被一个人消费掉就没了，但是不是广播；\n\n**消息的发布者（生产者）**\n\n```python\n# 其实这个手可以发现，并没有声明队列了，在basic_publish中routing_key也没有指定了。\n# 代表着我只需要把消息发送到exchange就可以了，exchange再把消息发送到队列里。\nimport pika\nimport sys\n \nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host=\'localhost\'))\nchannel = connection.channel()\n \nchannel.exchange_declare(exchange=\'logs\',\n                         type=\'fanout\')\n \nmessage = \' \'.join(sys.argv[1:]) or \"info: Hello World!\"\nchannel.basic_publish(exchange=\'logs\',\n                      routing_key=\'\',\n                      body=message)\nprint(\" [x] Sent %r\" % message)\nconnection.close()\n```\n\n**消息的订阅者（消费者）**\n\n```python\nimport pika\n \nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host=\'localhost\'))\nchannel = connection.channel()\n \nchannel.exchange_declare(exchange=\'logs\',\n                         type=\'fanout\')\n\n# 其实现在已经不需要队列了，因此手动声明队列的方式就显的很多余了。此时如下的这个操作就会自动为你生成队列，不用了以后会自动删掉。exclusive指的是唯一的，排他的。类似于数据库中的unique=True。其实就是指定生成一个名字唯一的队列名。不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后，自动将queue删除，这里返回的result其实就是一个queue的对象。\nresult = channel.queue_declare(exclusive=True) \n# 获取queue的名字\nqueue_name = result.method.queue\n# 把queue绑定到对应的exchange上。当没有任何一个队列绑定到exchange的时候消息会丢失，exchange并不负责对消息进行存储。应用场景比如新浪微博等等。虽然新浪微博用的不一定是rabbitmq。只有当前登录的用户才能收到消息，可以排除僵尸粉，应用场景登录的才有这样就可以做资源的节省，避免不必要的浪费。\nchannel.queue_bind(exchange=\'logs\',\n                   queue=queue_name)\n \nprint(\' [*] Waiting for logs. To exit press CTRL+C\')\n \ndef callback(ch, method, properties, body):\n    print(\" [x] %r\" % body)\n \nchannel.basic_consume(callback,\n                      queue=queue_name,\n                      no_ack=True)\n \nchannel.start_consuming()\n```\n\n### 消息组播\n\n\n\n**Publisher**\n\n```python\nimport pika\nimport sys\n \nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host=\'localhost\'))\nchannel = connection.channel()\n \nchannel.exchange_declare(exchange=\'direct_logs\',\n                         type=\'direct\')\n\n# 可以人工指定你把消息发送到哪个组里\nseverity = sys.argv[1] if len(sys.argv) > 1 else \'info\'\nmessage = \' \'.join(sys.argv[2:]) or \'Hello World!\'\n# 组播的时候routing_key就不是空了。\nchannel.basic_publish(exchange=\'direct_logs\',\n                      routing_key=severity,\n                      body=message)\nprint(\" [x] Sent %r:%r\" % (severity, message))\nconnection.close()\n```\n\n**subscriber**\n\n```python\nimport pika\nimport sys\n \nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host=\'localhost\'))\nchannel = connection.channel()\n \nchannel.exchange_declare(exchange=\'direct_logs\',\n                         type=\'direct\')\n \nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\n# 指定接收哪个分组的消息\nseverities = sys.argv[1:]\nif not severities:\n    sys.stderr.write(\"Usage: %s [info] [warning] [error]\\n\" % sys.argv[0])\n    sys.exit(1)\n\n# 循环绑定，对于组播来讲，就是你想收机组消息就绑定几组。\n# 订阅与发布一定是你绑定了而且在线，如果你离线了，对不起你是收不到的。\n# 这个很像广播电台，你打开了，你能听现在的，之前的你是收不到的。\nfor severity in severities:\n    channel.queue_bind(exchange=\'direct_logs\',\n                       queue=queue_name,\n                       routing_key=severity)\n \nprint(\' [*] Waiting for logs. To exit press CTRL+C\')\n \ndef callback(ch, method, properties, body):\n    print(\" [x] %r:%r\" % (method.routing_key, body))\n \nchannel.basic_consume(callback,\n                      queue=queue_name,\n                      no_ack=True)\n \nchannel.start_consuming()\n```\n\n### RPC\n\nsnmp，不需要远程装一个客户端来执行了。\n\n\n\n**RPC Server**\n\n```python\n# 1.定义好fib函数\n# 2.声明接收指令的队列名，rpc_queue\n# 3.监听队列，收到消息后，调用fib函数。\n# 4.把fib执行结果，发送回客户端指定的reply_to队列。\nimport pika\nimport time\nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host=\'localhost\'))\n \nchannel = connection.channel()\n \nchannel.queue_declare(queue=\'rpc_queue\')\n \ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n \ndef on_request(ch, method, props, body):\n    n = int(body)\n \n    print(\" [.] fib(%s)\" % n)\n    response = fib(n)\n \n    ch.basic_publish(exchange=\'\',\n                     # 客户端传过来的队列：props.reply_to\n                     routing_key=props.reply_to,\n                     # 同时还要带上uuid\n                     properties=pika.BasicProperties(correlation_id = \\\n                                                         props.correlation_id),\n                     body=str(response))\n    # 确认执行完毕。\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n \nchannel.basic_qos(prefetch_count=1)\nchannel.basic_consume(on_request, queue=\'rpc_queue\')\n \nprint(\" [x] Awaiting RPC requests\")\nchannel.start_consuming()\n```\n\n**RPC Client**\n\n```python\n# 1.声明一个队列，作为reply_to返回消息结果的杜烈\n# 2.发消息到队列，消息里带一个唯一标识符uid，reply_to\n# 3.监听reply_to的队列，直到有结果返回。\nimport pika\nimport uuid\n \nclass FibonacciRpcClient(object):\n    def __init__(self):\n        credentials = pika.PlainCredentials(\'lamber\', \'lamber123\')\n        parameters = pika.ConnectionParameters(host=\'192.168.56.100\', credentials=credentials)\n        self.connection = pika.BlockingConnection(pika.ConnectionParameters(\n                host=\'localhost\'))\n \t\t\n        self.channel = self.connection.channel()\n        # 初始化一个消息队列。也就是replay_to\n        result = self.channel.queue_declare(exclusive=True)\n        # queue_name\n        self.callback_queue = result.method.queue\n        # 声明监听（只是声明）到reply_to队列收到消息以后执行回调函数on_response\n        self.channel.basic_consume(self.on_response, no_ack=True,\n                                   queue=self.callback_queue)\n \n    def on_response(self, ch, method, props, body):\n        # 收到队列结果以后执行的函数\n        # props端返回的消息结果\n        if self.corr_id == props.correlation_id:\n            self.response = body\n \n    def call(self, n):\n        # 返回值\n        self.response = None\n        # 设置唯一标识符也就是uid，可以使用uuid模块，也可以使用当前时间戳生成md5都可以\n        self.corr_id = str(uuid.uuid4())\n        self.channel.basic_publish(exchange=\'\',\n                                   routing_key=\'rpc_queue\',\n                                   # 带着唯一标识符和队列这个reply_to和correlation_id\n                                   # 这个是内置参数，所以名字这是写好的，别随便改。\n                                   properties=pika.BasicProperties(\n                                         reply_to = self.callback_queue,\n                                         correlation_id = self.corr_id,\n                                         ),\n                                   body=str(n))\n        while self.response is None:\n            # 不同于start_consuming，下面的用法是非阻塞的。\n            # 检测队列里有没有新消息。收到消息以后触发调用回调函数。\n            self.connection.process_data_events()\n        return int(self.response)\n \nfibonacci_rpc = FibonacciRpcClient()\n \nprint(\" [x] Requesting fib(30)\")\nresponse = fibonacci_rpc.call(30)\nprint(\" [.] Got %r\" % response)\n```\n\n### 规则播\n\n\n\n```\n# 代表所有\nkern.* 代表以kern开头的\n```\n\n","timestamp":1540354517190},{"name":"01-restful.md","path":"04-Django/13-Django-rest-framework/01-restful.md","content":"# DRF\n\n> www.cnblogs.com/wupeiqi/articles/7805382.html\n\n## RestFul\n\n###Restful说明\n\n- REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”\n- REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态\n- REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”\n- 所有的数据，不过是通过网络获取的还是操作（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性\n- 对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：面向资源架构（ROA：Resource Oriented Architecture）\n\n###Restful设计规范\n\n- API与用户的通信协议，总是使用[HTTPs协议](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)。（推荐使用https）\n- 域名 \n  - https://api.example.com：尽量将API部署在专用域名（会存在跨域问题，需要自己解决）\n  - https://example.org/api/：尽量使用这种，这样的API很简单\n\n- 版本：可能存在多个版本共存的情况，版本之间可能也需要过渡，因此url后面一般还会带一个版本\n  - URL，如：https://api.example.com/v1/    一般版本号放在url\n  - 版本好也可以加到请求头                                                  跨域时，引发发送多次请求\n- 路径，视网络上任何东西都是资源（面向资源编程），均使用名词表示（可复数），比如订单order，而不是get_order，或者delete_order这样的url。\n  - https://api.example.com/v1/zoos\n  - https://api.example.com/v1/animals\n  - https://api.example.com/v1/employees\n- method\n  - GET      ：从服务器取出资源（一项或多项）\n  - POST    ：在服务器新建一个资源\n  - PUT      ：在服务器更新资源（客户端提供改变后的完整资源，即全部更新）\n  - PATCH  ：在服务器更新资源（客户端提供改变的属性，即局部更新）\n  - DELETE ：从服务器删除资源\n- 过滤，通过在url上传参的形式传递搜索条件\n  - https://api.example.com/v1/zoos?limit=10：指定返回记录的数量\n  - https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置\n  - https://api.example.com/v1/zoos?page=2&per_page=100：指定第几页，以及每页的记录数\n  - https://api.example.com/v1/zoos?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序\n  - https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件\n\n- 状态码：根据状态码给用户做提示，但是仅仅用状态码是不够的，因此大多使用code+状态码结合使用。status code可以在HTTPResponse中以参数形式返回。现在主要还是以code为主。有的对状态码有需求，有的没有需求，在写接口前要问清楚。\n\n  ```html\n  200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n  201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n  202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n  204 NO CONTENT - [DELETE]：用户删除数据成功。\n  400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n  401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n  403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n  404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n  406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n  410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n  422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n  500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n  \n  更多看这里：http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n  ```\n\n- 错误处理，状态码是4xx时，应返回错误信息，推荐用error当做key。\n\n  ```json\n  {\n      error: \"Invalid API key\"\n  }\n  ```\n\n- 返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n  ```\n  GET /collection：返回资源对象的列表（数组）\n  GET /collection/resource：返回单个资源对象\n  POST /collection：返回新生成的资源对象\n  PUT /collection/resource：返回完整的资源对象\n  PATCH /collection/resource：返回完整的资源对象\n  DELETE /collection/resource：返回一个空文档\n  ```\n\n- Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。（其实就是为了让你省事，再给你返回一个url）\n\n  ```\n  {\n      \"link\": {\n          \"rel\":   \"collection https://www.example.com/zoos\",\n          \"href\":  \"https://api.example.com/zoos\",\n          \"title\": \"List of zoos\",\n          \"type\":  \"application/vnd.yourformat+json\"\n       }\n  }\n  ```\n\n**谈谈你对Restful规范的认识**\n\n```\n本质上就是一个规范，让后台更容易处理，让前端更容易记住这些url，在url上能体现更多的操作。\nrestful有些适用项目，有些也不适用，不一定要完全符合这个标准，最重要的还是契合项目。\n协同开发的时候共同遵循这个规范，让操作更加统一。\n推荐使用CBV的方式\n```\n\n\n\n\n\n\n\n\n\n封装体现在两大方面：\n\n- 对方法封装到类中，比如操作文件的增删改查，和操作数据库的增删改查。\n- 将数据封装到对象中，体现在比如学生类，学生的信息都封装在学生类的对象里面。\n\n\n\n中间件：用户登录认证，rbac，csrftoken\n\n\n\n你用过什么中间件？CSRFtoken是怎么实现的？csrf写在了process_view里面，为什么不写在process_request里面呢？虽然都是请求之前做的判断，但是我们知道可以通过添加装饰器免除csrf的验证，也就是验证过程中还要验证这个函数有没有加这个装饰器。因为在process_request执行完了以后才执行的路由的匹配，才找到的那个函数。process_view方法用来检查视图是否被装饰器装饰，装饰了就可免除认证。去请求体或者cookie中获取token，然后根据获取的token做校验。\n\n\n\n\n\n开发模式\n\n1. 普通模式：前后端放到一起写\n2. 前后端分离的模式","timestamp":1540354517190},{"name":"02-DRF认证.md","path":"04-Django/13-Django-rest-framework/02-DRF认证.md","content":"# Django Rest FrameWork\n\n## DRF安装\n\n```python\npip3 install djangorestframework\n```\n\n## 简单环境准备\n\nmodel class简单点，一个用来存储用户信息一个用来存储token认证信息。\n\n```python\nfrom django.db import models\n\nclass UserInfo(models.Model):\n    user_type_choices = (\n        (1, \'普通用户\'),\n        (2, \'VIP\'),\n        (3, \'SVIP\'),\n    )\n    user_type = models.IntegerField(choices=user_type_choices)\n    username = models.CharField(max_length=64, unique=True)\n    password = models.CharField(max_length=64)\n\nclass UserToken(models.Model):\n    # 还可以在这里加token时间，最多使用次数\n    user = models.OneToOneField(\'UserInfo\', on_delete=models.CASCADE)\n    token = models.CharField(max_length=64)\n```\n\n## 认证源码解析\n\n使用drf的时候我们的视图逻辑使用的是CBV而不是FBV，这里CBV有一个要点不是继承默认的django的View而是要继承DRF的APIView。\n\n```python\nclass AuthView(APIView):\n\n    pass\n```\n\n其实这个APIView也继承自Django的View，因此DRF相当于在Django的View上又给封装了一层，CBV中找到对应request.method视图方法的关键是利用反射来完成的，默认的Django的View就是做了一层的反射：\n\n```python\ndef dispatch(self, request, *args, **kwargs):\n    # Try to dispatch to the right method; if a method doesn\'t exist,\n    # defer to the error handler. Also defer to the error handler if the\n    # request method isn\'t on the approved list.\n    if request.method.lower() in self.http_method_names:\n        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)\n    else:\n        handler = self.http_method_not_allowed\n    return handler(request, *args, **kwargs)\n```\n\n不过我们知道，我们可以在自己的CBV中重写这个dispatch，先调用一下父类（View）的dispatch方法，然后在调用之前和调用之后就可以做一些我们自己的操作了，其实DRF也是这么干的。\n\n```python\n# DRF的dispatch，drf的dispatch和django的dispatch几乎是一致的，只不过在原来的基础上加了一些钩子，也就是我们所说的在调用父类的操作之前，执行一些其他的方法。这些钩子分别存在于开始，结束以及异常的时候。\ndef dispatch(self, request, *args, **kwargs):\n\n    self.args = args\n    self.kwargs = kwargs\n    # 1、首先从这里开始，DRF对django的request做了封装。\n    # 这个request已经发生变化了，是经过drf加工过后的request了。\n    request = self.initialize_request(request, *args, **kwargs)\n    self.request = request\n    self.headers = self.default_response_headers  # deprecate?\n\n    try:\n        self.initial(request, *args, **kwargs)\n\n        # Get the appropriate handler method\n        if request.method.lower() in self.http_method_names:\n            handler = getattr(self, request.method.lower(),\n                              self.http_method_not_allowed)\n        else:\n            handler = self.http_method_not_allowed\n\n        response = handler(request, *args, **kwargs)\n\n    except Exception as exc:\n        response = self.handle_exception(exc)\n\n    self.response = self.finalize_response(request, response, *args, **kwargs)\n    return self.response\n```\n\nDRF是如何封装request的？这里只着重认证部分，其他的部分会回过头来重新说明的。\n\n```python\n# initialize_request\ndef initialize_request(self, request, *args, **kwargs):\n    \"\"\"\n    返回初始化的request对象，返回一个drf的Request的对象，相当于在原基础上封装了更多的内容\n    但是原来的django的request给封装到了返回的对象里，所以说依然可以使用之前的request。\n    \"\"\"\n    parser_context = self.get_parser_context(request)\n    \n    # _request：原生的request，authenticators获取认证类的对象。\n    return Request(\n        request,\n        parsers=self.get_parsers(),\n        # self.authentication_classes中列出的类的对象\n        authenticators=self.get_authenticators(),\n        negotiator=self.get_content_negotiator(),\n        parser_context=parser_context\n    )\n```\n\n在初始化封装request的过程中，返回了一个DRF的Request对象，里面封装了原生的request以及一个authenticators，这个authenticators是调用`self.get_authenticators()`获得的。\n\n来看一下get_authenticators是如何操作的。\n\n```python\n# 遍历self.authentications_classes返回对应每一个item的实例，填充到列表里。\ndef get_authenticators(self):\n    \"\"\"\n    Instantiates and returns the list of authenticators that this view can use.\n    \"\"\"\n    return [auth() for auth in self.authentication_classes]\n```\n\n此时的这个self是谁？这个self现在是我们定义的CBV，因此去找self.authentication_classes的时候会优先到我们自己的类里面去找，假如我在我自己的类里面定义了这个内容：\n\n```python\nclass OrderView(APIView):\n    # 表示在你写的这个类中应用drf的认证规则\n    authentication_classes = [Authtication, ]\n    def get(self, request, *args, **kwargs):\n\t\tpass\n\n    def post(self, request, *args, **kwargs):\n        pass\n```\n\n那么get_authenticators返回的就是我们自己定义的authentication_classes中的对象。到此为止我们在认证方面知道dispatch在DRF中被初始化，request被重新封装，而且封装后的内容包含原生的request，以及一个我们自定制的认证规则类的对象列表。\n\n接下来继续看dispatch的内容，在dispatch的后续代码中调用了initial方法。\n\n```python\ndef dispatch(self, request, *args, **kwargs):\n\n    self.args = args\n    self.kwargs = kwargs\n    request = self.initialize_request(request, *args, **kwargs)\n    self.request = request\n    self.headers = self.default_response_headers  # deprecate?\n\n    try:\n        self.initial(request, *args, **kwargs)\n\n        # Get the appropriate handler method\n        if request.method.lower() in self.http_method_names:\n            handler = getattr(self, request.method.lower(),\n                              self.http_method_not_allowed)\n        else:\n            handler = self.http_method_not_allowed\n\n        response = handler(request, *args, **kwargs)\n\n    except Exception as exc:\n        response = self.handle_exception(exc)\n\n    self.response = self.finalize_response(request, response, *args, **kwargs)\n    return self.response\n```\n\n找到self.initial方法\n\n```python\ndef initial(self, request, *args, **kwargs):\n    \"\"\"\n    Runs anything that needs to occur prior to calling the method handler.\n    \"\"\"\n    self.format_kwarg = self.get_format_suffix(**kwargs)\n\n    # Perform content negotiation and store the accepted info on the request\n    neg = self.perform_content_negotiation(request)\n    request.accepted_renderer, request.accepted_media_type = neg\n\n    # Determine the API version, if versioning is in use.\n    version, scheme = self.determine_version(request, *args, **kwargs)\n    request.version, request.versioning_scheme = version, scheme\n\n    # Ensure that the incoming request is permitted\n    self.perform_authentication(request)\n    self.check_permissions(request)\n    self.check_throttles(request)\n```\n\n看最后的self.perform_authentication方法，这个方法是用来确认这个进来的请求是否经过允许，也就是进来的这个请求是否认证成功？\n\n```python\ndef perform_authentication(self, request):\n    \"\"\"\n    Perform authentication on the incoming request.\n\n    Note that if you override this and simply \'pass\', then authentication\n    will instead be performed lazily, the first time either\n    `request.user` or `request.auth` is accessed.\n    \"\"\"\n    request.user\n```\n\n返回了一个request对象的user方法，注意此时的request是已经被封装过的request，我们取DRF的Request类中去找这么一个方法，之所以没有加括号是因为被property修饰过了：\n\n```python\n@property\ndef user(self):\n    \"\"\"\n    Returns the user associated with the current request, as authenticated\n    by the authentication classes provided to the request.\n    \"\"\"\n    if not hasattr(self, \'_user\'):\n        with wrap_attributeerrors():\n            self._authenticate()\n    return self._user\n```\n\n我们看，如果说认证成功以后会返回self.\\_user，如果没有注册成功调用self.\\_authentication()方法\n\n```python\ndef _authenticate(self):\n    \"\"\"\n    Attempt to authenticate the request using each authentication instance\n    in turn.\n    \"\"\"\n    # 循环self.authenticators中的对象\n    for authenticator in self.authenticators:\n        try:\n            # 执行认证类的authenticate方法，如果没有异常的话，返回一个用户认证的元组\n            user_auth_tuple = authenticator.authenticate(self)\n        except exceptions.APIException:\n            # 如果捕获到异常了，那么就调用_not_authenticated方法。\n            self._not_authenticated()\n            # 向上级抛出异常\n            raise\n\t\t# 如果有返回值，那么执行相关认证赋值操作\n        # 如果返回None的话，那么循环继续，表示当前认证不处理，交给下一个认证类去处理。\n        \n        if user_auth_tuple is not None:\n            # 赋值，request.user和request.auth就是这么来的。因此有返回值必须是一个元组\n            # 元组里面必须有两个元素，第一个给request.user，第二个给request.auth\n            self._authenticator = authenticator\n            self.user, self.auth = user_auth_tuple\n            return\n\t# 也有可能都不处理，返回的都是None，这个时候就默认赋值\n    self._not_authenticated()\n```\n\n我们在\\_authenticate中发现，循环遍历了我们封装的self.authenticators中的对象，然后调用对象的authenticate方法，也就是说在我们自己写的类里面要有一个authenticate方法，这个方法应该返回什么？上面的方法支持三种返回值：\n\n1. 自己返回元组：元组中包含认证用户的user对象，以及认证结果的认证对象（比如token表中的对象）。\n2. 抛出异常：会在\\_authenticate中捕获到，并调用`self._not_authenticated()`\n3. 返回None，也就是所有的认证规则全部通过，但是没有返回值，此时调用`self._not_authenticated()`.\n\n来看看`self._not_authenticated()`都干了点什么？\n\n```python\ndef _not_authenticated(self):\n\t# 设置默认的_authenticator为空，\n    self._authenticator = None\n\t# 如果设置了UNAUTHENTICATED_USER那么就调用，否则就返回None\n    if api_settings.UNAUTHENTICATED_USER:\n        self.user = api_settings.UNAUTHENTICATED_USER()\n    else:\n        self.user = None\n\t# 如果设置了UNAUTHENTICATED_TOKEN那么就调用，否则就返回None\n    if api_settings.UNAUTHENTICATED_TOKEN:\n        self.auth = api_settings.UNAUTHENTICATED_TOKEN()\n    else:\n        self.auth = None\n```\n\n其实为默认的用户做一个设置，给通过认证却没有返回具体认证信息的人一个身份。到此为止，认证是ok了。不过刚才走的authenticate_classes是我们自己定义的，难道我们每写一个类都要自己这样定义一下么？其实不是的，针对这个认证规则是有一个全局设置的。\n\n之前的authenticate_classes是默认优先找自己定义的cbv中的这个属性，假如说没有的话那么久应该去父类去找了，那么父类中是如何定义的？最后我们发现这个内置的authentication_classess，它是一个api_settings的一个配置项：\n\n```python\nclass APIView(View):\n\n    # The following policies may be set at either globally, or per-view.\n    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES\n    parser_classes = api_settings.DEFAULT_PARSER_CLASSES\n    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES\n    ………………………………\n    \n    \napi_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)\n\n\ndef reload_api_settings(*args, **kwargs):\n    setting = kwargs[\'setting\']\n    # 会去配置文件中找REST_FRAMEWORK这样一个key，我们就可以把配置项写到这里。\n    if setting == \'REST_FRAMEWORK\':\n        api_settings.reload()\n```\n\n默认这个变量是没有东西的，需要我们自己去加，加的方法如下：\n\n```python\n# settings.py文件最后进行添加\nREST_FRAMEWORK = {\n    # 这里写的是认证类的路径，可以单独扔到一个py文件里\n    \'DEFAULT_AUTHENTION_CLASSES\': [\'api.utils.auth.FirstAuth\', \'api.utils.xxx.xxx\'],\n    # 推荐使用None\n    \'UNAUTHENTICATED_USER\': None,\n    \'UNAUTHENTICATED_TOKEN\': None,\n}\n```\n\n类不能和view写到一起，因此在api项目下新建一个utils的目录，新建一个auth.py将我们的认证逻辑都扔到auth.py里面去，这里的值我们知道对应的是一个列表，里面写的都是类的全路径。\n\n这样我们实际的每一个业务类就不用写这些内容了，相当于全局添加了认证，但是也有例外的页面，比如认证页面，认证页面是不需要添加认证机制的，你得先通过了认证页面拿到了token访问别的需要认证的页面的时候才需要认证，你现在都没登录，我认证页面还不让你访问那就没办法访问了。因此针对一些业务类需要放开这个权限，放开的方法也很简单，定义一个空列表就行了。因为在类的内部定义了，因此会优先走类内部的，实现了单独的类的特殊放开。\n\n```python\nclass AuthView(APIView):\n    \n    authentication_classes = []\n\n    def post(self, request, *args, **kwargs):\n \t\t………………\n\n    def get(self, request, *args, **kwargs):\n        ………………\n```\n\n## 内置认证类\n\n```python\nfrom rest_framework.authentication import BaseAuthentication\n```\n\n为了规范都要继承默认的BaseAuthentication类。authenticate_header是认证失败的时候给你的浏览器返回的响应头。\n\n\n\n\n\nDjango的生命周期：\n\nwsgi 中间件 dispath(drf的dispatch)","timestamp":1540354517190},{"name":"01-Django功能概览.md","path":"04-Django/14-Django源码剖析/01-Django功能概览.md","content":"django的test\n\n\n\n","timestamp":1540354517190},{"name":"03-runserver.md","path":"04-Django/14-Django源码剖析/03-runserver.md","content":"# Runserver\n\n","timestamp":1540354517190},{"name":"30-Django待整理内容.md","path":"04-Django/30-Django待整理内容.md","content":"## 2、学员管理系统初步\n\n### 2.1、单表操作（增删改查）\n\n表结构设计\n\n```mysql\n# 班级表\nid   title\n1    全栈4期\n2    全栈5期\n\n# 学生表\nid   name    班级id(FK)\n1    user1   1\n\n# 老师表(老师和班级是多对多的关系)\nid   name\n1    林海峰\n2    林狗\n3    袁日天\n\n# 老师和班级关系表\nid   老师id   班级id\n1       1       1\n2       1       2\n3       2       2\n\n########表结构设计##########\ncreate database django1;\n\ncreate table class(\n  id int unsigned not null primary key auto_increment,\n  title varchar(255) not null\n) engine=innodb charset=utf8;\n\ncreate table student(\n  id int unsigned not null primary key auto_increment,\n  name varchar(255) not null,\n  class_id int unsigned not null,\n  constraint `fk_class_id` foreign key (`class_id`) references class(`id`)\n) engine=innodb charset=utf8;\n\ncreate table teacher(\n  id int unsigned not null primary key auto_increment,\n  name varchar(255) not null\n) engine=innodb charset=utf8;\n\ncreate table teacher2class(\n  id int unsigned not null primary key auto_increment,\n  teacher_id int unsigned not null,\n  class_id int unsigned not null,\n  constraint `fk_teacher_id` foreign key (`teacher_id`) references teacher(`id`),\n  constraint `fk_cls_id` foreign key (`class_id`) references class(`id`)\n) engine=innodb charset=utf8;\n```\n\n### 2.2、一对多操作（增删改查）\n\n\n\n\n\n#### 基于ajax创建班级\n\n**模态对话框**（一般和ajax进行绑定）\n\n主要用于以下（比如登录）：\n\n> - 少量的输入框\n> - 数据少\n>\n> 相比较新URL的方式，新URL可以承载更多的操作已经更大的数据量。\n\n默认submit提交的时候会导致页面的刷新，这个属于form表单提交时的一个特性。这个是不受后台返回内容所限制的，不管你后台是return一个render重新渲染还是return一个httpresponse亦或是return一个redirect都不会影响。\n\n\n\n```javascript\n引入jquery：\n$.ajax({\n  url: \'要提交的地址\'，\n  type: \'POST\', // post或者是get这里指的是提交的方式\n  data: {\'k1\':\'v1\', \'k2\':\'v2\' ……}, // 这里指的是要提交的数据\n  success: function(data){\n      //当服务器处理完成并返回数据后会自动调用的一个函数。\n      //data表示返回的数据\n}\n \n})\n```\n\n使用Ajax删除班级，使用Ajax编辑班级。\n\n\n\n\n\n```javascript\n# 当页面框架加载完成后执行\n$(function(){\n  balabala……\n})\n\n# jquery阻止默认事件的发生\njquery绑定事件直接在函数中返回一个false就可以阻止事件的默认发生了，比如：\n$(function(){\n  $(\'#testmodel\').click(function(){\n    alert(123);\n    return false;\n  });\n});\n\n```\n\n模板的额外使用：\n\n```django\n{% if item.id in class_id %}\n\n{% else %}\n\n{% endif %}\n```\n\n\n\n### 2.3、多对多操作（增删改查）\n\n多对多的设计：\n\n\n\n\n\n\n\n=============\n\n响应头中如果有location的话，浏览器会直接再次发起请求。\n\n当a标签有默认跳转功能和其他事件比如click事件的时候会优先发生其他的附加事件，最后再执行跳转事件，如果想让默认事件不执行，可以让附加事件return一个函数，函数再renturn一个false默认事件就不会执行了，如果想让这个事件执行的话return true就可以了。\n\n\n\nplaceholder属性\n\nselect标签里的multiple属性，可以实现select标签的多选，size设置显示的范围大小。\n\npymysql中的lastrowid，在提交的时候还要把自增id拿到，lastrow_id要在commit以后才能拿到。\n\n取前端返回的多个数据可以使用\n\n```django\nrequest.POST.getlist(\'select标签的name\')\n```\n\n\n\n数据库类操作：\n\n```python\nclass DB():\n    \n    \n    def __init__(self):\n        # 从配置文件把配置读取出来\n        self.connect()\n    \n    def connect(self):\n        self.conn = pymysql.connect(xxxx)\n        self.cursor = self.conn.cursor(XXX)\n        \n    def get_list(self, sql, args):\n        self.cusor.excude(sql,args)\n        result = self.cursor.fethall()\n        return result\n    \n    def get_one(self, sql, args):\n        self.cursor.excute(sql, args)\n        result = self.cursor.fetchone()\n        return result\n    \n    def modify(self, sql, args):\n        # 这是链接一次提交多次，如果多次操作的每一次提交也是耗时\n        self.cursor.excute(sql, args)\n        self.conn.commit()\n        \n    def create(self, sql, args):\n        self.cursor.excute(sql, args)\n        self.conn.commit()\n        return self.cursor.lastrowid\n    \n    def multuple_modify(self, sql, args):\n        # 链接一次，提交一次，args是多个元组，我们要去构造。\n        self.cursor.excutemany(sql, args)\n        self.conn.commit()\n        \n    def close(self):\n        self.conn.close()\n        self.cursor.close()\n        \n        \n\n```\n\n\n\n表格的左右移动\n\n\n\n新URL方式\n\n\n\n通过ajax获取select列表的option所有的选项，在点击弹出框的时候通过ajax去服务器去取值。\n\n```javascript\n# 加载框显示的时机：用户一点弹出框增加的时候，先把透明底层和这个加载层显示出来，最后等数据加载完成了，也就是加载数据的这一块代码结束了，然后再把这个loading遮罩层给干掉，加上hide的class\n\n$.each(arg, function(i, row){\n  var tag = document.createElement(\'option\')\n  tag.innerHTML = row.title;\n  tag.setAttribute(\'value\', row.id);\n  $(\'#classIds\').append(tag);\n})\n// 加载框，加载完了以后先把loading的显示层隐藏掉，添加的框显示出来\n$(\'#loading\').addClass(\'hide\');\n$(\'#addModel\').removeClass(\'hide\');\n```\n\n注意：\n\n```javascript\n# 如果ajax里面传递的json有列表，如果要服务端显示为列表要加上traditional:true\n# 因为ajax会给你做特殊处理，如果加上traditional就不会做特殊处理，返回的就是列表，只支持列表，并不支持字典。\n$.ajax({\n  url: \'要提交的地址\'，\n  type: \'POST\', // post或者是get这里指的是提交的方式\n  data: {\'k1\':\'v1\', \'k2\':\'v2\' ……}, // 这里指的是要提交的数据\n  traditional: true,\n  success: function(data){\n      //当服务器处理完成并返回数据后会自动调用的一个函数。\n      //data表示返回的数据\n}\n```\n\n如何判断某个元素是不是在js的某个列表中\n\n```javascript\nv = [11,22,33]\nv.indexOf(22)\n# 如果有的话返回索引，如果没有的话返回-1\n```\n\n\n\nHTTP请求的生命周期\n\n请求头→提取URL→路由关系匹配→函数（模板+数据渲染）→返回用户（响应头+响应体）\n\n模版的渲染工作发生在哪一端？\n\n在服务端，浏览器拿到的一定是渲染完毕后的结果。\n\n默认从a标签跳转过去的都是get请求。\n\n\n\n## 初识BootStrap & fontawesome(图标库)\n\n使用bootstrap3\n\n下载用于生产环境的\n\n一个bootstrap.css，另外一个就是bootstrap.min.css，第二个是第一个的压缩版，但是功能是一模一样的。这样在调试的时候可以看，但是生产的时候要用压缩版。\n\nfonts是字体文件，特殊的图标文件也在里面。\n\n在static下新建一个plugin目录把这个放到里面去\n\n如何引用：\n\n```html\n<link ref=\'stylesheet\' href=\'/static/plugins/bootstrap……\'>\n```\n\n组件里有图标\n\nBootStrap：一个包含CSS和JS的样式库\n\n- 样式\n- 响应式：会根据用户的访问环境显示出不同的结构，比如手机端和pc端访问\n\n```css\n/*当小于等于700px的宽度的时候会执行@media里面的内容*/\n@media (max-width:700px){\n  .pg_header{\n   \tstyle1;\n    style2;\n  }\n}\n\n这样的可以添加多个形成一个多层改变的过程\n```\n\n组件：导航条\n\n响应式的代表一类是导航条，\n\nbootstrap总共给你把页面分成了12格子（bootstrap的栅格系统）\n\ncol-md col-lg col-xs col-sm\n\n\n\n全局样式里有一个：目的是是否允许移动设备进行缩放\n\n在 Bootstrap 2 中，我们对框架中的某些关键部分增加了对移动设备友好的样式。而在 Bootstrap 3 中，我们重写了整个框架，使其一开始就是对移动设备友好的。这次不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。也就是说，**Bootstrap 是移动设备优先的**。针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。\n\n为了确保适当的绘制和触屏缩放，需要在 `<head>` 之中**添加 viewport 元数据标签**。\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n```\n\n在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 `user-scalable=no` 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n```\n\n\n\n\n\n关于后台管理的布局，一般标准的就是那种布局，一般不去做响应式，不过也可以做响应式。但是使用bootstrap做响应式定制性不高。\n\n创建用户表，使用用户登录\n\ni标签\n\nhover是可以实现级联的：\n\n```css\n.pg-header .avatar:hover .user-infor{\n  xxxxx\n}\n```\n\n\n\nposition:absolute一会出现高度塌陷\n\n\n\n路径导航：\n\n\n\nDjango的程序目录介绍\n\n```python\n# 在对应的项目目录通过manage.py直接创建小的小项目，简单来说一个平台需要很多功能，但是功能之间又没有太大的联系。\npython manage.py startapp app01\n\n\n# 通过pycharm也是可以创建的\n在创建project的时候，在more settings下直接写一个application name就可以在创建project的同时会创建一个app，但是我们也可以在pycharm的terminal终端通过命令去创建，创建的目录里面其实会自带已给view\n\n一般业务代码放在对应的app文件夹里；\n\napp中的migrations是和数据库相关的。\nadmin是内部存在的后台管理，xxxx/admin，默认的账号和密码是：\napps是当前app的配置文件\nmodels是django的orm的类，和数据库进行沟通的\ntests是进行单元测试的。\nviews就是和之前一样的页面的，views不一定就是一个单文件，有时候逻辑特别多的时候写到一个py文件不是很好，我们可以把这个views.py删掉换成一个views文件夹，然后里面针对业务分成多个py文件。\n```\n\n## 路由系统\n\n### 动态路由\n\nurl->函数\n\n- 一一对应：/login/ → def login\n- /add-user/(+d)\n\n\n\nSEO会把get传参的内容页面的权重变低，因为爬虫会认为get传参的是经常变的，因此不经常变动的优先级会较高一些。\n\n```python\n# 正则表达式\nhttp://127.0.0.1/edit/ffff\nurl(r\'^edit/(\\w+)\', view.edit),\nurl(r\'^edit/(\\w+)/(\\w+)\', view.edit), ## 函数要接收两个参数，按照顺序接收\n# 这个并不是什么html文件，只是一个正则模版，这个叫伪静态\nurl(r\'^edit/(\\w+).html$\', view.edit),\ndef edit(requst, a1):\n    print(a1)\n    return xxxx\n\nurl(r\'^edit/(?P<a1>\\w+)/(?P<a2>\\w+)/\')\n这样就可以按照对应的标签去匹配了，a1就是第一个，a2就是第二个。这个可以不按照顺序去接收。这个就是按照参数名称进行存放的方式。\n\n如果加名字的和不加名字的共存那是如何接收的？\n答：这样就会直接报错，这个函数她会不知道如何接收，因此用法要统一，要不就关键字要不就位置的。\n\n函数在接收参数的时候可以使用*args和**kwargs\n\n推荐使用终止符号\nurl(r\'^edit$\'， view.edit)\n```\n\n什么是伪静态\n\n```\n\n```\n\n路由分发\n\n```python\nfrom django.conf.urls import include\n\n# 先从主的转到对应的app下的url路由关系，然后根据引入的urls再进行路由匹配\nurl(r\'^app01\', include(\'app01.urls\'))\n# 对应的访问结果应该就是这样的，路由分发只匹配到app01，后面的内容不会进行匹配\nhttp://128.0.0.1/app01/xxx/xxx.html\n\n转到具体的urls就不会看从app01开始往前的内容了。\n\n经过如上的操作，路由被分成了两级，project的入口成为了路由分发器\n\n啥没写可以跳转到一个默认的页面，比如跳转到主页\nurl(r\'^\', views.index)\n```\n\n路由系统之别名反向生成URL\n\n```python\nfrom django.urls import reverse\nurl(r\'^edit/\', view.edit, name=\'n1\'),  # 起一个别名\n# 可用于日后根据别名反生成url\nv = reverse(\'n1\')   # \'/edit/\'\n\n# 指定反向生成的内容\nurl(r\'^edit/(\\d+)\', view.edit, name=\'n1\')\nv = reverse(\'n1\', args=(1,))  # \'/edit/1/\'\n\n# 指定反向生成的内容(dict)\nurl(r\'^edit/(?P<a1>\\d+)\', view.edit, name=\'n1\')\nv = reverse(\'n1\', kwargs={\'a1\':\'111\'}  # \'/edit/111/\'\n            \n# 有了这个别名以后，form表单的action以后就可以这样写了，也可以根据名称反生成url\n<form method=\'POST\' action=\'{% url \"m1\" %}\'></form>\n            \n# 对应的跳转链接也可以通过反向链接实现，这是不使用python而是使用html模版循环的方法\n{% for i in list %}\n# 可以按照对应的值生成URL<a href=\"{% url \'n1\' i.1,i.2,i.3…… %}\">\n# 结果： <a href=\'/edit/aaa/bbb/ccc/ddd\'>\n<a href=\"{% url \'n2\' i %}\">xxxx\n{% endfor %}\n            \n\n# 在web中分全权限显示页面\n每个人的权限不一样，保存的权限跳转链接也不一样。\n            \n假如说可以访问的url很长，那么在数据库也要存储很长，如果说有一个别名的话就可以使用别名存储到数据库就可以了。通过别名就可以找到相对的url了。这个别名只在django里面有，在其他的系统里并不存在。当然不使用别名，完全使用url也是可以的。在crm权限管理中会用到，稍后说。\n```\n\n","timestamp":1540354517190},{"name":"01-CMDB简介.md","path":"04-Django/50-项目实战/01-CMDB/01-CMDB简介.md","content":"","timestamp":1540354517190},{"name":"02-中控客户端设计.md","path":"04-Django/50-项目实战/01-CMDB/02-中控客户端设计.md","content":"# 中控客户端设计（AutoClient）\n\n> CMDB资产采集：www.cnblogs.com/wupeiqi/articles/6415436.html\n>\n> 项目目录结构：\n>\n> ```shell\n> (cmdb) ➜  cmdb > tree -L 1 .\n> .\n> ├── bin             # 可执行的程序文件\n> ├── config          # 配置目录\n> ├── lib             # 类库，可以使用的各种工具类\n> └── src             # 业务代码\n> ```\n\n## 客户端配置文件设计\n\n> 很多应用程序在运行的时候不需要加任何参数就可以直接跑起来，或者说使用很少的参数就可以跑起来。其实并不是因为不需要参数，而是因为程序内部就包含了很多内置的参数供我们调用，当我们自己进行单独指定配置文件的参数项以后，程序又会按照我们指定的参数进行运行，因此配置文件设计思路有两点：\n>\n> 1. 程序包含一套内置的默认配置文件\n> 2. 用户可以自己定制配置文件的值，用户定制的配置优先权重要高于默认的\n\n首先按照以下的规则进行创建配置文件：\n\n```shell\n(cmdb) ➜  cmdb > tree . -L 2\n.\n├── bin\n│   ├── __init__.py\n│   └── start.py\n├── config\n│   ├── __init__.py\n│   └── settings.py              # 用户可以进行配置定义的配置文件\n├── lib\n│   ├── __init__.py\n│   └── conf\n│       ├── __init__.py\n│       ├── config.py            # 配置文件加载脚本\n│       └── global_settings.py   # 全局默认的配置文件\n├── src\n```\n\n为了方便测试，我们在全局配置文件和用户配置文件中添加一些配置项：\n\n```python\n# global_settings.py\nUSER = \'lamber\'\nPASSWORD = \'123456\'\nEMAIL = \'1020561033@qq.com\'\nBANNER = \'Hello World!\'\n\n# settings.py\nMODE = \"AGENT\"\n```\n\n在配置脚本的py文件中进行加载配置项，config.py：\n\n```python\n# -*- coding: utf-8\n\nimport os\nimport importlib\n\n# 分别引入默认文件和用户配置文件\nfrom . import global_settings\n\n\nclass Settings(object):\n    \n    def __init__(self):\n\n        # 找到默认配置，默认配置的优先级是要低于自定义的\n        # 因此默认配置先执行，通过dir属性拿到global_settings模块中的属性值\n        for name in dir(global_settings):\n            # 配置文件的每一个选项必须是大写的。\n            if name.isupper():\n                # 注意这里拿到的其实只不过是字符串而已，如果要想取属性值要利用到反射\n                value = getattr(global_settings, name)\n                # 通过setattr将对象的name属性设置为value的值\n                setattr(self, name, value)\n\n        # 随后找到自定义配置，从全局环境变量中拿USER_SETTINGS的值\n        # settings_module = os.environ[\'USER_SETTINGS\']\n        # 替换成get要优于上面的写法，如果没有的话不会报错而会返回None\n        # USER_SETTINGS是在start入口文件进行设置的，内容为用户自定义配置\n        settings_module = os.environ.get(\'USER_SETTINGS\')\n        if not settings_module:\n            return\n        # 根据字符串导入模块，返回的m其实就是对应的模块\n        m = importlib.import_module(settings_module)\n        for name in dir(m):\n            # 配置文件的每一个选项必须是大写的。\n            if name.isupper():\n                # 因为对应的用户自定义的选项在后面，因此如果有同名的name的话默认的会被自定义的覆盖\n                value = getattr(m, name)\n                setattr(self, name, value)\n\n\n# 只要以后导入这个settings就可以进行使用了。\nsettings = Settings()\n```\n\n调用：\n\n```python\n# bin/start.py\nimport os\n\n# 引用集成的文件就可以拿到对应的配置文件了。\nfrom lib.conf.config import settings\n\n# 全局变量做赋值，这个只在当前的运行的应用程序的环境变量里\n# 运行完了就没了，这个并不影响其他的程序。\nos.environ[\'USER_SETTINGS\'] = \'config.settings\'\n\nprint(settings.USER)\nprint(settings.EMAIL)\nprint(settings.MODE)\nprint(settings.BANNER)\n\n# 执行结果：\nlamber\n1020561033@qq.com\nAGENT\nHello World!\n```\n\n这样我们就可以取到想要的默认配置和用户配置了。\n\n## 可插拔式插件\n\n> 作为数据采集和cmdb数据录入的中间人的中控机来讲，中控机具有采集客户端各个指标的功能，我们把这些采集指标的功能叫做功能插件，这个插件应该可以是灵活的进行管控的，就好像Django中的INSTALLED_APP，允许我们自己进行添加和删除。针对这个需求进行可插拔式插件的设计。\n\n可插拔式的插件对于用户来说是可以进行自己控制和定义的。因此可以在用户自定义配置文件中去进行配置。在项目根目录的src目录下新建一个plugins目录用于保存我们的自定义插件，每一个插件就是一个一个小的监控脚本，比如：\n\n```shell\n➜  plugins > tree\n.\n├── __init__.py\n└── basic.py\n```\n\n既然是允许用户可以自定义的，那么就允许用户在setting配置文件中进行配置的。我们可以构造一个字典，其中key为要监控的对应的指标，value为对应插件所在路径，比如如下样式：\n\n```python\nPLUGINS_DICT = {\n    \'basic\': \"src.plugins.basic.Basic\",\n}\n```\n\nPython Package中的`__init__.py`文件会在模块被导入的时候执行，为了保证导入模块的时候，我们的组件全部加载执行并获取到数据，我们可以把对应的内容获取脚本写到plugins目录下的`__init__.py`中去。\n\n```python\nimport importlib\nimport subprocess\nimport paramiko\n# 将用户配置的可插拔插件的配置项导入\nfrom lib.conf.config import settings\n\n\nclass PluginManager(object):\n\n    def __init__(self, hostname=None):\n        \"\"\"\n        把用到的内容都放到构造方法里清晰明了\n        因为采集方式不一样，那么有的需要主机名，有的也就不需要\n        需要的话就传递，不需要的话就默认为None\n        \"\"\"\n        # 这个用户名我们在构造函数中传递一下，如果说传递了就用传递的，没有传递默认None。\n        self.hostname = hostname\n        # 先把可插拔配置项拿到，这里拿到的就是一个小字典\n        self.plugin_dict = settings.PLUGINS_DICT\n        # 获取的方式有agent，ssh或者salt三种，这个是允许用户在配置文件里配置的。\n        self.mode = settings.MODE\n        # 是否打开调试模式\n        self.debug = settings.DEBUG\n        # 如果当方式为ssh的模式，那么就需要ssh所必须的地址，端口，密码，或者是密钥\n        if self.mode == \"SSH\":\n            self.ssh_user = settings.SSH_USER\n            self.ssh_port = settings.SSH_PORT\n            self.ssh_pwd = settings.SSH_PWD\n            self.ssh_key = settings.SSH_KEY\n\n    def exec_plugin(self):\n        \"\"\"\n        获取所有的插件，执行并获取插件的返回值\n        :return: 插件的返回值\n        \"\"\"\n        # 构造一个空字典\n        response = {}\n        for k, v in self.plugin_dict.items():\n            \"\"\"\n            循环遍历可插拔配置中的每一条记录项目，内容示例如下：\n            k = \'basic\'，v = \"src.plugins.basic.Basic\",\n            需要导入模块然后运行再拿到模块的返回值，因此需要我们进行拆分\n            \"\"\"\n            # rsplit表示从右面才是切割，1表示切一次，如此切割可以将模块路径和模块名切开\n            # 比如module_path=\'src.plugin.basic\'，class_name=\'Basic\'\n            module_path, class_name = v.rsplit(\'.\', 1)\n            m = importlib.import_module(module_path)\n            # 根据模块名去找类。\n            cls = getattr(m, class_name)\n            if cls:\n                # 根据v获取类，并执行其对应的process方法采集资产\n                # 这里直接把命令执行方法的内存地址传递了过去，供插件进行调用。\n                # 拿到插件的返回值以后更新字典\n                result = cls().process(self.command)\n                response[k] = result\n        return response\n\n    def command(self, cmd):\n\t\t\"\"\"\n\t\t对应的执行命令的方法，我们知道获取数据有三种方案，agent，ssh或者是salt\n\t\t那么难道每次执行都要重新写一遍这三种方法么？当然不用。我们可以定义一个基类，在基类\n\t\t中去实现这三种方法，然后后面的所有插件都继承这个基类就可以了，就可以在插件类中直接调用\n\t\t这里没有采用继承的方案，而是自己去构造了一个内部的方法去实现。根据配置文件中设置的不同\n\t\tMODE，我们判断去执行不同的方法。\n\t\t\"\"\"\n        if self.mode == \"AGENT\":\n            \"调用subprocess\"\n            return self.__agent(cmd)\n        elif self.mode == \"SSH\":\n            return self.__ssh(cmd)\n        elif self.mode == \"SALT\":\n            return self.__salt(cmd)\n        else:\n            raise Exception(\'模式只能是AGENT/SSH/SALT\')\n\n    def __agent(self, cmd):\n        \"\"\"\n        单下划线：私有的，外部不能访问，外部也无需关心。\n        :param cmd:\n        :return:\n        \"\"\"\n        output = subprocess.getoutput(cmd)\n        return output\n\n    def __ssh(self, cmd):\n        # private_key = paramiko.RSAKey.from_private_key_file(self.ssh_key)\n        # ssh = paramiko.SSHClient()\n        # ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        # ssh.connect(hostname=self.hostname, port=self.ssh_port, username=self.ssh_user, pkey=private_key)\n        # stdin, stdout, stderr = ssh.exec_command(cmd)\n        # result = stdout.read()\n        # ssh.close()\n\t\t\"\"\"\n\t\tssh存在两种方式，一种为账号密码端口，一种直接采用密钥。\n\t\t\"\"\"\n        ssh = paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        ssh.connect(hostname=self.hostname, port=self.ssh_port, username=self.ssh_user, password=self.ssh_pwd)\n        stdin, stdout, stderr = ssh.exec_command(cmd)\n        result = stdout.read()\n        ssh.close()\n        return result\n\n    def __salt(self, cmd):\n        \"\"\"\n        salt只能运行在python2中。python3支持不是很好。\n        所以在python3中可以使用subprocess来仿制一下salt\n        :param cmd:\n        :return:\n        \"\"\"\n        # import salt.client\n        # local = salt.client.LocalClient()\n        # result = local.cmd(self.hostname, \'cmd.run\', [cmd])\n        # return result[self.hostname]\n        salt_cmd = \"salt \'%s\' cmd.run \'%s\'\" % (self.hostname, cmd,)\n        output = subprocess.getoutput(salt_cmd)\n        return output\n```\n\n到此为止，整个插件调用的过程就写完了。最后exec_plugins会给我们把数据获取的所有字典给返回过来。接下来就是插件的具体实现。配置文件中我们配置了basic，我们就可以先来实现这个内容。假定MODE目前为agent模式，我们采用subprocess去调用。\n\n从插件调用的过程中，我们知道插件内部需要存在一个process方法。这里首先模拟一个数据，查看是否能够真正的拿到数据，最后真实的数据要通过subprocess模块动态的去获取，这里举一个插件的例子：\n\n```python\nclass Basic(object):\n    def __init__(self):\n        pass\n\n    def process(self, command_func, debug):\n        if debug:\n            output = {\n                \'os_platform\': \"linux\",\n                \'os_version\': \"CentOS release 6.6 (Final)\\nKernel \\r on an \\m\",\n                \'hostname\': \'c1.com\'\n            }\n        return output\n```\n\n在入口文件进行调用(bin/start.py)：\n\n```python\nimport os\nimport sys\n\n# 全局变量做赋值，这个只在当前的运行的应用程序的环境变量里\n# 运行完了就没了，这个并不影响其他的程序。\nos.environ[\'USER_SETTINGS\'] = \'config.settings\'\n# 因为要导入的src在start.py的上级目录下，因此首先将整个项目目录添加到path中。\nBASEDIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.append(BASEDIR)\n\n\n# 引用集成的文件就可以拿到对应的配置文件了。\nfrom lib.conf.config import settings\n# 在导入的plugins模块的时候__init__.py文件会自动执行然后加载所有模块并拿到对应的返回值。\nfrom src.plugins import PluginManager\n\nif __name__ == \'__main__\':\n    server_info = PluginManager().exec_plugin()\n    print(server_info)\n```\n\n最后打印出来的结果如下，假如说我们添加了其他的插拔式组件的话，其他的组件内容也会被假如到这里面来，最后形成一个大字典：\n\n```python\n{\n    \'basic\': {\n        \'os_platform\': \'linux\', \n        \'os_version\': \'CentOS release 6.6 (Final)\\nKernel \\r on an \\\\m\', \n        \'hostname\': \'c1.com\'\n    }\n}\n```\n\n### 针对可插拔插件预留钩子\n\n> 在上面的入口文件我们可以发现我们直接去实例化PluginManager然后调用exec_plugin方法，在这个过程中是依次去实例化每一个插件类，然后调用插件类的process方法。如果以后有这么一个需求，在实例化之前先去做一些什么操作的话这样现在的逻辑就不支持了。因此针对这个问题预留一个钩子。\n\n在每一个插件类中定义一个initial的类方法，通过这个方法实现实例化之前的一系列操作。\n\n```python\nclass Basic(object):\n    def __init__(self):\n        pass\n\n    @classmethod\n    def initial(cls):\n        \"这里可以写点实例化之前要做的操作。方便入口拓展\"\n        return cls()\n\n    def process(self, command_func, debug):\n        …………………………\n        return output\n```\n\n然后在plugins中的`__init__.py`文件中进行判断对应的模块类中是否有这个方法。如下为对PluginManager中的exec_plugins方法的改进：\n\n```python\ndef exec_plugin(self):\n    \"\"\"\n    获取所有的插件，执行并获取插件的返回值\n    :return: 插件的返回值\n    \"\"\"\n    response = {}\n    for k, v in self.plugin_dict.items():\n        # k = \'basic\'\n        # v = \"src.plugins.basic.Basic\",\n        # rsplit表示从右面才是切割，1表示切一次\n        module_path, class_name = v.rsplit(\'.\', 1)\n        m = importlib.import_module(module_path)\n        # 根据模块名去找类。\n        cls = getattr(m, class_name)\n        if hasattr(cls, \'initial\'):\n            obj = cls.initial()\n        else:\n            # 根据v获取类，并执行其对应的process方法采集资产\n            obj = cls()\n        result = obj.process(self.command, self.debug)\n        response[k] = result\n    return response\n```\n\n### 资产采集之错误堆栈信息\n\n上面的资产采集插件内容我们都是写死的，而实际过程中我们是需要去动态的获取的，比如这样：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport os\n\n\nclass Basic(object):\n    def __init__(self):\n        pass\n\n    @classmethod\n    def initial(cls):\n        return cls()\n\n    def process(self, command_func, debug):\n        if debug:\n            output = {\n                \'os_platform\': command_func(\"uname\").strip(),\n                \'os_version\': \"Darwin 马晓雨的MBP 17.4.0 Darwin Kernel Version 17.4.0: Sun Dec 17 09:19:54 PST 2017; root:xnu-4570.41.2~1/RELEASE_X86_64 x86_64\",\n                \'hostname\': \'马晓雨的MBP\'\n            }\n        else:\n            output = {\n                \'os_platform\': command_func(\"uname\").strip(),\n                \'os_version\': command_func(\"cat /etc/issue\").strip().split(\'\\n\')[0],\n                \'hostname\': command_func(\"hostname\").strip(),\n            }\n        return output\n```\n\n这里设置一个debug其实就是方便调试，也就是拿我们写死的数据，如果非调试模式就是直接通过subprocess去动态执行命令拿返回值。那么执行命令就有可能存在执行失败报错，那么我们就需要捕获这个报错，因此针对执行命令的入口，PluginManager的exec_plugins方法进行修改：\n\n```python\ndef exec_plugin(self):\n    response = {}\n    for k, v in self.plugin_dict.items():\n        # 在这里再套一个字典，设置data和status命令执行状态，默认执行成功，status为true\n        # 这里status表示采集数据是否成功，如果成功data字段就有数据，如果不成功，字段就没有数据\n        ret = {\'status\': True, \'data\': None}\n        # 在结果获取的过程中设置try except去捕获可能出现的报错\n        try:\n            module_path, class_name = v.rsplit(\'.\', 1)\n            m = importlib.import_module(module_path)\n            # 根据模块名去找类。\n            cls = getattr(m, class_name)\n            if hasattr(cls, \'initial\'):\n                obj = cls.initial()\n            else:\n                obj = cls()\n            result = obj.process(self.command, self.debug)\n            ret[\'data\'] = result\n        except Exception as e:\n            # 如果捕获到报错的话，那么获取结果状态设置为false，并且将错误堆栈信息记录到ret\n            ret[\'status\'] = False\n            ret[\'data\'] = \"[%s][%s] 采集数据出现错误 : %s\" %(self.hostname if self.hostname else \"AGENT\", k, traceback.format_exc())\n        response[k] = ret\n    return response\n```\n\n这里针对记录的错误堆栈信息不是<u>单纯的打印exception捕获的e</u>，这个e仅仅是错误内容，而我们需要的是把捕获到的整个堆栈信息全部都捕获到，确保用户知道出错了以后定位到某一个文件的具体某一个位置。\n\n**可插拔式插件的设计体现了高内聚,低耦合的特性**\n\n- 高内聚：一个功能在它自己内部全部完成。\n\n- 低耦合：插件和其他的没有关系，它自己是一个独立的整体。\n\n## 通过API拿到采集的信息\n\n>现在我的中控机上已经可以拿到数据了，那么这个数据采集了以后我怎么提供给cmdb服务端，将采集的信息录入到CMDB呢？这里就要通过API了。\n>\n>- Agent模式\n>\n>  针对agent客户端模式，向API发送报告资产信息，比如agent多久采集一次，然后给api发送信息就可以了。发送过去直接采集入库。\n>\n>- SSH、SALT，存在中控机。\n>\n>  1. 首先来获取采集的主机列表\n>  2. 循环主机列表，采集资产，发送到API\n\n实现一个工具类，src/client.py。在书写这个之前，针对ssh和salt模式需要讨论一下采集效率的问题。当机器比较多的时候比如100台甚至更多的时候，如果通过for循环去一台一台的获取的话效率是很低的，因为这个过程是串行的，执行完一个再执行下一个，因此针对这个问题，可以采用多线程或者多进程去提高并发去处理，由于这个操作是IO（网络IO）密集型的，而不是计算密集型的，因此我们使用线程池就可以了。\n\n即使是多线程也不能无限制的开启，因为多线程的上下文切换也会有很多的损耗。因此我们要设置一个限制，使用线程池去控制开启的现成数量。针对python2和python3来说，python2只有进程池没有线程池，python3是既有线程池，也有进程池。来看一下线程池示例代码：\n\n```python\nimport time\n# 线程池和进程池的切换也很方便，切换个单词就行了\nfrom concurrent.futures import ThreadPoolExecutor\n# from concurrent.futures import ProcessPoolExecutor\n\n\ndef task(i):\n    time.sleep(1)\n    print(i)\n\n\n# 最多开10个线程\np = ThreadPoolExecutor(10)\nfor row in range(100):\n    # 在线程池拿一个线程去执行，接收两个参数，一个任务名称，一个执行任务接收的参数\n    # 看打印结果我们就可以看到是十个十个出来的\n    p.submit(task, row)\n```\n\n将线程池应用到API获取工具类的SSHSALT部分。\n\n### API实现代码\n\n```python\nimport requests\nimport json\nfrom src.plugins import PluginManager\nfrom lib.conf.config import settings\nfrom concurrent.futures import ThreadPoolExecutor\n\n\nclass Base(object):\n\t\"\"\"定义一个基类，定义基础向远程发送资产信息的方法，通过requests发送\"\"\"\n    def post_asset(self, server_info):\n        \"\"\"\n        向远程地址发其实就是向API发，这个API可以先定义在settings配置文件中。我们取的时候直接导入settings然后使用settings.API取就行了。那么，我们要发什么？当然是发server的数据，我们采集到的数据其实是一个大字典。\n        requests.post可以接受两个参数，第一个是要请求的api地址，第二个要发送的就是请求的数据，比如data={xxx}或者json={xxx}，如果使用json={xxx}的形式的话那么它会在内部给你做一个json.dumps的转换给你转换成字符串以后再给你发过去。\n        发过来以后服务端怎么接受呢？其实所有的原生值都在request.body中，request.post是根据body中的特殊请求头部拿出来的内容，因此我们发送的内容就放到了请求体里，同时设置了header请求头，这个时候request.post是没有值的。request.post只有在请求头是：application/x-www-form-urlencoded的时候才会把内容放到request.post，并且这里也不能把这些数据放到request.POST中去。在ajax提交的时候，data中key值对应的value值可以是字符串，数字，数组但是不能是字典格式，我们要把这个字典序列化一下变成字符串才可以。这里其实也是一个道理。因此不能把我们提交的这个数据扔到request.post里去。\n        body: json.dumps(server_info)\n        headers= {\'content-type\':\'application/json\'}\n        \n        # 那么再django后台取数据的时候只能用下面这种方法来取。\n        request.body\n        json.loads(request.body)\n        \"\"\"\n        requests.post(settings.API, json=server_info)\n\n\nclass Agent(Base):\n\n    def execute(self):\n        server_info = PluginManager().exec_plugin()\n        self.post_asset(server_info)\n\nclass SSHSALT(Base):\n    def get_host(self):\n        # 获取未采集的主机列表：\n        response = requests.get(settings.API)\n        # \"{status:\'True\',data: [\'c1.com\',\'c2.com\']}\"\n        # 这里拿到的数据是一个一个的主机名\n        result = json.loads(response.text) \n        if not result[\'status\']:\n            return\n        return result[\'data\']\n    \n    def run(self,host):\n        # 定义发送API信息的任务\n        server_info = PluginManager(host).exec_plugin()\n        self.post_asset(server_info)\n\n    def execute(self):\n\t\t# 获取主机列表\n        host_list = self.get_host()\n        # 建立一个线程池，池子大小为10\n        pool = ThreadPoolExecutor(10)\n        for host in host_list:\n            # 循环并发执行采集信息任务\n            pool.submit(self.run, host)\n```\n\n使用一个脚本去调用api工具类：\n\n```python\n# src/script.py\nfrom lib.conf.config import settings\nfrom .client import Agent\nfrom .client import SSHSALT\n\n\ndef run():\n    if settings.MODE == \"AGENT\":\n        obj = Agent()\n    else:\n        obj = SSHSALT()\n    obj.execute()\n```\n\n最后在入口文件start.py去调用：\n\n```python\nfrom src import script\nif __name__ == \'__main__\':\n    script.run()\n```\n\n## 主机唯一标识\n\n一般来说，都会认为主板的SN号，是唯一标识，不过针对的这个是物理机，也就是说如果是物理机的话那么就可以认为这个SN号是唯一的。如果是虚拟机的话分为虚要采集和不需要采集，如果需要采集的话那么就不能用SN号了，不然采集出来的SN号都是一样的。一堆虚拟机都是一样的SN号，这样做不到唯一的标识。\n\n**因此需要做标准化：**\n\n- 主机名的标准化：主机名不能重复，需要依赖本地文件。FQDN应该是唯一并且有意义的。\n  1. 新机装系统初始化软件，运行CMDB。\n     - 通过命令获取主机名\n     - 写入本地的指定的文件\n  2. 将资产信息发送给api\n  3. 获取资产信息\n     - 本地文件主机名 ≠ 命令获取的主机名（按照文件的主机名）\n     - 本地文件主机名 == 命令获取的文件主机名\n- 流程的标准化：\n  - 装机的时候，需要将服务信息录入CMDB\n    - 资产录入，机房，机柜，机柜位置\n    - 装机的时候，需要将服务信息录入CMDB，可以利用cobbler，这个时候已经知道主机名\n    - 资产采集，获取主机名，从cmdb找到然后添加数据。有就操作，没有就忽略操作。\n\n**最终流程：**\n\n- 标准化：主机名不重复，流程的标准化（装机的同时，主机名在cmdb中设置）\n\n**服务器资产采集（Agent）：**\n\n1. 第一次：文件不存在，或内容为空：\n2. 资产采集：\n   - 主机名写入文件\n   - 发送API\n3. 第n次：采集资产，主机名，从文件中获取。\n\n**SSH或者SALT（有中控机存在）：**\n\n- 中控机：获取未采集主机名列表：拿到主机名，采集主机信息然后返回。\n\n### 唯一标识实现代码\n\n```python\n# 修改采集用户api信息工具类的Agent工具类部分\nclass Agent(Base):\n\n    def execute(self):\n        server_info = PluginManager().exec_plugin()\n        # 首先获取到第一次的唯一标识，也就是主机名，这个就是新装系统的时第一次获取用于唯一标识\n        hostname = server_info[\'basic\'][\'data\'][\'hostname\']\n        # 获取到的内容拟放在config目录下的cert文件中保存\n        with open(settings.CERT_PATH, \'r\', encoding=\"utf-8\") as certfile:\n            certname = certfile.read().strip()\n            # 如果打开的cert文件没有内容我们就把内容写进去\n            if not certname:\n                with open(settings.CERT_PATH,\'w\',encoding=\'utf-8\') as f:\n                    f.write(hostname)\n            else:\n                # 如果有内容还涉及到本地文件主机名和命令获取的主机名一致不一致的问题，\n                # 默认以文件获取的为准，因此就直接等于文件读取到的certname\n                # 所以你手动改了主机名也没事。因为有唯一的标准参考\n                server_info[\'basic\'][\'data\'][\'hostname\'] = certname\n\n        self.post_asset(server_info)\n```\n\n\n\n","timestamp":1540354517190},{"name":"03-CMDB服务端设计.md","path":"04-Django/50-项目实战/01-CMDB/03-CMDB服务端设计.md","content":"# CMDB AutoServer设计\n\n> 一部分做api一部分做后台管理，根据这样的需求可以做两个app。\n\n## API\n\n在上一节的AutoClient设计中，已经可以通过API向服务端发送消息了，现在可以简单的测试一下服务端接收消息了。\n\n- 首先新建AutoServer端项目\n\n  ```python\n  # 进入虚拟环境\n  workon cmdb\n  # 创建django project\n  cd workspace\n  django-admin startproject autoserver\n  # 新建两个django的app项目，一个用来做api，一个用来做server的后台\n  python manage.py startapp api\n  python manage.py startapp backend\n  ```\n\n- 在全局url路径中引入api项目的路由\n\n  ```python\n  from django.contrib import admin\n  from django.urls import path, include\n  \n  urlpatterns = [\n      path(\'admin/\', admin.site.urls),\n      path(\'api/\', include(\'api.urls\'))\n  ]\n  ```\n\n- 书写api路由\n\n  ```python\n  from django.urls import path, re_path\n  from api import views\n  \n  urlpatterns = [\n      re_path(\'asset.html$\', views.asset),\n  ]\n  ```\n\n- 书写视图函数，先简单一点。\n\n  ```python\n  from django.shortcuts import render, HttpResponse\n  \n  # Create your views here.\n  def asset(request):\n      if request.method == \"POST\":\n          print(request.POST)\n          print(request.body)\n          return HttpResponse(\'...\')\n      \n  \n      \n  \n  - 在client端发送数据，当前client端的mode为agent，那么会将采集的内容，发送过来，这里我们打印了request.POST和request.body，由于在client端发送的时候，header为`application/json`的，因此这里的request.POST是拿不到数据的，可以发现第一个querydict为空。\n  \n  \n  <QueryDict: {}>   // 这里是打印的request.POST\n  b\'{\"basic\": {\"status\": true, \"data\": {\"os_platform……………………………………略  // request.Body\n  ```\n\n## Backend服务端\n\n### Server端数据库设计\n\napi采集的信息要入库，api要使用这些表，后台同时也会使用这些表，那么数据库表的模型应该放在哪一个app下呢？其实放在哪一个下面都对。放在api中比较好，当然拆出来也是可以的，因此把数据库模型这块单独拆出来，作为一个数据库访问层单独来提供数据的访问来进行统一管理。\n\n```python\n# MTV中的Model层，单独创建这一个app只放数据库模型。因为api或者backend都要进行数据库，那么可能api这个app内写一部分的数据操作逻辑，backend写一部分的数据操作逻辑。比起这个方案来说还有一个更好的方案那就是把公共的部分调用逻辑都写到resposity这个app里面，其他的app直接调用就可以了。\npython manage.py startapp repository\n```\n\n### 模型类\n\n```python\nfrom django.db import models\n\n\nclass UserProfile(models.Model):\n    \"\"\"\n    用户信息，为什么要用用户信息，因为不管是一个业务线，还是一组机器都要有人管理。\n    \"\"\"\n    name = models.CharField(u\'姓名\', max_length=32)\n    email = models.EmailField(u\'邮箱\')\n    phone = models.CharField(u\'座机\', max_length=32)\n    mobile = models.CharField(u\'手机\', max_length=32)\n\n    class Meta:\n        verbose_name_plural = \"用户表\"\n\n    def __str__(self):\n        return self.name\n\n\nclass AdminInfo(models.Model):\n    \"\"\"\n    用户登陆相关信息，只有管理员才能能力登录系统。userinfo包含所有的用户这里的是具备管理能力的负责人\n    \"\"\"\n    user_info = models.OneToOneField(\"UserProfile\", on_delete=models.CASCADE)\n    username = models.CharField(u\'用户名\', max_length=64)\n    password = models.CharField(u\'密码\', max_length=64)\n\n    class Meta:\n        verbose_name_plural = \"管理员表\"\n\n    def __str__(self):\n        return self.user_info.name\n\n\nclass UserGroup(models.Model):\n    \"\"\"\n    用户组\n    \"\"\"\n    name = models.CharField(max_length=32, unique=True)\n    users = models.ManyToManyField(\'UserProfile\')\n\n    class Meta:\n        verbose_name_plural = \"用户组表\"\n\n    def __str__(self):\n        return self.name\n\n\nclass BusinessUnit(models.Model):\n    \"\"\"\n    业务线，比如把哪些业务线分给哪个业务线。\n    \"\"\"\n    name = models.CharField(\'业务线\', max_length=64, unique=True)\n    # 系统管理员和业务负责人不应该只有一个人，应该是一个用户组\n    contact = models.ForeignKey(\'UserGroup\', verbose_name=\'业务负责人\', related_name=\'c\', on_delete=models.CASCADE)\n    manager = models.ForeignKey(\'UserGroup\', verbose_name=\'系统管理员\', related_name=\'m\', on_delete=models.CASCADE)\n\n    class Meta:\n        verbose_name_plural = \"业务线表\"\n\n    def __str__(self):\n        return self.name\n\n\nclass IDC(models.Model):\n    \"\"\"\n    机房信息\n    \"\"\"\n    name = models.CharField(\'机房\', max_length=32)\n    floor = models.IntegerField(\'楼层\', default=1)\n\n    class Meta:\n        verbose_name_plural = \"机房表\"\n\n    def __str__(self):\n        return self.name\n\n\nclass Tag(models.Model):\n    \"\"\"\n    资产标签\n    \"\"\"\n    name = models.CharField(\'标签\', max_length=32, unique=True)\n\n    class Meta:\n        verbose_name_plural = \"标签表\"\n\n    def __str__(self):\n        return self.name\n\n\nclass Asset(models.Model):\n    \"\"\"\n    资产信息表，所有资产公共信息（交换机，服务器，防火墙等）\n    之所以要设置资产表，因为不同的设备采集的内容不一样，十个资产里比如有五个服务器，五个路由器\n    因此将资产要单独拿出来。\n    \"\"\"\n    device_type_choices = (\n        (1, \'服务器\'),\n        (2, \'交换机\'),\n        (3, \'防火墙\'),\n        (4, \'路由器\'),\n    )\n    device_status_choices = (\n        (1, \'上架\'),\n        (2, \'在线\'),\n        (3, \'离线\'),\n        (4, \'下架\'),\n    )\n\n    device_type_id = models.IntegerField(choices=device_type_choices, default=1, verbose_name=\"资产类型\")\n    device_status_id = models.IntegerField(choices=device_status_choices, default=1)\n\n    cabinet_num = models.CharField(\'机柜号\', max_length=30, null=True, blank=True)\n    cabinet_order = models.CharField(\'机柜中序号\', max_length=30, null=True, blank=True)\n\n    idc = models.ForeignKey(\'IDC\', verbose_name=\'IDC机房\', null=True, blank=True, on_delete=models.CASCADE)\n    # 这个资产到底是哪一个业务线的\n    business_unit = models.ForeignKey(\'BusinessUnit\', verbose_name=\'属于的业务线\', null=True, blank=True, on_delete=models.CASCADE)\n\n    tag = models.ManyToManyField(\'Tag\')\n\n    latest_date = models.DateField(null=True)\n    create_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        verbose_name_plural = \"资产表\"\n\n    def __str__(self):\n        return \"%s-%s-%s\" % (self.idc.name, self.cabinet_num, self.cabinet_order)\n\n\nclass Server(models.Model):\n    \"\"\"\n    服务器信息，关于服务器的信息，有些是一对多关系，比如一台服务器有多个硬盘\n    但是有些只有一条属性的，比如主板SN号，系统版本等。直接扔在server信息里就可以了，无需多建一个表\n    \"\"\"\n    # 资产和设备是一对一的关系，通过这个字段就可以跨到资产表去拿一些资产信息，比如在哪个机柜什么的。\n    asset = models.OneToOneField(\'Asset\', on_delete=models.CASCADE)\n    hostname = models.CharField(max_length=128, unique=True)\n    sn = models.CharField(\'SN号\', max_length=64, db_index=True)\n    manufacturer = models.CharField(verbose_name=\'制造商\', max_length=64, null=True, blank=True)\n    model = models.CharField(\'型号\', max_length=64, null=True, blank=True)\n\n    manage_ip = models.GenericIPAddressField(\'管理IP\', null=True, blank=True)\n\n    os_platform = models.CharField(\'系统\', max_length=16, null=True, blank=True)\n    os_version = models.CharField(\'系统版本\', max_length=16, null=True, blank=True)\n\n    cpu_count = models.IntegerField(\'CPU个数\', null=True, blank=True)\n    cpu_physical_count = models.IntegerField(\'CPU物理个数\', null=True, blank=True)\n    cpu_model = models.CharField(\'CPU型号\', max_length=128, null=True, blank=True)\n\n    create_at = models.DateTimeField(auto_now_add=True, blank=True)\n\n    class Meta:\n        verbose_name_plural = \"服务器表\"\n\n    def __str__(self):\n        return self.hostname\n\n\nclass NetworkDevice(models.Model):\n    asset = models.OneToOneField(\'Asset\', on_delete=models.CASCADE)\n    management_ip = models.CharField(\'管理IP\', max_length=64, blank=True, null=True)\n    vlan_ip = models.CharField(\'VlanIP\', max_length=64, blank=True, null=True)\n    intranet_ip = models.CharField(\'内网IP\', max_length=128, blank=True, null=True)\n    sn = models.CharField(\'SN号\', max_length=64, unique=True)\n    manufacture = models.CharField(verbose_name=u\'制造商\', max_length=128, null=True, blank=True)\n    model = models.CharField(\'型号\', max_length=128, null=True, blank=True)\n    port_num = models.SmallIntegerField(\'端口个数\', null=True, blank=True)\n    device_detail = models.CharField(\'设置详细配置\', max_length=255, null=True, blank=True)\n\n    class Meta:\n        verbose_name_plural = \"网络设备\"\n\n\nclass Disk(models.Model):\n    \"\"\"\n    硬盘信息，一个服务器可以有多个硬盘，多个槽位，每个硬盘的大小可能不一样\n    \"\"\"\n    slot = models.CharField(\'插槽位\', max_length=8)\n    model = models.CharField(\'磁盘型号\', max_length=32)\n    capacity = models.FloatField(\'磁盘容量GB\')\n    pd_type = models.CharField(\'磁盘类型\', max_length=32)\n    server_obj = models.ForeignKey(\'Server\', related_name=\'disk\', on_delete=models.CASCADE)\n\n    class Meta:\n        verbose_name_plural = \"硬盘表\"\n\n    def __str__(self):\n        return self.slot\n\n\nclass NIC(models.Model):\n    \"\"\"\n    网卡信息\n    \"\"\"\n    name = models.CharField(\'网卡名称\', max_length=128)\n    hwaddr = models.CharField(\'网卡mac地址\', max_length=64)\n    netmask = models.CharField(max_length=64)\n    ipaddrs = models.CharField(\'ip地址\', max_length=256)\n    up = models.BooleanField(default=False)\n    server_obj = models.ForeignKey(\'Server\', related_name=\'nic\', on_delete=models.CASCADE)\n\n    class Meta:\n        verbose_name_plural = \"网卡表\"\n\n    def __str__(self):\n        return self.name\n\n\nclass Memory(models.Model):\n    \"\"\"\n    内存信息\n    \"\"\"\n    slot = models.CharField(\'插槽位\', max_length=32)\n    manufacturer = models.CharField(\'制造商\', max_length=32, null=True, blank=True)\n    model = models.CharField(\'型号\', max_length=64)\n    capacity = models.FloatField(\'容量\', null=True, blank=True)\n    sn = models.CharField(\'内存SN号\', max_length=64, null=True, blank=True)\n    speed = models.CharField(\'速度\', max_length=16, null=True, blank=True)\n\n    server_obj = models.ForeignKey(\'Server\', related_name=\'memory\', on_delete=models.CASCADE)\n\n    class Meta:\n        verbose_name_plural = \"内存表\"\n\n    def __str__(self):\n        return self.slot\n\n\nclass AssetRecord(models.Model):\n    \"\"\"\n    资产变更记录,creator为空时，表示是资产汇报的数据。\n    \"\"\"\n    # 到底是哪一个资产变更了？通过资产就能找到具体的设备\n    asset_obj = models.ForeignKey(\'Asset\', related_name=\'ar\', on_delete=models.CASCADE)\n    # 要有资产变更的内容，比如内存有多少提升到了多少，哪个槽位的硬盘被拿出来了。比如核心路由的板卡卸载掉等\n    content = models.TextField(null=True)\n    # 谁变更了资产？因此要和用户也有一个关联，如果为空就是自动采集，如果不为空就是某个人修改的。因此设置可以为空\n    creator = models.ForeignKey(\'UserProfile\', null=True, blank=True, on_delete=models.CASCADE)\n    create_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        verbose_name_plural = \"资产记录表\"\n\n    def __str__(self):\n        return \"%s-%s-%s\" % (self.asset_obj.idc.name, self.asset_obj.cabinet_num, self.asset_obj.cabinet_order)\n\n\nclass ErrorLog(models.Model):\n    \"\"\"\n    错误日志,如：agent采集数据错误 或 运行错误\n    \"\"\"\n    asset_obj = models.ForeignKey(\'Asset\', null=True, blank=True, on_delete=models.CASCADE)\n    title = models.CharField(max_length=16)\n    content = models.TextField()\n    create_at = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        verbose_name_plural = \"错误日志表\"\n\n    def __str__(self):\n        return self.title\n\n```\n\n","timestamp":1540354517190},{"name":"04-资产入库.md","path":"04-Django/50-项目实战/01-CMDB/04-资产入库.md","content":"# 资产数据入库\n\n\n\n##  API验证\n\n> 首先为什么要做API验证？主要就是为了防止别随便来一个人都能从我这个接口这里拿数据，随便来一个人访问我的接口都能给我提交数据。保证数据一定的安全性。\n\n为了验证来访者是我们认识的，一个可用方案是可以让来访问的人带着一个我能认识的东西来访问这样就可以彼此达成共识。\n\n#### 静态token\n\n这个静态的token串是预先存在client和server端的，彼此预先做好交互的暗号。比如在客户端新建一个py文件做如下的操作：\n\n```python\n#!/usr/local/bin/python3\n\nimport requests\nkey = \"asdfasdfasdfasdf098712sdfs\"\nresponse = requests.get(\"http://127.0.0.1:8000/api/asset.html\",headers={\'OpenKey\':key})\nprint(response.text)\n```\n\n这里我们把这个key放到请求头里去，那么在server端应该如何去取呢？\n\n```python\n# 在视图函数中进行操作\ndef asset(request):\n    if request.method == \"GET\":\n        for k, v in request.META.items():\n            print(k, v)\n```\n\nrequest中有一个META数据，这个包含了发过来的请求的所有信息，通过查看内容我们就可以发现里面有一个键值对是`HTTP_OPENKEY`对应`asdfasdfasdfasdf098712sdfs`。value对应的正好就是我们发过来的字符串，但是key前面多了一个http，这个http是django为我们添加上的。然后我们把这个key和server端的key进行比较就可以，server端可以把这key扔到settings然后通过`from django.conf import settings`，然后通过settings进行调用。\n\n不过这种静态的认证字符串是有问题的，如果中间有第三者比如黑客截获以后你这个key是静态的不变的，那么黑客就可以拿过来自己写一个去为所欲为了。因此我们要对这个认证方案进行改进，改为动态的认证key。\n\n#### 动态token\n\n如果需要实现动态的token，可以采用两种方案，可以随着时间动起来，或者随着uuid动起来。这两个都能够成为唯一的辨识信息。因此对client端做如下的改动（以时间为唯一标准）：\n\n```python\nimport time\n# import uuid\nimport requests\nimport hashlib\n\n# 获取当前的时间戳，把key和time结合起来，首先让它动态起来。\nctime = time.time()\nkey = \"asdfasdfasdfasdf098712sdfs\"\nnew_key = \"%s|%s\" %(key, ctime,)\n\n# 避免内容是明文的，因此需要对这些内容需要一个加密\nm = hashlib.md5()\n# 在python3中，update后面接的内容是一个字节字符串，因此我们需要按照一定的编码转换一下\nm.update(bytes(new_key,encoding=\'utf-8\'))\n# 这个就是拿到的加密后的新key，这个key客户端在每一次调用的时候都是不一样的！因为时间戳在变。\n# 这里考虑一个问题，这个动态的内容是时刻在变的，那么服务端我怎么知道呢？服务端我只有一个key啊\n# 不可能这边加密操作一遍，然后在服务端再利用时间戳加密一遍，因为网络io是有时差的，加密后的值必定是不一样的，因此这里我们要把这个当前加密的时间戳给服务端发送过去才可以。\nmd5_key = m.hexdigest()\n\n# 将加密的key和时间戳拼接一下发送给服务端\nmd5_time_key = \"%s|%s\" %(md5_key,ctime)\n\nprint(md5_time_key)\nresponse = requests.get(\"http://127.0.0.1:8000/api/asset.html\",headers={\'OpenKey\':md5_time_key})\nprint(response.text)\n```\n\n在服务端处理\n\n```python\ndef asset(request):\n    \n    if request.method == \"GET\":\n        # 从META数据中拿到客户端封装到请求头的数据，一个是加密的key另外一个是客户端的时间戳\n        client_md5_key, client_ctime = request.META.get(\'HTTP_OPENKEY\').split(\'|\')\n        # 通过客户端的时间戳和服务端本地的key进行和客户端一样的加密认证，然后对比加密后值\n        auth_str = \"%s|%s\" % (settings.AUTH_KEY, client_ctime)\n        m = hashlib.md5()\n        m.update(bytes(auth_str, encoding=\'utf-8\'))\n        auth_code = m.hexdigest()\n        if auth_code == client_md5_key:\n            print(\'auth ok\')\n        else:\n            print(\'auth failed\')\n```\n\n经过上面这一番处理以后，我们的token也动态变化起来了。但是仍然存在bug的，假如说在发送过程中被截获的话，截获者拿到的就是`dfb9bb5f3b5ac49360eb3336b73ae043|1526372746.1284108`这样的一个内容，那么这个截获者带着这一串内容去请求我们的接口的话你会发现仍然是可以的，虽然我们的key对外部不是透明的，但是经过和时间戳加密后的值是可以对应上的，截获者不需要知道你的key的值就能通过接口拿到数据。\n\n不仅如此，现在可以访问接口的key变为无限制多个了，随便截获一个这个字符串都是有效的，可以认证成功，因此还需要改。需要添加上这些内容的时效性。让这些内容不是永久有效的。\n\n#### 为动态token添加时效\n\n首先说客户端其实每次发请求的时候都是结合自己的时间戳做字符串加密的，因此客户端每次发过来的加密的key应该都是不一样的。为了避免被\n\n\n\n\n\nAES加密：www.cnblogs.com/wupeiqi/articles/6746744.html\n\n\n\n\n\n后台序列化操作:\n\n有两种，一种是django内置的，另外一种是重写json方法。","timestamp":1540354517190},{"name":"05-API验证&AES加密.md","path":"04-Django/50-项目实战/01-CMDB/05-API验证&AES加密.md","content":"","timestamp":1540354517190},{"name":"06-CURD1.md","path":"04-Django/50-项目实战/01-CMDB/06-CURD1.md","content":"# 增删改查插件\n\n> 数据的采集以及录入已经完成，接下来就是将我们的数据展示出来，在autoserver项目中新建一个app名称为backend，用来做cmdb后台。本次实现插件的方法为基于前端的CURD插件，传递过来数据以后数据的展示是由JS动态生成的。\n\n## 后端项目准备工作\n\n**在主路由入口配置backend的路由设置**\n\n```python\nurlpatterns = [\n    path(\'admin/\', admin.site.urls),\n    path(\'api/\', include(\'api.urls\')),\n    path(\'backend/\', include(\'backend.urls\')),\n]\n```\n\n记得在settings中注册一下backend，否则app将无法正常使用，然后写第一个页面的展示\n\n```python\n# 路由\nurlpatterns = [\n    re_path(\'^curd.html$\', views.curd),\n    re_path(\'^curd_json.html$\', views.curd_json)\n]\n```\n\n**模板**\n\n模板，模板中，其实啥都没有，就放了一个div容器和一个table的框架，我们要将我们采集到的数据都在这里显示，具体的数据我们会通过js的ajax去请求然后动态的生成在页面上：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <link rel=\"stylesheet\" href=\"/static/css/bootstrap.css\">\n</head>\n<body>\n    <div style=\"width: 700px;margin: 0 auto;\">\n        <table class=\"table table-bordered table-hover\">\n            <thead id=\"tbhead\"></thead>\n            <tbody id=\"tbbody\"></tbody>\n\n    </table>\n    </div>\n\n    <script src=\"/static/js/jquery-3.3.1.js\"></script>\n    <script src=\"/static/js/bootstrap.js\"></script>\n    <script src=\"/static/js/backend.js\"></script>\n</body>\n</html>\n```\n\n**视图函数**\n\n对应的视图函数，实际的页面展示中，发起两个请求，第一次请求就是单独的展示这个html，这个html就是一个框架，或者叫一个模子。\n\n```python\ndef curd(request):\n   return render(request, \'backend/curd.html\')\n```\n\n第二个请求同时会向后台请求数据，为前端提供数据。要显示的数据有标题以及对应标题的内容。\n\n## Table_Config设计\n\n>  我们存到数据库里的数据最后要显示出来的，但是有的时候并不是所有字段我们都需要显示出来的，举个简单的例子，比如ID字段，这个就可以不显示。而我这里想要达到的效果是对这个显示的字段（标题头部）进行自定制，让前端显示啥，前端就显示啥。不想让某一个字段在前端显示直接在后端注销掉对应的字段就可以，因此提出table_config的这样一个设计。\n\n构造这样一个数据结构，table_config本身是一个列表，列表中套小字典，每一个小字典代表表头的一个字段，然后根据需要去扩展每一个字段。\n\n### table_config字段说明\n\n首先看一个table_config示例：\n\n```python\n[{\n    \'q\': \'sn\',\n    \'title\': \'SN号\',\n    \'display\': True,\n    \'text\': {\n        \'tpl\': \'{n1}\',\n        \'kwargs\': {\'n1\': \'@sn\'},\n    },\n},]\n```\n\n- q：即query，要查询的字段，比如主机名的q就是hostname，id的q就是id；因为我们这里完全是借助的django_orm去操作的。因此这里也可以使用跨表，反向查询的。当然这里的值也可以是None，None指的是这个字段不需要去数据库查询的时候设置的值；因为有的时候我们可能要在标题显示一列操作，这一列操作和数据本身没有什么关系，也不用去数据库拿值。\n\n- title：要显示在标题的名称。\n\n- display：是否显示当前字段，有的时候字段需要取，但是不一定要显示，比如id字段，我们可以去用来提交数据等，但是没必要显示，有的情况下可能也不是连续的，所以没有实际的意义就可以不显示\n\n- text：模板，根据模板我们可以定制最终在表格中展示的数据的最终形式。有的时候我们并不想让数据原原本本的就显示从数据库取出来的样子，我们有时候会给数据加上一个后缀或者前缀然后再在前端页面显示，这里就用到了模板，这个操作加强了我们的数据展示的可定制性。\n\n  ```python\n  # text本身就是一个小字典，其内部包含tpl以及kwargs两个key，其中tpl表示要展示在前端表格的模板，kwargs表示要填充进模板的参数。比如下面这个示例实际的tpl展示的就是一个a标签，然后nid会被对应的id替换到这个a标签中。这样就可以保证每个a标签中的nid都是跟随数据库中的id一致。\n  # 这里@id其实就是要替换的值为id字段的值，具体的处理我们会放到前端去做内容的匹配，你只要知道这里的@后面的其实和query的内容是一个意思就可以了。\n  \'text\': {\n      \'tpl\': \'<a href=\"/backend/del?nid={nid}\">删除</a>\',\n      \'kwargs\': {\'nid\': \'@id\'},\n  },\n      \n  # \n  ```\n\n简单的table_config说明完毕，当然这只是展示的一个页面或者仅仅是一个服务，比如在CMDB中，我要展示资产表，我有这样的一个table_config，当展示服务器表或者其他表的时候对应的字段根据models设计的不一样也是会发生变化的，因此针对不同的服务需要设置不同的table_config。\n\n### 取值&传值\n\n现在我们设计好了要拿的字段，接下来就是需要在数据库去取了。\n\n```python\n# 取的话还是很简单的，直接去遍历table_config然后过滤掉q为None的情况，因为查询的字段不允许出现None值。使用列表生成式构造一个values_list。\nvalues_list = [row[\'q\'] for row in table_config if row[\'q\']]\n```\n\n取数据的话那么就简单多了：\n\n```python\n# 取的时候支持*args列表，或者**kwargs字典，我们就可以把取号的values_list都扔在这里。\n# 最后拿到的这个资源列表就是我们最终想要的这么一个资源的query_set。\nresource_list = models.Server.objects.values(*values_list)\n```\n\n因为具体数据的生成是靠前端JS去动态的生成，因此我们将取出的数据值直接序列化一下丢给前端就可以了。这里提供了两种方法，其中一种借用django，另外一种自定制：\n\n1. 使用Django的序列化模块\n\n   ```python\n   # 可以使用序列化模块进行序列化，\n   v = models.Server.objects.all()\n   from django.core import serializers\n   # serializers可以针对queryset对象进行序列化。\n   data = serializers.serialize(\'json\', v)\n   ```\n\n2. 自己序列化\n\n   ```python\n   # 自己序列化想到的无非就是json.dumps一下，然后return给前端，不过json.dumps的时候需要注意几个问题，首先queryset对象是不可以序列化的，因为我们在上面的取出来的内容就是一个queryset，所以在返回给前端的时候要list一下，强制做一下类型的转换。或者你取的时候你就别取queryset就得了。直接拿列表\n   # 还有一个问题就是如果你取出来的值包含datetime对象的话同样也会造成序列化失败，同queryset，报错内容为：Object of type \'xxx\' is not JSON serializable。因此需要我们自己对默认的JSON做一个二次扩展，代码内容如下：\n   \n   from datetime import date, datetime\n   class JsonCustomEncoder(json.JSONEncoder):\n   \n       def default(self, value):\n           # 看要序列化的这个对象是不是datetime对象，如果是的话我们自己处理时间格式。\n           if isinstance(value, datetime):\n               return value.strftime(\'%Y-%m-%d %H:%M:%S\')\n           # 看要序列化的这个对象是不是date对象，如果是的话我们自己处理时间格式。\n           elif isinstance(value, date):\n               return value.strftime(\'%Y-%m-%d\')\n           # 如果不是的话那么就使用默认的\n           else:\n               return json.JSONEncoder.default(self, value)\n   \n   # json在调用的时候加一个cls参数。这样在每一个字段序列化的时候都会调用这个类的特殊方法，默认如果不填写的话调用的就是json.JSONEncoder\n   json.dumps(ret, cls=JsonCustomEncoder)\n   ```\n\n然后我们把数据返回给前端，前端就可以拿到数据了。\n\n```python\nret = {\n    \'server_list\': list(server_list),\n    \'table_config\': table_config,\n}\n```\n\n完整视图函数参考：\n\n```python\ndef curd_json(request):\n    table_config = [\n        {\n            \'q\': \'id\',\n            \'title\': \'ID\',\n            \'text\': {\n                \'tpl\': \'{n1}\',\n                \'kwargs\': {\'n1\': \'@id\'},\n            }\n        },\n        {\n            \'q\': \'hostname\',\n            \'title\': \'主机名\',\n            \'text\': {\n                \'tpl\': \'{n1}\',\n                \'kwargs\': {\'n1\': \'@hostname\'},\n            }\n        },\n        {\n            \'q\': \'create_at\',\n            \'title\': \'创建时间\',\n            \'text\': {\n                \'tpl\': \'{n1}\',\n                \'kwargs\': {\'n1\': \'@create_at\'},\n            }\n        },\n        {\n            \'q\': \'asset__cabinet_num\',\n            \'title\': \'机柜号\',\n            \'text\': {\n                \'tpl\': \'{n1}\',\n                \'kwargs\': {\'n1\': \'@asset__cabinet_num\'},\n            }\n        },\n        {\n            \'q\': \'asset__business_unit__name\',\n            \'title\': \'业务线名称\',\n            \'text\': {\n                \'tpl\': \'{n1}\',\n                \'kwargs\': {\'n1\': \'@asset__business_unit__name\'},\n            }\n        },\n        {\n            \'q\': None,\n            \'title\': \'操作\',\n            \'text\': {\n                \'tpl\': \'<a href=\"/backend/del?nid={nid}\">删除</a>\',\n                \'kwargs\': {\'nid\': \'@id\'},\n            }\n        },\n    ]\n    values_list = [row[\'q\'] for row in table_config if row[\'q\']]\n    server_list = models.Server.objects.values(*values_list)\n\n    class JsonCustomEncoder(json.JSONEncoder):\n\n        def default(self, value):\n            if isinstance(value, datetime):\n                return value.strftime(\'%Y-%m-%d %H:%M:%S\')\n            elif isinstance(value, date):\n                return value.strftime(\'%Y-%m-%d\')\n            else:\n                return json.JSONEncoder.default(self, value)\n    ret = {\n        \'server_list\': list(server_list),\n        \'table_config\': table_config,\n    }\n\n    return HttpResponse(json.dumps(ret, cls=JsonCustomEncoder))\n```\n\n## JS端的简单处理\n\n现在已经可以通过访问后端拿到传递过来的数据了，那么应该如何处理呢？表头和表数据分别填充；\n\n### 拿数据\n\n```javascript\n$(function () {\n    // 一开始执行的一个初始化函数\n    initial();\n});\n\n// 后端发送获取数据的js\nfunction initial() {\n    $.ajax({\n        url:\'/backend/curd_json.html\',\n        type:\'GET\',\n        dataType: \'JSON\',\n        success:function (arg) {\n            // 这里分别定义了两个初始化函数一个创建表头，一个填充数据内容。\n            // 创建表头，将我们的定制的配置文件table_config传递过去。\n            initTableHeader(arg.table_config);\n            // 为数据表填充数据，将资产和table_config传递过去，根据table_config填充数据\n            initTableBody(arg.server_list,arg.table_config);\n        }\n    })\n}\n```\n\n### 填充表头数据\n\n```javascript\nfunction initTableHeader(table_config) {\n    /*\n    * 我现在要通过这个table_config动态的，因为table_config要显示啥使我们在后端定义好的\n    * 插入表格的表头，也就是th标签；遍历table_config，k为索引值，v为含有标题的小字典\n    */\n    // 生成tbhead中的一行，一个tr标签。\n    var $tr = $(\'<tr>\');\n    $.each(table_config,function (k,v) {\n        var tag = document.createElement(\'th\');\n        tag.innerHTML = v.title;\n        $(\'#tbhead\').find(\'tr\').append(tag);\n    })\n    $(\'#tbhead\').append($tr);\n}\n```\n\n![](http://tuku.dcgamer.top/18-8-16/75017048.jpg)\n\n### 填充表格内容\n\n```javascript\n// 为字符串创建可以像Python那样的字符串的格式化方法\nString.prototype.format = function (args) {\n    return this.replace(/\\{(\\w+)\\}/g, function (s,i) {\n        return args[i];\n    });\n};\n\nfunction initTableBody(server_list,table_config) {\n    /*\n    * server_list从后台发回来的数据是一个列表套字典的形式，每一个小字典都\n    * 是一条资产信息。我们遍历具体的每一条资产拿数据。\n    */\n    $.each(server_list,function (k,row) {\n        // 遍历server_list列表，k为索引值，row是一条资产信息，形如：\n        // row:{\"id\": 1, \"hostname\": \"lamber的MacBookPro\"},\n        // 每循环一条资产数据加一行，生成一个tr\n        var tr = document.createElement(\'tr\');\n        $.each(table_config,function (key, tbconfig_value) {\n            // 这里把table_config引进来是为了解决字段乱序的问题，按照table_config的设置\n            // 在我们传过来的server资产中去拿数据，这样显示的数据就不会是乱序的，而且显示\n            // 的顺序我们也是可以自己定义的，只要改后端table_config的对应项的位置就可以了。\n            // tableconfig_value: {\'q\':\'id\',\'title\':\'ID\'}样式的字典\n            // 如果让显示再显示，不让显示的就不显示。判断display属性。\n            if (tableconfig_value.display){\n                // 创建一个td\n                var td = document.createElement(\'td\');\n                /**\n                 * 如果rrow.q是有值的那么rrow.q就是我们要的字段名称，将这个作为key的话填入到\n                 * row中，就可以根据这个key值拿到对应的value填入到td中就可以了。\n                 * if(tabconfig_value[\'q\']){\n                 *     td.innerHTML = row[rrow.q];\n                 * }else{\n                 *     console.log(rrow.text);\n                 *     td.innerHTML = rrow.text;   \n                 * }\n                 */\n                /* 这里并不采用上述的方法，为了保证我们之前说过的可以自定制内容的显示因此要把text中的\n                * kwargs参数项目利用起来。这里对上述的插入数据的方法做了一点扩展；\n                * text.tpl对应的是模板，而text.kwargs对应的则是参数，可以参考下面的示例：\n                * rrow.text.tpl = \"asdasd{n1}asd\"\n                * rrow.text.kwargs = {\'n1\':\'@id\', \'n2\':\'as\'}\n                */\n                // 首先定义一个空的字典\n                var newKwargs = {};\n                // 遍历传递过来的参数,这里我们自定义了一种模式，模板以”@+字段名“形式的组合的会被动态的\n                // 替换成字段名的数据，当然并不是所有的数据都需要被替换成动态数据，因此要原原本本显示的\n                // 的数据就不加@符号了，我把@符号作为是否替换动态数据的依据，这个是我们自定义的。\n                $.each(tableconfig_value.text.kwargs, function (tpkey,tpvalue) {\n                \tvar item = tpvalue;\n                    if(tpvalue[0] === \"@\"){\n                    // 模板是以@开头的，比如@username,@id这类的。判断方法也很简单直接用字符串切割。\n                    // 如果是以@开头的那么就那么就把后面的字段名拿出来，否则item就等于原原本本的值就行\n                    // 通过substring取到@后面的字段值，然后作为key值在row中取到真实的数据。\n                        item = row[tpvalue.substring(1,tpvalue.length)];\n                    }\n                    // 更新字典，比如newKwargs[\'n1\'] = 22;这样的\n                    newKwargs[tpkey] = item;\n            \t});\n                // 然后我们想让JavaScript像python字符串那样格式化，因此需要扩展js的string对象\n                // 具体可以查看最上方的扩展方法，替换完了以后tpl中的变量都被替换成了最终数据值\n                var newText = rrow.text.tpl.format(newKwargs);\n                // newText就是我们的最终的替换完变量要显示的文字，动态的为这个td设置上\n            \ttd.innerHTML = newText;\n                // 为tr添加一列\n            \t$(tr).append(td)\n    \t\t}\n        });\n        // 循环完成以后把整条资产加到表格中，\n   \t    $(\'#tbbody\').append(tr);\n    });\n}\n```\n\n现在其实就可以简单的显示出来我们的要的内容了。\n\n![](http://tuku.dcgamer.top/18-8-16/22947558.jpg)\n\n### 封装\n\n最后我们想把这个小的插件封装成一个js组件方便以后项目的调用，因此采用jquery的插件扩展功能。这个项目中存在变数的有url，这是访问后端api数据的，这个内容是变化的。\n\n```javascript\n// 声明一个匿名函数，给这个匿名函数传递一个jQuery的参数。匿名函数会自执行。\n(function(jq){\n    function initial(url){……}\n    function initTableHeader(table_config){……}\n    function initTableBody(server_list, table_config){……}\n    \n    // 对jquery进行扩展\n    jq.extend({\n        curd: function(url){\n            initial(url);\n        }\n    })\n})(jQuery)\n```\n\n那么前端想使用这个插件的时候，直接引入这个插件然后：\n\n```javascript\n# 直接这样调用，然后传入api的地址就行了，这样这个插件就有一定的通用性了\n$.curd(\'/backend/curd_json.html\')\n```\n\n为什么要把这些功能封到一个匿名函数中呢，因为这个匿名函数的作用域包含上述的函数在外部都是不可调用的，唯一的入口也就是我们自己定义的这个扩展的jq的curd这个方法可以用到。","timestamp":1540354517190},{"name":"07-CURD2.md","path":"04-Django/50-项目实战/01-CMDB/07-CURD2.md","content":"# 增删改查组件2\n\n> 上一节已经可以进行数据的简单展示了，并且我们使用jquery的拓展将这个curd封装成了插件。我引入以后直接调用插件的curd方法然后再传入一个url就可以了。接下来对更复杂的情况进行扩展说明。\n\n## 扩展下拉框数据\n\n像服务器列表这种一些数据就是固定的显示的数据，不过如果是资产表（Asset）这种表中就会存在选择的内容，比如：\n\n```python\n# 截取自asset model设计\ndevice_type_choices = (\n    (1, \'服务器\'),\n    (2, \'交换机\'),\n    (3, \'防火墙\'),\n    (4, \'路由器\'),\n)\ndevice_status_choices = (\n    (1, \'上架\'),\n    (2, \'在线\'),\n    (3, \'离线\'),\n    (4, \'下架\'),\n)\ndevice_type_id = models.IntegerField(choices=device_type_choices, default=1, verbose_name=\"资产类型\")\ndevice_status_id = models.IntegerField(choices=device_status_choices, default=1)\n```\n\n一个资产在是服务器那么device_type_id在数据库实际保存的就是1，同理资产状态保存的也不是上线下线这种汉字，而是对应的1，2，3，4这种数值。按照之前的逻辑，那么取出来的话显示在前端的就是意义不明的数字，因此针对这一部分要进行进一步的扩展。\n\n### table_config扩展\n\n给前端穿过去的每一条资产信息都在server_list里，对应的类似于device_type_id的这种字段的值都是数字，而不是真正的数据，因此在前端table_config这里做一些扩展；\n\n```python\n{\n    \'q\': \'device_type_id\',\n    \'title\': \'资产类型\',\n    \'display\': True,\n    \'text\': {\n        \'tpl\': \'{n1}\',\n        \'kwargs\': {\'n1\': \'@@device_type_choices\'},\n    },\n    \'attrs\': {\n        \'global-key\': \'device_type_choices\',\n    }\n},\n```\n\n1. kwargs新增一种双@符号的形式，这种规则是我自己定制的，用来匹配这种特殊类型的字段。\n2. attrs：新增一个attrs字段，传递一些其他的必要信息，这里在attrs中新增一个global_key，这个key对应的value我们填写的就是这个字段对应的choices选择。名称要和model模型中相对应。\n3. 最后我们将这个内容一并发到前端去\n\n```python\n# 在返回给前端的ret字典中新家一个global_dict，对应的内容就是table_config中的global_key\n# 当然值的话我们其实是在models模型类中写死的，直接拿就行了。最后一起发送到前端。\nret = {\n    \'server_list\': list(asset_list),\n    \'table_config\': asset_table_config,\n    \'global_dict\': {\n        \'device_type_choices\': models.Asset.device_type_choices,\n    },\n}\n```\n\n### 前端JS扩展\n\n为了能在前端这个插件中整体使用这个传过来的global变量，我们在匿名函数中设置一个GLOBAL_DICT的变量用来接收这个传递过来的内容\n\n```javascript\n(function(jq){\n    var GLOBAL_DICT = {};\n    ………………\n })(jQuery)\n```\n\n变量设置好了，就应该把设置好的内容填充到这个变量里去，最好的时机就是在initial初始化的时候，因此对初始化函数进行进一步改写，在初始化的时候我们去遍历传过来的global_dict，然后循环填充我们设置的字典，其中的key就是device_type_choices这种的key，value就是可选项：\n\n```javascript\nfunction initial(url) {\n    $.ajax({\n        url: url,\n        type: \'GET\',\n        dataType: \'JSON\',\n        success: function (arg) {\n            /*\n            server_list: 相关资产信息\n            table_config: 自定义的表配置\n            global_dict: 相关的状态信息\n            * */\n            $.each(arg.global_dict, function (k, v) {\n                GLOBAL_DICT[k] = v;\n            });\n\n            initTableHeader(arg.table_config);\n            initTableBody(arg.server_list, arg.table_config);\n        }\n    })\n}\n```\n\n对数据填充函数inittablebody进行扩展，加上对双@符号的判断：\n\n```javascript\n\nfunction initTableBody(server_list, table_config) {\n    $.each(server_list, function (k, row) {\n        var tr = document.createElement(\'tr\');\n        tr.setAttribute(\'nid\', row.id);\n        $.each(table_config, function (key, tbconfig_value) {\n            if (tbconfig_value.display) {\n                var td = document.createElement(\'td\');\n                /* 在td标签中添加内容 */\n                var newKwargs = {};\n                $.each(tbconfig_value.text.kwargs, function (tpkey, tpvalue) {\n                    var item = tpvalue;\n                    // 多加一个判断，如果说前两个字符是以\'@@\'开头的话。\n                    // 那么就取到双@后面的字段值然后去我们的GLOBAL_DICT中拿值就可以了。\n                    if (tpvalue.substring(0, 2) === \'@@\') {\n                        // 拿到当前这个td的所有可选值\n                        var choices = GLOBAL_DICT[tpvalue.substring(2, tpvalue.length)]\n                        // 拿到实际可选值的id，假如这个字段是device_type_id，那么q取到的值\n                        // 就是对应的1，2，3或者4.然后循环遍历判等，如果相等赋值就完事了。\n                        var nid = row[tbconfig_value.q];\n                        $.each(choices, function (gk, gv) {\n                            // 这里要判断一下nid是否存在，因为这个字段虽然是选择字段\n                            // 但是允许不选择。可以留空的。如果我留空了，那么数据库就取不到数据\n                            // 自然gv[0]也不会等于nid，因此单独加一个判断，否则会显示我们\n                            // 定制的双@的字符串，意义不明。\n                            // 或者有一个更好的方法，在数据库设置一个值显示为无，默认值为这个\n                            if (nid) {\n                                if (gv[0] === nid) {\n                                \titem = gv[1];\n                            \t}\n                            }else{\n                                item = \'\'\n                            }  \n                        })\n                    // 这里维持原来的判断\n                    } else if (tpvalue[0] === \"@\") {\n                        item = row[tpvalue.substring(1, tpvalue.length)];\n                    }\n                    // 每遍历一列就更新一个字典\n                    newKwargs[tpkey] = item;\n                });\n                var newText = tbconfig_value.text.tpl.format(newKwargs);\n                td.innerHTML = newText;\n                $(tr).append(td)\n            }\n        });\n        $(\'#tbbody\').append(tr);\n    });\n```\n\n到目前为止数据已经可以正常显示了，下面开始增加以下操作这些内容的按钮，来对这个插件的功能进行进一步扩展。\n\n## 功能按钮的设计\n\n> 设计功能按钮的想法是能让用户在前端就可以直接对资源进行自由的增删改查的一些操作，可以让数据的显示和操作同屏完成，使操作更加简便快捷。\n\n这里借用BootStrap的按钮组来实现界面的显示。有各种各样的功能，针对这些功能，一个一个的说。。\n\n```html\n<div class=\"btn-group row\" role=\"group\">\n    <button id=\"checkAll\" type=\"button\" class=\"btn btn-default\">全选</button>\n    <button id=\"checkReverse\" type=\"button\" class=\"btn btn-default\">反选</button>\n    <button id=\"checkCancel\" type=\"button\" class=\"btn btn-default\">取消</button>\n    <button id=\"jobAdd\" type=\"button\" class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#myModal\">新增报事\n    </button>\n    <button id=\"multiDel\" type=\"button\" class=\"btn btn-default\">删除</button>\n    <button id=\"refresh\" type=\"button\" class=\"btn btn-default\">刷新</button>\n    <button id=\"save\" type=\"button\" class=\"btn btn-default\">保存</button>\n    <button id=\"editmodelornot\" type=\"button\" class=\"btn btn-default\">进入编辑模式</button>\n</div>\n```\n\n### 全选\n\n全选这个功能相对简单很多，找到tbbody下的checkbox都给它勾上就行了。\n\n```javascript\n$(\'#checkAll\').click(function () {\n    var $tbbody = $(\'#tbbody\');\n    $tbbody.find(\':checkbox\').prop(\'checked\', true);\n});\n```\n\n### 反选\n\n反选也很简单，就是多了一个判断，找到tbbody下的所有checkbox，勾上的去掉钩，没钩的给勾上。\n\n```javascript\n$(\'#checkReverse\').click(function () {\n    $(tbbody).find(\':checkbox\').each(function () {\n        if ($(this).prop(\'checked\')) {\n            $(this).prop(\'checked\', false);\n        }else {\n            $(this).prop(\'checked\', true);\n        }\n    })\n});\n```\n\n### 取消\n\n找到tbbody下所有勾上的，然后去掉勾就完事了。\n\n```javascript\n$(\'#checkCancel\').click(function () {\n\t$(tbbody).find(\':checkbox\').each(function () {\n        if ($(this).prop(\'checked\')) {\n            $(this).prop(\'checked\', false);\n        }\n\t})\n});\n```\n\n### 删除\n\n在书写table_config的时候，第一列为选择列，放了一堆checkbox，通过tpl我们把id也带了过去，这样在选中的时候那么可以通过这个input的value值去取到这条资产记录的id了；\n\n```javascript\n{\n    \'q\': None,\n    \'title\': \'选择\',\n    \'display\': True,\n    \'text\': {\n        \'tpl\': \'<input type=\"checkbox\" value=\"{n1}\">\',\n        \'kwargs\': {\'n1\': \'@id\'}\n    },\n    \'attrs\': {\n        \'edit-enable\': \'false\',\n    }\n},\n```\n\nJS处理：定义一个idList空数组，然后找到tbbody下的选中的标签，去遍历，这里的每一个$(this)是那个checkbox的input框，然后我们直接去value就可以了，遍历push到后端。\n\n这里有一个csrftoken的问题，出于安全的考虑，django会对POST、PUT、DELETE这几种操作进行csrdtoken的检查。POST可以将其放到post参数中，但是django对put和delete只能通过检查header的方式检查csrf_token。因此在提交数据的时候要在header中封装csrftoken进去。这里放两个内容参考，对这一块的内容处理进行了拓展：\n\n- [使django支持PUT，DELETE方案](https://blog.csdn.net/weixin_35993084/article/details/80778921)\n- [Ajax请求中提交csrfToken | django中csrf的其他使用 | Django](http://www.cnblogs.com/pymkl/articles/9209618.html)\n\n```javascript\n$(\'#multiDel\').click(function () {\n    var idList = [];\n    // 记得现在前端模版上放上{% csrf_token %}\n    var csrftoken = $(\'input[name=csrfmiddlewaretoken]\');\n    $(\'#tbbody\').find(\':checked\').each(function () {\n        idList.push($(this).val());\n    });\n    $.ajax({\n        url: url,\n        // form表单只能提交get或者post请求，但是对于ajax delete也是ok的。\n        type: \'delete\',\n        headers: {\"X-CSRFToken\": $(csrftoken).val()},\n        data: JSON.stringify(idList),\n        success: function (arg) {\n            console.log(arg)\n        }\n    })\n});\n```\n\n这样我在后端其实就可以拿到对应的id数值了，只不过django并没有对delete请求进行封装，所以我们只能自己去request.body里去取数据了，注意取过来的是字节类型的，转码一下。\n\n```python\ndef showwork_ajax(request):\n    \"\"\"向前端发送具体的消息\"\"\"\n    if request.method == \"DELETE\":\n        # 针对delete请求，我们只能去request.body中自己取数据了。\n        del_id_list = request.body.decode(\'utf-8\')\n        print(del_id_list)\n        # 这里删除的操作就省略了。\n        # models.xx.objects.delete(*del_id_list)\n        return HttpResponse(\'...\')\n    \n    …………………………略\n```\n\n### 编辑模式的设计\n\n> 针对编辑模式的设计，我想设计这样一个按钮，点击按钮进入编辑模式，可以编辑的内容当这条记录被选中的时候，可以被修改的部分就会进入修改状态。然后就可以进行编辑了\n\n#### 编辑模式？\n\n何谓编辑模式，比如下面这样一条记录：\n\n![](http://tuku.dcgamer.top/18-8-17/18194609.jpg)\n\n其中资产类型和状态都是可选的，那么进入编辑模式的时候应该是一个select框，机柜号和机房应该是对应的生成一个input框，让我们可以输入想要的值，不需要编辑的字段还让它保持原样，如图：\n\n![](http://tuku.dcgamer.top/18-8-17/66634404.jpg)\n\n#### 模式实现\n\n设计思路为，需要多选的就把当前td的内容替换掉生成一个select框，然后把多个选项遍历依次生成option标签塞到select标签下。\n\n##### 扩展table_config\n\n刚才说到的，如果这些内容都是用前端来去生成的，前端并不知道你哪些内容该编辑，哪些内容不该编辑，哪些内容应该被替换成input框，哪些内容应该被替换成select框，这些内容其实前端是不知道的，我们应该在后端告诉前端，这个时候又要在table_config中加字段了。\n\n```python\n{\n    \'q\': \'device_type_id\',\n    \'title\': \'资产类型\',\n    \'display\': True,\n    \'text\': {\n        \'tpl\': \'{n1}\',\n        \'kwargs\': {\'n1\': \'@@device_type_choices\'},\n    },\n    \'attrs\': {\n        \'edit-enable\': \'true\',\n        \'edit-type\': \'select\',\n        \'global-key\': \'device_type_choices\',\n        \'origin\': \'@device_type_id\',\n        \'name\': \'device_type_id\'，\n    }\n},\n```\n\n不需要在table_config中添加更多的字段，只需要继续扩充attrs这个字典就可以了。\n\n- edit-enable：是否可以编辑，这个要告诉前端，当前字段是否可以编辑\n- edit-type：告诉前端你这个字段应该是一个input框还是一个select选择框\n- origin：标识原始的数据值，@device_type_id会在前端被替换成对应的值。该字段的作用是当字段的值发生变化以后有一个可对比的原值参照，如果值变了才提交，值不变的话那么就不用提交。\n- name：如果以后数据提交了的话对应提交到数据库的哪个字段呢？这里就是一个标识\n\n##### 前端JS逻辑实现\n\n在上面扩展table_config以后新增的这些属性如何让它在前端体现出来可以拿到我们提供的数据呢？这就需要在初始化表格时候把我们给的所有的属性值作为每一列（td）的属性值在生成表格的都作为属性加到对应的td标签上去，因此对initTablebody进行进一步的修改，添加为td增加属性的逻辑：\n\n```javascript\nfunction initTableBody(server_list, table_config) {\n    $.each(server_list, function (k, row) {\n        var tr = document.createElement(\'tr\');\n        // 为这一行设置一下id，让我们知道每一行资源实际的id是什么\n        tr.setAttribute(\'nid\', row.id);\n        $.each(table_config, function (key, tbconfig_value) {\n            if (tbconfig_value.display) {\n                var td = document.createElement(\'td\');\n                /* 在td标签中添加内容 */\n                var newKwargs = {};\n                $.each(tbconfig_value.text.kwargs, function (tpkey, tpvalue) {\n                    // 这里是遍历kwargs，根据模板生成数据值的操作，太多就直接省略了 \n                    // 略略略略略略略略略略略略略略略\n                });\n                var newText = tbconfig_value.text.tpl.format(newKwargs);\n                td.innerHTML = newText;\n\n                /* 这里就是我们新添加的逻辑，为td属性设置属性的逻辑 */\n                $.each(tbconfig_value.attrs, function (attrkey, attrvalue) {\n                    if (attrvalue[0] === \'@\') {\n                        attrvalue = row[attrvalue.substring(1, attrvalue.length)];\n                    }\n                    td.setAttribute(attrkey, attrvalue);\n                });\n            $(tr).append(td)\n           }\n       });\n       $(\'#tbbody\').append(tr);\n    });\n}\n```\n\n增加完了以后的结果就是如图所示的，这样我们就可以取到对应的属性值了：\n\n![](http://tuku.dcgamer.top/18-8-17/27557887.jpg)\n\n在完成逻辑之前首先设计一个总的可编辑按钮的开关，用于标识是否进入编辑模式，如果进入编辑模式以后，那么选中的行应该会进入可编辑的状态，如果在非编辑模式下，即使选中了改行，那么也不会进入编辑模式。针对这个编辑模式的按钮设计很简单，整一个按钮，进入编辑模式之前是一个颜色，进入编辑模式之后是一个颜色，进入不同的模式以后分别执行不同的方法就ok。\n\n```javascript\n/*\n1、Bootstrap提供了很多的按钮样式，直接加上对应的btn class就可以让按钮显示对应的样式，这里我让进入编辑模式以后button的样式变成btn-warning的样式\n2、因此判断是否进入编辑模式的标准就可以通过是否有这个btn-warning这个class来进行判断了。当有这个类的时候，就应该退出这个模式，并一并修改按钮上的问题。同理，没有这个类的时候应该加上这个类，并把按钮上的文字改为“退出编辑模式”\n3、进入编辑模式以后并不是所有的记录都应该是编辑状态，应该是你选中了那一条记录，那条记录才应该进入编辑状态，因此在进入编辑状态后还应该在判断一下这些记录哪些记录是被选中的。只有选中的记录才应该进入编辑模式允许用户编辑\n4、同理退出编辑模式的时候也是刚才选中的那些退出编辑模式。\n*/\n$(\'#editmodelornot\').click(function () {\n    if ($(this).hasClass(\'btn-warning\')) {\n        // 如果有这个css class的话那么应该退出这个编辑模式\n        $(this).removeClass(\'btn-warning\');\n        $(this).text(\'进入编辑模式\');\n        $(\'#tbbody\').find(\':checkbox\').each(function () {\n            var $tr = $(this).parent().parent();\n            if ($(this).prop(\'checked\')) {\n                trOutEdit($tr);\n            }\n        })\n    } else {\n        $(this).addClass(\'btn-warning\');\n        $(this).text(\'退出编辑模式\');\n        // 还有一个问题就是我在未进入编辑模式的时候选中一些数据，然后再点进入编辑模式发现并不会变\n        // 化因此我们在进出编辑模式的时候不只是改改字换换样式啥的，也要做基础的判断是否选中。\n        $(\'#tbbody\').find(\':checkbox\').each(function () {\n            // $(this)是当前这个input type为checkbox的input框\n            // 它的父级的父级也就是这一条资源记录的tr标签我们要传递给trIntoEdit\n            var $tr = $(this).parent().parent();\n            // 只有选中状态的tr才应该进入编辑模式。\n            if ($(this).prop(\'checked\')) {\n                trIntoEdit($tr);\n            }\n        })\n    }\n});\n```\n\n在上面进入和退出编辑模式的时候分别调用了trIntoEdit和trOutEdit函数，这两个函数我们还没有定义，因此我们需要在上面定义一下这两个函数来处理进出编辑模式的具体逻辑\n\n**trIntoEdit**\n\n这个函数需要一个参数，就是我们要操作哪一条资源？因此在上面循环遍历的时候要找到对应记录的tr，然后传递进来。\n\n```javascript\nfunction trIntoEdit($tr) {\n    // 找到这条记录下可以编辑的td标签然后开始遍历\n    $tr.children(\'td[edit-enable=\"true\"]\').each(function () {\n        // $(this)就是循环的每一个td对象\n        // 如果传过来的没有设置的话就是undefined，设置的就是设置的值。\n        \n        // 获取一下当前的td的editype\n        var editType = $(this).attr(\'edit-type\');\n        if (editType === \'select\') {\n            // 如果type是select，那么生成下拉框\n            var $tag = $(\'<select>\');\n            // 通过我们设置的gloabal-key的属性去直接拿GLOBAL_DICT中的选择值。\n            var device_type_choices = GLOBAL_DICT[$(this).attr(\'global-key\')];\n            // 设置一个原始值用来作为判断数据是否被修改的依据\n            var origin = $(this).attr(\'origin\');\n            $.each(device_type_choices, function (key, value) {\n                // value才是真正的数据，v.0是id，v1是名称，比如v.0=1,v.1表示服务器\n                var $option = $(\'<option>\');\n                $option.text(value[1]);\n                $option.val(value[0]);\n                // 为select框设置一个默认值，比如进入编辑模式之前是服务器\n                // 那么进入编辑模式只有应该默认的选项也应该是服务器，因此这里做一下判断。\n                if (value[0] == origin) {\n                    $option.prop(\'selected\', true);\n                }\n                $tag.append($option);\n            });\n            // 把这个select框内容放到td下，此时的$(this)就是这个td，看最顶层的each。\n            $(this).html($tag);\n        } else {\n            // 如果editType不是select，就目前来讲只有input因此不需要做额外的条件判断    \n            // 获取原来的td标签的内容\n            var text = $(this).text();\n                \n            // 创建一个input标签并设置里面的内容。\n            var $tag_input = $(\'<input>\');\n            $tag_input.val(text);\n            $(this).html($tag_input);\n        }\n    })\n}\n```\n\n**trOutEdit**\n\n对于退出编辑模式，同样需要传递一个参数，这个参数其实就是我们操作的这一行的tr，传递一个当前行的tr对象过来就可以了，同trIntoEdit。\n\n```javascript\nfunction trOutEdit($tr) {\n    $tr.children(\'td[edit-enable=\"true\"]\').each(function () {\n        var editType = $(this).attr(\'edit-type\');\n        if (editType === \'select\') {\n            // 首先要拿到默认选中的值。\n            /**\n             * DOM对象转换为jq对象，只要用$()把dom对象包装起来就可以得到了。\n             * jq对象转换为dom对象的时候在后面加一个\"[0]\"就可以了。\n             * 这里将select的jq对象转换为dom对象调用selectedOptions方法。\n             * */\n            // 如果td内容是一个select框的话，那么在退出之前首先要获取用户到底选中了哪一个\n            var option = $(this).find(\'select\')[0].selectedOptions;\n            // 然后将这个选中的值以一个名为new-origin的属性记录在这td上。\n            // 这么做的原因是后面如果做了修改还要提交到后台，new-origin和origin要进行比较\n            // 如果值相等说明根本就没改，那么发送请求的时候这个就可以pass，new-origin也是一个作为\n            // 判断是否修改的一个标准。\n            $(this).attr(\'new-origin\', $(option).val());\n            // 然后把这个td设置为这个option的显示的值。text是option的值，比如“服务器”,val是对应id\n            $(this).html($(option).text());\n        } else {\n            // 如果不是select框直接先拿值，然后把input框干掉把数值塞在这就行了。\n            var input_val = $(this).find(\'input\').val();\n            $(this).html(input_val);\n        }\n    })\n}\n```\n\n书写完两个函数以后，此时我们进入编辑模式以后，再随便选中一个项目以会发现此时对应的内容并没有变化，这是因为我们在设置编辑按钮的时候只是检测编辑模式下哪些选中了给它变成编辑模式，如果是编辑模式下，我后来又手动选中的内容就不会发生变化，因此我们还需要单独给checkbox绑定事件：\n\n```javascript\n# 注意，这里要用on的方式绑定数据，直接使用click(function(){})的方式是绑定不上的，这种方式要求得先有数据，因此要用事件的委派。这个时候不管你是先生成的还是后生成的都可以绑定的上。\n$(\'#tbbody\').on(\'click\', \':checkbox\', function () {\n    /**\n     * $(this)表示当前的checkbox标签\n     * 1.点击首先检测是否进入编辑模式，如果是，就退出，不是就进入\n     */\n    var $tr = $(this).parent().parent();\n    // 否则什么都不做，因为本来就是直接点不进入编辑模式的。\n    if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n        if ($(this).prop(\'checked\')) {\n            // 进入编辑模式\n            trIntoEdit($tr);\n        } else {\n            // 退出编辑模式\n            trOutEdit($tr)\n        }\n    }\n});\n```\n\n这样操作完成以后，我们就可以进行简单的编辑模式的进出编辑模式了。不过对应的上面的很多内容要进行进一步的扩展，比如全选，全选的时候要判断是否是编辑模式，如果是编辑模式的话就该进入编辑模式，如果不是的话就应该什么都不做，同样的反选，取消操作也要做扩展。\n\n#### 扩展全选/反选/取消\n\n##### 扩展全选\n\n扩展内容无非也就是针对编辑模式多了一层判断：\n\n1. 首先全选的时候会遍历每一行，然后针对每一行做内容的判断，首先判断是否进入编辑模式，如果不在编辑模式的话，我们就逐行遍历然后不管你之前勾上没勾上吧，统一再给你勾一遍。\n2. 如果说在编辑模式的话，我们需要判断在全选之前是否有已经勾选过的。如果没有勾选的就给它勾上，同时进入编辑模式，执行trIntoEdit；如果是已经勾选上的tr，那么这一行本身就应该已经处在一个编辑模式了，我们不要再调用一次trIntoEdit方法去执行了。\n3. 为什么在编辑模式全选的时候要单独判断有没有之前就勾选的内容呢？还记得trIntoEdit的逻辑么，假如edit_type为input的时候，在进入编辑模式的时候首先获取到`$(this)`的text值然后新建一个input标签，然后将这个input标签的value值设置为text的内容，注意，此时设置的是value值，但是input的text内容是空的，空的，空的！所以如果又执行一遍的话，你就会发现input框变成空的了，啥都没有了。很蛋疼；此时如果再执行trOutEdit退出编辑模式的时候，value为空，那么最后设置的td就是一个空值。总之，这里注意的地方就是，td有值那是因为td的text有值，input有值那是因为input的value有值，注意这两点别搞混。\n\n```javascript\n$(\'#checkAll\').click(function () {\n    var $tbbody = $(\'#tbbody\');\n    /**\n     * 首先全选的时候应该让这一行进入编辑模式，但是我们发现通过事件触发和我们手动点击不一样\n     * 手动点击会触发编辑模式，但是事件触发checked并不会进入编辑模式，因此我们需要手动调用一下\n     * */\n     if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n         $tbbody.find(\':checkbox\').each(function () {\n             if (!$(this).prop(\'checked\')) {\n                 $(this).prop(\'checked\', true);\n                 var $tr = $(this).parent().parent();\n                 trIntoEdit($tr)\n             }\n          })\n     } else {\n         $tbbody.find(\':checkbox\').prop(\'checked\', true);\n     }\n });\n```\n\n##### 扩展反选\n\n同全选，加一个针对编辑模式的判断。\n\n```javascript\n$(\'#checkReverse\').click(function () {\n    if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n        $(\'#tbbody\').find(\':checkbox\').each(function () {\n            var $tr = $(this).parent().parent();\n            if ($(this).prop(\'checked\')) {\n                $(this).prop(\'checked\', false);\n                trOutEdit($tr);\n            } else {\n                $(this).prop(\'checked\', true);\n                trIntoEdit($tr);\n            }\n         })\n    } else {\n        $(\'#tbbody\').find(\':checkbox\').each(function () {\n            if ($(this).prop(\'checked\')) {\n                $(this).prop(\'checked\', false);\n            } else {\n                $(this).prop(\'checked\', true);\n            }\n         })\n    }\n});\n```\n\n##### 扩展取消按钮\n\n```javascript\n$(\'#checkCancel\').click(function () {\n    if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n        $(\'#tbbody\').find(\':checkbox\').each(function () {\n            if ($(this).prop(\'checked\')) {\n                $(this).prop(\'checked\', false);\n                var $tr = $(this).parent().parent();\n                trOutEdit($tr)\n            }\n        })\n     } else {\n        $(\'#tbbody\').find(\':checkbox\').prop(\'checked\', false);\n     }\n});\n```\n\n### 刷新\n\n设置一个刷新按钮，目的就是为了刷新一遍重新拿数据。刷新的时候重新执行以下initial()初始化函数就行了。\n\n```javascript\n$(\'#refresh\').click(function () {\n    // 刷新一遍重新拿数据\n    initial(url);\n});\n```\n\n注意此时执行的时候要扩展以下inittablebody和inittablehead，在创建之前先清除一下，否则你就会看到刷新一次重复的数据在页面重新生成一次：\n\n```javascript\n// 在initTableHeader函数的第一行加上这么一句，先清空再重新生成\n$(tbhead).empty();\n\n// 和initTableHeader函数的第一行加上这么一句，先清空再重新生成。\n$(tbbody).empty();\n```\n\n### 保存\n\n设计编辑模式的原因其实就是为了方便我们进行修改，修改完了以后我们是要提交给后端服务的，因此这里又设置了一个保存按钮，方便用户进行数据的保存：\n\n1. 保存按钮设计为需要退出编辑模式以后才能进行保存，当我们退出编辑模式，执行trOutEdit的时候是会将修改的值获取到然后放到td中的。同时为当前的td设置一个new-origin的属性用来表示数据是否已经发生更改，作为判断标准或者依据。\n2. 定义一个all_list用以保存我们发生修改的数据。\n3. 然后开始遍历tablebody的每一行，之前为每一个tr设置了nid，这个nid其实就是资产信息在数据库的id，在这里就可以很方便的使用上了，定义一个row_dict用来保存到底这一行的哪些数据发生了变化；\n4. 遍历这一行tr的每一个td标签，首先判断这一个td是否是能编辑的，如果不能编辑那就不用进内部的判断了；如果这个数据是可编辑的并且edit-type是select的，那么就要比较new-origin和origin的值，如果变化了，说明修改了，如果没变化说明没有修改；如果修改了的话，那么我们就将这个td字段的name属性作为key，新数据newData作为value更新到这个字典里。当字段不是select的时候，直接获取text值，然后和td的origin属性值进行比较，如果变化了，做如上的同样操作。\n5. 我们在遍历每一行的时候，首先设置一个flag置位，只要数据发生变化了需要修改了那么就把flag置位为true，当遍历完tr的每一个td的时候如果发生了变化，那么还要把这一条tr的资产信息的id带过去。\n6. 将发生变化的这个row_dict字典添加到all_list中\n7. ajax提交到后台，注意cstf_token的问题\n\n```javascript\n$(\'#save\').click(function () {\n    // 设计为首先推出编辑模式以后才能保存\n    var editornot = $(\'#editmodelornot\');\n    if ($(editornot).hasClass(\'btn-warning\')) {\n        // 在编辑模式下应该退出\n        $(\'#tbbody\').find(\':checkbox\').each(function () {\n            if ($(this).prop(\"checked\")) {\n                var $tr = $(this).parent().parent();\n                trOutEdit($tr);\n            }\n        })\n        // 退出编辑模式记得修改按钮样式和文字。否则在下一次触发的时候会报错\n        $(editornot).removeClass(\'btn-warning\');\n        $(editornot).text(\'进入编辑模式\');\n    }\n    // 定一个修改资产的列表总表，下面去循环每一个发生变化的项然后append进来\n    var all_list = [];\n    // 退出以后获取用户修改过的数据，然后通过ajax提交到后台\n    $(\'#tbbody\').children().each(function () {\n        // $(this)这里指的就是tr\n        var $tr = $(this);\n        var nid = $tr.attr(\'nid\');\n        var row_dict = {};\n        var flag = false;\n        $tr.children().each(function () {\n            // 要判断是否可编辑，同时还要判断下拉框的情况下\n            if ($(this).attr(\'edit-enable\') === \'true\') {\n                if ($(this).attr(\'edit-type\') == \'select\') {\n                    var newData = $(this).attr(\'new-origin\');\n                    var oldData = $(this).attr(\'origin\');\n                    if (newData) {\n                        if (newData != oldData) {\n                            var name = $(this).attr(\'name\');\n                            row_dict[name] = newData;\n                            // 如果写过数据就置位为true\n                            flag = true;\n                         }\n                     }\n                } else {\n                    var newData = $(this).text();\n                    var oldData = $(this).attr(\'origin\');\n                    if (newData != oldData) {\n                        var name = $(this).attr(\'name\');\n                        row_dict[name] = newData;\n                        // 如果写过数据就置位为true\n                        flag = true;\n                    }\n                }\n            }\n        });\n   \n        // 如果没有编辑的话dict可能为空，因此要做一下判断\n        if (flag) {\n            // 在这里我加了个判断，做了修改的一个是要传递一下资产的id过去\n            // 再有就是把这一条资产添加到这个all_list中去。\n            row_dict[\'id\'] = nid;\n            all_list.push(row_dict);\n        }\n    });\n    /**\n     * RestfulApi\n     * 添加：post；获取用get；删除：delete；修改:put\n     * */\n    $.ajax({\n        url: url,\n        method: \'PUT\',\n        headers: {\"X-CSRFToken\": $(csrftoken).val()},\n        data: JSON.stringify(all_list),\n        success: function (arg) {\n        \tconsole.log(arg);\n        }\n    })\n});\n```\n\n后台接收到以后的形式就是这样的：\n\n```javascript\n# 形如这样一个列表套多个字典的的形式\n[{\n    \"sys_name\":\"4\",\n    \"job_type\":\"4\",\n    \"job_describe\":\"协助123123发版脚本修改\",\n    \"job_user\":\"123123\",\n    \"ops3\":\"4\",\n    \"oprate\":\"2\",\n    \"status\":\"2\",\n    \"job_method\":\"修改环境变量处理nohup无法直接调用java的问题\",\n    \"job_time\":\"4\",\n    \"note\":\"null22222\",\n    \"id\":\"1\"\n},{……},{……},\n]\n\n# 因为对应的一个个小字典的key其实都是对应的我们的字典的值，因此可以直接进行更新\nall_list = json.loads(request.body.decode(\'utf-8\'))\nfor row in all_list:\n    nid = row.pop(\'id\')\n    models.Server.objects.filter(id=nid).update(**row)\n```\n\n### 新增\n\n关于新增，后期补充，新增视业务的不同而不同，如果内容少量内容的添加可以直接使用模态框就可以了，如果多数内容的添加，也可以针对这个内容单独设置一个页面进行添加也是可以的。换句话说就是这个添加的操作不适合封装到这个curd插件里，关于这个内容，直接写一个a标签触发事件最方便。","timestamp":1540354517190},{"name":"08-CURD3.md","path":"04-Django/50-项目实战/01-CMDB/08-CURD3.md","content":"# 组件搜索\n\n> 目前已经可以说已经完成了组件的增删改，但是还有一样，那就是查，接下来将会扩展插件的查询功能。允许用户可以实现组合条件的查询\n\n## 前端展示代码\n\n```html\n<!--作为额外元素的按钮式下拉菜单-->\n<div>\n    <!--搜索列表-->\n    <div class=\"search-list clearfix\" style=\"position: relative;\">\n        <!--搜索按钮，col-md-offset-10,列偏移，向右占位10个，然后搜索按钮实际占位是两份-->\n        <div class=\"search-btn col-md-offset-10 col-md-2\" style=\"position: absolute;bottom: 1px;text-align: right;\">\n            <input id=\"doSearch\" type=\"button\" class=\"btn btn-primary\" value=\"搜索\"/>\n        </div>\n\n        <!--每一个搜索条目，因为这个的定位是relative用来给内部做相对定位的，如果说本身没有设置宽度撑开的话\n        那么本身定位就是有问题的，宽度是个空，因此会出现元素重叠的现象。不管你加多少个都撑不开\n        都叠在一起了。\n        -->\n        <div class=\"search-item col-md-offset-2 col-md-8 clearfix\" style=\"position: relative;height: 35px;\">\n            <!--左边的加号-->\n            <div style=\"position: absolute;left:0;width: 38px;\">\n                <a type=\"button\" class=\"btn btn-default add-search-condition\">\n                    <span class=\"glyphicon glyphicon-plus\"></span>\n                </a>\n            </div>\n            <!--右边的输入框，或者是select框-->\n            <div class=\"input-group searchArea\" style=\"position: absolute;left: 40px;right: 0;\">\n                <div class=\"input-group-btn\">\n                    <button type=\"button\" class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\">\n                        <span class=\"searchDefault\">默认值</span>\n                        <span class=\"caret\"></span></button>\n                    <ul class=\"dropdown-menu\"></ul>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n```\n\n## JS操作\n\n> 在这里其实很简单的设置了一个加号和一个下拉框；加号允许我创建多个搜索的条件，最后需要达到的结果是多个条件放在一起做搜索；然后旁边的下拉框其实是限制选取的搜索类型，我们搜索可以搜索服务器或者搜索服务器状态，比如上架或者下架等。比如服务器就应该让我们输入一个服务器的名称，而状态就应该让我们去选择一个状态；因此根据搜索条件的不同，旁边展示的内容也应该是不一样的，可能是搜索框，也可能是下拉菜单。\n\n### 初始化搜索框\n\n首先从后台构造一个搜索的配置，传递到前端来，前端根据搜索配置去生成对应的搜索条件，比如：\n\n```python\nsearch_config = [\n        # 使用xxx__contains做模糊匹配，orm的用法再回顾一下。\n        {\'name\': \'hostname__contanins\', \'text\': \'主机名\', \'search_type\': \'input\'},\n        {\'name\': \'sn__contains\', \'text\': \'SN号\', \'search_type\': \'input\'},\n    ]\n```\n\n前端拿到这样的数据以后就可以针对这个内容进行遍历了。根据search_type生成不同的条件框。（需要在视图函数中，将search_config也作为返回的字典中的一项给传递到前端来），针对上述内容做简单说明：\n\n- name：这个是实际要使用orm在数据库搜索的字段，比如hostname就是搜索数据库server表中的server字段，hostname__contains的用法为模糊匹配\n- text：在前端搜索条件框那里要显示的中文名称。\n- search_type：搜索条件，值为input或者select，根据type的不同，生成不同的搜索条件框\n- global_name：如果search_type为select的话我们还应该把对应的选项的名字传递过去，比如device_type_id这个字段我们就应该把device_type_choices传递过去，只要把这个传递过去，我们就可以在对应的GLOBAL_DICT中拿到我们想要的选项。\n\n现在可以开始进行初始化搜索框的设置了，需要做的工作就是讲我们从后端传递过来的每一个搜索项填充到我们上面的html的搜索项目中：\n\n```javascript\n(function(jq){\nvar CREATE_SEARCH_CONDITION = true;\nfunction initSearch(search_config) {\n    // 有可能有的表单没有设置search_config，没有设置的时候其实就是一个undefined，不需要就不生成即可。\n    // CREATE_SEARCH_CONDITION设置一个置位，这个置位的作用是防止这个搜索条件的重复初始化生成\n    // 仅仅第一次生成的时候就够了，后续就不用生成了。\n    if (search_config && CREATE_SEARCH_CONDITION) {\n        CREATE_SEARCH_CONDITION = false;\n        // 找到搜索框的ul的位置，在里面动态添加li(搜索条件)\n        $.each(search_config, function (k, v) {\n            // 这里的v才是我们真正需要的数据\n            // 创建一个li标签，然后设置li的属性；\n            var li = document.createElement(\'li\');\n            $(li).attr(\'search_type\', v.search_type);\n            $(li).attr(\'name\', v.name);\n            if (v.search_type === \'select\') {\n                $(li).attr(\'global_name\', v.global_name);\n            }\n            // 设置一个a标签，然后将a的文本显示为search_config的text文本添加到a\n            // 然后把这个a添加到li下，最后将整个li添加到ul下，循环遍历，这样所有的下拉项就生成了。\n            var a = document.createElement(\'a\');\n            a.innerHTML = v.text;\n            li.append(a);\n            $(\'.searchArea\').find(\'ul\').append(li)\n        });\n\n        // 初始化搜索默认条件，这么多下拉项总有一个是默认选中的。因此需要设置一下默认选项\n        // 创建一个默认的局部变量，让它作为默认项，值为search_config第一个索引位的值。\n        var defaultcondition = search_config[0];\n        // 替换一下默认值的文本文字\n        $(\'.search-item .searchDefault\').text(defaultcondition.text);\n        // 替换搜索框的标签，如果search_type为select就换成下拉框，反之则是input框\n        if (defaultcondition.search_type === \'select\') {\n            // 动态生成一个select框\n            var $sel = $(\'<select>\');\n            $sel.addClass(\'form-control\');\n            $sel.attr(\'name\', defaultcondition.name);\n            // 我们有下拉项的名字，我们就可以在GLOBAL_DICT中拿到下拉项的值。遍历值生成option\n            $.each(GLOBAL_DICT[defaultcondition.global_name], function (k, v) {\n                var option = document.createElement(\'option\');\n                $(option).text(v[1]);\n                $(option).val(v[0]);\n                $sel.append(option);\n            });\n            $(\'.input-group\').append($sel);\n        } else {\n            var $inp = $(\'<input>\');\n            $inp.addClass(\'form-control\');\n            $inp.attr(\'name\', search_config[0].name);\n            $inp.prop(\'type\', \'text\');\n            $(\'.input-group\').append($inp);\n        }\n    }\n}\n})(jQuery)\n```\n\n将initSearch加入到initial()这个函数中来和inittablebody以及inittableheader进行统一初始化；\n\n现在生成了搜索条件的li以及对应的右侧的搜索框，不过我们发现切换的时候，搜索条目并没有变，而且右侧的内容也没有动态起来。因此需要针对这个li加入点击事件，做到搜索框选择不同类型的时候，对应的右侧的搜索类型也要变；\n\n```javascript\n// 这里使用到了事件委派，因为li是动态生成的一开始并没有，因此直接click是会绑定失败的。\n$(\'.search-list\').on(\'click\', \'li\', function () {\n    // 点击li执行函数\n    var li_text = $(this).text();\n    var search_type = $(this).attr(\'search_type\');\n    var name = $(this).attr(\'name\');\n    // 如果没有就是undefined\n    var global_name = $(this).attr(\'global_name\');\n\n    // 替换显示的文本\n    $(this).parent().prev().children(\'.searchDefault\').text(li_text);\n\n    // 替换搜索框的标签，如果search_type为select就换成下拉框\n    if (search_type === \'select\') {\n        var $sel = $(\'<select>\');\n        $sel.addClass(\'form-control\');\n        $sel.attr(\'name\', name);\n        $.each(GLOBAL_DICT[global_name], function (k, v) {\n            option = document.createElement(\'option\');\n            $(option).text(v[1]);\n            $(option).val(v[0]);\n            $sel.append(option);\n        });\n\n        $(this).parent().parent().next().remove();\n        $(this).parent().parent().after($sel);\n    } else {\n        var $inp = $(\'<input>\');\n        $inp.addClass(\'form-control\');\n        $inp.attr(\'name\', name);\n        $inp.prop(\'type\', \'text\');\n        $(this).parent().parent().next().remove();\n        $(this).parent().parent().after($inp);\n    }\n});\n```\n\n### 搜索框的动态添加\n\n我们要允许多个条件的联合查询，因此我们需要点击最左侧的加号可以动态得去生成搜索框，因此针对这个加号添加点击事件。\n\n```javascript\n// 如果要求点击事件添加多个搜索条件的话因为这个后添加的条件一开始也是没有的，因此也要做事件的委派\n$(\'.search-list\').on(\'click\', \'.add-search-condition\', function () {\n    if ($(this).children(\'span\').hasClass(\'glyphicon-plus\')) {\n        /**\n         * 如果我当前点击a标签的符号是一个加号的话那么就执行加一个的操作\n         * 1、克隆一个search-item\n         * 2、然后把这个item下的a标签中的span的class改为减号\"glyphicon-minus\"\n         * */\n         var newSearchItem = $(this).parent().parent().clone();\n         $(newSearchItem).find(\'.add-search-condition\').find(\'span\').removeClass(\'glyphicon-plus\').addClass(\'glyphicon-minus\');\n         $(\'.search-list\').append(newSearchItem);\n     } else {\n         /**\n          * 条件能走到这里说明点的这个选项是没有加号的，是一个减号；\n          * 如果我点击的当前a标签的符号是一个减号的话，那么应该执行一个删除的操作\n          * 把当前的点击的这个item给删除掉 */\n          $(this).parent().parent().remove();\n     }\n});\n```\n\n### 查询数据的提交\n\n现在已经可以做到添加多条数据了，接下来就是需要对数据进行提交搜索了。数据提交的第一步就是要先把所有的搜索条件都拿到再说：\n\n```javascript\nfunction getSearchCondition() {\n    // 搜索条件可能有多个，这里直接构造一个字典去保存。\n    var conditon = {};\n    // 遍历search-list下的所有条件，找到所有type为text或者select框。\n    $(\'.search-list\').find(\'input[type=text],select\').each(function () {\n        // $(this)，这个要不就是input框，要你就是select，获取所有搜索条件\n        var name = $(this).attr(\'name\');\n        var value = $(this).val();\n        // 关于搜索条件这一块，比如针对服务器搜索，针对机柜是b14并且又是在线状态的服务器\n        // 这里的两个条件是不同的条件，不同的条件的时候应该是与的关系，比如既是上线状态又是b13机柜的。\n        // 针对同样条件的，比如收到两个条件分别为b13机柜和b14机柜，这样应该是或的关系\n        // 不能说这个设备又是13机柜又是14机柜的，这个是不合理的，因此做如下处理\n        // 同样的一个属性归到一个列表里去，不同的属性直接赋值即可。\n        if (conditon[name]) {\n            conditon[name].push(value)\n        } else {\n            conditon[name] = [value]\n        }\n    });\n    return conditon;\n}\n```\n\n数据的发送这里不单独做发送，而是在在执行初始化initial的时候直接传递过去，让后台去接收，当然这里的提交方式就是通过get方式提交的了：\n\n```javascript\n# 对initial进行进一步的扩展\nfunction initial(url) {\n    // 执行一个函数，获取当前搜索条件，没有条件的时候拿到的是一个空对象\n    var searchCondition = getSearchCondition();\n    $.ajax({\n        url: url,\n        type: \'GET\',\n        data: {\'condition\': JSON.stringify(searchCondition)},\n        dataType: \'JSON\',\n        success: function (arg) {\n            /*\n             * server_list: 相关资产信息\n             * table_config: 自定义的表配置\n             * global_dict: 相关的状态信息\n             * */\n             $.each(arg.global_dict, function (k, v) {\n                 GLOBAL_DICT[k] = v;\n             });\n             initTableHeader(arg.table_config);\n             initTableBody(arg.server_list, arg.table_config);\n             initSearch(arg.search_config);\n       }\n   })\n}\n```\n\n那么这个条件在最开始生成页面的时候其实就是不存在的，是一个空字典（对象），那么后续我们添加了条件以后应该还有一个触发搜索的机制，目前还有一个小件没有用到，那就是我们一开始放那的那个搜索按钮，因此我们现在再对这个搜索按钮加一个事件：\n\n```javascript\n// 搜索按钮触发事件，重新获取结果，让它重新生成一下就可以了。\n$(\'#doSearch\').click(function () {\n    initial(url);\n})\n```\n\n数据的发送到这里也就完成了\n\n### 后端接收和处理\n\n因为我们是通过get方式发送到后端的，所以后端也是通过get方式去取数据就可以了。key为condition，name为对应的字段名，value为对应要查询的属性值，不同的字段类型之间的查询关系为or，同类型的\n\n```python\n# 针对获取server_list进行函数的封装\nfrom django.db.models import Q \nfrom backend import models\ndef get_data_list(request, table_config, model_cls):\n    con = Q()\n    condition = request.GET.get(\'condition\')\n    condition_dict = json.loads(condition)\n    for name, values in condition_dict.items():\n        ele = Q()\n        ele.connector = \'OR\'\n        for item in values:\n            ele.children.append((name, item))\n        con.add(ele, \'AND\')\n    values_list = [row[\'q\'] for row in table_config if row[\'q\']]\n    server_list = model_cls.objects.filter(con).values(*values_list)\n    return server_list\n\n# 调用，传入request， 我们的的table_config， 还有Server的model模型类，然后将server_list返回给前端就可以了。返回的数据都是满足要求的数据，每次使用搜索按钮都会重新发一次请求获取的数据都是重新生成的。\nserver_list = get_data_list(request, server_table_config, models.Server)\n```\n\n","timestamp":1540354517190},{"name":"09-CURD代码.md","path":"04-Django/50-项目实战/01-CMDB/09-CURD代码.md","content":"# CURD代码\n\n## JS CURD Plugin\n\n```javascript\n(function (jq) {\n\n    var GLOBAL_DICT = {};\n    var tbhead = $(\'#tbhead\');\n    var tbbody = $(\'#tbbody\');\n    var search_list = $(\'.search-list\');\n    var csrftoken = $(\'input[name=csrfmiddlewaretoken]\');\n    var CREATE_SEARCH_CONDITION = true;\n\n    // 为字符串创建可以像Python那样的字符串的格式化方法\n    String.prototype.format = function (args) {\n        return this.replace(/\\{(\\w+)\\}/g, function (s, i) {\n            return args[i];\n        });\n    };\n\n    function initial(url) {\n        // 执行一个函数，获取当前搜索条件，没有条件的时候拿到的是一个空对象\n        var searchCondition = getSearchCondition();\n        $.ajax({\n            url: url,\n            type: \'GET\',\n            data: {\'condition\': JSON.stringify(searchCondition)},\n            dataType: \'JSON\',\n            success: function (arg) {\n                $.each(arg.global_dict, function (k, v) {\n                    GLOBAL_DICT[k] = v;\n                });\n                initTableHeader(arg.table_config);\n                initTableBody(arg.server_list, arg.table_config);\n                initSearch(arg.search_config);\n            }\n        })\n    }\n\n    function getSearchCondition() {\n        var conditon = {};\n        $(\'.search-list\').find(\'input[type=text],select\').each(function () {\n            // $(this)，这个要不就是input框，要你就是select，获取所有搜索条件\n            var name = $(this).attr(\'name\');\n            var value = $(this).val();\n            if (conditon[name]) {\n                conditon[name].push(value)\n            } else {\n                conditon[name] = [value]\n            }\n        });\n        return conditon;\n    }\n\n    function initSearch(search_config) {\n        // 有可能有的表单没有设置，没有设置的时候其实就是一个undefined\n        if (search_config && CREATE_SEARCH_CONDITION) {\n            CREATE_SEARCH_CONDITION = false;\n            // 找到搜索框的ul的位置，在里面动态添加li\n            $.each(search_config, function (k, v) {\n                var li = document.createElement(\'li\');\n                $(li).attr(\'search_type\', v.search_type);\n                $(li).attr(\'name\', v.name);\n                if (v.search_type === \'select\') {\n                    $(li).attr(\'global_name\', v.global_name);\n                }\n                var a = document.createElement(\'a\');\n                a.innerHTML = v.text;\n                li.append(a);\n                $(\'.searchArea\').find(\'ul\').append(li)\n            });\n\n            // 初始化搜索默认条件，直接设置defaultcondition的值就可以了。\n            var defaultcondition = search_config[0];\n            $(\'.search-item .searchDefault\').text(defaultcondition.text);\n            // 替换搜索框的标签，如果search_type为select就换成下拉框\n            if (defaultcondition.search_type === \'select\') {\n                var $sel = $(\'<select>\');\n                $sel.addClass(\'form-control\');\n                $sel.attr(\'name\', defaultcondition.name);\n                $.each(GLOBAL_DICT[defaultcondition.global_name], function (k, v) {\n                    var option = document.createElement(\'option\');\n                    $(option).text(v[1]);\n                    $(option).val(v[0]);\n                    $sel.append(option);\n                });\n\n                $(\'.input-group\').append($sel);\n            } else {\n                var $inp = $(\'<input>\');\n                $inp.addClass(\'form-control\');\n                $inp.attr(\'name\', search_config[0].name);\n                $inp.prop(\'type\', \'text\');\n                $(\'.input-group\').append($inp);\n            }\n        }\n    }\n\n    function initTableHeader(table_config) {\n        // 为了保证刷新，所以这里每一次重新请求的时候先清空重新填写数据\n        $(tbhead).empty();\n        var $tr = $(\'<tr>\');\n        $.each(table_config, function (k, v) {\n            if (v.display) {\n                var tag = document.createElement(\'th\');\n                tag.innerHTML = v.title;\n                $tr.append(tag);\n            }\n        });\n        $(tbhead).append($tr);\n    }\n\n    function initTableBody(server_list, table_config) {\n        $(tbbody).empty();\n        $.each(server_list, function (k, row) {\n            var tr = document.createElement(\'tr\');\n            tr.setAttribute(\'nid\', row.id);\n            $.each(table_config, function (key, tbconfig_value) {\n                if (tbconfig_value.display) {\n                    var td = document.createElement(\'td\');\n                    /* 在td标签中添加内容 */\n                    var newKwargs = {};\n                    $.each(tbconfig_value.text.kwargs, function (tpkey, tpvalue) {\n                        var item = tpvalue;\n                        if (tpvalue.substring(0, 2) === \'@@\') {\n                            var choices = GLOBAL_DICT[tpvalue.substring(2, tpvalue.length)];\n                            var nid = row[tbconfig_value.q];\n                            $.each(choices, function (gk, gv) {\n                                if (nid) {\n                                    if (gv[0] === nid) {\n                                        item = gv[1];\n                                    }\n                                }else{\n                                    item = \'\';\n                                }\n\n                            })\n                        } else if (tpvalue[0] === \"@\") {\n                            item = row[tpvalue.substring(1, tpvalue.length)];\n                        }\n                        newKwargs[tpkey] = item;\n                    });\n                    var newText = tbconfig_value.text.tpl.format(newKwargs);\n                    td.innerHTML = newText;\n\n                    /* 为td属性设置属性 */\n                    $.each(tbconfig_value.attrs, function (attrkey, attrvalue) {\n                        if (attrvalue[0] === \'@\') {\n                            attrvalue = row[attrvalue.substring(1, attrvalue.length)];\n                        }\n                        td.setAttribute(attrkey, attrvalue);\n                    });\n\n                    $(tr).append(td)\n                }\n            });\n            $(\'#tbbody\').append(tr);\n        });\n\n    }\n\n    function trIntoEdit($tr) {\n        $tr.children(\'td[edit-enable=\"true\"]\').each(function () {\n            // $(this)就是循环的每一个td对象\n            // 如果传过来的没有设置的话就是undefined，设置的就是设置的值。\n            var editType = $(this).attr(\'edit-type\');\n            if (editType === \'select\') {\n                // 生成下拉框\n                var $tag = $(\'<select>\');\n                var device_type_choices = GLOBAL_DICT[$(this).attr(\'global-key\')];\n                var origin = $(this).attr(\'origin\');\n                $.each(device_type_choices, function (key, value) {\n                    // value才是真正的数据，v.0是id，v1是名称\n                    var $option = $(\'<option>\');\n                    $option.text(value[1]);\n                    $option.val(value[0]);\n                    // 设置默认值\n                    if (value[0] == origin) {\n                        $option.prop(\'selected\', true);\n                    }\n                    $tag.append($option);\n                });\n                // 把内容放到td下\n                $(this).html($tag);\n\n            } else {\n                // 获取原来的td标签的内容\n                var text = $(this).text();\n                // 创建一个input标签并设置里面的内容。\n                var $tag_input = $(\'<input>\');\n                $tag_input.val(text);\n                $(this).html($tag_input);\n            }\n\n        })\n    }\n\n    function trOutEdit($tr) {\n        $tr.children(\'td[edit-enable=\"true\"]\').each(function () {\n            var editType = $(this).attr(\'edit-type\');\n            if (editType === \'select\') {\n                /**\n                 * DOM对象转换为jq对象，只要用$()把dom对象包装起来就可以得到了。\n                 * jq对象转换为dom对象的时候在后面加一个\"[0]\"就可以了。\n                 * 这里将select的jq对象转换为dom对象调用selectedOptions方法。\n                 * */\n                var option = $(this).find(\'select\')[0].selectedOptions;\n                $(this).attr(\'new-origin\', $(option).val());\n                $(this).html($(option).text());\n            } else {\n                var input_val = $(this).find(\'input\').val();\n                $(this).html(input_val);\n            }\n\n        })\n    }\n\n    jq.extend({\n        curd: function (url) {\n            // 调用执行初始化的函数\n            initial(url);\n\n            // 对所有的checkbox绑定事件\n            $(\'#tbbody\').on(\'click\', \':checkbox\', function () {\n                //\n                /**\n                 * $(this)表示当前的checkbox标签\n                 * 1.点击首先检测是否进入编辑模式，如果是，就退出，不是就进入\n                 */\n                var $tr = $(this).parent().parent();\n                // 否则什么都不做，因为本来就是直接点不进入编辑模式的。\n                if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n                    if ($(this).prop(\'checked\')) {\n                        // 进入编辑模式\n                        trIntoEdit($tr);\n                    } else {\n                        // 退出编辑模式\n                        trOutEdit($tr)\n                    }\n                }\n            });\n\n            // 对全选按钮绑定事件\n            $(\'#checkAll\').click(function () {\n                if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n                    $(tbbody).find(\':checkbox\').each(function () {\n                        if (!$(this).prop(\'checked\')) {\n                            $(this).prop(\'checked\', true);\n                            var $tr = $(this).parent().parent();\n                            trIntoEdit($tr)\n                        }\n                    })\n                } else {\n                    $(tbbody).find(\':checkbox\').prop(\'checked\', true);\n                }\n\n\n            });\n\n            // 对反选按钮绑定事件\n            $(\'#checkReverse\').click(function () {\n                if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n                    $(\'#tbbody\').find(\':checkbox\').each(function () {\n                        var $tr = $(this).parent().parent();\n                        if ($(this).prop(\'checked\')) {\n                            $(this).prop(\'checked\', false);\n                            trOutEdit($tr);\n                        } else {\n                            $(this).prop(\'checked\', true);\n                            trIntoEdit($tr);\n                        }\n                    })\n                } else {\n                    $(\'#tbbody\').find(\':checkbox\').each(function () {\n                        if ($(this).prop(\'checked\')) {\n                            $(this).prop(\'checked\', false);\n                        } else {\n                            $(this).prop(\'checked\', true);\n                        }\n                    })\n                }\n\n            });\n\n            // 对取消按钮绑定事件\n            $(\'#checkCancel\').click(function () {\n                if ($(\'#editmodelornot\').hasClass(\'btn-warning\')) {\n                    $(\'#tbbody\').find(\':checkbox\').each(function () {\n                        if ($(this).prop(\'checked\')) {\n                            $(this).prop(\'checked\', false);\n                            var $tr = $(this).parent().parent();\n                            trOutEdit($tr)\n                        }\n                    })\n                } else {\n                    $(\'#tbbody\').find(\':checkbox\').prop(\'checked\', false);\n                }\n            });\n\n            // 编辑模式按钮\n            $(\'#editmodelornot\').click(function () {\n                if ($(this).hasClass(\'btn-warning\')) {\n                    $(this).removeClass(\'btn-warning\');\n                    $(this).text(\'进入编辑模式\');\n                    $(\'#tbbody\').find(\':checkbox\').each(function () {\n                        var $tr = $(this).parent().parent();\n                        if ($(this).prop(\'checked\')) {\n                            trOutEdit($tr);\n                        }\n                    })\n                } else {\n                    $(this).addClass(\'btn-warning\');\n                    $(this).text(\'退出编辑模式\');\n                    $(\'#tbbody\').find(\':checkbox\').each(function () {\n                        var $tr = $(this).parent().parent();\n                        if ($(this).prop(\'checked\')) {\n                            trIntoEdit($tr);\n                        }\n                    })\n                }\n            });\n\n            // 删除按钮\n            $(\'#multiDel\').click(function () {\n                var idList = [];\n                $(tbbody).find(\':checked\').each(function () {\n                    idList.push($(this).val());\n                });\n                $.ajax({\n                    url: url,\n                    type: \'delete\',\n                    headers: {\"X-CSRFToken\": $(csrftoken).val()},\n                    data: JSON.stringify(idList),\n                    success: function (arg) {\n                        console.log(arg)\n                    }\n                })\n            });\n\n            // 刷新按钮\n            $(\'#refresh\').click(function () {\n                // 刷新一遍重新拿数据\n                initial(url);\n            });\n\n            // 保存按钮\n            $(\'#save\').click(function () {\n                // 设计为首先推出编辑模式以后才能保存\n                var editornot = $(\'#editmodelornot\');\n                if ($(editornot).hasClass(\'btn-warning\')) {\n                    // 在编辑模式下应该退出\n                    $(\'#tbbody\').find(\':checkbox\').each(function () {\n                        if ($(this).prop(\"checked\")) {\n                            var $tr = $(this).parent().parent();\n                            trOutEdit($tr);\n                        }\n                    });\n                    $(editornot).removeClass(\'btn-warning\');\n                    $(editornot).text(\'进入编辑模式\');\n                }\n                // 定一个修改资产的列表总表，下面去循环每一个发生变化的项然后append进来\n                var all_list = [];\n                // 退出以后获取用户修改过的数据，然后通过ajax提交到后台\n                $(\'#tbbody\').children().each(function () {\n\n                    // $(this)这里指的就是tr\n                    var $tr = $(this);\n                    var nid = $tr.attr(\'nid\');\n                    var row_dict = {};\n                    var flag = false;\n                    $tr.children().each(function () {\n                        // 要判断是否可编辑，同时还要判断下拉框的情况下\n                        var oldData = $(this).attr(\'origin\');\n                        if ($(this).attr(\'edit-enable\') === \'true\') {\n                            if ($(this).attr(\'edit-type\') == \'select\') {\n                                var newData = $(this).attr(\'new-origin\');\n                                if (newData) {\n                                    if (newData != oldData) {\n                                        var name = $(this).attr(\'name\');\n                                        row_dict[name] = newData;\n                                        // 如果写过数据就置位为true\n                                        flag = true;\n                                    }\n                                }\n                            } else {\n                                var newData = $(this).text();\n                                if (newData != oldData) {\n                                    var name = $(this).attr(\'name\');\n                                    row_dict[name] = newData;\n                                    // 如果写过数据就置位为true\n                                    flag = true;\n                                }\n                            }\n\n                        }\n                    });\n                    // 如果没有编辑的话dict可能为空，因此要做一下判断\n                    if (flag) {\n                        row_dict[\'id\'] = nid;\n                        all_list.push(row_dict);\n                    }\n                });\n                /**\n                 * RestfulApi\n                 * 添加：post；获取用get；删除：delete；修改:put\n                 * */\n                $.ajax({\n                    url: url,\n                    method: \'PUT\',\n                    headers: {\"X-CSRFToken\": $(csrftoken).val()},\n                    data: JSON.stringify(all_list),\n                    success: function (arg) {\n                        console.log(arg);\n                    }\n                })\n            });\n\n            // 搜索框选择不同的类型的时候对应的类型也要变，一开始的时候是没有li的\n            $(search_list).on(\'click\', \'li\', function () {\n                // 点击li执行函数\n                var li_text = $(this).text();\n                var search_type = $(this).attr(\'search_type\');\n                var name = $(this).attr(\'name\');\n                var global_name = $(this).attr(\'global_name\');\n\n                // 替换显示的文本\n                $(this).parent().prev().children(\'.searchDefault\').text(li_text);\n\n                // 替换搜索框的标签，如果search_type为select就换成下拉框\n                if (search_type === \'select\') {\n                    var $sel = $(\'<select>\');\n                    $sel.addClass(\'form-control\');\n                    $sel.attr(\'name\', name);\n                    $.each(GLOBAL_DICT[global_name], function (k, v) {\n                        option = document.createElement(\'option\');\n                        $(option).text(v[1]);\n                        $(option).val(v[0]);\n                        $sel.append(option);\n                    });\n\n                    $(this).parent().parent().next().remove();\n                    $(this).parent().parent().after($sel);\n                } else {\n                    var $inp = $(\'<input>\');\n                    $inp.addClass(\'form-control\');\n                    $inp.attr(\'name\', name);\n                    $inp.prop(\'type\', \'text\');\n                    $(this).parent().parent().next().remove();\n                    $(this).parent().parent().after($inp);\n                }\n\n            });\n\n            // 对搜索框的加号添加点击事件\n            $(search_list).on(\'click\', \'.add-search-condition\', function () {\n                if ($(this).children(\'span\').hasClass(\'glyphicon-plus\')) {\n                    /**\n                     * 如果我当前点击a标签的符号是一个加号的话那么就执行加的操作\n                     * 1、克隆一个search-item\n                     * 2、然后把这个item下的a标签中的span的class改为减号\"glyphicon-minus\"\n                     * */\n                    var newSearchItem = $(this).parent().parent().clone();\n                    $(newSearchItem).find(\'.add-search-condition\').find(\'span\').removeClass(\'glyphicon-plus\').addClass(\'glyphicon-minus\');\n                    $(\'.search-list\').append(newSearchItem);\n                } else {\n                    /**\n                     * 如果我点击的当前a标签的符号是一个减号的话，那么应该执行一个删除的操作，把当前的点击的这个item给删除掉\n                     * */\n                    $(this).parent().parent().remove();\n                }\n\n            })\n\n            // 搜索按钮触发事件，重新获取结果\n            $(\'#doSearch\').click(function () {\n                /**\n                 * 获取input框，或者select框，获取name和value\n                 * 通过ajax提交到后台。\n                 * */\n                initial(url);\n            })\n        }\n    })\n\n\n})(jQuery);\n```\n\n## Search部分HTML\n\n```html\n<div>\n        <!--搜索列表-->\n        <div class=\"search-list clearfix\" style=\"position: relative;\">\n            <!--搜索按钮，col-md-offset-10,列偏移，向右占位10个，然后搜索按钮实际占位是两个-->\n            <div class=\"search-btn col-md-offset-10 col-md-2\" style=\"position: absolute;bottom: 1px;text-align: right;\">\n                <input id=\"doSearch\" type=\"button\" class=\"btn btn-primary\" value=\"搜索\"/>\n            </div>\n\n            <!--每一个搜索条目，因为这个的定位是relative用来给内部做相对定位的，如果说本身没有设置宽度撑开的话\n            那么本身定位就是有问题的，宽度是个空，因此会出现元素重叠的现象。不管你加多少个都撑不开\n            都叠在一起了。\n            -->\n            <div class=\"search-item col-md-8 clearfix\" style=\"position: relative;height: 35px;\">\n                <!--左边的加号-->\n                <div style=\"position: absolute;left:0;width: 38px;\">\n                    <a type=\"button\" class=\"btn btn-default add-search-condition\">\n                        <span class=\"glyphicon glyphicon-plus\"></span>\n                    </a>\n                </div>\n                <!--右边的输入框，或者是select框-->\n                <div class=\"input-group searchArea\" style=\"position: absolute;left: 40px;right: 0;\">\n                    <div class=\"input-group-btn\">\n                        <button type=\"button\" class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\">\n                            <span class=\"searchDefault\">默认值</span>\n                            <span class=\"caret\"></span>\n                        </button>\n                        <ul class=\"dropdown-menu\"></ul>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n```\n\n## 按钮组\n\n```html\n<div class=\"btn-group row\" role=\"group\">\n        <button id=\"checkAll\" type=\"button\" class=\"btn btn-default\">全选</button>\n        <button id=\"checkReverse\" type=\"button\" class=\"btn btn-default\">反选</button>\n        <button id=\"checkCancel\" type=\"button\" class=\"btn btn-default\">取消</button>\n        <button id=\"multiDel\" type=\"button\" class=\"btn btn-default\">删除</button>\n        <button id=\"refresh\" type=\"button\" class=\"btn btn-default\">刷新</button>\n        <button id=\"save\" type=\"button\" class=\"btn btn-default\">保存</button>\n        <button id=\"editmodelornot\" type=\"button\" class=\"btn btn-default\">进入编辑模式</button>\n    </div>\n```\n\n## 数据表框架\n\n```html\n<div class=\"row\">\n        {% csrf_token %}\n        <table class=\"table table-bordered table-hover\">\n            <thead id=\"tbhead\"></thead>\n            <tbody id=\"tbbody\"></tbody>\n        </table>\n</div>\n```\n\n","timestamp":1540354517190},{"name":"99-CMDB-1.md","path":"04-Django/50-项目实战/01-CMDB/99-CMDB-1.md","content":"# CMDB\n\n> 配置管理数据库\n\n## CMDB介绍\n\n运维愿景：\n\n\t1. 自动装机\n\t2. 配置管理\n\t3. 监控\n\t4. 堡垒机\n\t\n\t必备：资产管理\n\n目前状况：\n目前状况：\n\t手动维护Excel表格\n\t资产自动采集并汇报入库，少了块硬盘多了个内存自动记录汇报\n\t\n\tCMDB - 配置管理数据库（资产管理）\n\n如何实现自动采集？\n如何实现自动采集？\n\tsubprocess\n\tLinux基本命令\n\tv = subprocess.getoutput(\'ls\')\n\t1. Agent\n\t\n\t2. SSH类，paramiko，(机器少的时候用paramiko，因为ssh本身存在性能瓶颈)\n\t\tpip3 install paramiko\n\t\t\n\t3. saltstack(Python开发)\n\t\tmaster\n\t\t\tyum install salt-master\n\t\t\t\n\t\t\t配置：1.1.1.1\n\t\t\tservice salt-master start\n\t\t\t\n\t\tsalve\n\t\t\tyum install salt-minion\n\t\t\t配置：\n\t\t\t\tmaster: 1.1.1.1\n\t\t\tservice salt-master start\n\t\tsalve\n\t\t\tyum install salt-minion\n\t\t\t配置：\n\t\t\t\tmaster: 1.1.1.1\n\t\t\tservice salt-master start\n\n\n​\t\n\t\t授权：\n\n​\t\t\n​\t\t\n​\t\t\n\t\t执行命令：\n\t\t\t在master上执行： salt \"*\" cmd.run \"ifconfig\"\n\t\n\t4. puppet(ruby)\n\n目标：兼容三种采集方式软件\n目标：兼容三种采集方式软件\n​\t\n​\t\t\n任务：\n\t1. Agent方式\n\n\t\tAPI：Django接收数据并入库\n\t\n\t\t程序：放置在每台服务器\n\t\n\t2. SSH类\n\t\n\t\tAPI：Django接收数据并入库\n\t\n\t\t程序：放在中控机\n\t\n\t3. saltstack\n\t\n\t\thttp://www.cnblogs.com/wupeiqi/articles/6415436.html\n\t\n\t\tAPI：Django接收数据并入库\n\t\n\t\tmaster:\n\t\t\tv = subprocess.getoutput(\'salt \"*\" cmd.run \"ls\"\')\n\t\n\t\t前提：\n\t\t\t两个虚拟机：\n\t\t\t\t安装：\n\t\t\t\t\tmaster\n\t\t\t\t\tminion\n\t\t\t\t\n\t\t\t\t配置：\n\t\t\t\t\t...\n\t\t\t\t授权：\n\t\t\t\t\t...\n\t\t\t\t\t\n\t发送：\n\t\t# url = \"http://127.0.0.1:8000/asset.html\"\n\t\t# import requests\n\t\t#\n\t\t# response = requests.post(url,data={\'k1\':value1,\'k2\':value2})\n\t\t# print(response.text)\n\n\nCMDB资产采集：\nCMDB资产采集：\nCMDB资产采集：\n\n- 采集资产：执行命令，正则或字符串方法获取想要的数据\n- 兼容性\n- 汇报数据\n\n```python\n# 使用字符串导入模块，下面就是从a模块下的b模块下导入c\nimportlib.import_model(\'a.b.c\')\n\nm = importlib.import_model(\'a.b.c\')\ncls = getattr(m, \'d\')\ncls()\n```\n\n面向对象：\n\n```python\nclass Foo:\n    def __init__(self, xxx):\n        pass\n    @classmethod\n    def instance(cls):\n        return cls()\n    def process(self):\n        pass\nif hasattr(Foo, \'instance\'):\n    obj = Foo.instance()\nelse:\n    obj = Foo()\n```\n\n面向对象2：\n\n```python\nclass A:\n    def f1(self):\n        self.f2()\n    def f2(self):\n        print(\'A.f2\')\n\nclass B(A):\n    def f2(self):\n        print(\"B.f2\")\nobj = B()\nobj.f1()  # B.f2\n```\n\n\n\n\n\n","timestamp":1540354517190},{"name":"01-Django的Admin.md","path":"04-Django/50-项目实战/02-CRM/01-Django的Admin.md","content":"","timestamp":1540354517190},{"name":"02-CRM概述.md","path":"04-Django/50-项目实战/02-CRM/02-CRM概述.md","content":"","timestamp":1540354517190},{"name":"03-定制启动文件.md","path":"04-Django/50-项目实战/02-CRM/03-定制启动文件.md","content":"# 定制启动文件\n\n1. 创建App组件，比如我的组件叫lamber\n\n2. 在settings中注册我们的app\n\n   ```python\n   # 如果你不用django的admin的话也不用django的那些认证系统的话，一部分组件是可以注释掉的\n   # 注意自己在注册的时候的方式，不要直接写一个app的名字。\n   INSTALLED_APPS = [\n       # \'django.contrib.admin\',\n       # \'django.contrib.auth\',\n       \'django.contrib.contenttypes\',\n       \'django.contrib.sessions\',\n       # \'django.contrib.messages\',\n       \'django.contrib.staticfiles\',\n       \'lamber.apps.LamberConfig\'\n       \'app01\',\n   ]\n   ```\n\n3. 指定启动的时候加载的文件\n\n   ```python\n   # 所有app在启动的时候都会执行每一个app中的两个文件，一个是apps，一个是admin.py，而且apps.py先执行\n   # 这里指定执行我们的文件，lamber.py而不是admin.py。\n   from django.apps import AppConfig\n   \n   \n   class LamberConfig(AppConfig):\n       name = \'lamber\'\n   \n       def ready(self):\n           super(LamberConfig, self).ready()\n   \n           from django.utils.module_loading import autodiscover_modules\n           autodiscover_modules(\'lamber\')\n   ```\n\n\n这样在刚刚运行的时候每一个app就会运行我们自己指定admin文件也就是lamber.py文件。","timestamp":1540354517190},{"name":"04-Model&url生成.md","path":"04-Django/50-项目实战/02-CRM/04-Model&url生成.md","content":"# Model&URL\n\n## 自动注册Model\n\n在lamber的app中我新建一个service的python package，在里面新建一个v1.py用于存放我们注册Model相关的业务逻辑。\n\n```python\n# lamber/service/v1.py\nclass BaseLamberAdmin(object):\n    pass\n\nclass LamberSite(object):\n    def __init__(self):\n        self._registry = {}\n        self.namespace = \'lamber\'\n        self.appname = \'lamber\'\n\n    def register(self, model_class, xxx=BaseLamberAdmin):\n        # 这里的xxx其实就是相当于django admin里面的admin_class\n        self._registry[model_class] = xxx(model_class, self)\n\nsite = LamberSite()\n```\n\n然后我们就可以在其他的app里面仿照djang admin中的admin.py那样去新建一个我们自己的注册文件，比如叫lamber.py。根据上面的设定，只要程序一启动起来，就回去执行我们的lamber.py文件。在Django Admin中我们是通过`admin.site.register(models.xxx)`这样的方式去注册，在这里我们同样可以这样去操作：\n\n```python\n# 以新建一个app01中的lamber.py为例\nfrom lamber.service import v1\nfrom app01 import models\n\nv1.site.register(models.UserInfo)\n```\n\n这样就完成了一个模型类的注册，其他类的注册也是按照这个流程以此类推。其实这里的site本身就是LamberSite()的一个实例化的对象，所以我们不管怎么使用，使用的都是这样个实例化后的对象，所以这是一个单例模式的应用。\n\n我们调用了site实例的register方法，register方法会填充初始的默认字典`_register`，其中key就是我们的`model_class`，value就是`BaseLamberAdmin`的对象。这里每一个value其实都是不同的对象，原因很简单，因为传入的`model_class`不一样，所以生成的对应实例也不是一个。\n\n这里其实可以看到，我们在调用register方法的时候，只传入了默认一个模型类，但是在register方法中还有个xxx，有一个默认值，是BaseLamberAdmin，这里后面会说到，我们这里这个类还可以自定制。\n\n就目前来讲，我们完成了注册操作以后其实就是得到了一个构造好的`_registry`字典。\n\n## 自动生成URL\n\n我们最终的目的是要注册类以后就生成一系列的url供我们使用和访问，类似于django admin中的如下模式：\n\n- 查：http://127.0.0.1:8000/admin/app01/userinfo/\n- 增：http://127.0.0.1:8000/admin/app01/userinfo/add/\n- 改：http://127.0.0.1:8000/admin/app01/userinfo/1/change/\n- 删：http://127.0.0.1:8000/admin/app01/userinfo/1/delete/\n\n我们的目的是为了每注册一个类，就为这个模型类生成这样的一套CURD的操作，让操作流程标准化。因此对LamberSite做进一步扩展：\n\n```python\nclass LamberSite(object):\n    def __init__(self):\n        self._registry = {}\n        self.namespace = \'lamber\'\n        self.appname = \'lamber\'\n\n    def register(self, model_class, xxx=BaseLamberAdmin):\n        self._registry[model_class] = xxx(model_class, self)\n\n    def login(self, request):\n        # 默认的login页面，login和logout其实是不需要动态生成的。\n        return HttpResponse(\'login\')\n\n    def logout(self, request):\n        return HttpResponse(\'logout\')\n\n    def get_urls(self):\n        # 先把这些不需要动态生成的扔在这里。\n        ret = [\n            path(\'login/\', self.login, name=\'login\'),\n            path(\'logout/\', self.logout, name=\'logout\')\n        ]\n\t\t# 动态的把我们注册的模型类的操作通过循环_registry添加到这个ret里面去。\n        # 循环的key是模型类，value是BaseLamberAdmin的对象。\n        for model_cls, lamber_admin_obj in self._registry.items():\n            # 获取字符串app的名称和模型类的名称。比如app01下的userinfo类。\n            appname = model_cls._meta.app_label\n            model_name = model_cls._meta.model_name\n            # 调用lamber_admin_obj对象的urls方法生成这一个类的增删改查方法\n            ret.append(path(\'%s/%s/\' % (appname, model_name), include(lamber_admin_obj.urls),))\n\t\t# 将所有的url对应关系返回\n        return ret\n\n    @property\n    def urls(self):\n        return self.get_urls(), self.appname, self.namespace\n```\n\n在生成对应模型类的时候，我们调用了BaseLamberAdmin的对象的urls方法，这个方法的作用是为了生成这个类的CURD的url路由映射，这样，不管我们注册了几个类，只要循环调用urls方法就可以了，接下来看一下这个urls方法是如何写的。\n\n```python\nclass BaseLamberAdmin(object):\n\n    def __init__(self, model_class, site):\n        self.model_class = model_class\n        self.site = site\n        # 提前协上一点常用的\n        self.app_label = self.model_class._meta.app_label\n        self.model_name = self.model_class._meta.model_name\n        self.request = None\n        \n    def changelist_view(self, request):\n        pass\n\n    def add_view(self, request):\n        pass\n\n    def delete_view(self, request, object_id):\n\t\tpass\n\n    def change_view(self, request, object_id):\n        pass\n\n    @property\n    def urls(self):\n        # 首先获取到对应的app的名称，以及模型类的名称。\n        info = self.model_class._meta.app_label, self.model_class._meta.model_name\n        urlpatterns = [\n            # 我们自己构造一个urlpatterns，构造成功以后返回就行了。这里的视图函数我们后续慢慢补充\n            \n            # 如果什么也不接收就是默认显示所有数据，注意reverse url的拼接\n            path(\'\', self.changelist_view, name=\'%s_%s_changelist\' % info),\n            # 如果是add，那么就是要添加数据\n            path(\'add/\', self.add_view, name=\'%s_%s_add\' % info),\n            # 删除和修改数据都应该传递一个数据的id过来，我们才知道要修改哪一个\n            path(\'<path:object_id>/delete/\', self.delete_view, name=\'%s_%s_delete\' % info),\n            path(\'<path:object_id>/change/\', self.change_view, name=\'%s_%s_change\' % info),\n        ]\n        return urlpatterns\n```\n\nurls.py中，直接调用v1中site对象的urls方法，因为加了property的装饰器，因此可以直接像属性一样调用，实际上这里返回的就是一个元组，分别为urls对应关系、appname、namespace。这里的逻辑和include的逻辑是一样的，具体include的逻辑可以参照上一节Django中的include的逻辑说明。include在这里返回的也是一个元组。\n\n```python\n# 调用成功之后所有注册的model class就全部加入进来了。\nfrom lamber.service import v1\nurlpatterns = [\n    path(\'lamber/\', v1.site.urls),\n]\n```\n\n## 反向URL的生成\n\n> 首先说一下为什么会用到反向的url，其中一个原因就是我们的CURD业务逻辑对应的都是BaseLamberAdmin中的一套CURD的方法（changelist_view，add_view，delete_view，change_view），以增加为例，比如userinfo数据类中添加成功了应该跳转回userinfo的列表，那么这个add_view如何知道跳转回哪个展示列表，它是不知道的，它不知道应该跳转回userinfo的展示列表还是usergroup的展示列表的，这个时候只能利用反向URL来跳转回去，具体看如下是如何操作的。\n\n生成url的时候其实就是用的reverse，不过和之前唯一的区别就是我们加入了namespace，namespace的作用其实就是在之前的url逻辑上又做了一层的区分，比如说两个app的reverse的name都叫aaa，为了区别到底是哪个aaa，就可以加上namespace加以区别。因此在使用反向url的时候我们还要额外的带上namespace，否则Django不知道你是要为哪一个namespace生成。\n\n还记得看include源码的时候，namespace如果没有传递的时候namespace其实就是appname。\n\n```python\n# 在这里必须要加上namespace，我们这里的namespace就是lamber\n# 如果在分发的时候指定了namespace，那么在反向生成的时候就必须指定namespace\n# 使用的方式很简单，就是reverse name:namespace\n\"\"\"\n常见的指定namespace的方式\npath(\'\', include(\'app01.urls\', namespace=\'xx\'))\n\"\"\"\nprint(reverse(\'lamber:login\'))\n\n# 如果不指定namespace的话对应的反向URL找不到会报如下的错误\nNoReverseMatch at /lamber/login/\nReverse for \'login\' not found. \'login\' is not a valid view function or pattern name.\n```\n\n知道如何生成反向URL了，那么根据我们定制的规则，其实就可以通过拼接name得到对应的url了。\n\n## 多级namespace反向URL\n\nurl的对应关系是可以嵌套的，比如：\n\n```python\nurlpatterns = [\n    path(\'test1/\', include([\n        path(\'aaa/\', include([\n            path(\'bbb/\', views.bbb, name=\'bbb\')\n        ], namespace=\'n2\')),\n    ], namespace=\'n1\'))\n]\n```\n\n针对这种情况下要按照如下的办法生成反向url：\n\n```python\nfrom django.urls import reverse\n# 这个namespace多层嵌套的情况下，从最外层开始依次往下写就可以了。有几层套几层就行了。\nprint(reverse(n1:n2:bbb))\n```\n\nnamespace的意义在于区分不同的app之间重复的反向name的情况。","timestamp":1540354517190},{"name":"05-数据展示.md","path":"04-Django/50-项目实战/02-CRM/05-数据展示.md","content":"# 数据展示\n\n从展示页面change_list_view开始，比如现在用户想要访问的是app01下的userinfo，那么此时应该展示所有的userinfo的model class的信息。那么首先从取数据开始。\n\n取数据要拿到对应的模型类，在之前注册的时候还记得_registry中存的是什么么？key为对应的模型类，而value是对应的BaseLamberAdmin的对象，在构造函数`__init__`我们传递了两个参数，一个是model class，第二个则是LamberAdmin的对象。因此我们可以通过构造函数中的model_class直接拿过来就可以了。\n\n```python\n# BaseLamberAdmin的changelist_view方法\ndef changelist_view(self, request):\n    result_list = self.model_class.objects.all()\n    context = {\n        \'result_list\': result_list,\n    }\n    return render(request, \'checklist_view.html\', context)\n```\n\n## 通用性问题\n\n现在对应的数据我们已经拿到了，我们可以通过在前端页面去遍历result_list，然后输出每一条记录的对应字段，但是之前讲到的，我们这里的CURD是一个统一的方法，也就是说不管是你哪个模型类注册进来了，在访问changelist_view的时候我都要把字段给你展示出来，那么这就有问题了，我怎么知道应该展示哪个字段？用的模板也是一套，在前端界面这个是不能写死的，比如前端循环的每一条记录是item，我不能写成`{{ item.name }}`或者其他的，因为我不知道这个模型类里有没有name字段，因此我们这里就要对BaseLamberAdmin进行进一步扩展。\n\n```python\n# 定制一个BaseLamberAdmin，给它里面添加一个字段，list_display，默认是__all__也就是显示所有\nclass BaseLamberAdmin(object):\n    # 定制可以展示的类，默认是__all__，在它的子类中继承它就可以进行个别列的扩展了。\n    list_display = \'__all__\'\n    \n    def changelist_view(self, request):\n    \tresult_list = self.model_class.objects.all()\n    \tcontext = {\n        \t\'result_list\': result_list,\n            # 要展示的字段数据一起扔给前端\n            \'list_display\': self.list_display,\n            \'lamberadmin_obj\': self,\n    \t}\n    \treturn render(request, \'checklist_view.html\', context)\n```\n\n我可以新加一个字段list_display，通过这个我们就可以指定要显示的字段了。还记得我们的类是怎么注册的么？\n\n```python\nv1.site.register(models.UserInfo)\n```\n\n这种注册的时候我们的register方法默认为我们填写了一个xxx=BaseLamberAdmin的类，如果我们自己写呢？这样我们就可以实现我们自己的功能了。\n\n```python\nv1.site.register(models.UserInfo, LamberUserInfo)\n```\n\n同时这个LamberUserInfo继承BaseLamberAdmin，这样就达成了一个我们自定制有的，走我们的，没有的走BaseLamberAdmin默认的；这样我们就可以通过循环self.list_display来得知该显示什么字段了，不指定当然也是ok的，会去寻找父类BaseLamberAdmin的list_display。默认为`__all__`。为`__all__`的时候，就让它不显示具体字段而是把这一条数据对象打印出来，如果指定了具体要显示的字段的话那么就显示具体的字段就可以了。\n\n```python\n\"\"\"\n这里按照admin的逻辑来讲，这里其实我就应该传入几个内容，要注册的类或者类的列表，admin源码中这里可以传入一个类或者一个可迭代对象;然后后面其实还有一个内容就是admin_class，在django的admin中，admin_class我们没传递，默认为None;在register的逻辑中，如果admin_class默认为None的话，那么admin_class就是ModelAdmin，\n\"\"\"\nclass LamberUserInfo(v1.BaseLamberAdmin):\n\n    # 如果我继承了，但是我什么也不做的话其实还是和原来的是一样的，现在继承了，只不过我新加了内容而已\n    list_display = [\'id\', \'username\', \'email\']\n```\n\n## 额外字段的问题\n\n最后的想法是要展示出来一个表格，有表头，数据体。不过这个表可能存在一些扩展字段，比如有一列选项，或者最后有一列操作，允许我们编辑啊，或者删除啊，等等操作，这些内容其实并不是我们的字段数据，在实际的表数据中也不存在这个字段，这个时候我们就可以继续扩展list_display的内容。\n\n![](http://tuku.dcgamer.top/18-10-17/37634909.jpg)\n\n在上面的扩展中，list_display我们填入的只是字符串形式的字段名，当然这里还可以填写方法名，\n\n```python\nfrom django.utils.safestring import mark_safe\nclass LamberUserInfo(v1.BaseLamberAdmin):\n    \n    def checkbox(self, obj=None, is_header=None):\n            return mark_safe(\'<input name=\"pk\" type=\"checkbox\" value=\"{0}\">\'.format(obj.pk))\n\n    list_display = [checkbox, \'id\', \'username\', \'email\',]\n```\n\n这个方法return一个我们想要显示的内容就可以了。\n\n## 数据展示问题\n\n操作上来讲，如果可以拿到list_display那么就可以去遍历操作，通过反射去获取对应的每一个实例item中的对应字段。但是这个遍历的操作不能使用前端的模板语言去获取，因为默认的模版语言所能支持的操作是有限的，因此现在可以考虑使用inclusion_tag去实现。在lamber的app中创建一个目录为templatetags，在里面创建一个lamber_list.py用来展示视图逻辑，展示过程中涉及到如下几个问题：\n\n- 如何展示字段的中文？\n\n  ```\n  关于展示中文的问题，我们在list_display中填写的一般都是字段名称，比如，id，name什么的，那么如何把这些字段名称和对应的中文名称结合起来显示在表头上呢？\n  1、通过前端传递一个BaseLamberAdmin的对象，取到其中封装的models模型类\n  2、我们在models定义的时候一般会给每个字段加上verbose_name用以标识字段的意义，值为中文。\n  3、model class的每一个字段其实都是一个实例，verbose_name本身也是一个属性，那么它就可以取到。\n  4、使用模型类._meta中的get_fields可以拿到对应的字段实例，调用实例的verbose_name方法即可取到。\n     model_class._meta.get_fields(\'username\').verbose_name\n  5、使用getattr可以同样达到这样的效果。\n  ```\n\n- 如何过滤掉list_display中的function\n\n  ```python\n  # 因为list_display中并不是每一个字段都是数据字段，也有我们自定义显示的内容，因此循环遍历的时候我们要判断一下循环的每一个item的类型，判断是否是方法，只要判断这个item是不是FunctionType的实例就可以了。\n  \n  # 与此同时，方法同样也要展示方法的列名，但是方法名改怎么显示呢？可以使用func.__name__的方法，但是那只是获取方法的名称，不过我这里想让它显示中文的表头信息，其实这里可以使用两种办法，一种是写到__doc__里面去，但是__doc__不明显，如果注释写错了就比较难搞了。另外一种就是加一个标记位。让函数类的列再接收一个is_header的参数。非函数列不设置is_header的参数。然后在函数中去判断表头的显示即可。\n  \n  # 方法中可以判断如果是表头就返回一个表头的名字，如果不是表头则返回表数据。\n  for item in list_display:\n      if isinstance(item, FunctionType):\n          print(\'This is a function\')\n          header_list.append(item(lamberadmin_obj, is_header=True) )\n      else:\n          pass\n  ```\n\n这样根据上面的方案，其实对应的方法列就可以改成这样，这样每一个字段具体显示成什么样子，基本就可以完全按照我们的想法来了。：\n\n```python\ndef checkbox(self, obj=None, is_header=None):\n    # 关于这里为什么会传一个obj，因为可能会用到当前对象的一些属性内容。\n    if is_header:\n        # 这里我还可以return mark_safe(\'<input type=checkbox>\')，为这个绑定js事件，实现全选\n        return \'选项\'\n    else:\n        return mark_safe(\'<input name=\"pk\" type=\"checkbox\" value=\"{0}\">\'.format(obj.pk))\n```\n\n那么再inclusiontag中根据不同种类的表判断是否传递is_header即可。\n\n```python\n# lamber/templatetags/lamber_list.py\nfrom django.template import Library\n\n# 只能叫register\nregister = Library()\n\n# 给inclusion_tag分别传递表头和表体的数据。\ndef table_header(list_display, lamberadmin_obj):\n    header_list = []\n    for item in list_display:\n        if isinstance(item, FunctionType):\n            # 或者在函数中加一个选项，根据is_header的布尔值返回不同的内容就可以了。\n            header_list.append(item(lamberadmin_obj, is_header=True) )\n        else:\n            # 如果不是方法列，那么就是真实的数据列，数据列就取verbose name\nheader_list.append(lamberadmin_obj.models_class._meta.get_fields(item).verbose_name)\n            \ndef table_body(result_list, list_display, lamberadmin_obj):\n    # 使用yield不是所有的一起全部都搜索出来；也就是默认不循环，调用的时候才拿一个\n    for item in result_list:\n        sub = []\n        for name in list_display:\n            val = getattr(item, name)\n            sub.append(val)\n            yield sub\n\n# 这里注意inclusion_tag的逻辑，这个func中的返回值是给inclusion_tag中指定的模板md.html使用的。\n# 最后会把经过渲染完成后的md.html的内容拿过来直接扔到调用这个inclusion_tag的模板的位置。\n# 最终我们是要生成一个表格，表格分为表头和表体，这两个部分需要单独的去遍历抽取。\n@register.inclusion_tag(\'md.html\')\ndef func(result_list, list_display, lamberadmin_obj):\n    # 把table body拿到\n    v = table_body(result_list, list_display, lamberadmin_obj)\n    # 拿到table head表头数据\n    h = table_header(list_display, lamberadmin_obj)\n    return {\'xxxxx\': v, \'header_list\': h}\n```\n\n因为inclusion_tag的逻辑，func所return的值其实是给md.html使用的，因此在md模板中直接遍历表头表体填充数据就可以了。\n\n```html\n# lamber/templates/md.html\n# 这里我们在我们自己lamber这一个组件里新增了一个templates文件夹，注意这个要和settings设置的同名\n# 然后如果我们再在这个文件目录写模板文件的话会优先找这里的模板\n<!--我这想写啥就写啥了，反正最后渲染了就可以了，那么这里就可以写一个表格-->\n<table class=\"table table-striped table-bordered\" style=\"margin-top: 10px;\">\n    <thead>\n    <!--遍历表头-->\n    <tr>\n        {% for item in header_list %}\n            <td>{{ item }}</td>\n        {% endfor %}\n    </tr>\n    </thead>\n    <tbody>\n    <!--遍历表数据，逐条将表数据展示出来就可以了。-->\n    {% for item in xxxxx %}\n        <tr>\n            {% for val in item %}\n                <td>{{ val }}</td>\n            {% endfor %}\n        </tr>\n    {% endfor %}\n    </tbody>\n</table>\n```\n\n最后渲染完成的md模板会整体拿过来，放在调用inclusion_tag的位置，注意在使用的时候先load一下，然后把我们需要到的参数传递进去，至于为什么需要这几个参数这里就不赘述了；\n\n```python\n{% load lamber_list %}\n\n<!--数据表格 开始-->\n\n<!--result_list：表内容，list_display：表头，lamberadmin_obj：BaseLamberAdmin的对象。因为我们用到了这个对象里的模型类的部分属性，BaseLamberAdmin对象封装了model_class，因此要传递过来。-->\n{% func result_list list_display lamberadmin_obj %}\n\n<!--数据表格结束-->\n```\n\n**Table_header方法优化**\n\n上面的逻辑我们通过循环取到了表头数据，传递给md.html，在md.html模板中我还要继续循环，这种形式其实一定程度上性能比较低了，因此我们优化一下采用yeild的方式去生成，这样只有在md.html循环的时候直接去拿，相当于变成了一个循环；\n\n```python\ndef table_header(list_display, lamberadmin_obj):\n    # 如果是__all__的话那就没有必要循环了。\n    if list_display == \'__all__\':\n        yield \'对象列表\'\n    else:\n        for item in list_display:\n            if isinstance(item, FunctionType):\n                yield item(lamberadmin_obj, is_header=True)\n            else:\n                yield lamberadmin_obj.model_class._meta.get_field(item).verbose_name\n```\n\n**Table_body方法优化**\n\n```python\nfor item in result_list:\n    # 如果没有指定list_display的话那么默认就是__all__\n    # 那么就循环每一个数据对象，然后调用str方法的时候调用默认的__str__方法\n    if list_display == \"__all__\":\n        # 因为我们要循环，所以要yield一个列表，如果你yield str(item)的话那么就是循环字符串了。\n        yield [str(item), ]\n    else:\n        yield [name(lamberadmin_obj, obj=item) if isinstance(name, FunctionType) else getattr(item, name) for name in list_display]\n```\n\n## 操作列设计\n\n数据列已经完成了，现在我想要在最后加一列操作列，比如这一列可以编辑啊，删除啊，什么之类的，由于并不是数据列的原因，因此我们仍然可以使用上述的在list_display中传入一个方法的形式去构造这一列。\n\n```python\nfrom django.http.request import QueryDict\n\ndef func(self, obj=None, is_header=False):\n    \"\"\"\n    当是表头的时候，返回表头的列名，当不是表头的时候要返回一个html标签，但是不管是编辑还是删除，都是针对\n    一条数据做编辑或者删除，因此需要知道当前这一条数据的id是什么。\n    \"\"\"\n    if is_header:\n        return \'操作\'\n    else:\n        param_dict = QueryDict(mutable=True)\n        base_edit_url = reverse(\"{0}:{1}_{2}_change\".format(self.site.namespace, self.app_label, self.model_name), args=[obj.pk, ])\n\n        # 去掉里面的querydict\n        if self.request.GET:\n            param_dict[\'_changelistfilter\'] = self.request.GET.urlencode()\n            base_edit_url = base_edit_url + \'?\' + param_dict.urlencode()\n            \n        return mark_safe(\"<a href=\'{0}\'>编辑</a>\".format(base_edit_url))\n```\n\n**针对上述内容做说明**\n\n1. 首先最后的目的肯定是要返回一个html标签，这里以编辑为例，那么编辑就要跳转到另外一个界面去进行数据的编辑，那么这个href应该怎么写？这个时候我们就应该用到反向url解析了。\n\n2. 最后要生成的url应该是如下形式的，目标就是要拼出如下结构的url来：\n\n   ```python\n   /lamber/app01/userinfo/1/change/\n   /lamber/app01/userinfo/2/change/\n   /lamber/app01/userinfo/3/change/\n   ```\n\n3. 在BaseLamberAdmin中的url的name是`%s_%s_change`形式的，第一个参数的位置为app名称，第二个位置为model class的名称。因为我们传递过来了BaseLamberAdmin的对象，因此一种方式是可以利用这个对象来获取：\n\n   ```python\n   # 其实这里考察到了如何通过一个对象获取到对应的类，__class__是一种方法\n   # 另外一种方法也可以使用type(obj)来拿到它所属的类。\n   app_name = obj.__class__._meta.app_label\n   model_name = obj.__class__._meta.model_name\n   ```\n\n   另外一种方式也是非常简单的一种方式就是直接在它的父类中直接把我们需要的数据封装进去，就行了。因为我们这里自定义的不管是LamberUserInfo还是其他的类，都要继承自BaseLamberAdmin这个类，因此进行数据的封装一种非常不错的方法。\n\n   ```python\n   class BaseLamberAdmin(object):\n       list_display = \'__all__\'\n   \n       def __init__(self, model_class, site):\n           self.model_class = model_class\n           # 单例模式的LamberSite的对象\n           self.site = site\n           self.app_label = self.model_class._meta.app_label\n           self.model_name = self.model_class._meta.model_name\n           self.request = None\n   ```\n\n4. 在反向url的时候，需要appname，model name，还有就是namespace，self.site中封装了namespace，再把app_label和model_name一起封装近父类就可以使用了。\n\n   ```python\n   # 构造反向url，主键id建议用pk，这样就不用关心你是id还是nid了。\n   base_edit_url = reverse(\"{0}:{1}_{2}_change\".format(self.site.namespace, self.app_label, self.model_name), args=[obj.pk, ])\n   \n   # 这里记得要传递args去填充那个\\d+的参数位置，否则会报错，并且这里接收的是一个可迭代的对象\n   Reverse for \'app01_userinfo_change\' with no arguments not found. 1 pattern(s) tried: \n   [\'lamber\\\\/app01\\\\/userinfo\\\\/(?P<object_id>.+)\\\\/change\\\\/$\']\n   ```\n\n5. 在实际的使用过程中，当前页面的数据条目可能是非常多的，因此会进行分页的操作，常见的分页我们可以看到连接可能为`http://xxx:8000/lamber/app01/userinfo/?page=100`诸如此类的，情况，现在要求是我们点击编辑页面的时候跳转到一个页面进行编辑，然后跳转回来的时候仍然会带着跳转源后面的参数。举个例子，比如你是从100页跳转过来的，那么修改完了以后也应该跳转回100页，而不是第一页。\n\n   ```python\n   # 针对这个问题的解决方案就是为我们跳转标签的href加上当前的参数，再利用这些参数去拼接跳转回来的时候的连接，这样就可以做到跳转前后页面一致了。\n   \n   # 在访问到changelist_view的时候我们可以给构造函数中的self.request赋值。\n   def changelist_view(self, request):\n       self.request = request\n       \n   # 这样在我们的func中就可以拿到self.request这个变量了。既然是将参数放在url连接里的，那么就是GET方式的传参。我们可以通过request.GET取到值。值的内容类似下面的一个结构；request.GET是django.http.request.QueryDict的对象\n   <QueryDict: {\'page\': [\'10\'], \'id\': [\'666\']}>\n   \n   # 这个时候发现这个好像和我们传递的时候格式不太一样，其实使用request.GET.urlencode就可以转换\n   print(request.GET.urlencode()) # page=10&id=666\n   \n   # 当然这里使用的是request.GET，django为我们封装好的，除了django的我们还可以利用urllib这个库的方法，这一种方式不依赖于django，这里也提一下。\n   import urllib\n   urllib.parse.urlencode()\n   \n   # 最简单的办法就是编辑完成以后跳转回去的连接比如http://xxx/lamber/app01/userinfo/的后面拼接上这么一长串的参数，但是为了避免混淆，这里对这一堆参数做一次封装。我们自己生成一个QueryDict的对象，然后将mutable的属性设置为True，这样就可以改它了，默认mutable=False，是不可以修改的。\n   from django.http.request import QueryDict\n   param_dict = QueryDict(mutable=True)\n       \n   # 从传递过来的连接里，如果原来这一堆连接它是带着一堆参数的话，那么好，我拿过来。赋值给param_dict，其中key我命名为_changelistfilter。value就是urlencode后的值(page=10&id=666)，然后再对param_dict使用urlencode进行封装，封装完成以后的url连接形如：\n   \n   #_changelistfilter=%3CQueryDict%3A+%7B%27page%27%3A+%5B%2710%27%5D%2C+%27id%27%3A+%5B%27666%27%5D%7D%3E\n   if self.request.GET:\n       param_dict[\'_changelistfilter\'] = self.request.GET.urlencode()\n       base_edit_url = base_edit_url + \'?\' + param_dict.urlencode()\n   ```\n\n   这样进行二次封装过后的内容就不会与之前的参数有什么冲突了（其实就是怕里面的一些参数比如page啊，id啊会影响到函数的调用，比如参数的重名等等），最后我们将这个内容与base_edit_url合并，一起作为编辑标签的href属性；这样我们就完成了带着额外参数去跳转的目标了。在编辑页面我们也可以把这一部分参数拆出来用来跳转回来使用。这样操作列说明完毕，具体的编辑如何跳转回来，后文再说明。\n\n## 小结\n\n- 使用list_display的方式对字段做自定制的展示。允许字段传入方法或者字符串。\n- model class的所有属性都是可以获取到的，包括verbose_name。\n- 通过yield可以适当的减少不必要的循环，提供程序的性能。\n- 判断一个对象是不是一个方法，可以使用isinstance(item, FunctionType)的方式。\n- inclusion_tag使得复杂的数据展示成为可能。\n- 通过对象获取类的方法可以用`obj.__class__`或者`type(obj)`\n- model class中的_meta封装了很多模型类的属性信息。\n- LamberSite的实例是一个单例，因为每一次导入的都是site，对象都是同一个。\n- 带namespace的反向url生成形式为`namespace:name`\n- 可以通过django的request.GET拿到在url中传递的参数。\n- 我们可以通过实例化QueryDict，并且设置mutable为True去构造一个自定制的QueryDict\n\n","timestamp":1540354517190},{"name":"06-数据操作.md","path":"04-Django/50-项目实战/02-CRM/06-数据操作.md","content":"# 数据操作\n\n## 数据的添加\n\n### 添加按钮\n\n接下来要开始进行数据操作了，首先在调用inclusion_tag的地方加一个a标签，用于添加数据。那么编辑也好，添加也好，都是需要一个跳转链接的，其实操作方式都很多元化，可以是弹出一个模态框，或者是直接跳转到一个新的页面，这里采用跳转到一个新的页面，但是跳转链接怎么拿到呢？这里采用通过后端统一返回的形式。\n\n```html\n<div class=\"container\">\n    <h1>数据列表</h1>\n    <a href=\'{{ add_url }}\' style=\"float: right;\" class=\"btn btn-default\">添加</a>\n\n    <!--数据表格 开始-->\n    {% func result_list list_display lamberadmin_obj %}\n    <!--数据表格结束-->\n</div>\n```\n\n当访问某一个模型类的数据的时候，肯定会走通用的changelist_view这个视图方法，我们就在这里返回。\n\n```python\ndef changelist_view(self, request):\n    # 生成页面上的添加按钮\n    add_url = reverse(\"{0}:{1}_{2}_add\".format(self.site.namespace, self.app_label, self.model_name))\n   \n    context = {\n        \'result_list\': result_list,\n        \'list_display\': self.list_display,\n        \'lamberadmin_obj\': self,\n        \'add_url\': add_url,\n    }\n    return render(request, \'checklist_view.html\', context)\n```\n\n不过这样和编辑存在同样的问题，就是你添加完了以后跳转会哪里？和编辑一样，首先要能跳转回来，而且你从100页跳转过来的，你添加完了以后也要跳转回去。操作也基本和编辑的时候去拼接一个url是大同小异的。\n\n```python\nfrom django.http.request import QueryDict\ndef changelist_view(self, request):\n    param_dict = QueryDict(mutable=True)\n    add_url = reverse(\"{0}:{1}_{2}_add\".format(self.site.namespace, self.app_label, self.model_name))\n    if request.GET:\n        # 判断一下有没有携带参数，如果带了参数再拼接，没带的话就不要拼接了。\n        # 这个特殊封装可以简单看到，比如%3D就是等于号。\n        # 结果_changelistfilter=page%3D10%26id%3D666\n        param_dict[\'_changelistfilter\'] = request.GET.urlencode()\n        add_url = add_url + \'?\' + param_dict.urlencode()\n```\n\n### 基于ModelForm添加数据\n\n点击添加按钮，那么就会进入到我们的BaseLamberAdmin的add_view视图中，应该存在一个添加页面的，但是每一个类字段不一样，属性不同，该如何显示不同的类的字段呢？\n\n这里使用ModelForm的方案去实现，自动为我们生成对应的html表格。\n\n**ModelForm由谁来创建？**\n\n我们知道ModelForm中的内容是可以自定制的，比如，label，error_message，widgets等等。所以这个内容肯定不能写死了，而是应该像展示数据的时候展示列一样，当我不写的时候走默认的`list_display=__all__`，用户还可以自己定制展示的列。这里也是同理的，允许用户自己定制ModelForm，但是如果用户不定制的话就用程序原本默认的ModelForm。\n\n```python\nfrom django.forms import ModelForm\nclass BaseLamberAdmin(object):\n    # 添加一个属性，用于表示模型类，默认为None，表示用程序内部的ModelForm，如果用户想自定制，对这个属性进行重写就可以了。\n    add_or_edit_model_form = None\n    \n    def get_add_or_edit_model_form(self):\n        if self.add_or_edit_model_form:\n            # 如果自定制了，那么就优先返回用户的。\n            return self.add_or_edit_model_form\n        else:\n            \"\"\"\n            否则返回系统内部的定制的默认modelform组件，这里使用type来创建\n            第一个参数是类名，第二个是一个元组，表示继承自哪些类，第三个就是类的一些参数。\n            先创建内层的Meta，然后再创建外层的MyModelForm\n            常规创建方式参考：\n            class MyModelForm(ModelForm):\n                class Meta:\n                    model = self.model_class\n                    fields = \'__all__\'\n            \"\"\"\n            _m = type(\'Meta\', (object, ), {\'model\': self.model_class, \'fields\': \'__all__\'})\n            MyModelForm = type(\'MyModelForm\', (ModelForm, ), {\'Meta\': _m})\n            return MyModelForm\n```\n\nadd_view\n\n```python\n# BaseLamberAdmin中的add_view方法。\ndef add_view(self, request):\n    # GET请求展示数据\n    if request.method == \'GET\':\n        model_form_obj = self.get_add_or_edit_model_form()()\n    else:\n        model_form_obj = self.get_add_or_edit_model_form()(data=request.POST, files=request.FILES)\n        if model_form_obj.is_valid():\n            model_form_obj.save()\n            # 添加成功了以后要进行跳转\n            base_list_url = reverse(\'{0}:{1}_{2}_changelist\'.format(self.site.namespace, self.app_label, self.model_name))\n            # 有参数我才给你拼接，没有参数的话不需要拼接，否则会拼一个None过去。\n           if request.GET.get(\'_changelistfilter\'):\n               base_list_url = \"{0}?{1}\".format(base_list_url, request.GET.get(\'_changelistfilter\'))\n           return redirect(base_list_url)\n    context = {\n        \'form\': model_form_obj\n    }\n\n    return render(request, \'add.html\', context )\n```\n\nadd.html\n\n```html\n# lamber/templates/add.html\n<!--action可以不写，默认就是往当前页面提交。-->\n<form action=\"\" method=\"post\" novalidate>\n    {% csrf_token %}\n    {{ form.as_p }}\n    <input type=\"submit\" value=\"提交\">\n</form>\n```\n\n## 数据的编辑\n\n在数据展示的时候，我们的连接其实已经拼接好了，如果带参数的话，也会给编辑的href跳转链接拼接上我们自定一的参数（_changelistfilter）；\n\n当点击编辑页面的时候，会跳转到编辑页面。\n\n\n\n## 数据的删除\n\n删除操作其实是一样的，大同小异，因此就省略了。参考数据的编辑\n\n## POPUP\n\n> popup是一种添加数据的方式，利用window.open方法打开一个新的浏览器窗口用来添加数据，并且提交完成以后可以动态的添加到当前的页面。其实操作同样可以使用模态对话框太实现，不过popup简单的地方是，popup可以使用已经存在的页面，比如你这个add的页面已经存在了，那么你就可以直接通过popup拿过来使用了。\n\n**POPUP原理**\n\n```javascript\n// 谁发起的我，这个opener代指的就是哪个页面。发起的页面其实就是一开始添加的页面\n// opener可以调用发起页面的一个函数，因此可以在原页面写一个回调函数，用来接收回调的内容。\n\n# popup弹出多级页面\n比如点击一个按钮弹出一个popup，这个popup里面还有一个按钮，可以弹出新的popup按钮，其实这个是可以弹出多级的，那么对应的同样的popup会重复的弹出么？其实是不会的，因为我们在调用window.open的时候，它是有一个name参数的，这个参数其实就是这个open弹窗的唯一标识，假如当前name为x1的弹窗已经存在，那么它不会再创建一个，而是把现在这个干掉重新生成。所以不会出现说同样的一个popup按钮点多次就open多个窗口。\n对应的opener，它是知道谁打开它的，因此我们可以通过opener进行相关的回调操作。\n```\n\n**哪些字段需要动态的添加数据？**\n\n以userinfo表为例，里面如果存在ForeignKey或者多对多关系的时候，比如用户所属的角色，现在我要添加一个用户的话，可以选择角色添加，但是这个时候恰巧这个角色不存在，就需要用到动态添加了。\n\n之前添加数据的时候，我们通过modelform来动态生成的，直接使用form.as_p生成了，但是这种情况下的可定制性非常低，因此我们现在自己去循环form，然后自定制添加页面。\n\n由于页面的生成依旧相对繁琐，因此这里依然使用inclusion_tag来实现这个功能。在lamber项目中的templatetags新建一个lamber_form的py文件用于保存我们的inclusion_tag的逻辑\n\n```python\n# lamber/templatetags/lamber_form.py\nfrom django.template import Library\nfrom django.forms.models import ModelChoiceField\nfrom django.shortcuts import reverse\nfrom lamber.service import v1\n\n\nregister = Library()\n\n@register.inclusion_tag(\'add_edit_form.html\')\n# 我们将modelform的对象作为参数传递给show_add_edit_form\ndef show_add_edit_form(form):\n    form_list = []\n    \"\"\"\n    循环form，其实就是循环每一个标签的过程，那么这个每一个循环的标签到底是什么？\n    通过查看item的type可以知道，每一个item都是django.forms.boundfield下BoundField的对象。\n    通过导入BoundField对象查看源码其实我们可以发现，我们可以用的item的几个属性\n    field：就是对应的form字段的对象，比如fields.CharField或者fields.XX等其他类的对象。\n    通过field属性，我们可以拿到label等信息，这个label获取的其实就是model模型的verbose_name，\n    因此我们可以通过label让它显示字段的中文名称。\n    而每一个print(item)的结果就是调用了item对象中的__str__方法，把这个标签的内容打印出来了。\n    error：可以通过item.errors.0去打印当前字段的错误，和form组件中是一致的。\n    \"\"\"\n    for item in form:\n        # 首先初始化一个字典，默认popup属性为false\n        row = {\n            \'is_popup\': False,\n            \'item\': None,\n            \'popup_url\': None,\n        }\n        \"\"\"\n        什么样的字段才应该支持popup呢？前面说到了，一对多或者多对多的字段是需要支持popup的。在modelform中，一对多或者多对多modelform是通过ModelChoiceField和ModelMultipleChoiceField来实现的，这是有Django默认提供的，支持数据的动态更新，而且这两个类型里都封装了queryset。ModelMultipleChoiceField本身是ModelChoiceField的子类，因此只要判断这个字段是不是ModelChoiceField的实例，并且，这个字段所属的类已经注册就可以了。如果这个类没有注册过，那么对应的反向解析就不存在，url无法生成，自然程序是会报错的。\n        因为ModelMultipleChoiceField和ModelChoiceField中都封装了queryset，因此可以利用item.field.queryset.model来获取到当前字段所属的model class，然后再进一步判断这个model class是否在我们之前注册的_registry字典中。\n        \"\"\"\n        if isinstance(item.field, ModelChoiceField) and item.field.queryset.model in v1.site._registry:\n            # 如果满足条件，那么就是popup字段，字段设置为True。\n            row[\'is_popup\'] = True\n            # 字段为当前form字段实例\n            row[\'item\'] = item\n            # 跳转url，就是要跳转到哪里，同样遵循我们的反向解析url。因为我们的site本身就是单例的\n            # 因此这里直接导入即可，就可以拿到namespace，以及app_label，model_name等内容\n            # 这里为什么要拼接一个?popup，因为，我们popup出来的弹窗最后form提交的地址还是add的那个\n            # 地址，最后是要走BaseLamberAdmin的add_view方法的，非popup的正常提交后是要重定向\n            # 但是popup的提交是不能重定向的，而是要给popup的回调函数返回数据，因此在url中添加标识\n            # 在add_view中通过标识去判断这个是popup的添加还是普通的新增数据。\n            # 这里还要判断对应的添加的是哪一个字段的，因此这里使用auto_id\n            # auto_id形如：id_username，id_ug，id_mmm这样的。\n            row[\'popup_url\'] = reverse(\"{0}:{1}_{2}_add\".format(v1.site.namespace,\n                                             item.field.queryset.model._meta.app_label,\n                                             item.field.queryset.model._meta.model_name)\n            ) + \'?popup=\' + item.auto_id\n        else:\n            # 如果不是需要popup的字段的话，那么就不对默认的row字典做相关操作，只把当前item实例赋值\n            row[\'item\'] = item\n        # 改良，这里可以使用yield进行改良\n        form_list.append(row)\n    return {\'form_list\': form_list}\n```\n\n在判断实例的归属性这里有点需要声明的就是，ModelMultipleChoiceField是继承自ModelChoiceField的，因此如果你在判断的时候，ModelMultipleChoiceField的实例也是ModelChoiceField的实例，因此你是判断不出来的，虽然当前的场景下，不管多选单选框都需要支持popup，但是有的场景下需要明确的区分。这种情况下其实可以使用type来查看，通过type是可以明确分辨出来的。\n\n```python\nfor item in model_form_obj:\n    if type(item.field) == ModelChoiceField:\n        print(111)\n    elif type(item.field) == ModelMultipleChoiceField:\n        print(222)\n```\n\n接下来，show_add_edit_form的返回值会传递个add_edit_form.html；根据传递过来的内容做判断，如果是popup的字段那么就加一个对应的a标签，如果没有的话就不用加。\n\n```html\n# lamber/templates/add_edit_form.html\n<form action=\"\" method=\"post\" novalidate>\n    {% csrf_token %}\n    {% for col in form_list %}\n        {% if col.is_popup %}\n            <p>{{ col.item.field.label }}{{ col.item }}<a href=\"#\" onclick=\"popupOpen(\'{{ col.popup_url }}\')\">添加</a>{{ col.item.errors.0 }}</p>\n        {% else %}\n            <p>{{ col.item.field.label }}{{ col.item }} {{ col.item.errors.0 }}</p>\n        {% endif %}\n    {% endfor %}\n    <input type=\"submit\" value=\"提交\">\n</form>\n\n<script>\n    /*\n    这里请求的url就是我们popup_url，name的话也以url命名。\n    status：1，是否显示状态栏，1表示显示，默认是yes；toolbar表示是否显示工具栏。\n    */\n    function popupOpen(url) {\n        window.open(url, url, \'status=1, height=500, width=600, toolbar=0, resizeable=0\');\n    }\n\n    function popupCallBack1(data_dict) {\n        var tag = document.createElement(\'option\');\n        tag.innerHTML = data_dict.text;\n        tag.setAttribute(\'value\', data_dict.pk);\n        // tag.setAttribute(\'selected\', \'selected\');\n        document.getElementById(data_dict.popid).appendChild(tag);\n    }\n</script>\n```\n\n调用inclusion_tags\n\n```html\n# lamber/templates/add.html\n{% load lamber_form %}\n{% show_add_edit_form form %}\n```\n\n在界面中，接下来点开popup，就对应到相应的添加界面了，添加界面要走BaseLamberAdmin的add_view方法，因此需要对add_view进行扩展；\n\n```python\n# BaseLamberAdmin/add_view方法\ndef add_view(self, request):\n    # GET请求展示数据\n    if request.method == \'GET\':\n        model_form_obj = self.get_add_or_edit_model_form()()\n    else:\n        model_form_obj = self.get_add_or_edit_model_form()(data=request.POST, files=request.FILES)\n        if model_form_obj.is_valid():\n            # modelform的返回值就是你新增的数据对象\n            obj = model_form_obj.save()\n            # 看看有没有传递过来popupid，如果有的话那么是popup更新\n            popid = request.GET.get(\'popup\')\n            if popid:\n                # 直接让它显示__str__的内容在对应的下拉菜单中。\n                text = str(obj)\n\n                # 当内容比较多的时候可以构造一个字典传递到前端，这里指的内容多是在前端要接收的内容多\n                # 构造字典传到前端需要注意，这里扔过去以后在前端会被转义；\n                # 这是由于django的xss给转义的，比如单引号会被转义成\'&#39;\'，让我看起来像乱码\n                # 因此在前端要使用safe一下才能将转义去掉，正常的显示数据。\n                # 还有一个问题就是我们这样传递的话传递过去都是单引号的，因为js支持单引号，所以无妨。\n                # 有些语言只支持双引号。如果需要双引号，要不就在你写的时候传递双引号过去\n                # 要不你就json.dumps一下然后再发过去，这样就是双引的。json.dumps同样需要safe一下。\n                return render(request, \'popup_response.html\', {\n                    \'data_dict\': {\'pk\': obj.pk, \'text\': text, \'popid\': popid, },\n                })\n            else:\n                # 添加成功了以后要进行跳转\n                # /lamber/app01/userinfo + request.GET.get(\'_changelistfilter\')\n                base_list_url = reverse(\'{0}:{1}_{2}_changelist\'.format(self.site.namespace, self.app_label, self.model_name))\n                # 有参数我再给你拼接，没有参数就不要拼接了。\n                if request.GET.get(\'_changelistfilter\'):\n                    base_list_url = \"{0}?{1}\".format(base_list_url, request.GET.get(\'_changelistfilter\'))\n                return redirect(base_list_url)\n    context = {\n        \'form\': model_form_obj\n    }\n\n    return render(request, \'add.html\', context )\n```\n\n如果是popup的话，那么需要将当前添加的这一条数据返回回来到一个页面，这里到popup_response\n\n```html\n# lamber/templates/popup_response\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>关闭页面中……</title>\n</head>\n<body>\n<script>\n    var data_dict = {{ data_dict|safe }}\n    <!--opener可以调用发起这个popup页面的一个回调函数，谁发起的我，这个opener代指的就是哪个页面。发起的页面其实就是一开始添加的页面，也就是add_edit_form.html，在这个页面的js里还有一个回调函数，popupCallBack，这个回调函数是直接可以通过opener调用的。将我们的返回的数据返回去-->\n    opener.popupCallBack(data_dict);\n    window.close()\n</script>\n</body>\n</html>\n```\n\n因为对返回的数据进行了封装，因此我们可以直接使用date_dict.pk的形式调用，来看回调函数：\n\n```javascript\nfunction popupCallBack1(data_dict) {\n        # 不管是单选还是多选下拉菜单其实都是往里面塞option标签\n        var tag = document.createElement(\'option\');\n        tag.innerHTML = data_dict.text;\n        tag.setAttribute(\'value\', data_dict.pk);\n        # 如果需要option是选中状态还可以添加这个状态。\n        // tag.setAttribute(\'selected\', \'selected\');\n        # 通过id找到对应的菜单，然后添加进去就可以了。\n        document.getElementById(data_dict.popid).appendChild(tag);\n    }\n```\n\n### POPUP和模态框的区别？\n\n模态框适用于列表页面，增加当前页面的数据。而不是在添加页面去添加另外一张表的数据。POPUP可以针对原来写的页面直接做重用。\n\n\n\n","timestamp":1540354517190},{"name":"07-数据分页展示.md","path":"04-Django/50-项目实战/02-CRM/07-数据分页展示.md","content":"# 数据的分页展示\n\n> 数据展示页面目前显示的是所有的页面数据，如果数据非常多的话那是很不方便查看的，因此这里需要对数据做分页处理。\n\n之前自定制过一个分页的工具，我们可以直接作为一个工具拿过来使用。不过要稍微做一下修改\n\n```python\n# 我们在项目中新建一个utils的目录，存放我们可能使用到的各种工具类，然后新建一个page.py，把分页操作拿过来\n# lamber/utils/page.py\nclass PageInfo(object):\n    def __init__(self, current_page, all_count, base_url, page_param_dict, per_page=10, show_page=11):\n        \"\"\"\n        :param current_page:\n        :param all_count: 数据库总行数。\n        :param per_page: 每页显示多少条数据。\n        :param base_url: 跳转的url\n        :param page_param_dict: 这个是新加的一个参数，携带原来的参数内容。\n        :return:\n        \"\"\"\n        try:\n            self.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        self.per_page = per_page\n        pages, spare = divmod(all_count, per_page)\n        if spare:\n            page += 1\n        self.all_pager = a\n        self.show_page = show_page\n        self.base_url = base_url\n        self.page_param_dict = page_param_dict\n\n    @property\n    def start(self):\n        return (self.current_page - 1) * self.per_page\n    @property\n    def end(self):\n        return self.current_page * self.per_page\n\n    def pager(self):\n        page_list = []\n        half = int((self.show_page - 1) / 2)\n        if self.all_pager < self.show_page:\n            begin = 1\n            stop = self.all_pager + 1\n        else:\n            if self.current_page <= half:\n                begin = 1\n                stop = self.show_page + 1\n            else:\n                if self.current_page + half > self.all_pager:\n                    begin = self.all_pager - self.show_page + 1\n                    stop = self.all_pager + 1\n                else:\n                    begin = self.current_page - half\n                    stop = self.current_page + half + 1\n        if self.current_page <= 1:\n            prev = \"<li><a href=\'#\'>上一页</a></li>\"\n        else:\n            # para_dict传递过来了以后需要和base_url进行拼接。\n            #/yg/app01/usergroup/?id=2&name=alex&page=self.current_page - 1\n            self.page_param_dict[\'page\'] = self.current_page - 1\n            prev = \"<li><a href=\'%s?%s\'>上一页</a></li>\" % (self.base_url,self.page_param_dict.urlencode() ,)\n        page_list.append(prev)\n        for i in range(begin, stop):\n            self.page_param_dict[\'page\'] = i\n            if i == self.current_page:\n                temp = \"<li class=\'active\'><a href=\'%s?%s\'>%s</a></li>\" % (self.base_url,self.page_param_dict.urlencode(), i,)\n            else:\n                temp = \"<li><a href=\'%s?%s\'>%s</a></li>\" % (self.base_url, self.page_param_dict.urlencode(), i,)\n            page_list.append(temp)\n        if self.current_page >= self.all_pager:\n            nex = \"<li><a href=\'#\'>下一页</a></li>\"\n        else:\n            self.page_param_dict[\'page\'] = self.current_page + 1\n            nex = \"<li><a href=\'%s?%s\'>下一页</a></li>\" % (self.base_url, self.page_param_dict.urlencode(),)\n        page_list.append(nex)\n        return \'\'.join(page_list)\n```\n\n在列表查看页面changelist_view方法中添加分页相关逻辑，之前的操作我们是直接把所有的数据都拿出来了，但是实际的过程中，我们对数据的需求可能是有要求的，会添加很多的条件，因此，在这里我们要保留这个条件的口子，保证我们可以传递条件进来：\n\n```python\n# BaseLamberAdmin中的changelist_view方法，重复的部分不会在这里体现，只把新的代码写到这里。\nfrom lamber.utils.page import PageInfo\nimport copy\n\nclass BaseLamberAdmin(object):\n    def changelist_view(self, request):\n        # 分页相关逻辑，定义一个空字典，用来准备存储各种数据过滤条件。当然现在没条件\n        # 我们可以通过循环request.GET中传递过来的参数来进行字段的拼凑，这里先略过。\n        condition = {}\n        # pageinfo需要几个参数，接下来构造参数，取数据总条数\n        all_count = self.model_class.objects.filter(**condition).count()\n        page_param_dict = copy.deepcopy(request.GET)\n        page_param_dict._mutable = True\n        # 构造base_url传递给PageInfo，还是根据name进行反向reverse解析。\n        base_page_url = reverse(\"{0}:{1}_{2}_changelist\".format(self.site.namespace, self.app_label, self.model_name))\n        page_obj = PageInfo(\n            request.GET.get(\'page\'), \n            all_count, \n            base_page_url, \n            # 把这个参数内容传递过去就好了。\n            page_param_dict)\n        # 返回查询数据，带上condition的过滤条件。\n        result_list = self.model_class.objects.filter(**condition).all()[page_obj.start:page_obj.end]\n        context = {\n            \'result_list\': result_list,\n            \'list_display\': self.list_display,\n            \'lamberadmin_obj\': self,\n            \'add_url\': add_url,\n            # 对应的的生成url的标签内容也得给传递过去。传递到前端还要safe一下。\n            \'page_str\': page_obj.pager(),\n        }\n\n        return render(request, \'checklist_view.html\', context)\n```\n\n这里面就说一个点，为什么在生成page分页的时候还要把之前的那个request.GET的参数内容拿过来？举个例子，比如之前的分页url里面带着筛选条件，比如`http://x/lamber/app01/usergroup/?user=xxx&age=11&page=12`这种情况下，就算是你跳转到其他的页面，这个条件你还得是带着的，如果不带着那么筛选的数据岂不是出错了。\n\n因此这里需要把这些参数拿过来，那么这里为什么要deepcopy一下，因为字典的直接赋值其实是引用，如果你改了这个，那么实际的request.GET就改了，但是你不保证于此同时别的地方别的功能也会使用request.GET，如果你修改了，那么元数据就发生了改变，就会出现问题，因此这里我deepcopy一下，不改变原数据。\n\n```python\npage_param_dict = copy.deepcopy(request.GET)\n# 默认QueryDict的对象是不可修改的，因此要将QueryDict的对象的mutable属性设置为True\npage_param_dict._mutable = True\n```\n\n","timestamp":1540354517190},{"name":"08-定制Actions.md","path":"04-Django/50-项目实战/02-CRM/08-定制Actions.md","content":"# 定制Actions\n\n## 设计思路\n\n允许对数据进行一部分操作，类似于如下的样子\n\n![](http://tuku.dcgamer.top/18-10-19/45129488.jpg)\n\n比如可以选初始化，或者勾选批量删除等等。首先对这个功能说明一下，以后这个整体的CURD的组件是可以套用在多个系统的，那么当对应到不同的系统或者对应不同业务的模型类的时候，这个操作可能是不同的，具体的什么操作要看实际的业务而定，因此这里的操作每一个模型类，应该都是可以自己定制的，而不是定死的。因此这个操作列要像list_display一样或者add_or_edit_model_form一样允许用户自己去定义。因此我们可以在用户自定义的类中去重写这个action，来实现用户的私人定制。\n\n在BaseLamberAdmin中定一个action_list的列表。用来存储我们的action操作，那么里面操作对应的实体应该是什么呢？我们这里可以在里面存放对应的方法。通过相应的方法去操作。或者写上一个对象；\n\n## 设计实现\n\n以userinfo这个模型类为例，我们在注册这个类的时候实际上是使用了`v1.site.register(models.UserInfo, LamberUserInfo)`，因为这个LamberUserInfo这个类是继承BaseLamberAdmin，因此我们可以在这个LamberUserInfo中重写action_list去定制我们的action。首先定制一个initial操作为例\n\n```python\n# LamberUserInfo\nfrom lamber.service import v1\n\nclass LamberUserInfo(v1.BaseLamberAdmin):\n    \n    def initial(self, request):\n        \"\"\"\n        :param request:\n        :return: True：表示还在当前页面，因为当前页面可能还有其他条件\n        返回False：就不用保留地址，直接跳转到不加条件的首页\n        \"\"\"\n        # 在changelist_view调用，因为checkbox有name=pk，因此可以拿到选中的checkbox\n        pk_list = request.POST.getlist(\'pk\')\n        # 通过pk，我们又能拿到对应的value，就能拿到对应的对象。就能进行一系列操作\n        models.UserInfo.objects.filter(pk__in=pk_list).update(username=\'kakaka\')\n        # 这里其实返回不返回没有太所谓，这里就看自己的设计了，比如返回一个布尔值。\n        # 返回True就留在当前页面。返回false，跳转到其他页面。\n        return True\n    \n    # python里面一切皆对象，当然函数也是，所以我们可以像对象一样也给函数赋一个值\n    initial.text = \'初始化\'\n    \n    action_list = [initial, multi_del]\n```\n\n在BaseLamberAdmin的changelist_view中我们去对数据显示做操作。\n\n```python\n# BaseLamberAdmin\nclass BaseLamberAdmin(object):\n    def changelist_view(self, request):\n        # actions相关操作\n        action_list = []\n\n        for item in self.action_list:\n            # 这里我去遍历self.action_list，从self.action_list可以优先拿到用户自定制的。\n            # 然后针对每一个操作去构造一个小字典，name为函数的名字，text为函数的中文名\n            # 我们在定义的时候为函数添加了一个text属性，用来给函数命名，这样在前端就能看到中文了。\n            # 提交name的意义在于，我要将name赋值到options的value处。\n            # 这样拿到提交的数据的时候，我知道调用的是哪一个函数。\n            tpl = {\'name\': item.__name__, \'text\': item.text}\n            action_list.append(tpl)\n        if request.method == \'POST\':\n            # 根据提交的name获取到提交的options的value，虽然操作名是初始化，但是我可以拿到字符串\n            # 形式的initial，然后通过反射，我就可以拿到这个函数对象。\n            func_name_str = request.POST.get(\'action\')\n            # 获取到对象的时候同时进行调用\n            ret = getattr(self, func_name_str)(request)\n            # 在我们的设计中，设计的是如果返回True就还留在当前页面，简单的redirect以下就行。\n            # 但是当前页面可能存在参数，因此记得要拼接当前的url，带上相关的参数。\n            action_page_url = base_page_url\n            # 如果返回为true就跳转到带参数的页面，如果返回为false就跳转到不带参数的列表页\n            if ret:\n                action_page_url = \"{0}?{1}\".format(base_page_url, request.GET.urlencode())\n            return redirect(action_page_url)\n        context = {\n            \'result_list\': result_list,\n            \'list_display\': self.list_display,\n            \'lamberadmin_obj\': self,\n            \'add_url\': add_url,\n            \'page_str\': page_obj.pager(),\n            \'action_list\': action_list,\n        }\n\n        return render(request, \'checklist_view.html\', context)\n```\n\n前端展示模板：\n\n```html\n# lamber/templates/changelist_view.html\n<div class=\"container\">\n    <h1>数据列表</h1>\n    <form method=\"post\">\n        {% csrf_token %}\n        <!--以form表单形式传递，会携带checkbox和select框，给提交上去。当然这个要和对应的checkbox的列一起配合使用，比如给那一列加上对应的name，不然提交上去也取不到。-->\n        {% if action_list %}\n            <div class=\"row\">\n                <select name=\"action\" id=\"\" class=\"form-control\" style=\"width:200px;float: left\">\n                    {% for item in action_list %}\n                        <option value=\"{{ item.name }}\">{{ item.text }}</option>\n                    {% endfor %}\n                </select>\n                <input type=\"submit\" value=\"执行\" class=\"btn btn-primary\">\n            </div>\n        {% endif %}\n\n        <a href=\'{{ add_url }}\' style=\"float: right;\" class=\"btn btn-default\">添加</a>\n\n        <!--数据表格 开始-->\n        {% func result_list list_display lamberadmin_obj %}\n        <!--数据表格结束-->\n    </form>\n\n    <!--分页开始-->\n    <ul class=\"pagination\">\n        {{ page_str|safe }}\n    </ul>\n    <!--分页结束-->\n</div>\n</body>\n```\n\n","timestamp":1540354517190},{"name":"09-组合搜索.md","path":"04-Django/50-项目实战/02-CRM/09-组合搜索.md","content":"# 组合搜索\n\n所谓组合搜索其实就是同时有多个条件的搜索，这个内容其实使用场景也挺常见的，比如在ZOL中关村在线的，手机搜索排行榜这样的，可以n多条件进行组合搜索的。\n\n![](http://tuku.dcgamer.top/18-10-19/20922323.jpg)\n\n其实对应的你看每一行，都可以作为一张表去存储，比如品牌表，尺寸表，特性表等。我们这里要完成的也是这样的一个功能，将表中的诸多条件放出来供用户选择，提供数据过滤，而且不同的条件可以合并一起作为过滤条件进行筛选，最后展示我们想要的数据，类似如下的感觉。\n\n![](http://tuku.dcgamer.top/18-10-19/73423607.jpg)\n\n使用方式和action差不多，我要展示哪些筛选条件，比如我展示用户角色的筛选条件，以及用户所属用户组的筛选条件等等。这些都是允许用户进行自我定制的。所以同样的，我再BaseLamberAdmin中准类一个filter_list的列表。然后让用户在LamberUserInfo中去继承，实现内容的定制化。\n\n我们的目标是，filter_list的每一个元素，就是这一大整行，比如usergroup这一行，或者role这一行。那么每一个元素的使命就是将数据库中的数据取出来，然后全部展示到页面上，每一个小条件其实都可以认为是一个a标签。\n\n## 数据行的封装\n\n上面说到用户可以定制显示几大行，一整行就是一张表的数据，就是filter_list里面的一个元素。那么接下来对这一个数据行进行封装。\n\n- FilterOption封装的这一行数据的一些属性。比如这一行是否支持条件的多选。根据数据类型的不同可能存在多选的情况，有的行的所有条件都是互斥的，也就是不能存在多个，那就是不支持多选。\n- 针对数据的处理其实是多样化的，我们可以在这里传入一个方法进行数据的获取，再把取到的数据返回来，或者直接传入一个字段，比如我想让用户组显示在这里，那么我就传递一个usergroup字段也行。\n- FilterOption内部对传入的内容进行了判断，调用方法即可查看到传入的实例是方法还是字段的名称。\n\n```python\n# lamber/utils/filter_code\nclass FilterOption(object):\n    # 用来封装某一个组合搜索的配置。\n    def __init__(self, field_or_func, is_multi=False, text_func_name=None, val_func_name=None):\n        \"\"\"\n        :param field_or_func: 字段名或者函数，我可以接收你是字段也可以接收你是函数\n        :param is_multi: 是否支持多选\n        :param text_func_name: 在Model中定义函数，显示文本名称，说白了就是这里你这里填写一个函数名，然后把函数的返回值作为内容显示在条件上，是给人看的。不指定的话默认返回__str__的值。\n        :param val_func_name: 在Model中定义函数，显示参数名称，我们在搜索的时候显示的内容和搜索的内容有时候是不一致的，比如显示内容，搜索id，因此这里这个也是可以自定义的，函数返回要val的内容，如果不指定，默认使用对象.pk，对象主键。\n        \"\"\"\n        self.field_or_func = field_or_func\n        self.is_multi = is_multi\n        self.text_func_name = text_func_name\n        self.val_func_name = val_func_name\n\n    @property\n    def is_func(self):\n        # 看看你是不是函数。\n        if isinstance(self.field_or_func, FunctionType):\n            return True\n\n    @property\n    def name(self):\n        if self.is_func:\n            # 如果是函数的话我就给你返回函数的名字\n            return self.field_or_func.__name__\n        else:\n            # 如果是字段我给你返回字段就完了。\n            return self.field_or_func\n        \n# Model Class中定义返回text和val的方法。\nclass UserInfo(models.Model):\n    username = models.CharField(max_length=32, verbose_name=\'用户名\')\n    email = models.CharField(max_length=32, verbose_name=\'邮箱\')\n    ug = models.ForeignKey(\'UserGroup\', null=True, blank=True, on_delete=models.CASCADE, verbose_name=\'用户组\')\n    mmm = models.ManyToManyField(\'Role\', verbose_name=\'角色\')\n\n    def __str__(self):\n        return self.username\n\n    def text_username(self):\n        return self.username\n\n    def val_username(self):\n        return self.username\n\n    def text_email(self):\n        return self.email\n\n    def val_email(self):\n        return self.email\n```\n\n在LamberUserInfo中定制filter_list，比如我在userinfo的查看界面，我想把role啊，usergroup这些区分条件也显示出来，在userinfo中，用户和用户组是是外键关系（ug），而用户和用户角色是多对多关系（mmm），那么我就把字段传递进去生成对应的实例。\n\n```python\n# LamberUserInfo\nclass LamberUserInfo(v1.BaseLamberAdmin):\n    filter_list = [\n        FilterOption(\'username\', False, text_func_name=\'text_username\', val_func_name=\'val_username\'),\n        FilterOption(\'ug\', True),\n        FilterOption(\'mmm\', False),\n    ]\n```\n\n在BaseLamberAdmin的changelist_view中书写相关逻辑：\n\n```python\nfrom django.db.models import ForeignKey, ManyToManyField\n\nclass BaseLamberAdmin(object):\n    def changelist_view(self, request): \n        # 这里遍历的是每一个FilterOption的对象。\n        for option in self.filter_list:\n            if option.is_func:\n                # 如果是函数，那么就要去执行这个函数。\n                data_list = option.field_or_func(self, option, request,)\n            else:\n                # 如果不是函数那么就是传递的字段名称，字段名称可以是外键，多对多，多对一\n                # 如果不是方法的话，那么现在field_or_func肯定是一个字符串形式的字段名称\n                # 通过get_field方法获取到这个字段的实例。\n                field = self.model_class._meta.get_field(option.field_or_func)\n                # 如果有OneToOne的话要在ForeignKey前面，因为OneToOne继承ForeignKey\n                # 判断这个对象到底是ForeignKey的实例还是ManytoMany的实例。\n                # 查看源码可以看到self.model = to\n                if isinstance(field, ForeignKey):\n                    # 如果是ForeignKey的实例，比如说ug（usergroup），那么这个字段存在一个方法\n                    # remote_field.model方法(旧版本的可能是field.rel.model方法)\n                    # remote_field.model的返回值，就是外键关联的那个类，这里其实返回值就是\n                    # usergroup的类，那么我现在模型类拿到了，那么就可以取数据了。\n                    data_list = field.remote_field.model.objects.all()\n                elif isinstance(field, ManyToManyField):\n                    # 多对多关系其实是一样的，同样使用field.remote_field\n                    data_list = field.remote_field.model.objects.all()\n                else:\n                    # 如果既不是外键，也不是多对多的关系，那么就是自己这张表喽，比如userinfo表。\n                    # 这里其实我们可以直接用self.model_class.objects.all()获取数据。\n                    # 不过通过field这个字段实例也是可以获取到它所属的model class的。\n                    data_list = field.model.objects.all()\n        filter_list.append(data_list)\n    context = {\n        \'result_list\': result_list,\n        \'list_display\': self.list_display,\n        \'lamberadmin_obj\': self,\n        \'add_url\': add_url,\n        \'page_str\': page_obj.pager(),\n        \'action_list\': action_list,\n        \'filter_list\': filter_list\n    }\n\n    return render(request, \'checklist_view.html\', context)\n```\n\n把这些数据扔到前端去显示，我们给前端传递过去的filter_list是一个列表，列表的每一个元素是一个queryset，循环queryset把每一个条件取出来就可以了。\n\n```html\n# lamber/templates/checklist_view.html\n<div class=\"container\">\n    <h1>数据列表</h1>\n    {% if filter_list %}\n        <div class=\"row comb-search\">\n            <h3>组合搜索</h3>\n            {% for fl in filter_list %}\n                <div class=\"row\">\n                    {% for row in fl %}\n                        {{ row }}\n                    {% endfor %}\n                </div>\n            {% endfor %}\n        </div>\n    {% endif %}\n    <!--其他部分略过-->\n</div>\n```\n\n到目前为止，数据的展示是没问题了。不过结果并不是我们想要的。现在循环出来的每一个条件不过是字符串内容而已(显示的是数据对象的\\_\\_str\\_\\_方法)，我们想要的是可以循环出来直接就是现成的标签，是直接可以正常展示的内容，因此接下来对这部分内容进行进一步封装。\n\n## 组合搜搜定义yield和\\_\\_iter\\_\\_\n\n我们定义一个封装类，这个类将对我们刚才得到的queryset进一步封装，最后取得对应的html标签。那么现在传递到前端的filter_list中的元素不再是queryset，而是FilterList的对象，为了能让这个对象在前端仍然可以循环，我们要手动定义`__iter__`方法，这样对象就可以遍历了。\n\n```python\n# lamber/utils/filter_code\nimport copy\n\nfrom django.http.request import QueryDict\nfrom django.utils.safe_string import mark_safe\n\nclass FilterList(object):\n    def __init__(self,option,queryset,request):\n        \"\"\"\n        :param option: FilterOption的对象，option里有属性字段名称，以及是否支持多选的属性。\n        :param queryset: 拿到的queryset\n        :param param_dict: request.GET的querydict\n        :param path_info: request.path_info可以拿到除参数外的地址。\n        \"\"\"\n        self.option = option\n        self.queryset = queryset\n        # 避免影响原数据，因此这里做一个deepcopy\n        self.param_dict = copy.deepcopy(request.GET)\n        self.path_info = request.path_info\n\n    def __iter__(self):\n        # 优先返回整个行的div的起始\n        yield mark_safe(\"<div class=\'all-area\'>\")\n        \n        ################ 生成最前面的这个全部按钮  ##########################\n        # 最前面那个全部按钮也是要有url属性的，因此这个全部单独拎出来处理。关于全部按钮的逻辑\n        # 当我要列出来用户名叫大刘的，那么条件可能是如下的形式\n        # 示例：# /arya/app01/userinfo/?mm=2&fk=2&fk=21&username=大刘\n        # 但是当我不限制用户名的时候，url中是不应该出现username的筛选字段的，也就是说去掉username\n        # 不加这个条件其实就是表示所有了，那么我如何知道当前点的字段是userinfo，还是ug异或是mmm\n        # 在FilterOption封装的时候有一个option.name，这个可以让我们知道当前点的这一行到底是啥\n        # 如果你是函数，name就是函数名，如果是字段就是字段名。\n        if self.option.name in self.param_dict:\n            # 如果当前url参数中有当前字段，那么就给pop出去。\n            pop_val = self.param_dict.pop(self.option.name) #  1\n            # 拼接全部按钮的url连接。\n            if param_dict:\n            \turl = \"{0}?{1}\".format(self.path_info, self.param_dict.urlencode())\n            else:\n                url = self.path_info\n            # 当前这个param_dict实例，因为下面还要用，不能因为你当前的操作给pop出来，影响下面的操作\n            # 所以pop出来的还得给人家加回来，保证下面操作的时候，还是访问刚进来的这个param_dict\n            # self.param_dict[self.option.name] = pop_val，这样添加就有问题了。\n            # 因为pop出来的数据是一个列表，直接赋值就是列表套列表了，因此这里使用setlist方法。\n            # 归根结底我这里只是为了拼凑url，而不是真正的去操作url。\n            self.param_dict.setlist(self.option.name, pop_val)\n            # 打印出全部按钮\n            yield mark_safe(\"<a href=\'{0}\'>全部</a>\".format(url))\n        else:\n            # 在里面给pop出去，不在里面那就正好直接用了。\n            url = \"{0}?{1}\".format(self.path_info, self.param_dict.urlencode())\n            yield mark_safe(\"<a class=\'active\' href=\'{0}\'>全部</a>\".format(url))\n        # 给全部这个按钮的div封口，封起来，同时打印一个其他区域的头部\n        yield mark_safe(\"</div><div class=\'others-area\'>\")\n\n        ##################### 打印具体标签部分 ####################################\n\t\t# 遍历这一个表的每一条数据\n        for row in self.queryset:\n            # 避免每一次循环多选的param_dict发生改变，因此要做一下deepcopy，比如\n            # ug字段，是一个可以多选的字段，那么第一次循环进来的时候param_dict会多一个ug=1\n            # 这个ug=1应该拼接在第一个标签的按钮上，那么第二次进来以后，此时应该不包含ug=1\n            # 只有单独的ug=2的参数，但是你之前改了这个param_dict，因此这个链接会越加越多。\n            # 最后的结果就是你点击最后一个标签的时候，前面的全都给你选上了，这是不对的。\n            # 因此每次进来的时候我们的param_dict都应该是干净的，没有被上次循环修改过的，因此深拷贝\n            # 这个指挥影响到多选，单选不会受到影响。因为多选是追加，单选是直接赋值。\n            param_dict = copy.deepcopy(self.param_dict)\n            # 先看看有没有自定义方法返回text和val。\n            # 在url上（get方式）的参数是字符串，但是val我们默认是取的数据库的pk主键，是int类型。\n            # int的val不可能在value_list中找到，下面的判断就不会成立，因此要str一下。\n            val = str(getattr(row, self.option.val_func_name)() if self.option.val_func_name else row.pk)\n            text = getattr(row,self.option.text_func_name)() if self.option.text_func_name else str(row)\n            # 默认选中状态为False，在下面的判断中动态的修改。\n            active = False\n            if self.option.is_multi:\n                # 支持多选，获取当前这个字段的所有条件。\n                value_list = param_dict.getlist(self.option.name)\n                # 如果当前的值已经有了。那么就给去掉就行了，这样就实现了可以反选的功能\n                if val in value_list:\n                    # 注意这里value_list和param_dict中并不是一个引用，详见小结第一点。\n                    value_list.remove(val)\n \t\t\t\t\tparam_dict.setlist(self.option.name, value_list)\n                    active = True\n                else:\n                    # 向key为self.option.name的value列表中添加val\n                    param_dict.appendlist(self.option.name, val)\n\n            else:\n                # 单选情况，直接覆盖原来的值。\n                value_list = param_dict.getlist(self.option.name)\n                # 如果param_dict有这个值，那么就是选中的，那么就让active=True\n                if val in value_list:\n                    active = True\n                # 还记得QueryDict对象的字典形式么？\n                # {\'username\': [\'fangshaowei\'], \'ug\': [\'1\'], \'email\': [\'666\']\n                # 如果是单个值的话直接赋值就行了，会自动添加到param_dict对应key的value列表中。\n                param_dict[self.option.name] = val\n            url = \"{0}?{1}\".format(self.path_info, param_dict.urlencode())\n            if active:\n                tpl = \"<a class=\'active\' href=\'{0}\'>{1}</a>\".format(url,text)\n            else:\n                tpl = \"<a href=\'{0}\'>{1}</a>\".format(url, text)\n            yield mark_safe(tpl)\n\n\n        yield mark_safe(\"</div>\")\n```\n\n修改后的changelist_view的filter逻辑部分：\n\n```python\nfrom django.db.models import ForeignKey, ManyToManyField\nfrom lamber.utils.filter_code import FilterList\n\nclass BaseLamberAdmin(object):\n    def changelist_view(self, request): \n        for option in self.filter_list:\n            if option.is_func:\n                data_list = option.field_or_func(self, option, request,)\n            else:\n                field = self.model_class._meta.get_field(option.field_or_func)\n                if isinstance(field, ForeignKey):\n                    data_list = FilterList(option, field.remote_field.objects.all(), request)\n                elif isinstance(field, ManyToManyField):\n                    data_list = FilterList(option, field.remote_field.objects.all(), request)\n                else:\n                    data_list = FilterList(option, field.model.objects.all(), request)\n        filter_list.append(data_list)\n    context = {\n        \'result_list\': result_list,\n        \'list_display\': self.list_display,\n        \'lamberadmin_obj\': self,\n        \'add_url\': add_url,\n        \'page_str\': page_obj.pager(),\n        \'action_list\': action_list,\n        \'filter_list\': filter_list\n    }\n\n    return render(request, \'checklist_view.html\', context)\n```\n\n模板部分是不用改的。\n\n```html\n# lamber/templates/checklist_view.html\n<div class=\"container\">\n    <h1>数据列表</h1>\n    {% if filter_list %}\n        <div class=\"row comb-search\">\n            <h3>组合搜索</h3>\n            {% for fl in filter_list %}\n                <!--每一个fl都是一个FilterList的对象-->\n                <div class=\"row\">\n                    <!--循环FilterList，执行__iter__方法。-->\n                    {% for row in fl %}\n                        {{ row }}\n                    {% endfor %}\n                </div>\n            {% endfor %}\n        </div>\n    {% endif %}\n    <!--其他部分略过-->\n</div>\n```\n\n## 补充\n\n还有一个没有提到的地方就是之前的FilterOption我们说可以是接收一个字段也可以接收一个方法，上面的操作都是接收字段，接下来说明一下接收方法是如何实现的。\n\n比如在app01中的lamber.py的LamberUserInfo中定义一个email函数：\n\n```python\ndef email(self, option, request):\n    from lamber.utils.filter_code import FilterList\n    queryset = models.UserInfo.objects.filter(id__gt=2)\n    return FilterList(option, queryset, request)\n```\n\n函数很简单，其实就是从model class中自定制化的取出来一些数据，然后返回一个FilterList的对象，在我们的filter_list中要进行二次封装，即：\n\n```python\nfilter_list = [\n    FilterOption(\'username\', False, text_func_name=\'text_username\', val_func_name=\'val_username\'),\n    FilterOption(email, False, text_func_name=\'text_email\', val_func_name=\'val_email\'),\n    FilterOption(\'ug\', True),\n    FilterOption(\'mmm\', False),\n```\n\n这一次给FilterOption实例化传递过去的就是一个函数，那么再BaseLamberAdmin中的changelist_view中就会做判断，如果是函数我直接调用你就完了，最后你都是给我返回一个filter_list的对象而已。因此这里也可以通过传递一个函数来获取更加细化的数据内容。\n\n## 小结：\n\n1. 从QueryDict对象中拿一个key的value，我们知道request.GET中的key对应的是列表，但是即使赋值，对应的也不是一块地址。\n\n   ```python\n   # request.GET ==> {\'key1\': [1,2,3,], \'key2\': [4,5,6]}\n   value_list = request.GET.getlist(\'key1\')\n   \n   这个value_list拿到的是[1,2,3]但是和request.GET中key1的value引用的并不是同一块地址。究其原因要看一下这个getlist是如何操作的\n   \n   找到QuerDict这个类，发现getlist是在QueryDict的父类中MultiValueDict中定义的，来看一下。\n   def _getlist(self, key, default=None, force_list=False):\n       \"\"\"\n       Return a list of values for the key.\n   \n       Used internally to manipulate values list. If force_list is True,\n       return a new copy of values.\n       \"\"\"\n       try:\n           values = super().__getitem__(key)\n       except KeyError:\n           if default is None:\n               return []\n           return default\n       else:\n           if force_list:\n               values = list(values) if values is not None else None\n           return values\n       \n   def getlist(self, key, default=None):\n       \"\"\"\n       Return the list of values for the key. If key doesn\'t exist, return a\n       default value.\n       \"\"\"\n       return self._getlist(key, default, force_list=True)\n   ```\n\n2. \n\n3. \n\n4. Github示例：https://github.com/WuPeiqi/pro_admin\n\n5. 写的时候有没有什么坑？用到的知识点？写的好的地方写的不好的地方?\n\n   - 这个组件是参考Django Admin进行开发的，因此要熟悉Django的Admin，因此萌生开发自己组件的想法。Django Admin的功能较为臃肿。而且Django Admin的权限、组合搜索、页面显示（不够友好）；因此对于我们来说，它有的功能可能我们不需要，我们需要的功能它又没有，因此自己开发。\n   - 最终的目标是不仅可以和Django集合操作，而是适用于所有web框架的；CURD不依赖于DJango的ORM，而是CURD+SQLALchemy，这样就可以实现通用。因为常见的python的web框架中，也就Django自己带ORM了。\n   - 启动文件，在注册app中，有一个apps.py，在Appconfig这里，定义一个ready方法，将你自己定义的启动文件定义到这里。\n   - URL include的本质是什么？本质：url列表 appname namespace\n   - 单例模式，这里的单例模式其实就是引入对象。\n   - 模型类的注册，_registry中保存的是对象，key是model_class，value是BaseLamberAdmin的对象。\n   - URL的注册，循环进行url的注册，根据每一个模型类，进行URL的拼接。在URL拼接的过程中，用到了app的名称啊，模型类的名称啊，以及namespace的名称。我们用到了，model_class.\\_meta方法，这个\\_meta方法中包含了我们想要的一些内容，比如app_label，model name等。还可以利用模型类，去拿去字段，比如model_class.\\_meta.get_field(\'field_name\')。\n   - 通过字段对象去获取字段所属的类：`字段对象.model`，获取外键关联的类：`字段对象.remote_model`\n   - ModelForm去创建表单，本项目用到了type去创建ModelForm。\n   - 利用`__iter__`方法和yield来生成搜索标签。\n   - popup的使用，相比模态对话框可以直接利用原来的页面，相对更加简单快捷。\n   - 功能：定制列表显示页面，定制Actions操作组合，定制组合搜索条件。\n   - inclusion_tag的灵活使用。","timestamp":1540354517190},{"name":"01-堡垒机.md","path":"04-Django/50-项目实战/03-堡垒机/01-堡垒机.md","content":"业务系统，办公系统\n\n为什么要分开？因为系统物理上是隔离的，最终目的就是为了安全。\n\n\n\n\n\n","timestamp":1540354517190},{"name":"01-需求分析&DB设计.md","path":"04-Django/50-项目实战/04-Blog/01-需求分析&DB设计.md","content":"","timestamp":1540354517190},{"name":"02-首页.md","path":"04-Django/50-项目实战/04-Blog/02-首页.md","content":"","timestamp":1540354517190},{"name":"08-文件的上传.md","path":"04-Django/50-项目实战/04-Blog/08-文件的上传.md","content":"# 文件上传\n\n## 基于Form表单的上传\n\n> 基于Form表单的上传一个典型的特点就是提交就会刷新\n\n文件上传其实就是一个input的type为file的input框，在文件上传的时候值得注意的一点就是要指定form的`enctype=multipart/form-data`，否则后台拿不到对应的文件对象的。\n\n```python\nimport os\nfrom django.forms import Form\n\nclass F1Form(Form):\n    user = fields.CharField()\n    fafafa = fields.FileField()\n    \n    \ndef f1(request):\n    if request.method == \'GET\':\n        obj = F1Form()\n        return render(request, \'f2.html\',{\'obj\':obj})\n    else:\n        # 当发送POST请求的时候，我们就可以获取到用户提交的数据了。\n        # 这里拿到的也是一个文件对象，有name和size等其他属性，可以直接用file_obj.name获取\n        file_obj = request.FILE.get(\'fafafa\')\n        # 把文件一点一点的获取到，一块一块的。那么就可以像迭代器一样一块一块的去取\n        # 使用os.path.join拼一个路径出来，放到对应的目录下\n        f = open(os.path.join(\'static\',file_obj.name), \'wb\')\n        # chunk的size可以自定义，默认chunk_size为64*2**10，DEFAULT_CHUNK_SIZE\n        # chunk_size直接定义值就可以了。在调用的时候直接传参\n        for chunk in file_obj.chunks():\n           f.write(chunk)\n        f.close()\n        return render(request, \'f2.html\')\n\n# 这个enctype=\"multipart/form-data\"是要加的，否则后台获取到的数据字典是空的。\n# 这个和上传协议有关，加上以后会按照文件的编码进行上传。\n<form method=\"POST\" action=\'/xxx/\' enctype=\"multipart/form-data\">\n\t………………\n</form>\n```\n\n结合Form表单使用：\n\n```python\nfrom django.forms import Form\nfrom django.forms import fields, widgets\n\nclass F2Form(Form):\n    user = fields.CharField()\n    fafafa = fields.FileField()\n    \n    \ndef f2(request):\n    if request.method == \'GET\':\n        obj = F2Form()\n        return render(request, \'f2.html\',{\'obj\':obj})\n    else:\n        # 文本用data接收，文件用files接收。类型不一样\n        obj = F2Form(data=request.POST, files=request.FILES)\n        if obj.is_vaild():\n            # 文件获取到的是一个文件对象，有文件名啊，文件大小啊等各种属性\n            obj.cleaned_data.get(\'fafafa\')\n        return render(request, \'f2.html\', {\'obj\': obj})\n```\n\n","timestamp":1540354517190},{"name":"10-上传头像.md","path":"04-Django/50-项目实战/04-Blog/10-上传头像.md","content":"# 头像的上传\n\n> 用户在注册的时候或者注册以后允许用户上传自己的头像并且允许头像的实时预览，目前有两种方案：\n>\n> - 将图片上传到服务端通过ajax将图片的内容返回给前端\n> - 直接在浏览器预览，没问题后上传\n>\n> 第一种存在一种明显的问题就是上传以后服务器其实就有这个内容了，假如我只是上传了但是我不修改了或者页面被关掉了那么其实更新内容并没有更新上去，但是图片已经保存在服务器了。针对这个问题可以将图片放到一个临时的位置定期删除。\n>\n> 第二种问题相对来说要优秀很多，但是也存在一个浏览器兼容性的问题，也就是很多新版浏览器都是支持的，但是遇到ie这个老祖宗基本就会出现不兼容的情况。因此针对这个问题可以多方面的去做处理。根据条件去判断到底该使用什么办法从而达到一个全方面兼容的效果。\n\n\n\n\n\n## 获取头像\n\n> 来访问你网站的每一个人并不一定在你的网站注册了用户，因此，可以使用其他的方案去获取用户的头像。比如使用Gravatar，微博，QQ，微信等一些方式去获取用户的头像，实在是所有渠道都拿不到头像的话用一个默认头像也行，目前的处理方案大致如此。\n\n### Gravatar\n\n> Gravatar是Globally Recognized Avatar的缩写,是gravatar推出的一项服务，意为“全球通用头像”。如果在Gravatar的服务器上放置了你自己的头像，那么在任何支持Gravatar的blog或者留言本上留言时，只要提供你与这个头像关联的email地址，就能够显示出你的Gravatar头像来。\n\n本次要自己要完成一个博客的创作，我们要自己写获取头像的逻辑。这里你注册没注册过就不管了，自己可以注册一个试一试，方式很简单。Gravatar官方提供了Python的调用接口。我们直接去[这里](http://cn.gravatar.com/site/implement/images/python/)去查看官方提供的接口方法。\n\n```python\n# For Python2\n# import code for encoding urls and generating md5 hashes\nimport urllib, hashlib\n \n# Set your variables here\nemail = \"someone@somewhere.com\"\ndefault = \"https://www.example.com/default.jpg\"\nsize = 40\n \n# construct the url\ngravatar_url = \"https://www.gravatar.com/avatar/\" + hashlib.md5(email.lower()).hexdigest() + \"?\"\n# 这个最后拿到的一个gravatar_url就是我们要的地址了。\ngravatar_url += urllib.urlencode({\'d\':default, \'s\':str(size)})\n```\n\n如果你使用Python3的话还可以使用第三方的[libgravatar](http://libgravatar.readthedocs.io/en/latest/)去获取头像，只不过这个并不是被官方支持并维护的。Github地址：https://github.com/pabluk/libgravatar，有兴趣大家可以看看源码。\n\n**安装**\n\n```python\npip install libgravatar\n```\n\n使用get_image方法获取图片的URL\n\n```python\n>>> form libgravatar import Gravatar\n>>> g = Gravatar(\'myemailaddress@example.com\')\n>>> g.get_image()\n\'http://www.gravatar.com/avatar/0bc83cb571cd1c50ba6f3e8a78ef1346\'\n```\n\n简单的看一下get_image方法的默认参数：\n\n```python\nget_image(size=80, default=\'\', force_default=False, rating=\'\', filetype_extension=False, use_ssl=False)\n```\n\n- size：默认获取到的图片的大小是80px*80px的，如果你想要指定获取的大小的话你可以手动传递这个参数，你可以获取到1~2048px之间的任意大小的头像.\n- default：default参数用来提供一个默认的图片，如果说找不到对应邮箱的图片的话，可以使用default这里提供的图片。*default* can be an URL or one of the built in options *404*, *mm*, *identicon*, *monsterid*, *wavatar*, *robohash*, *retro* or *blank*.\n- force_default：强制默认的图片总是加载。\n- rating：can be used to request images by audience type. Possible values are *g*, *pg*, *r* or *x*. By default, only *g* rated images are displayed.\n- filetype_extension：加上一个可以选的.jpg的扩展名\n- use_ssl：允许你通过ssl请求image。\n\n`get_profile(data_format=\'\')`这个方法会返回一个和你Gravatar账户有关的信息的URL。更多的内容可以查看官方的说明文档：https://libgravatar.readthedocs.io/en/latest/\n\n### QQ\n\n```\nhttp://q1.qlogo.cn/g?b=qq&nk=qq号&s=100\n```\n\n- nk：qq号\n\n- s/spec：头像尺寸大小\n\n  | s/spec | px      |\n  | ------ | ------- |\n  | 1      | 40*40   |\n  | 2      | 40*40   |\n  | 3      | 100*100 |\n  | 4      | 140*140 |\n  | 5      | 640*640 |\n  | 40     | 40*40   |\n  | 100    | 100*100 |\n\n  ","timestamp":1540354517190},{"name":"22-在线编辑器使用.md","path":"04-Django/50-项目实战/04-Blog/22-在线编辑器使用.md","content":"# 在线编辑器\n\n## KindEditor\n\n> 官方网站：http://kindeditor.net/demo.php\n>\n> Documents：http://kindeditor.net/doc.php\n>\n> 安装包的话直接下载就可以了，解压后会发现其实有很多东西我们是用不到的，比如examples，asp，asp.net，php这种，这些不过是示例代码，因为我们这里用的是python所以这些基本可以不用关心。下载好了，放到自己的静态文件目录就可以使用了。\n\n### 目录结构\n\n```shell\n➜  kindeditor git:(master) ✗ > tree -L 1 .\n.\n├── kindeditor-all-min.js   # 全部JS的压缩版本，生产环境直接引用这个就可以了。\n├── kindeditor-all.js       # 全部的JS包含插件\n├── lang                    # 语言支持包，\n├── license.txt             # License\n├── plugins                 # KindEditor内部使用的插件\n└── themes                  # KindEditor主题文件\n```\n\n### 基本使用\n\n```html\n<textarea name=\"content\" id=\"content\"></textarea>\n \n<script src=\"/static/jquery-1.12.4.js\"></script>\n<script src=\"/static/plugins/kind-editor/kindeditor-all.js\"></script>\n<script>\n    $(function () {\n        initKindEditor();\n    });\n \n    function initKindEditor() {\n        var kind = KindEditor.create(\'#content\', {\n            width: \'100%\',       // 文本框宽度(可以百分比或像素)\n            height: \'300px\',     // 文本框高度(只能像素)\n            minWidth: 200,       // 最小宽度（数字）\n            minHeight: 400      // 最小高度（数字）\n        });\n    }\n</script>\n\n// 或者可以直接创建使用也可以，其中#i1是根据id找到对应的textarea标签\nKindEditor.create(\"#i1\", {\n            width: \"100%\",\n            height: \'500px\',\n            resizeType: 0,\n            uploadJson: \"/mem-admin/uploadimg/\",\n            extraFileUploadParams: {\n                \"csrfmiddlewaretoken\": \"{{ csrf_token }}\"\n            }\n```\n\n### 参数\n\n> http://kindeditor.net/docs/option.html\n\n我们看到上面在引用KindEditor的时候写了很多的参数，这个参数在官网比较完整的中文的说明，因此需要的话可以直接在上面的连接找到有用的内容。这里介绍几个常用的\n\n- width：顾名思义，就是设置编辑器的宽度，可以设置像素值px或者百分比。它设置的样式优先级要比textarea的宽度的样式优先级要高\n\n- height：顾名思义，就是编辑器的高度不过和宽度不一样的地方是支持px不支持百分比的形式设置。\n\n- items：我们在编辑器上可以看到很多选项，比如插入地图，插入文本，插入代码等等，这些小组件其实都是通过items去配置的，这里我们直接使用的话会看到默认的有很多小功能组件，这是因为items有默认的一个值，具体有什么默认值，可以直接在官方的options文档里查看，我们根据这个选项定制我们想要的功能。\n\n- htmlTags：这个选项是指定要保留的html标记，以及对应的标记可以使用的属性。其实是为了防止用户输入一些有风险的标签引起不必要的安全问题。数据结构为一个类似于字典的形式，key为html标签名，value为html属性的一个array。当然这里值得注意的是，这只是一个在前端的限制规则，我们是可以越过前端的限制而和后端的api直接交互的。因此后端的规则验证过滤规则是必须要加的，只不过前端加上以后多一层验证会更好一点。\n\n  ```javascript\n  {\n      font : [\'color\', \'size\', \'face\', \'.background-color\'],\n  }\n  ```\n\n- resizeType：是否允许改变编辑框的大小，Int型的值，取值为0，1，2；0表示不允许改变，1表示只能改变高度，2表示高度宽度都可以改变。\n\n- themeType：指定主题风格，默认的带一个default和一个simple。记得指定了对应的主题要引入theme文件夹内部的css文件。\n\n- uploadJson：上传文件必要参数，我们知道KindEditor是可以直接上传文件的，不管是图片，视频还是flash都是可以上传的，如果不设置这个内容那么会无法传递到后端，默认值为`basePath+\'php/upload_json.php\'`一看就知道肯定没这个地址。所以我们要自己制定：\n\n  ```javascript\n  uploadJson: \"/mem-admin/uploadimg/\",\n  ```\n\n- extraFileUploadParams：直接上传的话会提示403Forbidden，因为没有传递csrftoken，这个参数就可以支持在上传文件的时候添加别的参数一并上传到服务器。\n\n  ```javascript\n  extraFileUploadParams: {\n                  \"csrfmiddlewaretoken\": \"{{ csrf_token }}\"\n  }\n  ```\n\n- filePostName：文件可以上传到服务器我们要怎么从request.FILES中去拿呢？其实对应的去拿的那个key值就是filePostName的值，这里filePostName默认为imgFile，因此我们直接这样取就可以了`request.FILES.get(\'imgFile\')`\n\n常用的参数就介绍这么多，并且KindEditor在上传文件的时候会帮我们做好文件的分类，这个和你点击的什么按钮，比如你点击上传图片的按钮，在上传的时候KindEditor会在url后面一get方式拼接上一个传递方式如`xxx?dir=image`这样的形式，我们只要通过request.GET.get(\'dir\')就可以拿到用户上传的类型，不过刚才说到的，这个是取决于你按什么按钮，上传flash对应的dir就是flash，上传音视频对应的dir就是flash。\n\n### 完整的上传文件示例\n\n前端KindEditor示例：\n\n```javascript\n<script src=\"/static/js/kindeditor/kindeditor-all.js\"></script>\n<script>\n    // 通过iframe+form进行伪造ajax的提交方式进行提交\n    // filepostname imgFile是默认值，我们可以自己改。\n    KindEditor.create(\"#i1\", {\n        width: \"100%\",\n        height: \'500px\',\n        resizeType: 0,\n        uploadJson: \"/mem-admin/uploadimg/\",\n        extraFileUploadParams: {\n            \"csrfmiddlewaretoken\": \"{{ csrf_token }}\"\n        }\n\n\n    })\n</script>\n```\n\n后端视图函数：注意给前端返回的数据很重要，在这里只能是一个dic，内部包含error，url和message，返回其他的内容程序也不认识。\n\n```python\ndef uploadimg(request):\n    if request.method == \"POST\":\n        file_type = request.GET.get(\'dir\')\n        file = request.FILES.get(\'imgFile\')\n        file_path = os.path.join(\'static/imgs/upload\', file_type, file.name)\n        with open(file_path, \'wb\') as f:\n            for chunk in file.chunks():\n                f.write(chunk)\n        # 给人家程序返回的必须是这个内容\n        dic = {\n            # error取值0或者是1，url为上传成功的filepath，message表示\n            \'error\': 0,\n            \'url\': \"/\"+file_path,\n            \'message\': \'错了\'\n        }\n        return HttpResponse(json.dumps(dic))\n```\n\n## Markdown\n\n> markdown的写作方式已经使用很久了，感觉在书写的同时可以做到高效的排版，基本写完了以后层级设置好，不用进行二次排版可以直接预览或者通过程序进行展示，还是非常方便的，在网上找到了这么一个国人开发的开源的markdown在线编辑器，引入到自己的博客项目中使用，这里使用到的是Editor.md\n\n下载好安装文件以后，examples可以拿出来备用，这个是php写好的示例，可以单独用编辑器查看不需要拷贝到项目目录中去。lib文件夹是editormd依赖的一些第三方的js库，plugins里面是插件，比如emoji插件，代码格式化插件等等。\n\n**引入必要的文件**\n\n```html\n<!--需要引入editormd的css和js文件，js依赖jq，记得把jq引入引来-->\n<link rel=\"stylesheet\" href=\"/static/js/editormd/css/editormd.css\">\n\n<script src=\"/static/js/jquery-3.2.1.min.js\"></script>\n<script src=\"/static/js/editormd/editormd.min.js\"></script>\n```\n\n**布局html代码结构**\n\n```html\n<!--准备一个div，起好了id，在js调用的时候我们调用的就是这个div的id-->\n<div style=\"margin: 0 auto\" id=\"editormd\">\n    <textarea name=\"content\" id=\"i1\" cols=\"30\" rows=\"10\"></textarea>\n</div>\n```\n\n**JS调用生成编辑器**\n\n```javascript\n<script>\n    testEditor = editormd();\n    testEditor = editormd(\"editormd\", {\n        width: \"100%\",\n        height: \'1000px\',\n        path: \"/static/js/editormd/lib/\",\n        pluginPath: \'/static/js/editormd/plugins/\',\n        theme: \'default\',\n        previewTheme: \"default\",\n        editorTheme: \'base16-light\',\n        codeFold: true,\n    });\n```\n\n这里找的就是我们的那个div的id属性值“editormd”，此时你再去浏览器查看的时候就会发现我们的页面已经变成了markdown的编辑器了。这里有几点值得注意：\n\n1. 就是选取的是textarera外层的div的id属性值\n2. path路径需要自己制定，这样editormd才能调用到引用的js文件。\n3. pluginPath最好也指定一下，不然有可能出现部分组件无法使用的情况，这个看console就能看出来，部分plugin报错404；\n\n此时我们就可以用来进行书写了。左侧是正文，右侧则是markdown的预览：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-8-6/93039953.jpg)\n\n\n\n","timestamp":1540354517190},{"name":"100-crm1.md","path":"04-Django/50-项目实战/100-crm1.md","content":"# CRM\n\n> - 回顾，如何生成url，前端模板可以使用{% url xxx %}或者是reverse\n> - filter条件如何使用or，需要使用到Q；\n>\n> http://www.cnblogs.com/wupeiqi/articles/7444717.html\n\n组件是参考django admin来进行做的。\n\n两个问题：\n\n- 如何自动生成的url对应关系\n- django的admin路由，和我们使用的include url有什么差异？\n\nadmin.py的执行时间\n\n- 每一次访问的时候执行一次\n- 程序第一次启动的时候只执行一次。\n\n先admin.py，然后url根据类拼接出来，\n\n\n\n\n\n第一行读settings.py，然后执行admin.py。\n\n然后会执行一句\n\nROOT_URLCONF = \'s4day119.urls\'就会导入并执行urls\n\n```python\n\n```\n\n又是执行admin.site.urls。在执行之前，这个时候admin.site这个对象的，_registry这个时候已经有值了。我们找到这个url来看看到底是个什么：\n\n```python\n@property\ndef urls(self):\n    return self.get_urls(), \'admin\', self.name\n```\n\n这是一个属性，\n\n\n\n```python\ndef get_urls(self):\n        from django.urls import include, path, re_path\n        # Since this module gets imported in the application\'s root package,\n        # it cannot import models from other applications at the module level,\n        # and django.contrib.contenttypes.views imports ContentType.\n        from django.contrib.contenttypes import views as contenttype_views\n\n        def wrap(view, cacheable=False):\n            def wrapper(*args, **kwargs):\n                return self.admin_view(view, cacheable)(*args, **kwargs)\n            wrapper.admin_site = self\n            return update_wrapper(wrapper, view)\n\n        # Admin-site-wide views.\n        urlpatterns = [\n            path(\'\', wrap(self.index), name=\'index\'),\n            path(\'login/\', self.login, name=\'login\'),\n            path(\'logout/\', wrap(self.logout), name=\'logout\'),\n            path(\'password_change/\', wrap(self.password_change, cacheable=True), name=\'password_change\'),\n            path(\n                \'password_change/done/\',\n                wrap(self.password_change_done, cacheable=True),\n                name=\'password_change_done\',\n            ),\n            path(\'jsi18n/\', wrap(self.i18n_javascript, cacheable=True), name=\'jsi18n\'),\n            path(\n                \'r/<int:content_type_id>/<path:object_id>/\',\n                wrap(contenttype_views.shortcut),\n                name=\'view_on_site\',\n            ),\n        ]\n\n        # Add in each model\'s views, and create a list of valid URLS for the\n        # app_index\n        # 看这里看这里，遍历self_registry，这个时候这里面已经有值了，对这个字典进行循环。\n        valid_app_labels = []\n        for model, model_admin in self._registry.items():\n            # 每次循环的时候加上这个东西\n            urlpatterns += [\n                # 这个model._meta.app_label是什么：app名称\n                # model._meta.model_name：model的名称\n                # 然后include(model_admin.urls)\n                path(\'%s/%s/\' % (model._meta.app_label, model._meta.model_name), include(model_admin.urls)),\n            ]\n            if model._meta.app_label not in valid_app_labels:\n                valid_app_labels.append(model._meta.app_label)\n\n        # If there were ModelAdmins registered, we should have a list of app\n        # labels for which we need to allow access to the app_index view,\n        if valid_app_labels:\n            regex = r\'^(?P<app_label>\' + \'|\'.join(valid_app_labels) + \')/$\'\n            urlpatterns += [\n                re_path(regex, wrap(self.app_index), name=\'app_list\'),\n            ]\n        return urlpatterns\n```\n\n在看include：\n\n```python\ninclude(model_admin.urls)====这个model_admin是是ModelAdmin的对象，比如：\nadmin.ModelAdmin(model.UserInfo, admin.site),\n\n@property\ndef urls(self):\n    return self.get_urls()\n\n# 在看看这个get_urls是什么\ndef get_urls(self):\n    from django.urls import path\n    def wrap(view):\n        def wrapper(*args, **kwargs):\n            return self.admin_site.admin_view(view)(*args, **kwargs)\n        wrapper.model_admin = self\n        return update_wrapper(wrapper, view)\n    info = self.model._meta.app_label, self.model._meta.model_name\n    # 源码的入口，到这里位置都是每个url对应一个函数了。\n    urlpatterns = [\n        path(\'\', wrap(self.changelist_view), name=\'%s_%s_changelist\' % info),\n        path(\'add/\', wrap(self.add_view), name=\'%s_%s_add\' % info),\n        path(\'autocomplete/\', wrap(self.autocomplete_view), name=\'%s_%s_autocomplete\' % info),\n        path(\'<path:object_id>/history/\', wrap(self.history_view), name=\'%s_%s_history\' % info),\n        path(\'<path:object_id>/delete/\', wrap(self.delete_view), name=\'%s_%s_delete\' % info),\n        path(\'<path:object_id>/change/\', wrap(self.change_view), name=\'%s_%s_change\' % info),\n        # For backwards compatibility (was the change url before 1.9)\n        path(\'<path:object_id>/\', wrap(RedirectView.as_view(\n            pattern_name=\'%s:%s_%s_change\' % ((self.admin_site.name,) + info)\n        ))),\n    ]\n    return urlpatterns\n```\n\n使用admin还可以使用装饰器：\n\n```python\n@admin.register(models.UserInfo)\nclass UserAdmin(admin.ModelAdmin):\n    pass\n\n点进去看源码，还是使用admin.register\n```\n\n\n\n\n\n可以使用`__str__`让这个显示的更好看一点，这个在get_url中，change_list_view中还会做一些操作。这个方法在ModelAdmin中定义的，\n\n![Snip20180820_42](/Users/lamber/Pictures/Snip20180820_42.png)\n\n![image-20180820212900642](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820212900642.png)\n\n![image-20180820212918410](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820212918410.png)\n\n\n\n![image-20180820213216350](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213216350.png)\n\n\n\n![image-20180820213228439](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213228439.png)\n\n\n\n![image-20180820213313565](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213313565.png)\n\n![image-20180820213321941](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213321941.png)\n\n\n\n![image-20180820213439614](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213439614.png)\n\n\n\n使用list-display定制显示的列，\n\n![image-20180820213448192](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213448192.png)\n\n![image-20180820213544900](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213544900.png)\n\n![image-20180820213551803](/var/folders/8l/g95nllln61j4ly_zm_tqj2m40000gn/T/abnerworks.Typora/image-20180820213551803.png)\n\n这个obj就是model的一个对象，也就是说是一行\n\nfrom django.utils.safestring import mark_safe\n\n这样就可以通过上面这个东西给返回html了，这个是在后端处理，直接|safe是在前端处理。\n\n内部实现，循环这个列表，如果是字符串，去数据库拿数据，如果是函数去执行函数，函数返回什么显示什么。\n\n如何判断这个元素是一个函数，item.callable就判断，或者\n\nfrom types import FunctionType\n\nisinstance(item, Function)\n\nif 上面这个为真: return item()，否则return item\n\n\n\nlist_display_link让谁可以生成a标签，不是上面自定义的那种。\n\nfilter里面写字段，右面就会出现筛选的。\n\nlist_select_related：帮你查询的时候直接联表。第一次查询到时候就会联表，list_select_related写的就是foreignkey字段。\n\n分页相关\n\nlist-editable，列表时，可以编辑的列，填写上以后就是进入编辑模式了，就可以编辑了。不过始终是编辑模式的input框。相对来讲不太好看。\n\nserch_fields：列表的时候模糊搜索的功能。加上一个字端，比如user字段就会发现界面上多了一个搜索框。\n\n# [Django内置Admin](https://www.cnblogs.com/wupeiqi/articles/7444717.html)\n\nDjango内置的Admin是对于model中对应的数据表进行增删改查提供的组件，使用方式有：\n\n[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n```\n    依赖APP：\n        django.contrib.auth\n        django.contrib.contenttypes\n        django.contrib.messages\n        django.contrib.sessions\n\n    模板的context_processors：\n        django.contrib.auth.context_processors.auth\n        django.contrib.messages.context_processors.messages\n\n    中间件：\n        django.contrib.auth.middleware.AuthenticationMiddleware \n        django.contrib.messages.middleware.MessageMiddleware\n```\n\n[![复制代码](http://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)\n\n### 一. 配置路由\n\n当前配置的路由可以创建一些路由映射关系：\n\n/admin/\n/admin/login/\n/admin/logout/\n/admin/password_change/\n/admin/password_change/done/\n\n/admin/app名称/model名称/\n/admin/app名称/model名称/add/\n/admin/app名称/model名称/ID值/history/\n/admin/app名称/model名称/ID值/change/\n/admin/app名称/model名称/ID值/delete/\n\n### 二. 定制Admin\n\n在admin.py中只需要讲Mode中的某个类注册，即可在Admin中实现增删改查的功能，如：\n\n但是，这种方式比较简单，如果想要进行更多的定制操作，需要利用ModelAdmin进行操作，如：\n\nModelAdmin中提供了大量的可定制功能，如\n\n1. list_display，列表时，定制显示的列。\n\n2. list_display_links，列表时，定制列可以点击跳转。\n\n3. list_filter，列表时，定制右侧快速筛选。\n\n4. list_select_related，列表时，连表查询是否自动select_related\n\n\\5. 分页相关\n\n\\6. list_editable，列表时，可以编辑的列\n\n7. search_fields，列表时，模糊搜索的功能\n\n8. date_hierarchy，列表时，对Date和DateTime类型进行搜索\n\n9. preserve_filters，详细页面，删除、修改，更新后跳转回列表后，是否保留原搜索条件\n\n10. save_as = False，详细页面，按钮为“Sava as new” 或 “Sava and add another”\n\n11. save_as_continue = True，点击保存并继续编辑\n\n12. save_on_top = False，详细页面，在页面上方是否也显示保存删除等按钮\n\n13. inlines，详细页面，如果有其他表和当前表做FK，那么详细页面可以进行动态增加和删除，针对这个组可以既创建组，又创建人。\n\n\\14. action，列表时，定制action中的操作\n\n```\ndef func(request, queryset):\n    xxxxx\n    \nfunc.short_description = \"dayuhao\"\nactions = [func, ]\n\nfor item in actions:\n    if hasattr(item, \'short_description\');\n        print(item.short_description, item(1,2))\n    else:\n        print(item.__name__.title(), item(1,2))\n```\n\n\n\n\\15. 定制HTML模板\n\ncontrib---template——admin这里存放着所有内置的html。怎么改成自己的?\n\nchange_list_template = \"my_change_list.html\"，这个也可以使用母版，进行继承\n\n\n\n16. raw_id_fields，详细页面，针对FK和M2M字段变成以Input框形式\n\n\n\n17. fields，详细页面时，显示字段的字段\n\n18. exclude，详细页面时，排除的字段\n\n19. readonly_fields，详细页面时，只读字段\n\n20. fieldsets，详细页面时，使用fieldsets标签对数据进行分割显示,这玩意没啥用。\n\n\\21. 详细页面时，M2M显示时，数据移动选择（方向：上下和左右）\n\n22. ordering，列表时，数据排序规则\n\n23. view_on_site，编辑时，是否在页面上显示view on set\n\n24. radio_fields，详细页面时，使用radio显示选项（FK默认使用select）\n\n25. show_full_result_count = True，列表时，模糊搜索后面显示的数据个数样式\n\n\\26. formfield_overrides = {}，详细页面时，指定现实插件，几乎不用\n\n27. prepopulated_fields = {}，添加页面，当在某字段填入值后，自动会将值填充到指定字段。几乎不用\n\n*PS: DjangoAdmin中使用js实现功能，页面email字段的值会在输入：user、pwd时自动填充*\n\n\\28. form = ModelForm，用于定制用户请求时候表单验证\n\n\\29. empty_value_display = \"列数据为空时，显示默认值\"\n\n\n\n## Admin的定制\n\n1. list_display\n2. 123\n3. 123\n4. 123\n5. 123\n6. 123\n7. 123\n8. 123\n9. 123\n10. 123\n11. 123\n12. 123\n13. 123\n14. 123\n15. 123\n16. 123\n17. 123\n18. 123\n19. 1\n20. 1\n21. 1\n22. 1\n23. 1\n24. 1\n25. 1\n26. 1\n27. 1","timestamp":1540354517190},{"name":"101-DjangoAdmin.md","path":"04-Django/50-项目实战/101-DjangoAdmin.md","content":"# DjangoAdmin\n\n> 本次的主题为CRM，我们需要开发一个统一化的CRM插件去完成我们的工作，但是这个插件的设计思路，其实是参考Django的Admin来做的，因此在一切的一切的开始，先从DjangoAdmin说起。\n\n## Admin的使用\n\n之前针对Django Admin的使用大多数是用来临时添加数据，使用方式也很简单：\n\n0. admin本身也是一个app，但是默认的在项目创建好了以后，就自动为你注册上了；\n\n1. 编写数据models模型\n\n2. 进入admin.py中，注册我们的models模型，只要使用`admin.site.register(models.xx)`注册完成以后我们直接访问`http://your_address:8000/admin`就可以看到登录界面了，使用`python manage.py createsuperuser`创建好用户名和密码登录以后我们就可以登录了。\n\n3. 路由分发，路由是如何分发过来的？在入口的urls.py中，有一条默认的配置：\n\n   ```python\n   from django.contrib import admin\n   from django.urls import path\n   \n   urlpatterns = [\n       path(\'admin/\', admin.site.register),\n   ]\n   ```\n\n   其实从一开始就有这样的疑问，为什么这里的写法和我们平常使用的时候写法是不一样的？平常的写法的话，就是简单的`path(\'userinfo/\', views.userinfo)`样式的，不过这里并不是这样调用的？**这块到底是如何实现的？**\n\n比如我们自己注册了一个UserInfo的model class，那么就会在django的admin中发现我们的这个类：\n\n![](http://tuku.dcgamer.top/18-8-22/55457149.jpg)\n\n在这里我们就可以进行数据的增删改查了，其实到这一步为止这些操作我们都已经非常熟悉了，这里只是有一个需要注意的地方，观察一下增删改查的时候这些操作的URL：\n\n- 查：http://127.0.0.1:8000/admin/app01/userinfo/\n- 增：http://127.0.0.1:8000/admin/app01/userinfo/add/\n- 改：http://127.0.0.1:8000/admin/app01/userinfo/1/change/\n- 删：http://127.0.0.1:8000/admin/app01/userinfo/1/delete/\n\n通过上面的连接可以发现这几个连接的一个规律，查的时候为`http://your_ip:8000/admin/app_name/model_cls_name`，添加的时候是在上面的基础上添加一个add，删除和改的时候都是要针对某一条记录进行删和改，因此对应的后面多了一个id，对应的后面的分别为change和delete。\n\n当我们添加其他的app并注册对应app中的model_class后，上面的app_name和model_cls_name还会根据我们添加做对应的变化，这是DjangoAdmin在设计的时候增删改的一个url设计规范，随后我们在定制自己的插件的时候，也可以按照这个规则来。\n\n## Admin注册流程\n\n我们在app中注册的时候是这样注册的：\n\n```python\n# app01/admin.py\nadmin.site.register(models.UserInfo)\n```\n\n在我们调用`python manage.py runserver`以后会去依次调用所有的app中的两个文件，其中一个是admin.py，另外一个就是app.py。app.py要早于admin.py的调用；\n\n接下来看一下调用过程都做了什么\n\n1. admin.site.register(models.UserInfo)，这个site是什么，site是AdminSite的一个对象，这条代码在程序运行的一开始，只会执行一次，简单来说这就是一个最简单的单例模式：\n\n   ```python\n   # django/crontrib/admin/sites.py 525行 Django版本2.0.1\n   site = AdminSite()\n   ```\n\n2. site.register，找到AdminSite中的register方法，这里并不做所有代码的逐行分析，只是把用到的代码拿出来说一下:\n\n   ```python\n   def register(self, model_or_iterable, admin_class=None, **options):\n       if not admin_class:\n           admin_class = ModelAdmin\n       if isinstance(model_or_iterable, ModelBase):\n           model_or_iterable = [model_or_iterable]\n           for model in model_or_iterable:\n               if model._meta.abstract:\n                   raise ImproperlyConfigured(\n                       \'The model %s is abstract, so it cannot be registered with admin.\' % model.__name__\n                   )\n   \t\t\t# 避免重复注册，如果注册了两个同样的class的时候会报错。\n               if model in self._registry:\n                   raise AlreadyRegistered(\'The model %s is already registered\' % model.__name__)\n   \n               if not model._meta.swapped:\n                   if options:\n                       options[\'__module__\'] = __name__\n                       admin_class = type(\"%sAdmin\" % model.__name__, (admin_class,), options)\n   \n                   # Instantiate the admin class to save in the registry\n                   self._registry[model] = admin_class(model, self)\n   ```\n\n   - 在注册的时候我们并没有穿什么admin_class，而只是传递了我们的模型类，admin_class默认为None，如果admin_class为None的时候admin_class会被重新赋值为ModelAdmin\n   - 这里传递的模型类，可以是单个的模型类，还可以是一个可迭代的对象，因为不管是一个模型类，还是一个可迭代对象，最后它都会帮我们转换成一个列表。所以我们注册的时候不只是可以admin.site.register(models.AAA)这种写法，还可以\n     admin.site.register([models.AAA, models.BBB])这样写。\n   - register方法在构造函数`__init__`中，初始化了一个`self._registry`的字典\n   - 最后`self._registry[model] = admin_class(model, self)`\n\n那么最后其实分析完register这段代码以后我们发现我们执行的admin.site.register(models.UserInfo)其实是admin.site.register(models.UserInfo, ModelAdmin)。因为会去遍历执行所有app中的admin.py获取所有注册的模型类，因此最后会构造一个字典，也就是self_registry，大概结构如下：\n\n```python\n_registry = {\n    model.UserInfo: admin.ModelAdmin(model.UserInfo, admin.site),\n    model.UserGroup: admin.ModelAdmin(model.UserGroup, admin.site),\n}\n```\n\n这个字典的key为我们传递的model class，value是ModelAdmin的对象（当admin_class没传值的时候），这个对象都是不同的，因为每一个对象都传递了不同的模型类。第二个参数传递的是self，这里的self是AdminSite的对象，其实就是site。\n\n## Admin URLS\n\n现在该启动程序了，执行manage.py runserver，首先会设置加载环境变量，然后读取settings，循环执行admin.py，构造_registry。然后会执行一句ROOT_URLCONF，到这里就会导入urls。接下来看urls的导入部分：\n\n在原来我们书写url的时候可以直接在urlpatterns那里写url，以及调用的函数，比如：\n\n```python\nurlpatterns = [\n    path(\'login/\', views.login)\n]\n```\n\n当然我们还有一种方式导入那就是使用include\n\n```python\nfrom django.urls import path, include\nurlpatterns = [\n    path(\'frontend\', include(\'app01.urls\'))\n]\n```\n\n那么这个直接写和include有什么区别？来看一下include的代码怎么写的\n\n```python\ndef include(arg, namespace=None):\n    app_name = None\n    # 在这里我们发现include首先判断这个传进来的arg是不是一个元组，变相的告诉我们，这里其实是可以传递元组进来的，这个一会再说。\n    if isinstance(arg, tuple):\n        try:\n            urlconf_module, app_name = arg\n        except ValueError:\n            if namespace:\n                raise ImproperlyConfigured(\n                    \'Cannot override the namespace for a dynamic module that \'\n                    \'provides a namespace.\'\n                )\n            raise ImproperlyConfigured(\n                \'Passing a %d-tuple to include() is not supported. Pass a \'\n                \'2-tuple containing the list of patterns and app_name, and \'\n                \'provide the namespace argument to include() instead.\' % len(arg)\n            )\n    else:\n        # 当不是元组的时候urlconf_module就直接等于arg，也就是字符串的app01.urls\n        urlconf_module = arg\n\t# 如果这个是字符串的话会用import_module导入这个app01下的urls\n    if isinstance(urlconf_module, str):\n        urlconf_module = import_module(urlconf_module)\n    # 到这一步位置其实我们就可以看懂了，我们在自己写的时候这个include进来的urls其实也是要写一个urlpatterns的，如果你写别的话其实就不生效了，django也不认识了，因此这里直接使用反射来拿urlpatterns，那么最后的返回值patterns其实就是urlpatterns。\n    patterns = getattr(urlconf_module, \'urlpatterns\', urlconf_module)\n    app_name = getattr(urlconf_module, \'app_name\', app_name)\n    if namespace and not app_name:\n        raise ImproperlyConfigured(\n            \'Specifying a namespace in include() without providing an app_name \'\n            \'is not supported. Set the app_name attribute in the included \'\n            \'module, or pass a 2-tuple containing the list of patterns and \'\n            \'app_name instead.\',\n        )\n    # 没写namespace，那么namespace和app_name就是一回事。\n    namespace = namespace or app_name\n    # Make sure the patterns can be iterated through (without this, some\n    # testcases will break).\n    if isinstance(patterns, (list, tuple)):\n        for url_pattern in patterns:\n            pattern = getattr(url_pattern, \'pattern\', None)\n            if isinstance(pattern, LocalePrefixPattern):\n                raise ImproperlyConfigured(\n                    \'Using i18n_patterns in an included URLconf is not allowed.\'\n                )\n    # 最后看include返回了什么？返回了一个元组，为urlconfig_module，app_name，namespace\n    return (urlconf_module, app_name, namespace)\n```\n\n现在知道include实际返回的内容了以后其实我们就可以实际在path这里写一个元组了，其实这里是两种找法，如果返回的是一个模块，它会自己去里面找urlpatterns这个对应关系，如果返回的是一个元组（列表），那么就是直接的对应关系：\n\n```python\nurlpatterns = [\n    path(\'login/\', ([这里填写一个个路由匹配规则], \'appname\', \'namespace\'))\n]\n```\n\n不过还记得django的admin是怎么写的么？\n\n```python\nurlpatterns = [\n    url(r\'^admin/\', admin.site.urls),\n]\n```\n\n这样的方法和include又有什么本质上的区别呢？\n\n```python\n@property\ndef urls(self):\n    return self.get_urls(), \'admin\', self.name\n```\n\n查看一下get_urls中定义了一个urlpatterns，\n\n![](http://tuku.dcgamer.top/18-8-23/93976210.jpg)\n\n这里面已经定义了一堆url路由规则，比如login和logout等等，这也就是为什么装好程序以后啥都不用做直接访问`http://127.0.0.1:8000/admin`就可以进行登录的原因。紧接着：\n\n![](http://tuku.dcgamer.top/18-8-23/99765585.jpg)\n\n我们看到在这一步遍历了在程序一起动生成好的_registry这个字典，其中model就是我们的模型类，而model_admin是之前admin_class的对象。因为model是之前我们定义的模型类，那么可以通过\\_meta信息来获取到这个model所属的app以及model name。app那么为model.\\_meta.app_label，模型类的名称为model.\\_meta.model_name，其实现在就开始要拼接我们创建的app的model的增删改查的url了，类似于这样：\n\n![](http://tuku.dcgamer.top/18-8-23/2773998.jpg)\n\n```python\nurlpatterns += [\n    path(\'%s/%s\' % (model._meta.app_label, model._meta.model_name), include(model_admin.urls))\n]\n```\n\n只是靠格式化是拼接不出来改和删的内容的，因为有变化的内容id在，因此admin组件在这个url的拼凑中最后使用了`include(model_admin.urls)`这个内容，看看这个内容干了点啥；model_admin是ModelAdmin这个类的一个对象，看一下类中的urls方法\n\n```python\n@property\ndef urls(self):\n    return self.get_urls()\n```\n\nget_urls绑定方法内容：\n\n![](http://tuku.dcgamer.top/18-8-23/28897974.jpg)\n\n看这里的urlpatterns，这是一系列的url的匹配规则，其实到这里位置就把我们的add，delete，change也都拼接进去了，如果没有的话那么就是查，并且，每个对应的视图函数也都写好了。反向url也都写好了。\n\n### 定制Admin\n\n> http://www.cnblogs.com/wupeiqi/articles/7444717.html\n>\n> https://www.cnblogs.com/yuanchenqi/articles/8323452.html\n\n在admin.py中只需要讲Mode中的某个类注册，即可在Admin中实现增删改查的功能，如：\n\n```python\nadmin.site.register(models.UserInfo)\n```\n\n但是，这种方式比较简单，如果想要进行更多的定制操作，需要利用ModelAdmin进行操作，如：\n\n```python\n方式一：\n    class UserAdmin(admin.ModelAdmin):\n        list_display = (\'user\', \'pwd\',)\n \n    admin.site.register(models.UserInfo, UserAdmin) # 第一个参数可以是列表\n     \n \n方式二：\n    @admin.register(models.UserInfo)                # 第一个参数可以是列表\n    class UserAdmin(admin.ModelAdmin):\n        list_display = (\'user\', \'pwd\',)\n```\n\nModelAdmin中提供了大量的可定制功能，接下来对这些功能进行一些详细的说明\n\n- list_display，列表时，定制显示的列。这里的列字段不包含多对多的字段，写多对多的字段会报错\n\n  ```python\n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n      list_display = (\'user\', \'pwd\', \'xxxxx\')\n   \n      def xxxxx(self, obj):\n          return \"xxxxx\"\n      \n  # 同样这里还可以写一个函数，那么在字段显示的内容就会变为函数的返回值\n  from django.contrib import admin\n  from app01 import models\n  \n  \n  # Register your models here.\n  class UserInfoConfig(admin.ModelAdmin):\n  \n      def showtest(obj):\n          # 这里的参数是什么？这里的参数其实是这个modelclass的对象，那么这里显示的内容是不是可以做成一个a标签呢？当然是可以的\n          return \'aaa\'\n      \n      list_display = (\'name\', \'email\', \'phone\', showtest)\n      list_display_links = (\'email\', )\n  \n  \n  admin.site.register(models.UserInfo, UserInfoConfig)\n  ```\n\n  ![](http://tuku.dcgamer.top/18-8-23/5031604.jpg)\n\n  既然这里显示的内容是可以让我们自己定制的，那么这里可不可以显示一个a标签呢？当然是可以的\n\n  ```python\n  from django.contrib import admin\n  from app01 import models\n  from django.utils.safestring import mark_safe\n  \n  \n  # Register your models here.\n  class UserInfoConfig(admin.ModelAdmin):\n  \n      def showtest(obj):\n          return mark_safe(\'<a href=\"\'+str(obj.id)+\'/delete\">删除</a>\')\n  \n      list_display = (\'name\', \'email\', \'phone\', showtest)\n      list_display_links = (\'email\', )\n  \n  \n  admin.site.register(models.UserInfo, UserInfoConfig)\n  ```\n\n  这个时候对应的页面上的showtest列就编程一个删除的a标签了。\n\n- list_display_links，列表时，定制哪些列是可以点击并跳转。点击跳转跳转的其实就是这条记录的change页面\n\n  ```python\n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n      list_display = (\'user\', \'pwd\', \'xxxxx\')\n      list_display_links = (\'pwd\',)\n  ```\n\n- list_filter，列表时，定制右侧快速筛选。\n\n  ```python\n  from django.contrib import admin\n  from app01 import models\n  from django.utils.safestring import mark_safe\n  \n  \n  # Register your models here.\n  class UserInfoConfig(admin.ModelAdmin):\n  \n      def showtest(obj):\n          return mark_safe(\'<a href=\"\'+str(obj.id)+\'/delete\">删除</a>\')\n  \n      list_display = (\'name\', \'email\', \'phone\', showtest)\n      list_display_links = (\'email\', )\n      list_filter = [\'name\']\n  \n  \n  admin.site.register(models.UserInfo, UserInfoConfig)\n  ```\n\n  ![](http://tuku.dcgamer.top/18-8-23/2647530.jpg)\n\n  ```python\n  from django.utils.translation import ugettext_lazy as _\n   \n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n      list_display = (\'user\', \'pwd\')\n   \n      class Ugg(admin.SimpleListFilter):\n          title = _(\'decade born\')\n          parameter_name = \'xxxxxx\'\n   \n          def lookups(self, request, model_admin):\n              \"\"\"\n              显示筛选选项\n              :param request:\n              :param model_admin:\n              :return:\n              \"\"\"\n              return models.UserGroup.objects.values_list(\'id\', \'title\')\n   \n          def queryset(self, request, queryset):\n              \"\"\"\n              点击查询时，进行筛选\n              :param request:\n              :param queryset:\n              :return:\n              \"\"\"\n              v = self.value()\n              return queryset.filter(ug=v)\n   \n      list_filter = (\'user\',Ugg,)\n  ```\n\n- list_select_related，列表时，连表查询是否自动select_related。这个其实是一个有关于性能优化的一个设置项，一般查数据的时候如果没有联表，那么我们在跨表查数据的时候每一次跨表都要重新发起一次查询，list_select_related设置了以后会在一开始一并给你联表查询出来，避免后续跨表再频繁发送请求。\n\n- 分页相关：\n\n  ```python\n  # 分页，每页显示条数\n      list_per_page = 100\n   \n  # 分页，显示全部（真实数据<该值时，才会有显示全部）\n      list_max_show_all = 200\n   \n  # 分页插件\n      paginator = Paginator\n  ```\n\n- list_editable，列表时，可以编辑的列，设置哪些列是可以进行编辑的\n\n  ```python\n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n      list_display = (\'user\', \'pwd\',\'ug\',)\n      list_editable = (\'ug\',)\n  ```\n\n- search_fields，列表时，模糊搜索的功能，其实就会在数据列表上方显示一个搜索框允许你搜索，你可以搜user也可以搜pwd字段，只要你写了的字段你就可以在这里进行模糊搜索。\n\n  ```python\n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n       \n      search_fields = (\'user\', \'pwd\')\n  ```\n\n- date_hierarchy，列表时，对Date和DateTime类型进行搜索\n\n  ```python\n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n   \n      date_hierarchy = \'ctime\'\n  ```\n\n- preserve_filters，详细页面，删除、修改，更新后跳转回列表后，是否保留原搜索条件；这个比如你再分页的时候想要跳转到一个页面进行修改，跳转之前的url为xxxx?page=2，那么更新完成以后再跳转回来就是仍然还能保留最后面那个参数page=2。\n\n- save_as = False，详细页面，按钮为“Sava as new” 或 “Sava and add another”\n\n- save_as_continue = True，点击保存并继续编辑\n\n  ```python\n  save_as_continue = True\n   \n  # 如果 save_as=True，save_as_continue = True， 点击Sava as new 按钮后继续编辑。\n  # 如果 save_as=True，save_as_continue = False，点击Sava as new 按钮后返回列表。\n   \n  New in Django 1.10.\n  ```\n\n- save_on_top = False，详细页面，在页面上方是否也显示保存删除等按钮；有的时候一页的内容太多，要保存要翻到最底下，加上这个参数以后在上面也可以进行保存删除了。也没啥屌用\n\n- inlines，详细页面，如果有其他表和当前表做FK，那么详细页面可以进行动态增加和删除\n\n  ```python\n  class UserInfoInline(admin.StackedInline): # TabularInline\n      extra = 0\n      model = models.UserInfo\n   \n   \n  class GroupAdminMode(admin.ModelAdmin):\n      list_display = (\'id\', \'title\',)\n      inlines = [UserInfoInline, ]\n  ```\n\n- action，列表时，定制action中的操作\n\n  ```python\n  @admin.register(models.UserInfo)\n  class UserAdmin(admin.ModelAdmin):\n   \n      # 定制Action行为具体方法，其中queryset就是我们选中的那些数据\n      def func(self, request, queryset):\n          print(self, request, queryset)\n          print(request.POST.getlist(\'_selected_action\'))\n   \n      func.short_description = \"中文显示自定义Actions\"\n      actions = [func, ]\n   \n      # Action选项都是在页面上方显示\n      actions_on_top = True\n      # Action选项都是在页面下方显示\n      actions_on_bottom = False\n   \n      # 是否显示选择个数\n      actions_selection_counter = True\n  ```\n\n\n\n\n## Stark组件\n\n简单的了解了admin的注册以及生成url的逻辑以后就可以按照上面的套路定制我们自己的组件了。\n\n### 创建app\n\n目的是为了方便以后在哪都能用\n\n```python\ndjango-admin startapp lamber\n```\n\n### 配置准备\n\n最后我们写成的这个插件要也是允许用户注册用户的模型类，然后通过我们的插件去显示，在Django中，是在app下的admin.py注册的，那么这个名我们是否可以自己定义呢？\n\n首先，项目启动以后并不是app里所有的组件都会执行，会执行的只有admin.py和app.py，并且app.py是要先执行的。\n\n```python\n# apps.py\nfrom django.apps import AppConfig\n\nclass App01Config(AppConfig):\n    name = \'app01\'\n```\n\nsettings中注册的django的admin组件：\n\n```python\nINSTALLED_APPS = [\n    \'django.contrib.admin\',\n    \'django.contrib.auth\',\n    \'django.contrib.contenttypes\',\n    \'django.contrib.sessions\',\n    \'django.contrib.messages\',\n    \'django.contrib.staticfiles\',\n    \'app01\',\n]\n```\n\n我们可以看一下admin组件在导入的时候干了什么\n\n```python\n# 在site-packages/django/contrib/admin/__init__.py中最后有这样一个函数\n# 这里其实就是找我们的admin.py，看到这里也就是说这个名字是允许我们自己定义的。\ndef autodiscover():\n    autodiscover_modules(\'admin\', register_to=site)\n```\n\n现在我们要自己写插件，不适用django的admin了，那么再installed_apps中，这一行其实就可以注释掉了，之后再导入我们自己开发的组件就可以了。注释内容如下：\n\n```python\nINSTALLED_APPS = [\n    # \'django.contrib.admin\',\n    # \'django.contrib.auth\',\n    \'django.contrib.contenttypes\',\n    \'django.contrib.sessions\',\n    # \'django.contrib.messages\',\n    \'django.contrib.staticfiles\',\n    \'app01\',\n]\n\nMIDDLEWARE = [\n    \'django.middleware.security.SecurityMiddleware\',\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.middleware.common.CommonMiddleware\',\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n    # \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    # \'django.contrib.messages.middleware.MessageMiddleware\',\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n]\n\nTEMPLATES = [\n    {\n        \'BACKEND\': \'django.template.backends.django.DjangoTemplates\',\n        \'DIRS\': [],\n        \'APP_DIRS\': True,\n        \'OPTIONS\': {\n            \'context_processors\': [\n                \'django.template.context_processors.debug\',\n                \'django.template.context_processors.request\',\n                # \'django.contrib.auth.context_processors.auth\',\n                # \'django.contrib.messages.context_processors.messages\',\n            ],\n        },\n    },\n]\n\nAUTH_PASSWORD_VALIDATORS = [\n    # {\n    #     \'NAME\': \'django.contrib.auth.password_validation.UserAttributeSimilarityValidator\',\n    # },\n    # {\n    #     \'NAME\': \'django.contrib.auth.password_validation.MinimumLengthValidator\',\n    # },\n    # {\n    #     \'NAME\': \'django.contrib.auth.password_validation.CommonPasswordValidator\',\n    # },\n    # {\n    #     \'NAME\': \'django.contrib.auth.password_validation.NumericPasswordValidator\',\n    # },\n]\n```\n\n记得把urls.py中的引用也给注掉，不然会报错；然后我们在执行makemigrations和migrate的时候其实就会干净很多，很多没用的表也不会生成。如果你觉得没用的表太多的话其实把用不到的app注销掉是比较好的做法。\n\n既然admin注掉了，那么app重的admin.py其实也没什么用了，也就可以删掉了。\n\n既然我们把admin干掉了，那么我们也要创建一个和admin类似的组件。\n\n### 注册用户模型类\n\n当程序刚运行的时候，django会去找每一个app中的app.py，就会执行app.py中的内容，其中一个就会执行ready方法；首先看一下app.py，以lamber中的app.py为例：\n\n```python\n# apps.py\nfrom django.apps import AppConfig\n\nclass LamberConfig(AppConfig):\n    name = \'lamber\'\n```\n\nLamberConfig继承自Appconfig，在Appconfig这个类中的定义里有ready方法是这么写的：\n\n```python\ndef ready(self):\n    \"\"\"\n    当django启动的时候，在子类中的这个方法会重写这个方法来运行代码\n    Override this method in subclasses to run code when Django starts.\n    \"\"\"\n```\n\n因此我们可以在app中的app.py中定义一个ready函数：\n\n```python\nfrom django.apps import AppConfig\n\n\nclass LamberConfig(AppConfig):\n    name = \'lamber\'\n    \n    def ready(self):\n        super(LamberConfig, self).ready()\n\n        from django.utils.module_loading import autodiscover_modules\n        # 指定自动发现的内容为lamber.py，这里就是指定文件的过程。\n        autodiscover_modules(\'lamber\')\n```\n\n写好以后在settings中注册一下我们新创建的app：\n\n```python\nINSTALLED_APPS = [\n    # \'django.contrib.admin\',\n    # \'django.contrib.auth\',\n    \'django.contrib.contenttypes\',\n    \'django.contrib.sessions\',\n    # \'django.contrib.messages\',\n    \'django.contrib.staticfiles\',\n    \'app01\',\n    # 注意写的方式，这里要使用这种方式注册才能生效\n    \'lamber.apps.LamberConfig\'\n]\n```\n\n那么现在我们就可以在每一个app下创建一个lamber.py了；这样每一个app在加载的时候都会执行我们的lamber.py这个文件了。在这个加载文件的时候我们就可以完成用户模型类的注册。\n\n### 针对用户的类生成url\n\n其实我们知道了本质以后就让后面的内容返回一个元组就行了，元组就是有上面的三要素；那我们也仿照着admin去写一下，首先我们在新建的lamber项目下新建一个service的python package，然后service下新建一个v.py，接下来在路由的主入口函数中进行导入：\n\n```python\nfrom lamber.service import v1\nurlpatterns = [\n    # path(\'admin/\', admin.site.register),\n    path(\'lamber/\', v1.site.urls),\n]\n```\n\n我们想的是最后v1.site.urls要返回我们之前提到的三要素，一个元组，一个appname，一个namespace。\n\n```python\nclass BaseLamberAdmin(object):\n\n    list_display = \'__all__\'\n\n    def __init__(self, model_class, site):\n        self.model_class = model_class\n        self.site = site\n\n    @property\n    def urls(self):\n\n        info = self.model_class._meta.app_label, self.model_class._meta.model_name\n        urlpatterns = [\n            path(\'\', self.changelist_view, name=\'%s_%s_changelist\' % info),\n            path(\'add/\', self.add_view, name=\'%s_%s_add\' % info),\n            path(\'<path:object_id>/delete/\', self.delete_view, name=\'%s_%s_delete\' % info),\n            path(\'<path:object_id>/change/\', self.change_view, name=\'%s_%s_change\' % info),\n        ]\n        return urlpatterns\n\n    def changelist_view(self, request):\n        # info = self.model_class._meta.app_label, self.model_class._meta.model_name\n        # data = \"%s_%s_changelist\" % info\n        # return HttpResponse(data)\n        self.model_class.objects.all()\n\n    def add_view(self, request):\n        info = self.model_class._meta.app_label, self.model_class._meta.model_name\n        data = \"%s_%s_add\" % info\n        return HttpResponse(data)\n\n    def delete_view(self, request, pk):\n        info = self.model_class._meta.app_label, self.model_class._meta.model_name\n        data = \"%s_%s_del\" % info\n        return HttpResponse(data)\n\n    def change_view(self, request, pk):\n        info = self.model_class._meta.app_label, self.model_class._meta.model_name\n        data = \"%s_%s_change\" % info\n        return HttpResponse(data)\n\nclass LamberSite(object):\n    def __init__(self):\n        self._registry = {}\n        self.namespace = \'lamber\'\n        self.appname = \'lamber\'\n\n    def register(self, model_class, xxx=BaseLamberAdmin):\n        self._registry[model_class] = xxx(model_class, self)\n\n    def login(self, request):\n        # 在这里必须要加上namespace，我们这里的namespace就是lamber\n        # 如果在分发的时候指定了namespace，那么在反向生成的时候就必须指定namespace\n        print(reverse(\'lamber:login\'))\n        \"\"\"\n        NoReverseMatch at /lamber/login/\n        Reverse for \'login\' not found. \'login\' is not a valid view function or pattern name.\n        \"\"\"\n        # print(reverse(\'login\'))\n        return HttpResponse(\'login\')\n\n    def logout(self, request):\n        return HttpResponse(\'logout\')\n\n    def get_urls(self):\n        ret = [\n            path(\'login/\', self.login, name=\'login\'),\n            path(\'logout/\', self.logout, name=\'logout\')\n        ]\n\n        for model_cls, lamber_admin_obj in self._registry.items():\n            appname = model_cls._meta.app_label\n            model_name = model_cls._meta.model_name\n\n            # ret.append(path(\'%s/%s/\' % (appname, model_name), self.login,))\n            ret.append(path(\'%s/%s/\' % (appname, model_name), include(lamber_admin_obj.urls),))\n\n        return ret\n\n    @property\n    def urls(self):\n        return self.get_urls(), self.appname, self.namespace\n\n\nsite = LamberSite()\n```\n\nadmin中site是AdminSite返回的对象，这里我们也照葫芦画瓢定义个LamberSite，在入口函数中，调用了v1.site.urls方法。\n\n\n\n## 小结：\n\n### Include\n\n如果传入的是一个路径，它会去自动导入模块，然后找urlpatterns这个变量。urlpatterns对应的是一个列表，列表里对应的就是一个url对应关系。","timestamp":1540354517190},{"name":"102-crm.md","path":"04-Django/50-项目实战/102-crm.md","content":"## Django ModelForm\n\n> - Model：操作数据库\n> - Form：对用户请求过来的数据进行验证+生成html标签\n>\n> 那么modelform就是操作数据+用户请求验证+生成html标签。如果是写的大型的应用程序，那么不推荐使用modelform，比如数据库操作，不同的业务部门通过api或者rpc去访问。对于这些业务部门来说，他们是接触不到数据库这些表的，这些人只需要做form数据验证，然后转发给基础平台，让基础平台进行数据的插入就行了，这个时候model和form就应该分开了，互相没有依赖关系；对于中小型的应用，比如数据库表就在这个app里，通过modelform可以让你省一些事。\n>\n> 参考：www.cnblogs.com/wupeiqi/articles/6229414.html\n\n\n\n\n\n\n\n反向生成url\n\ninclude(\'app01.urls\',namespace=\'aaa\')\n\napp01.urls中的这一大堆对应关系是和aaa这个namespace对应的。\n\n我在调用v1.site.urls的时候返回的是\n\n[],appname,namespace\n\n其实就相当于include(\'v1.site.urls\', namespace=\'namespace\')\n\n因此以后再反向生成的时候就需要加上这个namespace了。\n\nnamespace在分发的时候做进一级别的划分，比如url的name都是n1，有两条，那么n1对应的到底是哪一个。\n\n这个时候如果再加上namespace就可以进行区分了。\n\n只要反向生成url就必须指定namespace\n\n```python\n\n```\n\n反向url的作用：增加成功，跳转回哪个列表？这几个执行函数其实是不知道的。它只能根据反向生成url，根据当前url，根据你的app再加上你的名称去做。可以反向生成的这个列表连接，这样就能跳转回去了？\n\n## CRM项目组件之处理用户请求\n\n在lamber下创建一个template模板，那么他们会优先来自己的template下找。\n\ninclusion_tag表示要导入一个html模板\n\n\n\n使用type\n\n```python\n什么是单例：例指的就是实例，单例指的是不管你怎么执行，用的始终是第一个实例。\nclass Foo:\n    def __init__(self):\n        pass\n    \nobj1 = Foo()\nobj2 = Foo()\n\n上面这个是简单的实例化\n\nclass Foo():\n    _instance = None\n    def __init__(self):\n        pass\n    \n    @classmethod\n    def get_instance(cls):\n        if cls._instance:\n            return cls._instance\n        else:\n            obj = cls()\n            cls._instance = obj\n            return obj\n\na1 = Foo.get_instance()\n\n或者模块只导入一次的方式进行单例\n\n__new__和__init__\n\nclass Foo:\n    def __init__(self):\n        pass\n    \n    def __new__(cls, *args, **kwargs):\n        return object.__new__(cls, *args, **kwargs)\n\nnew的作用就是创建对象，new创建完了以后再执行init方法，这里的这个self就是创建的这个对象。\nclass Foo:\n    _instance = None\n    def __init__(self):\n        pass\n    \n    def __new__(cls, *args, **kwargs):\n        if cls._instance:\n            return cls._instance\n        else:\n            obj = object.__new__(cls, *args, **kwargs)\n            cls._instance = obj\n            return obj\n这样就比上面的要更好一些，对于用户的写法来说没有太大的改变。\n\n单例模式可以用于自定义curd组件，或者发布文章的时候对于特殊字符的过滤，或者数据库等\n```\n\n\n\n\n\n\n\n","timestamp":1540354517190},{"name":"99-Django常见小问题.md","path":"04-Django/99-Django常见小问题.md","content":"# Django常见小问题汇总\n\n## 数据库问题\n\n1. 数据库字符集问题，主要原因是数据库的字符集不对，可以创建数据库的时候指定字符集，比如`create database xxx charset utf8`亦或是修改数据库的配置文件在[mysqld]下添加如下的两条内容：`default-character-set=utf8`和`init_connect=’SET NAMES utf8′`；\n\n   ```python\n   django.db.utils.InternalError: (1366, \"Incorrect string value: \'\\\\xE7\\\\x94\\\\xA8\\\\xE6\\\\x88\\\\xB7\' for column \'name\' at row 1\")\n   ```\n\n\n\n\n## 其他问题\n\n","timestamp":1540354517190}]