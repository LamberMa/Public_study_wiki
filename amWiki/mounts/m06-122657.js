if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m06']=[{"name":"01-Web框架的本质.md","path":"06-Django/01-Web框架的本质.md","content":"数据库\n\n1. 安装\n2. 创建用户+授权\n3. 连接\n   - 数据库：终端创建数据库（字符编码）\n   - 数据表：终端，orm，pymysql（create……，engine innodb，charset）\n   - 数据行：增删改查\n\n\n\n问题：简述ORM原理\n\n浏览器的请求头：\n\n```html\nGET / HTTP/1.1\nHost: localhost:10020\nConnection: keep-alive\nCache-Control: max-age=0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36\\\nUpgrade-Insecure-Requests: 1\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8,en;q=0.7,zh-TW;q=0.6\nCookie: Pycharm-2f1c850a=df26fed3-d2a7-4be6-bfa1-4dc7a4831b46\n```\n\n服务器会返回对应的响应头和响应体。\n\n\n\n小结：\n\n```\n1、HTTP 短连接，无状态\n2、浏览器 socket客户端    网站 socket服务端\n3、自己写网站\n   a：socket服务端\n   b：根据URL不同返回不同的内容，路由系统：URL -- 函数\n   c：字符串返回给用户，末班引擎渲染，html充当模板(特殊自符)，自己创造任意数据。\n4、web框架：\n   框架种类：\n     - a,b,c                 ----- tornado\n     - 第三方的a,b,c          ------ wsgiref -> Django\n     - 第三方的a,b,第三方的c   ------ Flask\n   分类：\n     - Django框架(包含n多的web工具，是一个大家伙)\n     - 其他\n```\n\n","timestamp":1523930994994},{"name":"02-Django开篇.md","path":"06-Django/02-Django开篇.md","content":"# Django\n\n## 1、初识Django\n\n### 1.1、安装\n\n```shell\npip3 install django\n```\n\n在终端新建一个django项目(记得跳转到指定的目录中去创建)：\n\n```bash\ndjango-admin startproject myfirstsite\n```\n\n目录结构：\n\n```bash\n➜  myfirstsite git:(master) ✗ > tree ./\n./\n├── manage.py        # 管理网站的使用，对当前Django程序的所有操作都可以基于 python manage.py runserver……等等来进行操作\n└── myfirstsite\n    ├── __init__.py\n    ├── settings.py  # 配置文件\n    ├── urls.py      # 路由系统，写的是url和函数的对应关系\n    └── wsgi.py      # web socket模块，用于定义Django用什么socket来实现。\n```\n\n启动django：\n\n```bash\n# 切换到项目目录，不加地址的话，默认监听的是本地的8000端口\npython3 manage.py runserver \n```\n\n**附：Pycharm创建Django项目**\n\n点击File→New Project→找到django→起名字→选择对应的Interrupter→点击确定：结束~\n\n### 1.2、第一个Django请求\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.shortcuts import HttpResponse\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容，在这里return的内容需要按照django的规则，\n    直接返回字符串的login或者是字节串都是不行的，如果想要原原本本的返回写的内容\n    需要from django.shortcuts import HttpResponse才可以\n    这里的参数request是一个对象。\n    :param request:\n    :return:\n    \"\"\"\n    # HttpResponse只加字符串\n    return HttpResponse(\'login\')\n\n\nurlpatterns = [\n    \"\"\"\n    做路由内容的匹配，要按照人家django的规则，注意后面调用的是函数的名字，记住不要加小括号\n    \"\"\"\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\n### 1.3、Django静态文件以及模板配置\n\n1.2小节是直接使用HttpResponse返回一个字符串，那么如果想要返回一个模板内容该怎么办呢？首先在template文件夹下新建一个html文件，然后要想django可以访问到这个模板文件的话还需要引入render模块：\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.shortcuts import HttpResponse, render\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容\n    :param request:\n    :return:\n    \"\"\"\n    return render(request, \'login.html\')\n\n\nurlpatterns = [\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\nrender需要两个参数，一个是request，另外一个就是模板文件，你在打的时候都可以给你提示，因为系统默认配置的会去templates文件夹下去找这个模板，如果想要换其他的模板的话可以在django的配置文件settings.py中进行配置：\n\n```python\nTEMPLATES = [\n    {\n        \'BACKEND\': \'django.template.backends.django.DjangoTemplates\',\n        \'DIRS\': [os.path.join(BASE_DIR, \'templates\')]\n        ,\n        \'APP_DIRS\': True,\n        \'OPTIONS\': {\n            \'context_processors\': [\n                \'django.template.context_processors.debug\',\n                \'django.template.context_processors.request\',\n                \'django.contrib.auth.context_processors.auth\',\n                \'django.contrib.messages.context_processors.messages\',\n            ],\n        },\n    },\n]\n```\n\n其实render的本质还是调用了HTTPResponse：\n\n```python\ndef render(request, template_name, context=None, content_type=None, status=None, using=None):\n    \"\"\"\n    Return a HttpResponse whose content is filled with the result of calling\n    django.template.loader.render_to_string() with the passed arguments.\n    \"\"\"\n    content = loader.render_to_string(template_name, context, request, using=using)\n    return HttpResponse(content, content_type, status)\n```\n\n那么静态文件应该放在那里呢？比如我们在项目的根目录下新建一个static文件夹。静态文件无外乎css，js和img图片文件夹：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-8/70769756.jpg)\n\n新建一个样式文件，然后渲染刚才的那个login.html\n\n```html\n<link rel=\"stylesheet\" href=\"/static/css/style.css\">\n```\n\n结果就会发现html并没有发生更改，其实主要原因是这个时候，样式的调用也是通过django去调用的。因此这个静态文件的目录也是需要配置的，找到settings.py文件，找到最后一行：\n\n```python\nSTATIC_URL = \'/static/\'\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \'static\'),\n)\n```\n\n我们要添加的内容是`STATICFILES_DIRS`，注意，这里是一个元组，因此一个元素后面必须要跟逗号，不然会被默认为一个元素，肯定会报错的。\n\n其实这里`STATIC_URL`只不过是一个前缀而已，当调用static下的css的时候那么它会去找`STATICFILES_DIRS`中的路径，你这个路径是啥都行，只要添加到对应的路径下，每当访问static前缀的时候就会去找这个路径。\n\n### 1.4、Django创建程序步骤\n\n- 创建project，pycharm还是terminal都可以。\n\n- 配置：\n\n  - 模板路径：给render用\n  - 静态文件路径：css，js，img\n\n- 额外配置：\n\n  ```python\n  # 暂时先将MIDDLEWARE中的csrf注释掉。\n  MIDDLEWARE = [\n      \'django.middleware.security.SecurityMiddleware\',\n      \'django.contrib.sessions.middleware.SessionMiddleware\',\n      \'django.middleware.common.CommonMiddleware\',\n      # \'django.middleware.csrf.CsrfViewMiddleware\',\n      \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n      \'django.contrib.messages.middleware.MessageMiddleware\',\n      \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n  ]\n  ```\n\n### 1.5、用户登录示例\n\n模板界面：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <link rel=\"stylesheet\" href=\"/static/css/style.css\">\n    <title>login_test</title>\n</head>\n<body>\n    <form method=\"POST\" action=\"\">\n        <h1>登录测试</h1>\n        <!--这里我们用name进行pist提交，那么在服务端其实会收到一个QueryDict字典\n\t\t\t这里的username和password就是key值，我们输入的内容就是value值-->\n        <input type=\"text\" name=\"username\">\n        <input type=\"password\" name=\"password\">\n        <input type=\"submit\">\n      \t{{ msg }}\n    </form>\n</body>\n</html>\n```\n\nurl路由配置：\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\n# 引入redirect用户重定向使用，其中redirect跳转第三方网站域名要写全，但是如果要跳转自己地的网站的话我们可以直接写后缀比如 \"redirect(\'/index/\')\"，它会自动去找urlpatterns进行匹配，Django会为你自动拼接.\nfrom django.shortcuts import HttpResponse, render, redirect\n\n\ndef login(request):\n    \"\"\"\n    处理用户请求，并返回内容\n    :param request:\n    :return:\n    \"\"\"\n    # 通过request.method来获取用户请求的方式\n    if request.method == \'GET\':\n        return render(request, \'login.html\')\n    else:\n        # 用户post提交的数据（请求体的内容），那么request.GET就是get请求的数据。获取到的\n        # 是一个字典内容，比如xx/?p=123，结果就为{\'p\': \'123\'}\n        # 这里其实可以使用request.POST[\'username\']这样去取数据，但是如果说name不是这个\n        # 那么就会报错，因此我们可以使用get方法，如果name不是这个的话不会报错，会返回空\n        user = request.POST.get(\'username\')\n        password = request.POST.get(\'password\')\n        if user == \'root\' and password == \'123123\':\n            print(\'登录成功\')\n            return redirect(\'http://bbs.dcgamer.top\')\n        else:\n            print(\'====验证失败====\')\n            # render可以接受的第三个参数是一个字典，Django的模板引擎会根据你传递的\n            # 内容替换对应的特殊字符，比如下面的字典的key是msg，它就会替换模板中的\n            # {{ msg }}字段的值。\n            return render(request, \'login.html\', {\'msg\': \'用户名或密码错误\'})\n\n\nurlpatterns = [\n    # path(\'admin/\', admin.site.urls),\n    path(\'login/\', login),\n]\n```\n\n### 1.6、小结\n\n- 发get请求的时候，只有request.GET有值\n\n- 发post请求的时候，request.GET和request.POST是都可能有值的，因为你在发POST请求的时候，你请求的内容是可以带参数的。比如：\n\n  ```html\n  <form method=\'POST\' action=\"/login/?p=123\"></form>\n  ```\n\n## 2、学员管理系统初步\n\n### 2.1、单表操作（增删改查）\n\n表结构设计\n\n```mysql\n# 班级表\nid   title\n1    全栈4期\n2    全栈5期\n\n# 学生表\nid   name    班级id(FK)\n1    user1   1\n\n# 老师表(老师和班级是多对多的关系)\nid   name\n1    林海峰\n2    林狗\n3    袁日天\n\n# 老师和班级关系表\nid   老师id   班级id\n1       1       1\n2       1       2\n3       2       2\n\n########表结构设计##########\ncreate database django1;\n\ncreate table class(\n  id int unsigned not null primary key auto_increment,\n  title varchar(255) not null\n) engine=innodb charset=utf8;\n\ncreate table student(\n  id int unsigned not null primary key auto_increment,\n  name varchar(255) not null,\n  class_id int unsigned not null,\n  constraint `fk_class_id` foreign key (`class_id`) references class(`id`)\n) engine=innodb charset=utf8;\n\ncreate table teacher(\n  id int unsigned not null primary key auto_increment,\n  name varchar(255) not null\n) engine=innodb charset=utf8;\n\ncreate table teacher2class(\n  id int unsigned not null primary key auto_increment,\n  teacher_id int unsigned not null,\n  class_id int unsigned not null,\n  constraint `fk_teacher_id` foreign key (`teacher_id`) references teacher(`id`),\n  constraint `fk_cls_id` foreign key (`class_id`) references class(`id`)\n) engine=innodb charset=utf8;\n```\n\n### 2.2、一对多操作（增删改查）\n\n\n\n\n\n#### 基于ajax创建班级\n\n**模态对话框**（一般和ajax进行绑定）\n\n主要用于以下（比如登录）：\n\n> - 少量的输入框\n> - 数据少\n>\n> 相比较新URL的方式，新URL可以承载更多的操作已经更大的数据量。\n\n默认submit提交的时候会导致页面的刷新，这个属于form表单提交时的一个特性。这个是不受后台返回内容所限制的，不管你后台是return一个render重新渲染还是return一个httpresponse亦或是return一个redirect都不会影响。\n\n\n\n```javascript\n引入jquery：\n$.ajax({\n  url: \'要提交的地址\'，\n  type: \'POST\', // post或者是get这里指的是提交的方式\n  data: {\'k1\':\'v1\', \'k2\':\'v2\' ……}, // 这里指的是要提交的数据\n  success: function(data){\n      //当服务器处理完成并返回数据后会自动调用的一个函数。\n      //data表示返回的数据\n}\n \n})\n```\n\n使用Ajax删除班级，使用Ajax编辑班级。\n\n\n\n\n\n```javascript\n# 当页面框架加载完成后执行\n$(function(){\n  balabala……\n})\n\n# jquery阻止默认事件的发生\njquery绑定事件直接在函数中返回一个false就可以阻止事件的默认发生了，比如：\n$(function(){\n  $(\'#testmodel\').click(function(){\n    alert(123);\n    return false;\n  });\n});\n\n```\n\n模板的额外使用：\n\n```django\n{% if item.id in class_id %}\n\n{% else %}\n\n{% endif %}\n```\n\n\n\n### 2.3、多对多操作（增删改查）\n\n多对多的设计：\n\n\n\n\n\n\n\n=============\n\n响应头中如果有location的话，浏览器会直接再次发起请求。\n\n当a标签有默认跳转功能和其他事件比如click事件的时候会优先发生其他的附加事件，最后再执行跳转事件，如果想让默认事件不执行，可以让附加事件return一个函数，函数再renturn一个false默认事件就不会执行了，如果想让这个事件执行的话return true就可以了。\n\n\n\nplaceholder属性\n\nselect标签里的multiple属性，可以实现select标签的多选，size设置显示的范围大小。\n\npymysql中的lastrowid，在提交的时候还要把自增id拿到，lastrow_id要在commit以后才能拿到。\n\n取前端返回的多个数据可以使用\n\n```django\nrequest.POST.getlist(\'select标签的name\')\n```\n\n\n\n数据库类操作：\n\n```python\nclass DB():\n    \n    \n    def __init__(self):\n        # 从配置文件把配置读取出来\n        self.connect()\n    \n    def connect(self):\n        self.conn = pymysql.connect(xxxx)\n        self.cursor = self.conn.cursor(XXX)\n        \n    def get_list(self, sql, args):\n        self.cusor.excude(sql,args)\n        result = self.cursor.fethall()\n        return result\n    \n    def get_one(self, sql, args):\n        self.cursor.excute(sql, args)\n        result = self.cursor.fetchone()\n        return result\n    \n    def modify(self, sql, args):\n        # 这是链接一次提交多次，如果多次操作的每一次提交也是耗时\n        self.cursor.excute(sql, args)\n        self.conn.commit()\n        \n    def create(self, sql, args):\n        self.cursor.excute(sql, args)\n        self.conn.commit()\n        return self.cursor.lastrowid\n    \n    def multuple_modify(self, sql, args):\n        # 链接一次，提交一次，args是多个元组，我们要去构造。\n        self.cursor.excutemany(sql, args)\n        self.conn.commit()\n        \n    def close(self):\n        self.conn.close()\n        self.cursor.close()\n        \n        \n\n```\n\n\n\n表格的左右移动\n\n\n\n新URL方式\n\n\n\n通过ajax获取select列表的option所有的选项，在点击弹出框的时候通过ajax去服务器去取值。\n\n```javascript\n# 加载框显示的时机：用户一点弹出框增加的时候，先把透明底层和这个加载层显示出来，最后等数据加载完成了，也就是加载数据的这一块代码结束了，然后再把这个loading遮罩层给干掉，加上hide的class\n\n$.each(arg, function(i, row){\n  var tag = document.createElement(\'option\')\n  tag.innerHTML = row.title;\n  tag.setAttribute(\'value\', row.id);\n  $(\'#classIds\').append(tag);\n})\n// 加载框，加载完了以后先把loading的显示层隐藏掉，添加的框显示出来\n$(\'#loading\').addClass(\'hide\');\n$(\'#addModel\').removeClass(\'hide\');\n```\n\n注意：\n\n```javascript\n# 如果ajax里面传递的json有列表，如果要服务端显示为列表要加上traditional:true\n# 因为ajax会给你做特殊处理，如果加上traditional就不会做特殊处理，返回的就是列表，只支持列表，并不支持字典。\n$.ajax({\n  url: \'要提交的地址\'，\n  type: \'POST\', // post或者是get这里指的是提交的方式\n  data: {\'k1\':\'v1\', \'k2\':\'v2\' ……}, // 这里指的是要提交的数据\n  traditional: true,\n  success: function(data){\n      //当服务器处理完成并返回数据后会自动调用的一个函数。\n      //data表示返回的数据\n}\n```\n\n如何判断某个元素是不是在js的某个列表中\n\n```javascript\nv = [11,22,33]\nv.indexOf(22)\n# 如果有的话返回索引，如果没有的话返回-1\n```\n\n\n\nHTTP请求的生命周期\n\n请求头→提取URL→路由关系匹配→函数（模板+数据渲染）→返回用户（响应头+响应体）\n\n模版的渲染工作发生在哪一端？\n\n在服务端，浏览器拿到的一定是渲染完毕后的结果。\n\n默认从a标签跳转过去的都是get请求。\n\n\n\n## 初识BootStrap & fontawesome(图标库)\n\n使用bootstrap3\n\n下载用于生产环境的\n\n一个bootstrap.css，另外一个就是bootstrap.min.css，第二个是第一个的压缩版，但是功能是一模一样的。这样在调试的时候可以看，但是生产的时候要用压缩版。\n\nfonts是字体文件，特殊的图标文件也在里面。\n\n在static下新建一个plugin目录把这个放到里面去\n\n如何引用：\n\n```html\n<link ref=\'stylesheet\' href=\'/static/plugins/bootstrap……\'>\n```\n\n组件里有图标\n\nBootStrap：一个包含CSS和JS的样式库\n\n- 样式\n- 响应式：会根据用户的访问环境显示出不同的结构，比如手机端和pc端访问\n\n```css\n/*当小于等于700px的宽度的时候会执行@media里面的内容*/\n@media (max-width:700px){\n  .pg_header{\n   \tstyle1;\n    style2;\n  }\n}\n\n这样的可以添加多个形成一个多层改变的过程\n```\n\n组件：导航条\n\n响应式的代表一类是导航条，\n\nbootstrap总共给你把页面分成了12格子（bootstrap的栅格系统）\n\ncol-md col-lg col-xs col-sm\n\n\n\n全局样式里有一个：目的是是否允许移动设备进行缩放\n\n在 Bootstrap 2 中，我们对框架中的某些关键部分增加了对移动设备友好的样式。而在 Bootstrap 3 中，我们重写了整个框架，使其一开始就是对移动设备友好的。这次不是简单的增加一些可选的针对移动设备的样式，而是直接融合进了框架的内核中。也就是说，**Bootstrap 是移动设备优先的**。针对移动设备的样式融合进了框架的每个角落，而不是增加一个额外的文件。\n\n为了确保适当的绘制和触屏缩放，需要在 `<head>` 之中**添加 viewport 元数据标签**。\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n```\n\n在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 `user-scalable=no` 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n```\n\n\n\n\n\n关于后台管理的布局，一般标准的就是那种布局，一般不去做响应式，不过也可以做响应式。但是使用bootstrap做响应式定制性不高。\n\n创建用户表，使用用户登录\n\ni标签\n\nhover是可以实现级联的：\n\n```css\n.pg-header .avatar:hover .user-infor{\n  xxxxx\n}\n```\n\n\n\nposition:absolute一会出现高度塌陷\n\n\n\n路径导航：\n\n\n\nDjango的程序目录介绍\n\n```python\n# 在对应的项目目录通过manage.py直接创建小的小项目，简单来说一个平台需要很多功能，但是功能之间又没有太大的联系。\npython manage.py startapp app01\n\n\n# 通过pycharm也是可以创建的\n在创建project的时候，在more settings下直接写一个application name就可以在创建project的同时会创建一个app，但是我们也可以在pycharm的terminal终端通过命令去创建，创建的目录里面其实会自带已给view\n\n一般业务代码放在对应的app文件夹里；\n\napp中的migrations是和数据库相关的。\nadmin是内部存在的后台管理，xxxx/admin，默认的账号和密码是：\napps是当前app的配置文件\nmodels是django的orm的类，和数据库进行沟通的\ntests是进行单元测试的。\nviews就是和之前一样的页面的，views不一定就是一个单文件，有时候逻辑特别多的时候写到一个py文件不是很好，我们可以把这个views.py删掉换成一个views文件夹，然后里面针对业务分成多个py文件。\n```\n\n## 路由系统\n\n### 动态路由\n\nurl->函数\n\n- 一一对应：/login/ → def login\n- /add-user/(+d)\n\n\n\nSEO会把get传参的内容页面的权重变低，因为爬虫会认为get传参的是经常变的，因此不经常变动的优先级会较高一些。\n\n```python\n# 正则表达式\nhttp://127.0.0.1/edit/ffff\nurl(r\'^edit/(\\w+)\', view.edit),\nurl(r\'^edit/(\\w+)/(\\w+)\', view.edit), ## 函数要接收两个参数，按照顺序接收\n# 这个并不是什么html文件，只是一个正则模版，这个叫伪静态\nurl(r\'^edit/(\\w+).html$\', view.edit),\ndef edit(requst, a1):\n    print(a1)\n    return xxxx\n\nurl(r\'^edit/(?P<a1>\\w+)/(?P<a2>\\w+)/\')\n这样就可以按照对应的标签去匹配了，a1就是第一个，a2就是第二个。这个可以不按照顺序去接收。这个就是按照参数名称进行存放的方式。\n\n如果加名字的和不加名字的共存那是如何接收的？\n答：这样就会直接报错，这个函数她会不知道如何接收，因此用法要统一，要不就关键字要不就位置的。\n\n函数在接收参数的时候可以使用*args和**kwargs\n\n推荐使用终止符号\nurl(r\'^edit$\'， view.edit)\n```\n\n什么是伪静态\n\n```\n\n```\n\n路由分发\n\n```python\nfrom django.conf.urls import include\n\n# 先从主的转到对应的app下的url路由关系，然后根据引入的urls再进行路由匹配\nurl(r\'^app01\', include(\'app01.urls\'))\n# 对应的访问结果应该就是这样的，路由分发只匹配到app01，后面的内容不会进行匹配\nhttp://128.0.0.1/app01/xxx/xxx.html\n\n转到具体的urls就不会看从app01开始往前的内容了。\n\n经过如上的操作，路由被分成了两级，project的入口成为了路由分发器\n\n啥没写可以跳转到一个默认的页面，比如跳转到主页\nurl(r\'^\', views.index)\n```\n\n路由系统之别名反向生成URL\n\n```python\nfrom django.urls import reverse\nurl(r\'^edit/\', view.edit, name=\'n1\'),  # 起一个别名\n# 可用于日后根据别名反生成url\nv = reverse(\'n1\')   # \'/edit/\'\n\n# 指定反向生成的内容\nurl(r\'^edit/(\\d+)\', view.edit, name=\'n1\')\nv = reverse(\'n1\', args=(1,))  # \'/edit/1/\'\n\n# 指定反向生成的内容(dict)\nurl(r\'^edit/(?P<a1>\\d+)\', view.edit, name=\'n1\')\nv = reverse(\'n1\', kwargs={\'a1\':\'111\'}  # \'/edit/111/\'\n            \n# 有了这个别名以后，form表单的action以后就可以这样写了，也可以根据名称反生成url\n<form method=\'POST\' action=\'{% url \"m1\" %}\'></form>\n            \n# 对应的跳转链接也可以通过反向链接实现，这是不使用python而是使用html模版循环的方法\n{% for i in list %}\n# 可以按照对应的值生成URL<a href=\"{% url \'n1\' i.1,i.2,i.3…… %}\">\n# 结果： <a href=\'/edit/aaa/bbb/ccc/ddd\'>\n<a href=\"{% url \'n2\' i %}\">xxxx\n{% endfor %}\n            \n\n# 在web中分全权限显示页面\n每个人的权限不一样，保存的权限跳转链接也不一样。\n            \n假如说可以访问的url很长，那么在数据库也要存储很长，如果说有一个别名的话就可以使用别名存储到数据库就可以了。通过别名就可以找到相对的url了。这个别名只在django里面有，在其他的系统里并不存在。当然不使用别名，完全使用url也是可以的。在crm权限管理中会用到，稍后说。\n```\n\n## CBV & FBV（之前用的）\n\n CBV：\n\n在视图函数匹配的时候，一个url可以对应一个函数，但是同时也可以对应一个类。\n\n```python\n# Login是一个类，其中as_view()是特殊的写法\nurl(r\'^login.html$\', views.Login.as_view())\n\n# 这个类需要继承这个Views\n# 看的是类里是不是getattr GET POST利用反射获取对应的方法\nfrom django.views import View\nclass Login(View):\n    \n    def get(self, request):\n        pass\n    \n    def post(self, request):\n        pass\n    \n    def dispath(self, request, *args, **kwargs):\n        # 可以对dispatch进行重写，先把父类的功能拿过来，先执行dispatch方法，然后dispatch去执行GET或者post方法，然后拿到返回值return才行\n        # 我们可以在执行dispatch的时候对一些方法进行统一的调用，或者循环操作等等，类似一个装饰器。\n        print(\'before\')\n        obj = super(Login, self).dispatch(self, request, *args, **kwargs)\n        print(\'after\')\n        return obj\n    \nGET和POST方法执行之前还执行了一个dispatch方法，这个即使利用反射获取GET还是POST，可以在父类Views里查看\n```\n\n## Django的分页\n\n### Django内置分页\n\n```python\nmodels.Userinfo.objects.all()[0:10]\nmodels.Userinfo.objects.all()[11:20]\n\nfrom django,core paginator import Paginator, Page\nuser_list = model.UserInfor.object.all()\npaginator = Paginator(user_list, 10)\n# 这个对象可以找到以下属性\n# - per_page: 每页显示条目数量\n# - count： 数据总个数\n# - num_pages: 总页数\n# - page_range： 总页数的索引范围，比如(1,10),(1,200)\n# - page： page对象，可以指定当前显示第几页\nposts = paginator.page(2)\n这个posts有以下方法：\n\nposts = paginator.page(current_page)\n        # has_next              是否有下一页\n        # next_page_number      下一页页码\n        # has_previous          是否有上一页\n        # previous_page_number  上一页页码\n        # object_list           分页之后的数据列表\n        # number                当前页\n        # paginator             paginator对象\n        \n就把posts.object_list传递给前端的模板就可以了\n\n上下页：\n{% if posts.has_next %}\n\t<a href=\'index.html?page={{ posts.next_page_number}}\'>下一页</a>\n{% endif %}\n\n如果传递的不是整形的花那么就默认让你访问第一页\n\nfrom django.shortcuts import render\nfrom django.core.paginator import Paginator, EmptyPage, PageNotAnInteger\n\nL = []\nfor i in range(999):\n    L.append(i)\n\ndef index(request):\n    current_page = request.GET.get(\'p\')\n\n    paginator = Paginator(L, 10)\n    # per_page: 每页显示条目数量\n    # count:    数据总个数\n    # num_pages:总页数\n    # page_range:总页数的索引范围，如: (1,10),(1,200)\n    # page:     page对象\n    try:\n        posts = paginator.page(current_page)\n        # has_next              是否有下一页\n        # next_page_number      下一页页码\n        # has_previous          是否有上一页\n        # previous_page_number  上一页页码\n        # object_list           分页之后的数据列表\n        # number                当前页\n        # paginator             paginator对象\n    except PageNotAnInteger:\n        posts = paginator.page(1)\n    except EmptyPage:\n        posts = paginator.page(paginator.num_pages)\n    return render(request, \'index.html\', {\'posts\': posts})\n```\n\n### 自定义分页\n\n```python\ndef custom(request):\n    # 获取当前页面，表示用户当前想要访问的页码\n    current_page = request.GET.get(\'page\')\n    # 设置一下每一页显示的数目\n    per_page = 10\n    current_page = int(current_page)\n   \n\t# 设置起始位置\n    start = (current_page-1) * per_page\n    stop = current * per_page\n   \n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[start, stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list})\n```\n\n把上面的逻辑封装到一个类\n\n```python\nclass PageInfor(object):\n    \n    def __init__(self, current_page, all_count, per_page, show_page=11)\n    \ttry:\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        # 数据库总行数\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        pages, spare = divmod(self.all_count, self.per_page)\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        \n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        page_list = []\n        # 当前页的每一边有几个\n        half = int((self.show_page-1)/2)\n        \n        # 关于极限值做一下判断，如果说当前页已经小于等于两边的分页了 \n        if self.current_page <= half:\n            # 那么就把左侧的极限值抠出来，也即是begin\n            begin = 1\n            # 如果说我想要显示n页面，实际要大于n页，stop就是我要显示的。\n            if self.all_pager > self.show_page:\n            \tstop = self.show_page + 1\n            # 如果说实际不够我要显示的页数，那么就是有几页就显示几页了\n            else:\n                stop = self.all_pager +1\n        # 没到极值的时候就按照之前的逻辑\n        else:\n        \tbegin = self.current_page - half\n        \tstop = self.current_page + half + 1\n            \n        for i in range(begin, stop):\n            if i == self.page:\n            \ttemp = \"<a style=\'display=inline-block;padding:5px;background:red;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            else:\n                temp = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n        \n    \n\n# 再次调用\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10)\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\n# 如果模板端需要使用的话需要，加上safe表示是安全的，而不是xss跨站脚本攻击。如果是安全的话就会渲染成标签，而不是字符串。\n{{ page_info.pager|safe }}\n```\n\n上面写的还有一些啰嗦，针对这个问题再做一下优化：\n\n```python\nclass PageInfor(object):\n    \n    def __init__(self, current_page, all_count, per_page, show_page=11)\n    \ttry:\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        # 数据库总行数\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        pages, spare = divmod(self.all_count, self.per_page)\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        \n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        page_list = []\n        # 当前页的每一边有几个\n        half = int((self.show_page-1)/2)\n\t\t# 如果数据库的总页数小于咱们设置的显示的页数那就看这点吧\n        if self.all_pager < self.show_page:\n            begin = 1\n            stop =  self.all_pager + 1\n        # 如果总页数大于11\n        else:\n            # 如果当前页小于等于5，那么就永远显示1~11页\n            if current_page < half:\n            \tbegin = 1\n            \tstop = self.show_pager + 1\n            else:\n                # 当前页大于5\n                if (self.current_page + half) > self.all_pager: \n                    begin = self.all_pager - self.show_page + 1\n                    stop = self.current_page + 1\n                else:\n        \t\t\tbegin = self.current_page - half\n        \t\t\tstop = self.current_page + half + 1\n        \n        if self.current_page < = 1 :\n        \tprev = \"<a style=\'display=inline-block;padding:5px;\' href=\'#\'>上一页</a>\"\n        else:\n        \tprev = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>上一页</a>\" % self.current_page - 1\n        \n        page_list.append(prev)\n        \n        for i in range(begin, stop):\n            if i == self.page:\n            \ttemp = \"<a style=\'display=inline-block;padding:5px;background:red;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            else:\n                temp = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>%s</a>\" % (i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n    \n    \tif self.current_page >= self.all_pager:\n            nxt = \"<a style=\'display=inline-block;padding:5px;\' href=\'#\'>下一页</a>\"\n        else:\n        \tnxt = \"<a style=\'display=inline-block;padding:5px;\' href=\'/custom.html?page=%s\'>下一页</a>\" % self.current_page + 1\n        page_list.append(nxt)\n    \n\n# 再次调用\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10)\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\n# 如果模板端需要使用的话需要，加上safe表示是安全的，而不是xss跨站脚本攻击。如果是安全的话就会渲染成标签，而不是字符串。\n{{ page_info.pager|safe }}\n```\n\n针对如上的内容再次进行优化：\n\n```python\ndef custom(request):\n\t# 获取一下总条目数\n    all_count = models.UserInfo.objects.all().count()\n    # 加一个html的前缀\n    page_info = PageInfor(request.GET.get(\'page\'), all_count, 10, \'/custom.html\' )\n\t# 需要起始位置和结束位置\n    user_list = models.UserInfo.objects.all()[page_info.start, page_info.stop]\n    \n    return render(request, \'custom.html\', {\'user_list\': user_list, \'page_info\': page_info})\n\nclass PageInfor(object):\n    # 接收位置参数调整一下\n    def __init__(self, current_page, all_count, per_page, base_url, show_page=11)\n    \ttry:\n    \t\tself.current_page = int(current_page)\n        except Exception as e:\n            self.current_page = 1\n        # 数据库总行数\n        self.all_count = self.all_count\n        self.per_page = per_page\n        # divmod(101, 10) 箭头 (10, 1)\n        pages, spare = divmod(self.all_count, self.per_page)\n        if spare:\n            pages += 1\n        self.all_pager = pages\n        self.show_page = show_page\n        # 要跳转的连接前缀\n        self.base_url = base_url\n        \n    def start(self):\n        return  (self.current_page-1) * self.per_page\n    \n    def stop(self):\n        return self.current_page * self.per_page\n\n\tdef pager(self):\n        page_list = []\n        # 当前页的每一边有几个\n        half = int((self.show_page-1)/2)\n\t\t# 如果数据库的总页数小于咱们设置的显示的页数那就看这点吧\n        if self.all_pager < self.show_page:\n            begin = 1\n            stop =  self.all_pager + 1\n        # 如果总页数大于11\n        else:\n            # 如果当前页小于等于5，那么就永远显示1~11页\n            if current_page < half:\n            \tbegin = 1\n            \tstop = self.show_pager + 1\n            else:\n                # 当前页大于5\n                if (self.current_page + half) > self.all_pager: \n                    begin = self.all_pager - self.show_page + 1\n                    stop = self.current_page + 1\n                else:\n        \t\t\tbegin = self.current_page - half\n        \t\t\tstop = self.current_page + half + 1\n        \n        if self.current_page < = 1 :\n        \tprev = \"<li><a href=\'#\'>上一页</a></li>\"\n        else:\n        \tprev = \"<li><a href=\'%s?page=%s\'>上一页</a></li>\" % (self.base_url, self.current_page - 1)\n        \n        page_list.append(prev)\n        \n        for i in range(begin, stop):\n            if i == self.page:\n            \ttemp = \"<li class=\'active\'><a href=\'%s?page=%s\'>%s</a></li>\" % (self.base_url, i, i)\n            else:\n                temp = \"<li><a href=\'%s?page=%s\'>%s</a></li>\" % (self.base_url, i, i)\n            page_list.append(temp)\n        return \'\'.join(page_list)\n    \n    \tif self.current_page >= self.all_pager:\n            nxt = \"<li><a href=\'#\'>下一页</a></li>\"\n        else:\n        \tnxt = \"<li><a href=\'%s?page=%s\'>下一页</a></li>\" % (self.base_url, self.current_page + 1)\n        page_list.append(nxt)\n```\n\n结合bootstrap进行样式优化，然后就可以把类单独拿出来了\n\n```python\n创建一个目录叫utils，用来存放工具类。把这个类拿过来，放到这个模块里就行了。\n```\n\n\n\n\n\n## Django Admin\n\n> Django Admin是由Django自身提供的一个管理后台\n\n创建用户名密码：\n\n```python\npython manage.py createsuperuser\n```\n\n\n\n```python\n# admin.py\nfrom django.crontrib import admin\nfrom app01 import models\nadmin.site.register(models.UserInfo)\n```\n\n这样操作就可以把我们自己创建的Userinfo注册到Django\n\n就可以在Django admin中操作数据表了。\n\n","timestamp":1523930994994},{"name":"01-Django_orm初识.md","path":"06-Django/03-Django ORM/01-Django_orm初识.md","content":"# Django ORM\n\n> 首先针对ORM不做太对的赘述，ORM不仅仅是Python有，其他的语言也有。比较重要的就是记住其中的映射关系。类对应数据表，字段对应属性，类的对象对应表中的每一条记录。\n>\n> - 数据库操作：事先创建好数据库\n> - 数据表操作：创建表，修改表，删除表\n> - Django Query_set的链式操作\n>\n> django的orm没办法直接连接数据库，需要pymysql等第三方工具去连接数据库。默认连接mysql的时候用的是 MysqlDB模块，py3中没有。因此需要修改默认连接mysql的方式。\n\n## 1、配置Django连接数据库\n\nDjango里面默认连接sqlite，那么修改的花其实就是修改settings的配置啦\n\n```python\n# http://www.cnblogs.com/wupeiqi/articles/5237704.html\n# 由sqlite变为mysql\nDATABASES = {\n    \'default\': {\n    \t\'ENGINE\': \'django.db.backends.mysql\',\n    \t\'NAME\':\'dbname\',  # 数据库的名称，要先创建好数据库\n    \t\'USER\': \'root\',\n    \t\'PASSWORD\': \'xxx\',\n    \t\'HOST\': \'localhost\',\n    \t\'PORT\': \'3306\',\n    }\n}\n\n# 在project同名的__init__.py中引入一下pymysql\n# 由于Django内部连接MySQL时使用的是MySQLdb模块，而python3中还无此模块，所以需要使用pymysql来代替\n# 如下设置放置的与project同名的配置的 __init__.py文件中\n  \nimport pymysql\npymysql.install_as_MySQLdb()\n```\n\n**踩坑记录~**\n\n```python\n# 因为我学习的时候django2.0刚发布没多久，因此默认安装的就是2.0的django。在使用过程中遇到如下报错，报我的mysql版本太低：\ndjango.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None\n\n找到对应使用的python版本的site-packages下django下db下banckends下mysql下的base.py\n我的位置是在如下的位置，win，mac，或者其他的linux版本位置可能不一样自己确定好位置再改。\n/usr/local/lib/python3.6/site-packages/django/db/backends/mysql\n\n在base.py中有这么一句，给注释掉就可以了，否者都不能创建django app\nif version < (1, 3, 3):\n    raise ImproperlyConfigured(\"mysqlclient 1.3.3 or newer is required; you have %s\" % Database.__version__)\n```\n\n**扩展：查看Django ORM执行的原生SQL**\n\n```python\n# 在settings中添加这些语句，这样重启项目以后我们就可以在终端查看到执行的所有语句了，调试的时候可以打开查看进行调试学习使用。\nLOGGING = {\n    \'version\': 1,\n    \'disable_existing_loggers\': False,\n    \'handlers\': {\n        \'console\':{\n            \'level\':\'DEBUG\',\n            \'class\':\'logging.StreamHandler\',\n        },\n    },\n    \'loggers\': {\n        \'django.db.backends\': {\n            \'handlers\': [\'console\'],\n            \'propagate\': True,\n            \'level\':\'DEBUG\',\n        },\n    }\n}\n\n当然这个不一定打开，因为打开以后实在是有点烦，你可以用对象的query方法，比如print(ob.query)进行单独查看。\n```\n\n## 2、Django数据表的创建\n\n> Django的ORMD是data_first类型的ORM，使用前必须先创建数据库\n\n### 2.1、建表流程\n\ndjango orm之创建数据表，在app的models类，创建一个类，这个类就是表（对应文件为小的项目下的models.py文件），表中的一行就是一个对象。\n\n```python\n# 表类创建示例\nclass Userinfo(models.Model):\n    # AutoField()就是自增的，在内部生成的是Int类型，还有一个BigAutoField，就是bigint\n    # 在django里，这一列可以不写，在内部会默认生成一列叫id，是int类型的，并且自增的，是PrimaryKey\n    # 当然这一列你写了就用你的。\n    nid = models.AutoField(primary_key = True)\n    # CharField就是字符串类型\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    \n# 表的修改\n直接修改models中的class数据模型类就行了。在已经有数据的表里添加字段的时候要添加默认值\nage = models.IntergerField(null=True)\n或者\nage = models.IntergerField(default=1)\n```\n\n表与表可以通过外键之间建立关系，但是表之间的关系Django提供了更多的处理方式\n\n```python\n# 下面这条命令是和UserGroup进行建立关系，关系建立后并不会在当前的表生成一个叫group_id的字段而是会\n# 自动生成一个group_id_id的这么一列，生成外键的关系。也就是说我们创建的外键在实际的表中会生成一个我们创建# 的名字_id形式的名字字段，因此如果说向这个表中添加数据的时候，指定的字段名应该是，外键_id的形式。\ngroup_id = models.ForeignKey(\"UserGroup\", null=False)\n\n示例：\nclass Userinfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(max_length=16)\n    age = models.IntegerField()\n    ut = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n    \n    那么结果会有id，name，age，ut_id字段，共4个字段\n```\n\n### 2.2、注册你的项目\n\n```python\n# 在settings中注册app\nINSTALLED_APPS = [\n    \'django.contrib.admin\',\n    \'django.contrib.auth\',\n    \'django.contrib.contenttypes\',\n    \'django.contrib.sessions\',\n    \'django.contrib.messages\',\n    \'django.contrib.staticfiles\',\n    \'app01\',  # 把你自己的小项目给加上\n]\n```\n\n### 2.3、创建数据表：\n\n```python\n# 最后创建数据库表\npython manage.py makemigrations  # 生成配置文件\n# 通过配置文件进行操作数据库，每一次都有一个配置文件，保存在app中的migrations文件夹中，修改的依据也是这个文件夹的操作配置的记录的配置文件。我们其实可以理解为一个数据库修改操作的记录表\npython manage.py migrate         \n\n# django自己会创建很多表\nmysql> show tables;\n+----------------------------+\n| Tables_in_study            |\n+----------------------------+\n| auth_group                 |\n| auth_group_permissions     |\n| auth_permission            |\n| auth_user                  |\n| auth_user_groups           |\n| auth_user_user_permissions |\n| backend_userinfo           |\n| django_admin_log           |\n| django_content_type        |\n| django_migrations          |\n| django_session             |\n+----------------------------+\n11 rows in set (0.00 sec)\n\n# 只有这个backend_userinfo才是我们自己的表，其他的都是django默认创建的。\n# Django通过自身的ORM为我们生成的表名默认是以appname_小写的类名。\n# 比如app名称是backend，那么对应的class UserInfo这个类生成的orm就是：backend_userinfo\n```\n\n## 3、Django Admin\n\n> Django为我们提供了一个内置的后台，我们可以使用\n\n登录后台是需要账号密码的，不过我们一开始也不知道，因此要重新设置一下密码\n\n```python\npython3 manage.py createsuperuser\n```\n\n按照命令行的提示输入账号和密码就可以啦~\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/1250519.jpg)\n\n主界面：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/37524661.jpg)\n\n假如说Django Admin的密码忘了怎么办？\n\n```python\npython manage.py changepassword <username>\n```\n\n通过Django Admin注册model实现数据插入：\n\n```python\n# 在对应的app的admin.py下引入models模块进行注册\nfrom django.contrib import admin\nfrom main import models\n\n# Register your models here.\nadmin.site.register(models.Article)\nadmin.site.register(models.Category)\nadmin.site.register(models.Tag)\nadmin.site.register(models.User)\n```\n\n再访问admin界面的时候我们就可以使用Django Admin进行数据添加了。\n\n","timestamp":1523930994994},{"name":"02-Django Model.md","path":"06-Django/03-Django ORM/02-Django Model.md","content":"# Django Model\n\n## 常用Model\n\n### 数字类型\n\n- AutoField(Field)\n\n  ```python\n  int自增列，必须填入参数 primary_key = True\n  ```\n\n- BigAutoField(AutoField)\n\n  ```python\n  这是bigint的自增列，必须填入参数primary_key=True\n  注：当model中如果没有自增列，则自动会创建一个列名为id的列\n\n  from django.db import models\n\n  class UserInfo(models.Model):\n      # 自动创建一个列名为id的且为自增的整数列\n      username = models.CharField(max_length=32)\n\n  class Group(models.Model):\n      # 当然我们可以自定义自增列\n      nid = models.AutoField(primary_key=True)\n      name = models.CharField(max_length=32)\n  ```\n\n- SmallIntegerField(IntegerField)\n\n  ```python\n  - 小整数 -32768 ～ 32767\n  ```\n\n- PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\n\n  ```python\n  - 正小整数 0 ～ 32767\n  ```\n\n- IntegerField(Field)\n\n  ```python\n  - 整数列(有符号的) -2147483648 ～ 2147483647\n  ```\n\n- PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)\n\n  ```python\n  - 正整数 0 ～ 2147483647\n  ```\n\n- BigIntegerField(IntegerField):\n\n  ```python\n  - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807\n\n  自定义无符号整数字段\n\n  class UnsignedIntegerField(models.IntegerField):\n      def db_type(self, connection):\n          return \'integer UNSIGNED\'\n  ```\n\n- FloatField(Field)\n\n  ```python\n  浮点型\n  ```\n\n- DecimalField(Field)\n\n  ```python\n  - 10进制小数,精确浮点\n  - 参数：\n     max_digits，总长度\n     decimal_places，小数位长度\n  ```\n\n### 字符串类型\n\n- CharField(max_length=255)\n\n  ```python\n  字符类型，必须提供max_length参数，max_length表示字符长度\n  ```\n\n- EmailField(CharField)\n\n  ```python\n  也是字符串类型，在Django Admin以及Model Form中可以提供邮箱格式的验证，但是直接create增加数据这样是并不能够提供验证功能的\n  ```\n\n- IPAddressField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制\n  ```\n\n- URLField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 URL\n  ```\n\n- SlugField(CharField)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）\n\n  Slug这个Field是用在文章的URL的，比如一个文章标题是i love django，那么可以把slug设置成i-love-django，然后这样这篇文章的url可以是www.example.com/article/i-love-django，每一篇文章都是唯一的，所以slug也要唯一，unique要设置为True。当然你可以不这么用，单纯的用文章的id也行。\n  ```\n\n- UUIDField(Field)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证\n  ```\n\n- GenericIPAddressField(Field)\n\n  ```python\n  字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6；参数1：protocol，用于指定Ipv4或Ipv6， \'both\',\"ipv4\",\"ipv6\"；参数2：unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\"both\"\n  ```\n\n- FilePathField(Field)\n\n  ```python\n  字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能。\n  参数如下：path（文件夹路径）,match=None（正则匹配）,recursive=False（是否递归下面的文件夹）,allow_files=True（允许文件）,allow_folders=False（允许文件夹）\n  ```\n\n- FileField(Field)\n\n  ```python\n  字符串，路径保存在数据库，文件上传到指定目录，可以在Django Admin中，直接进行使用。\n  参数1：upload_to = \"\"表示上传文件的保存路径；\n  参数2：storage = None表示存储组件，默认：django.core.files.storage.FileSystemStorage\n  ```\n\n- ImageField(FileField)\n\n  ```python\n  字符串，路径保存在数据库，文件上传到指定的目录；\n  参数如下：\n  - upload_to=\"\"（表示上传文件的保存路径）；\n  - storage=None(表示存储组件，默认的是django.core.files.storage.FileSystemStorage)；\n  - width_field=None（上传图片的高度保存的数据库字段名，字符串形式）；\n  - height_field=None（ 上传图片的宽度保存的数据库字段名，字符串形式）；\n\n  这个字段依赖于PIL库，因此确保你使用的时候安装了这个库，如果没有安装的话可以使用pip安装一下：pip install PIL否则是会报错的哦~\n  ```\n\n- CommaSeparatedIntegerField(CharField)\n\n  ```python\n  字符串类型，格式必须为逗号分割的数字\n  ```\n\n- TextField(Field)\n\n  ```python\n  - 文本类型\n  ```\n\n### 时间类型\n\n- DateTimeField(DateField)\n\n  ```python\n  - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]\n  ```\n\n- DateField(DateTimeCheckMixin, Field)\n\n  ```python\n  - 日期格式      YYYY-MM-DD\n  ```\n\n- TimeField(DateTimeCheckMixin, Field)\n\n  ```python\n  - 时间格式      HH:MM[:ss[.uuuuuu]]\n  ```\n\n- DurationField(Field)\n\n  ```python\n  - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型\n  ```\n\n关于时间类型，Django提供的model有DateTimeField，DateField，TimeField三种类型。分别对应的datetime()，date()，time()三种对象。这三个field有相同的参数，一个事auto_now，一个是auto_now_add。\n\n1. auto_now：这个字段属性值默认是false的，在保存数据对象的时候，将其设置为当前时间，然后当你修改的时候这个时间会随着你修改的时间变化而变化。简单来说，这个对象的时间会一直是最新的时间，你没办法为这个字段进行手动的赋值。\n2. auto_now_add：这个字段默认也是false的，如果设置为True以后其实和auto_now差不多，只不过这个时间不会因为你后续的修改而进行改变，而是只保存第一次创建的时间。比如说用户创建时间，这个不应该随着用户信息变化而发生改变，但是论坛发的帖子，可以有一个最后的修改时间可以随着修改而改变。\n\nauto_now和auto_now_add被设置为True后，这样做会导致字段成为editable=False和blank=True的状态。editable=False将导致字段不会被呈现在admin中，blank=True表示允许在表单中不输入值。此时，如果在admin的fields或fieldset中强行加入该日期时间字段，那么程序会报错，admin无法打开；如果在admin中修改对象时，想要看到日期和时间，可以将日期时间字段添加到admin类的readonly_fields中：\n\n```python\nclass YourAdmin(admin.ModelAdmin):\n    readonly_fields = (\'save_date\', \'mod_date\',)\nadmin.site.register(Tag, YourAdmin)\n```\n\n实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？\n\ndjango中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：\n\n```python\nfrom django.db import models\nimport django.utils.timezone as timezone\nclass Doc(models.Model):\n    add_date = models.DateTimeField(\'保存日期\',default = timezone.now)\n    mod_date = models.DateTimeField(\'最后修改日期\', auto_now = True)\n```\n\nhtml页面从数据库中读出DateTimeField字段时，显示的时间格式和数据库中存放的格式不一致，比如数据库字段内容为2016-06-03 13:00:00，但是页面显示的却是Apr. 03, 2016, 1 p.m.\n\n为了页面和数据库中显示一致，需要在页面格式化时间，需要添加如下类似的过滤器。刷新页面，即可正常显示。\n\n```python\n<td>{{ **infor.updatetime|date:\"Y-m-d H:i:s\" **}}</td>\n```\n\n### 布尔类型\n\n- BooleanField(Field)：布尔值类型\n- NullBooleanField(Field)：可以为空的布尔值类型\n\n### 枚举类型\n\n```python\nchoice=(\n        (1,\'male\'),\n        (2,\'female\'),\n        (3,\'other\')\n    )\nlover=models.IntegerField(choices=choice) #枚举类型\n\n# 在数据库存储枚举类型，比外键有什么优势？\n1、无需连表查询性能高一些，省硬盘空间(选项不固定时用外键)\n2、在model文件里不能动态增加（选项一成不变用Django的choice），选项固定的时候可以使用枚举，如果需要动态增加的时候建议使用外键。\n3、在Django Admin中可以直接结合枚举生效，生成下拉框。\n```\n\n### 二进制类型\n\n- BinaryField(Field)：二进制类型\n\n## Model中的其他参数\n\n```python\n# 字段参数\nnull                数据库中字段是否可以为空\ndb_column           数据库中字段的列名\ndefault             数据库中字段的默认值\nprimary_key         数据库中字段是否为主键\ndb_index            数据库中字段是否可以建立索引\nunique              数据库中字段是否可以建立唯一索引\nunique_for_date     数据库中字段【日期】部分是否可以建立唯一索引\nunique_for_month    数据库中字段【月】部分是否可以建立唯一索引\nunique_for_year     数据库中字段【年】部分是否可以建立唯一索引\n\n# 设置是否为空，设置默认值\nxxx = models.CharField.(max_length=32, null=True, default=\'111\')\nxxx = models.CharField.(max_length=32, db_index=True, unique=True)\n# unique_for_month,unique_for_day,unique_for_year，指定日期类型中的哪一端为索引，在数据库中我们添加索引的时候可以指定prefix长度为多少，这里可以指定年月日。\nxxx = models.DateTimeField(null=True, unique_for_data=True)\n\n# 联合唯一索引\nclass Meta:\n\tunique_together = (\n \t\t(\'email\',\'ctime\'),\n\t)\n    \n# 联合索引，不唯一（不做限制）\n\tindex_together = (\n\t\t(\'email\',\'ctime\'),\n\t)\n    \n# 联合唯一约束\nclass Love(models.Model):\n    b = models.ForeignKey(\'Boy\')\n    g = models.ForeignKey(\'Girl\')\n    \n    class Meta:\n        unique_together = [\n            (\'b\',\'g\'),\n        ]\n```\n\n### 元数据中可以填些啥？\n\n> 官方参考：https://docs.djangoproject.com/en/1.10/ref/models/options/\n\n```python\nclass UserInfo(models.Model):\n    nid = models.AutoField(primary_key=True)\n    username = models.CharField(max_length=32)\n    class Meta:\n        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名\n        db_table = \"table_name\"\n\n        # 联合索引\n        index_together = [\n            (\"pub_date\", \"deadline\"),\n        ]\n\n        # 联合唯一索引\n        unique_together = ((\"driver\", \"restaurant\"),)\n\n        # admin中显示的表名称\n        verbose_name\n\n        # verbose_name加s\n        verbose_name_plural\n```\n\n## 模型类在数据库中的对照参考\n\n```python\n# 以下为Django模型创建的字段值，在数据库中的属性体现\n\n\'AutoField\': \'integer AUTO_INCREMENT\',\n\'BigAutoField\': \'bigint AUTO_INCREMENT\',\n # 只能存储字节数据，无法作为过滤选项\n\'BinaryField\': \'longblob\',\n\'BooleanField\': \'bool\',\n\'CharField\': \'varchar(%(max_length)s)\',\n # 存储由逗号分隔的数字，实质为字符串\n\'CommaSeparatedIntegerField\': \'varchar(%(max_length)s)\',\n\'DateField\': \'date\',\n\'DateTimeField\': \'datetime\',\n\'DecimalField\': \'numeric(%(max_digits)s, %(decimal_places)s)\',\n\'DurationField\': \'bigint\',\n\'FileField\': \'varchar(%(max_length)s)\',\n\'FilePathField\': \'varchar(%(max_length)s)\',\n\'FloatField\': \'double precision\',\n\'IntegerField\': \'integer\',\n\'BigIntegerField\': \'bigint\',\n\'IPAddressField\': \'char(15)\',\n\'GenericIPAddressField\': \'char(39)\',\n\'NullBooleanField\': \'bool\',\n\'OneToOneField\': \'integer\',\n\'PositiveIntegerField\': \'integer UNSIGNED\',\n\'PositiveSmallIntegerField\': \'smallint UNSIGNED\',\n\'SlugField\': \'varchar(%(max_length)s)\',\n\'SmallIntegerField\': \'smallint\',\n\'TextField\': \'longtext\',\n\'TimeField\': \'time\',\n\'UUIDField\': \'char(32)\',\n```","timestamp":1523930994994},{"name":"03-表间关系.md","path":"06-Django/03-Django ORM/03-表间关系.md","content":"# 表与表之间的关系\n\n>- 一对多：当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）\n>  *例如：创建用户信息时候，需要选择一个用户类型【普通用户】【金牌用户】【铂金用户】等。*\n>- 多对多：在某表中创建一行数据是，有一个可以多选的下拉框\n>  *例如：创建用户信息，需要为用户指定多个爱好*\n>- 一对一：在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了\n>  *例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据*\n\n- 一对一：OneToOneField\n- 一对多（多对一）：ForeignKey\n- 多对多：ManyToManyField\n\n## 表间关系说明\n\n### 一对多（ForeignKey）\n\n创建测试表，然后用Django Admin创建点测试数据：\n\n```python\nclass UserType(models.Model):\n    caption = models.CharField(max_length=32)\n\n    def __str__(self):\n        return self.caption\n\n\nclass UserInfo(models.Model):\n    username = models.CharField(max_length=32)\n    age = models.IntegerField()\n    user_type = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.username\n```\n\n比如现在我要从UserInfo表跨表去查拿到用户所属的用户分类的分类名称，我可以这样取：\n\n```python\nobj = models.UserInfo.objects.filter(username=\'马晓雨\').values(\'id\', \'username\', \'user_type__caption\')\n```\n\n通过UserInfo表去跨表找到对应分类的用户：\n\n```python\nobj = models.UserInfo.objects.filter(user_type__caption=\'2B用户\')\n```\n\n上面都是在查的时候直接跨表，通过用户对象跨表就不使用双下划线的写法了，直接使用“.”：\n\n```python\n# 注意是通过设置的外键跳过去的。\nobj = models.UserInfo.objects.filter(username=\'马晓雨\').first()\nprint(obj.user_type.caption)\n```\n\n而且也可以通过UserType进行逆向查询：\n\n```python\nobj = models.UserType.objects.filter(userinfo__username=\'齐茂森\')\nprint(obj)\n\n# 使用表名_set的前提是拿到一个UserType的对象才会有userinfo_set的方法\n# obj2.userinfo_set拿到的是一个relatemanager对象\nobj2 = models.UserType.objects.filter(caption=\'2B用户\').first()\nprint(obj2.userinfo_set.all())\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 字段以及相关参数\n\n```python\nForeignKey(ForeignObject) # ForeignObject(RelatedField)\n        to,               # 要进行关联的表名，这个默认可以不写，直接写个表名就是to=\'表名\'\n        to_field=None,    # 要关联的表中的字段名称，默认关联到主键字段。\n        on_delete=None,   # 当删除关联表中的数据时，当前表与其关联的行的行为，下面是其他属性值\n            - models.CASCADE，删除关联数据，与之关联也删除\n            - models.DO_NOTHING，删除关联数据，引发错误IntegrityError\n            - models.PROTECT，删除关联数据，引发错误ProtectedError\n            - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）\n            - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）\n            - models.SET，删除关联数据，\n                a. 与之关联的值设置为指定值，设置：models.SET(值)\n                b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)\n                Example：\n                    def func():\n                        return 10\n\n                    class MyModel(models.Model):\n                        user = models.ForeignKey(\n                                   to=\"User\",\n                                   to_field=\"id\"\n                                   on_delete=models.SET(func),\n                        )\n        related_name=None,  # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\n        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(\'表名__字段名\')\n        limit_choices_to=None, # 在Admin或ModelForm中显示关联数据时，提供的条件：\n                               # 如：\n                                   - limit_choices_to={\'nid__gt\': 5}\n                                   - limit_choices_to=lambda : {\'nid__gt\': 5}\n\n                                   from django.db.models import Q\n                                   - limit_choices_to=Q(nid__gt=10)\n                                   - limit_choices_to=Q(nid=8) | Q(nid__gt=10)\n                                   - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption=\'root\')\n        db_constraint=True          # 是否在数据库中创建外键约束\n        parent_link=False           # 在Admin中是否显示关联数据\n\n\nOneToOneField(ForeignKey)\n        to,                         # 要进行关联的表名\n        to_field=None               # 要关联的表中的字段名称\n        on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为\n\n                                    ###### 对于一对一 ######\n                                    # 1. 一对一其实就是 一对多 + 唯一索引\n                                    # 2. 当两个类之间有继承关系时，默认会创建一个一对一字段\n                                    # 如下会在A表中额外增加一个c_ptr_id列且唯一：\n                                    class C(models.Model):\n                                        nid = models.AutoField(primary_key=True)\n                                        part = models.CharField(max_length=12)\n\n                                    class A(C):\n                                        id = models.AutoField(primary_key=True)\n                                        code = models.CharField(max_length=1)\n\nManyToManyField(RelatedField)\n        to,                         # 要进行关联的表名\n        related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()\n        related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(\'表名__字段名\')\n        limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：\n                                    # 如：\n                                            - limit_choices_to={\'nid__gt\': 5}\n                                            - limit_choices_to=lambda : {\'nid__gt\': 5}\n\n                                            from django.db.models import Q\n                                            - limit_choices_to=Q(nid__gt=10)\n                                            - limit_choices_to=Q(nid=8) | Q(nid__gt=10)\n                                            - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption=\'root\')\n        symmetrical=None,           # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段\n                                    # 做如下操作时，不同的symmetrical会有不同的可选字段\n                                        models.BB.objects.filter(...)\n\n                                        # 可选字段有：code, id, m1\n                                            class BB(models.Model):\n\n                                            code = models.CharField(max_length=12)\n                                            m1 = models.ManyToManyField(\'self\',symmetrical=True)\n\n                                        # 可选字段有: bb, code, id, m1\n                                            class BB(models.Model):\n\n                                            code = models.CharField(max_length=12)\n                                            m1 = models.ManyToManyField(\'self\',symmetrical=False)\n\n        through=None,               # 自定义第三张表时，使用字段用于指定关系表\n        through_fields=None,        # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表\n                                        from django.db import models\n\n                                        class Person(models.Model):\n                                            name = models.CharField(max_length=50)\n\n                                        class Group(models.Model):\n                                            name = models.CharField(max_length=128)\n                                            members = models.ManyToManyField(\n                                                Person,\n                                                through=\'Membership\',\n                                                through_fields=(\'group\', \'person\'),\n                                            )\n\nclass Membership(models.Model):\n    group = models.ForeignKey(Group, on_delete=models.CASCADE)\n    person = models.ForeignKey(Person, on_delete=models.CASCADE)\n    inviter = models.ForeignKey(\n          Person,\n                                                on_delete=models.CASCADE,\n                                                related_name=\"membership_invites\",\n                                            )\n                                            invite_reason = models.CharField(max_length=64)\n        db_constraint=True,         # 是否在数据库中创建外键约束\n        db_table=None,              # 默认创建第三张表时，数据库中表的名称\n```\n\n\n\n## 针对Django Admin生效的参数\n\n有一些Django提供的字段模型比如EmailField或者IPAddressField等都可以在Django Admin中提供字段验证的功能（Module Form也可以生效），但是这些功能对于直接create创建添加并不会起到验证的效果。\n\n如何在Django Admin中注册我们自己的模型类：\n\n```python\n# 在我们自己创建的app下的admin.py中进行注册\nfrom django.contrib import admin\nfrom backend import models\nadmin.site.register(models.DjangoAdmin_test)\n```\n\n再次查看后台主界面的时候就会发现我们注册的表已经添加进去了：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-31/33506367.jpg)\n\n点击Django admin_tests，进入到内部，点击右上方的ADD Django ADMIN_TEST我们其实就可以向绑定的这个表内添加数据了。在这里我们就可以看到Django提供的那些特殊字段的验证效果了，比如EmailField会验证是不是邮箱。\n\n- FileFeild()：在Django Admin中会变成上传的组件\n\n- DateTimeField()：时间类型，可以传入2017-10-11类似的。\n\n- 枚举类型，Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作，体现出来就是一个下拉菜单。如果不在Django Admin中使用的话，我们自己通过for循环取也是完全没有问题的。\n\n  ```python\n  # example1：\n  color_list = (\n      (1, \'black\'),\n      (2, \'white\'),\n      (3, \'blue\')\n  )\n  color = models.IntegerField(choices=color_list)\n\n  # example2：\n  gf = models.IntegerField(choices=[(0, \'何穗\'),(1, \'大表姐\'),],default=1)\n  ```\n\n- verbose_name：Admin中显示的字段名称，或者说使用model组件的时候显示的名称\n\n- blank：Admin中是否允许用户输入为空。\n\n- editable：Admin中是否可以编辑，如果为false你在页面上就直接看不到了。\n\n- help_text：Admin中显示该字段的提示信息\n\n- error_messages：自定义错误信息（字典类型），从而定制想要显示的错误信息；结合validators使用。\n\n  ```python\n  # 这个error_messages优先级是比较低的。错误信息会在Module Form中找的。\n  字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date                        如：{\'null\': \"不能为空.\", \'invalid\': \'格式错误\'}\n  ```\n\n- validators：自定义错误验证（列表类型），从而定制想要的验证规则\n\n  ```python\n  from django.core.validators import RegexValidator\n  from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\\                      MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator\n  # 如：\n  test = models.CharField(\n  \tmax_length=32,\n      error_messages={\n          # 这里的错误信息会优先于下面的validators中的错误进行显示。\n      \t\'c1\': \'优先错信息1\',\n          \'c2\': \'优先错信息2\',\n          \'c3\': \'优先错信息3\',\n      },\n      validators=[\n           RegexValidator(regex=\'root_\\d+\', message=\'错误了\', code=\'c1\'),\n           RegexValidator(regex=\'root_112233\\d+\', message=\'又错误了\', code=\'c2\'),\n           EmailValidator(message=\'又错误了\', code=\'c3\'), ]\n  )\n  ```\n\n\n\n\n#### \n\n小结：\n\n- Django Admin定制型太强，一般不会用很多，或者根本不用\n\n\n\n\n\n```python\n# ########### 基础函数 ###########\n\n    # 1. Concat，用于做类型转换\n    # v = models.UserInfo.objects.annotate(c=Cast(\'pwd\', FloatField()))\n\n    # 2. Coalesce，从前向后，查询第一个不为空的值\n    # v = models.UserInfo.objects.annotate(c=Coalesce(\'name\', \'pwd\'))\n    \"\"\"\n    上面内容的意思是，新加一列列名为c，当查询到每一行数据的时候如果name部位空，那么c这一列就为name，如果name为空，那么c就为pwd\n    \"\"\"\n    # v = models.UserInfo.objects.annotate(c=Coalesce(Value(\'666\'),\'name\', \'pwd\'))\n\n    # 3. Concat，拼接\n    # models.UserInfo.objects.update(name=Concat(\'name\', \'pwd\'))\n    \"\"\"如果要加单纯的字符串而不是字段的话需要用value渲染一下\"\"\"\n    # models.UserInfo.objects.update(name=Concat(\'name\', Value(\'666\')))\n    # models.UserInfo.objects.update(name=Concat(\'name\', Value(\'666\'),Value(\'999\')))\n\n    # 4.ConcatPair，拼接（仅两个参数）\n    # v = models.UserInfo.objects.annotate(c=ConcatPair(\'name\', \'pwd\'))\n    # v = models.UserInfo.objects.annotate(c=ConcatPair(\'name\', Value(\'666\')))\n\n    # 5.Greatest，获取比较大的值;least 获取比较小的值;\n    # v = models.UserInfo.objects.annotate(c=Greatest(\'id\', \'pwd\',output_field=FloatField()))\n\n    # 6.Length，获取长度\n    # v = models.UserInfo.objects.annotate(c=Length(\'name\'))\n\n    # 7. Lower,Upper,变大小写\n    # v = models.UserInfo.objects.annotate(c=Lower(\'name\'))\n    # v = models.UserInfo.objects.annotate(c=Upper(\'name\'))\n\n    # 8. Now，获取当前时间\n    # v = models.UserInfo.objects.annotate(c=Now())\n\n    # 9. substr，子序列\n    # 取name字段，第一个1是起始位置，2表示取多长的长度\n    # v = models.UserInfo.objects.annotate(c=Substr(\'name\',1,2))\n    # 下面是在数据库实际的操作，可以使用v.query查看。\n    select *,Concat(\'nid\',\'title\') from table_name \n\n    # ########### 时间类函数 ###########\n    # 1. 时间截取，不保留其他：Extract, ExtractDay, ExtractHour, ExtractMinute, ExtractMonth,ExtractSecond, ExtractWeekDay, ExtractYear,\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractYear(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractMonth(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.ExtractDay(\'ctime\'))\n    #\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'year\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'month\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Extract(\'ctime\', \'year_month\'))\n    \"\"\"\n    MICROSECOND\n    SECOND\n    MINUTE\n    HOUR\n    DAY\n    WEEK\n    MONTH\n    QUARTER\n    YEAR\n    SECOND_MICROSECOND\n    MINUTE_MICROSECOND\n    MINUTE_SECOND\n    HOUR_MICROSECOND\n    HOUR_SECOND\n    HOUR_MINUTE\n    DAY_MICROSECOND\n    DAY_SECOND\n    DAY_MINUTE\n    DAY_HOUR\n    YEAR_MONTH\n    \"\"\"\n\n    # 2. 时间截图，保留其他：Trunc, TruncDate, TruncDay,TruncHour, TruncMinute, TruncMonth, TruncSecond, TruncYear\n    # v = models.UserInfo.objects.annotate(c=functions.TruncHour(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.TruncDate(\'ctime\'))\n    # v = models.UserInfo.objects.annotate(c=functions.Trunc(\'ctime\',\'year\'))\n```\n\n自定义Func\n\n```python\nfrom django.db.models.functions.base import Func\nclass CustomFunc(Func):\n    function = \'DATE_FORMAT\'\n    \n    template = \'%(function)s(%(exporessions)s,%(format)s)\'\n    \n    def __init__(self, expression, **extra):\n        expressions = [expression]\n        super(CustomFunc, self).__init__(*expressions, ** extra)\n        \nCustomFunc(\'create_time\', \'%Y-%m\')\n# DATE_FORMAT(\'create_time\',\'%Y-%m\')\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-6/17906939.jpg)\n\n### 多对多\n\n> 比如一个老师可以任教多个班级，一个班级可以被多个老师任教，这就是一个多对多的关系\n\n```python\nclass Class(models.Model):\n    name = models.CharField(max_length=32, verbose_name=\"班级名\")\n    course = models.CharField(verbose_name=\"课程\", max_length=32)\n\n    def __str__(self):\n        return self.name\n\n\nclass Teacher(models.Model):\n    name = models.CharField(max_length=23, verbose_name=\"姓名\")\n    classes = models.ManyToManyField(verbose_name=\"所属班级\", to=\"Class\")\n\n    def __str__(self):\n        return self.name\n```\n\n针对多对多的关系就可以直接使用ManyToManyField进行声明。Django会为我们分别生成appname_class和appname_teacher这两个表，其中appname指的是你的app的名称。但是并不会在你的teacher的表中生成classes这么一个字段，而是单独的为你创建一个class和teacher的关系表。\n\n不过这个m2m的表只会为你创建三个字段，一个id，还有两个字段分别关联到class的主键字段和teacher的主键字段，如果我们还有其他的需求的话，这个Django默认是无法为我们完成的。因此这个表我们也可以自己进行定义的。\n\n\n\n\n\n## 多对多关系\n\nDjango自动生成多对多关联表：\n\n```python\nclass Boy(models.Model):\n    name = models.CharField(max_length=32)\n    # 为你生成一张多对多的关联表，表名app_boy_m\n    m = models.ManyToManyField(\'Girl\')\n    \n# 但是这张表是django为我们生成的，models里没有模型的定义，那么该如何操作呢？\n# 答案是无法直接对第三张表操作，但是可以通过这个m进行间接的操作。\n\nobj = models.Boy.objects.filter(name=\'user1\').first()\nobj.m.add(xxx)\nobj.m.add(xxx,xxx)\nobj.m.add(*list)\n# 删数据\nobj.m.remove(xxx)\nobj.m.remove(xxx,xxx)\nobj.m.remove(*list)\n# 修改，传值传入一个列表，set会进行重置。\nobj.m.set([1,])\n# 获取，因为没有第三张表的类定义，因为返回的内容并不是关系表的对象，而是关联表的对象\n# 比如A表和B关联，C表示A和B的关系表，通过A.m.all()这个取出来的不是c的对象而是B的对象\nobj.m.all()\n# 还可以进行二次筛选 obj.m.filter(xxx=xxx)\n# 删除\nobj.m.clear()\n# 逆向查找，关系表在Boy表中定义的，那么如何在Girl的对象中拿到呢？\nobj = models.Girl.objects.filter(nick=\'小鱼\').first\n# 可以使用_set进行逆向查找，这个下划线set同样有all，filter，add等操作\nobj.boy_set.all()\n\n# ManyToMany自动生成的关系表只能有三列，如果要有其他的列的时候，就得自己写了。\n# 比如男女相亲，还要记录相亲时间等等其他的字段这个就超出了Django默认能做的范畴了。\n# 所以到底选用什么方法要根据自己的需要进行选择，推荐自己去写，相对来讲更灵活。\n```\n\n如果说manytomany也用了，也自己定义了关系表了，那么按照原则来讲，Django会替我们创建一张关系表。我们可以通过配置让着两种用法同事存在并且不创建新表，让Django默认我们创建的就是那张关系表。\n\n```python\n# 这样可以用之前提到的manytomany的obj.m.clear()属性和obj.m.all()属性，其他的不能用\nclass Boy(models.Model):\n    name = models.CharField(max_length=32)\n    m = models.ManyToManyField(\"Girl\", through=\"Love\", through_fields=(\'b\',\'g\'))\n```\n\n","timestamp":1523930994994},{"name":"04-ORM数据操作.md","path":"06-Django/03-Django ORM/04-ORM数据操作.md","content":"# Django数据操作\n\n## 增&删&改\n\n针对于增删改来讲，相对来说是很简单的，\n\n```python\nfrom app01 import models\n\n# 增加数据\nmodels.UserGroup.objects.create(title=\'销售部\')\nmodels.UserInfo.objects.create(x,x,x,ut_id=1) # 虽然外键是ut，但是在数据表中生成的是ut_id\n\n# 使用字典形式添加数据\nuser_dict = {\"name\": \"chenchao\", \"age\": \"18\", \"user_type_id\": 1}\nmodels.UserInfo.objects.create(**user_dict)\n\n# 通过传递对象的方式添加数据，这里的ut就是我们添加的外键而不是表中实际的字段，实际字段为ut_id\nuser_type_obj = models.UserType.objects.get(id=1)   #先获取外键表中的数据对象\nuser_dict = {\"username\": \"chenchao\", \"age\": \"18\", \"ut\": user_type_obj} # 对象传入字典\nuser_type_obj.save() 或者 models.UserType.objects.create(**user_dict)\n或者\nobj = models.UserInfo(name=\'lamber\',age=15,ut_id=\'2\')\nobj.save()\n\nmodels.UserInfo.objects.create(**user_dict)\n\n# 删除\nmodels.UserGroup.objects.filter(id=2).delete()\n\n# 更新\nmodels.UserGroup.objects.filter(id=2).update(title=\'new_str\')\nmodels.UserGroup.objects.filter(id=2).update(**dict)\n```\n\n## 查\n\n查表的其实也是数据库里比较麻烦的，对应到orm操作内容也就相对来讲多一些。在查询的时候需要铭记于心的就是下面的两条：\n\n- **在联表操作过滤查找数据时用双下划线 \"__\"**\n- **在取数据时用点 \".\"**\n\n### 简单的查询\n\n```python\n# 简单的查\nret = models.UserGroup.objects.all().first()\nret = models.UserGroup.objects.all()\n- 返回的也是一个结果集（QuerySet），结果集我们可以看做是一个列表。列表中的每一个数据数一个数据对象。可以使用对应的对象.属性的方法去调用属性值。形如：\n<QuerySet [<Class: Class object (1)>, <Class: Class object (2)>, <Class: Class object (3)>, <Class: Class object (4)>, <Class: Class object (5)>]>\n\nQuerySet特点：\n<1>  可迭代的 \n<2>  可切片\n- books=models.Book.objects.all()[:10]  #切片 应用分页\n- books = models.Book.objects.all()[::2]\n- book= models.Book.objects.all()[6]    #索引\n<3>  惰性计算和缓存机制\n- 所谓惰性计算，就是查询返回的QuerySet（查询结果集对象），它并不会马上执行sql，而是当调用QuerySet的时候才执行。相当于一个生成器，不应用返回的Query_Set不会执行任何SQL操作。\n- query_set缓存机制：1次数据库查询结果query_set都会对应一块缓存，再次使用该query_set时，不会发生新的SQL操作；这样减小了频繁操作数据库给数据库带来的压力;\n\n# 取个数\nret = models.UserGroup.objects.all().count()\n\n# 根据查询方式的不同，返回的数据类型也是不一样的\n返回对象对象 UserInfo.objects.all()\n返回字典 UserInfo.objects.values(\"name\",\"age\").all()\n返回元组 User.objects.values_list(\"name\",\"age\").all()\n\n# 如果取出来的数据太大的话有可能会撑爆内存，这个时候只要迭代器就可以优雅的解决这个问题\nret = models.UserInfo.objects.all().iterator()\n```\n\n### 带条件的查询：\n\n如果没查到数据的话会返回一个空的Query_set（列表）\n\n```python\n# where条件，条件之间默认是and关系，下面这个就是相当于where id=1 and title=\'xx\'\nret = models.UserGroup.objects.filter(id=1,title=xx)\n\n# where条件大于和小于1，我们可以使用带双下划线的操作来获取(__gt&__lt)\nret = models.UserGroup.objects.filter(id__gt=1)\nret = models.UserGroup.objects.filter(id__lt=1)\n\n# 根据字典去过滤\ncondition = {\n    \'id\': 1,\n    \'name\': lamber\n}\nmodels.UserInfo.objects.filter(**condition)\n```\n\n### 联表\n\n多表连接操作涉及到多种对应关系，比如一对多，多对多等。首先看一个简单的例子：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-1-26/80257083.jpg)\n\n```python\n# Create your models here.\nclass UserType(models.Model):\n    \"\"\"用户类型\"\"\"\n    title = models.CharField(max_length=32)\n\n\nclass Userinfo(models.Model):\n    \"\"\"用户表\"\"\"\n    name = models.CharField(max_length=16)\n    age = models.IntegerField()\n    ut = models.ForeignKey(\'UserType\', on_delete=models.CASCADE)\n```\n\n#### 通过外键正向联表查找\n\n```python\n# foreign key 就代指对应关联表的一行数据，如下是在取数据的时候才跨表查询数据   \nresult = models.Userinfo.objects.all()\nfor user in result:\n    print(user.id, user.name, user.age, user.ut_id, user.ut.title)\n    \n# 在取数据的时候跨表查询数据，记住这种双下划线的使用方法。不同于在查的时候跨表\nmodels.Userinfo.objects.all.values(\'id\',\'name\', \'ut__title\')\n    \n# userinfo表里有一个外键叫ut，虽然生成的字段叫ut_id，但是可以直接调用ut，ut代表的是usertype里的一行数据，因此可以直接通过“.”把属性获取到，借由这个特性，我们可以横跨多张表。这个跨表操作是django帮我们做的。假如说我们这里的usertyle还有一个和其他表的外键关联，那么我们还可以继续多张表关联。比如\n\n现在有三张表A，B，C\nA有一个外键b指向B表的id\nb = models.ForeignKey(\'B\', on_delete=models.CASCADE)\nB有一个外键c指向C表的id\nc = models.ForeignKey(\'C\', on_delete=models.CASCADE)\n那么按照说的，A表实际生成的是一个叫b_id的字段，B表实际生成的是一个c_id的字段\n\n外键分别为b何c，根据上面的结论，我们创建的外键其实指代的就是指向表的一行数据，那么我们可以通过A表跨到C表去查数据：\nret = models.A.objects.all().first()\n那么我就可以这样取到C表的数据，假设C表有一个字段叫column_c\nret2 = ret.b.c.column_c   # 这样就可以获取到我们想要的数据了。\n\n# 在filter中也是可以进行跨表的，正向跨表实例：\nmodels.UserInfo.objects.filter(\'ut__title=\'超级用户\').values(\'id\', \'name\', \'ut__title\')\n```\n\n**Tip**\n\n```python\n# 这里有一个需要注意的点，在 Django 2.0 后，models.ForeignKey() 函数 和 models.OneToOneField() 中的 on_delete 参数不再默认为 CASCADE ，而是必须参数，因此在用：\n\nut = models.ForeignKey(\'UserType\')\n\n# 这样写的时候是会直接报错的，会报错说少一个参数，但是在django2.0之前是没有问题的。\n```\n\n#### 逆向查找\n\n```python\n# 如果有人和我做了外键，纵使我这边看不见，但是仍然是有一个隐含的字段。比如我userinfo和我usertype字段做了外键，我usertype是看不到的，但是会有一个隐含的字段，如下：\nobj = models.UserType.objects.all().first()  # 获取一个usertype的对象\nprint(obj.id, obj.title)\nfor row in obj.userinfo_set.all():  # 通过usertype的对象去逆向的查userinfo的数据\n  # 每一个row是一个userinfo对象，这里其实就是把type=obj.title的所有用户取出来了\n  print(row.name, row.age)\n  \n# 含表名小写_set.all()，反向操作。针对反向操作，我们还可以进行过滤等其他的操作\nobj.userinfo_set.all().filter(age__gt=20)\n\n# 在取的时候逆向查找。相当于UserType left join Userinfo谁在前面以谁为准，这就和left join让谁在前面一样，根据自己的需求去选择。跨表字段是小写的表名进行跨表。重要！！！\n# 如果要取表的字段可以使用双下划线，比如：userinfo__name\nret = models.UserType.objects.values(\'id\', \'title\', \'userinfo\')\n- 我们可以打开django的sql执行日志，看看sql内部执行了什么：\nSELECT `app_usertype`.`id`, `app_usertype`.`title`, `app_userinfo`.`name` FROM `app_usertype` LEFT OUTER JOIN `app_userinfo` ON (`app_usertype`.`id` = `app_userinfo`.`ut_id`);\n\n# 使用filter实现反向跨表\n# 在filter中也是可以进行跨表的，正向跨表实例：\nmodels.UserType.objects.filter(\'userinfo__name=\'lamber\').values(\'id\', \'title\', \'userinfo__name\')\n```\n\n### 其他查询操作\n\n首先来讲我们查询到的如果返回的是一个query_set的话里面的内容其实是一个一个的对象，但是我们并不知道这些里面是什么内容，因此我们可以改写一下models模型类，比如：\n\n```python\nclass Class(models.Model):\n\n    title = models.CharField(max_length=255)\n    \n    def __str__(self):  ## 如果是python2的话要协程__unicode__\n        return self.title\n# 这个时候我们再去排查的时候，比如print一下返回的return值就可以大概了解都是什么内容了，其实这个还可以根据我们的需求进行深度的定制，显示更加全面的信息，比如查询班级表中的所有内容：\n<QuerySet [<Class: 全栈4期>, <Class: 全栈5期>, <Class: php培训班>, <Class: java培训班>, <Class: mysql实战班>]>\n```\n\n#### order by\n\n```python\n# 按照id排序，从小到大\nmodels.UserInfo.objects.all().order_by(\'id\')\n# 按照id逆向排序\nmodels.UserInfo.objects.all().order_by(\'-id\')\n# 多个条件判定排序，先按照id从大到小，再按照name从小到大\nmodels.UserInfo.objects.all().order_by(\'-id\', \'name\')\n```\n\n#### 分组\n\n```python\nfrom django.db.models import Count, Sum, Max, Min\nret = models.UserInfo.objects.values(\'ut_id\').annotate(xxx=Count(\'id\'))\nprint(ret.query)   # 查看生成的sql语句\n# select “app_userinfo”.\"ut_id\",COUNT(\"app_userinfo\".\"id\") as xxx FROM \"app_userinfo\" GROUP BY \"app_userinfo\".\"ut_id\"\n简单来说就是不加annotate的话前面的语句就是直接select ut_id from userinfo，如果加上了annotate的话，那么values的内容即使group by的条件，后面的xxx是select count(app_userinfo.id)的别名。\n\n# having的使用，filter在annotate之前就是where，在annotate之后就是having\nret = models.UserInfo.objects.values(\'ut_id\').annotate(xxx=Count(\'id\')).filter(xxx__gt=2)\n```\n\n#### 其他\n\n```python\nmodels.UserInfo.objects.filter(id__gt=1) # 大于1\nmodels.UserInfo.objects.filter(id__lt=1) # 小于1\nmodels.UserInfo.objects.filter(id__gte=1) # 大于等于1\nmodels.UserInfo.objects.filter(id__lte=1) # 小于等于1\nmodels.UserInfo.objects.exclude(id=1)   # id不等于1\nmodels.UserInfo.objects.filter(id__in=[1,2,3]) # where in\nmodels.UserInfo.objects.filter(id__range=[1,2]) # 范围\nmodels.UserInfo.objects.filter(name__startswith=\'xxx\') # startwith\nmodels.UserInfo.objects.filter(name__endswith=\'xxx\')  # endwith\nmodels.UserInfo.objects.filter(name__contains=\'xxx\')  # 包含\nmodels.UserInfo.objects.filter(name__isnull=True)  # 判断是否为空\n```\n\n## Django中神奇的F和Q\n\n### 神奇的F\n\n```python\nfrom django.db.models import F\n\n# 比如我要把用户表的age字段的所有年龄自加一，F可以让你获取基础值\nmodels.UserInfo.objects.all().update(age=F(\'age\')+1)\n```\n\n### 神奇的Q\n\nQ可以用于构造复杂的查询条件\n\n```python\nfrom django.db.models import Q\n# 一个Q对象就是一个条件\nmodels.Userinfo.objects.filter(Q(id=1))\n# 多个Q对象实现或(or)的关系\nmodels.Userinfo.objects.filter(Q(id=1) | Q(id=2))\n# 多个Q对象实现与(and)的关系\nmodels.Userinfo.objects.filter(Q(id=1) & Q(id=2))\n\n# 第二种q的用法\ncon = Q()\nq1 = Q()\nq1.connector = \'OR\'  # q1的内部条件是什么，OR就是用或来连接，AND就是与\nq1.children.append((\'id\', 1)) # 通过append来添加不同的条件按照如上的条件进行or\nq1.children.append((\'id\', 10))\nq1.children.append((\'id\', 9))\nq2 = Q()\nq2.connector = \'OR\'\nq2.children.append((\'c1\', 1))\nq2.children.append((\'c1\', 10))\nq2.children.append((\'c1\', 9))\ncon.add(q1, \'AND\')   # 将q1和q2通过AND将两个大条件连接起来\ncon.add(q2, \'AND\')\n# 相当于\n(id=1 or id=10 or id=9) and (c1=1 or c1=10 or c1=9)\n# 按照上面的条件进行筛选\nmodels.Table_class.objects.filter(con)\n```\n\n这个可以应对来自前端页面传递过来的复杂查询：\n\n```python\n# 比如前端有很多条件要进行匹配查询，我们可以在前端把对应的数据拼成一个字典格式的json传递过来\n# 每一个大的过滤条件是一个key+value\ncondition_dict = {\n    \'k1\': [1,2,3,4],\n    \'k2\':[1,],\n}\ncon = Q()\nfor k, v in condition_dict.items():\n    q = Q()\n    # 每一个大条件之间的条件用or来匹配\n    q.connector = \'OR\'\n    for i in v:\n        q.children.appeend((\'id\', i))\n    # 大条件之前用AND来匹配，根据自己的需要。\n    con.add(q, \'AND\')\nmodels.UserInfo.objects.filter(con)\n```\n\n## Extra\n\n> 在使用mysql的时候经常会出现使用临时表的语句，比如：\n>\n> ```mysql\n> select id,name,(select count(1) from app_usertype where id>1) as count) from app_userinfo;\n> ```\n>\n> 这种临时表在ORM的操作中也是可以实现的，就是使用extra。\n>\n> 额外查询条件及相关表操作\n\n使用extra添加额外的查询，其中字典中的key n可以充当我们取出来的内容\n\n```python\n# select_params中的是按位置一个一个占位的。\nret = models.UserInfo.objects.all().extra(\n    select={\n        \'n\': \"select count(1) from app_usertype where id>%s and id < %s\",\n        \'m\': \"select count(1) from app_usertype where id>%s and id < %s\",\n    },\n    select_params=[1,3,4,6],\n)\n\nfor obj in ret:\n    print(obj.id, obj.name, obj.n)\n```\n\nextra中还可以使用where：\n\n```python\n# where后面接一个列表，列表中的元素以and连接\nmodels.UserInfo.objects.extra(\n    where=[\"id=1\",\"name=\'alex\'\"]\n)\n\n# 列表中的每个元素内部可以用or\nmodels.UserInfo.objects.extra(\n    where=[\"id=1 or id=%s\",\"name=%s\"],\n    params=[1,\'alex\']\n)\n```\n\ntables的应用\n\n```python\n# 相当于笛卡尔积:select * from app_userinfo,app_usertype\nmodels.UserInfo.objects.extra(\n    tables=[\'app_usertype\'],\n)\n\n# 使用where条件:select * from app_userinfo,app_usertype where app_usertype.id=app_userinfo.ut_id\nmodels.UserInfo.objects.extra(\n    tables=[\'app_usertype\'],\n    where=[\'app_usertype.id = app_userinfo.ut_id\']\n)\n```\n\n排序的使用：\n\n```python\n# 按照nid倒序排\nmodels.UserInfo.objects.extra(select={\'new_id\': \"select id from tb where id > %s\"}, select_params=(1,), order_by=[\'-nid\'])\n```\n\n当然上面四中条件还是可以混在一起写的：\n\n```python\nmodels.UserInfo.objects.extra(\n    select={\'newid\':select count(1) from tb1 where id>%s},\n    select_params=[1,],\n    where=[\'age>%s\'],\n    params=[18,],\n    order_by=[\'-age\',],\n    tables=[\'app_usertype\']\n)\n转换为sql以后就是如下的内容：\n\"\"\"\nselect \n\tapp_userinfo.id,  # 隐含的会取到\n\t(select count(1) from tb1 where id>1) as newid\nfrom app_userinfo,app_usertype\n\twhere \n\t\tapp_userinfo.age>18\n\torder_by\n\t\tapp_userinfo.age desc\n\t\n\"\"\"\n```\n\n## 执行原生SQL\n\n针对非常复杂的sql，django orm也是支持使用原生sql的。\n\n```python\nfrom django.db import connection, connections\n\ncursor = connection.cursor()\ncursor.execute(\'sql语句，和pymysql一样\')\nrow = cursor.fetchall()   # fetchall也有\nconnection.close()\n\n# 我们还可以使用connections去创建cursor\ncursor = connections[\'db_setting_name\'].cursor()\n\n# 在connections中可以填一个db设置的名称，这个设置的名称就是在配置文件中DATABASE部分设置的字典的key，如果存在多个数据库的话，那么我们可以配置连接不同的数据库。只要填上不同的db的配置文件的key就可以了。默认的就是default的数据。\nDATABASES = {\n    \'default\': {\n        \'ENGINE\': \'django.db.backends.mysql\',\n        \'NAME\': \'django_test\',\n        \'USER\': \'lamber\',\n        \'PASSWORD\': \'13082171785\',\n        \'HOST\': \'47.94.132.15\',\n        \'PORT\': \'3306\',\n    }\n    \'db2\': {\n\t\t……………………\n    }\n}\n\n比如：cursor = connections[\'db2\'].cursor()\n```\n\n## Django ORM细节梳理\n\n```python\n##################################################################\n# PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #\n##################################################################\n\ndef all(self)\n    # 获取所有的数据对象\n\ndef filter(self, *args, **kwargs)\n    # 条件查询\n    # 条件可以是：参数，字典，Q\n\ndef exclude(self, *args, **kwargs)\n    # 条件查询\n    # 条件可以是：参数，字典，Q\n\ndef select_related(self, *fields)\n     # 性能相关：表之间进行join连表操作，一次性获取关联的数据。\n     model.tb.objects.all().select_related()\n     # 会把外键字段关联的表连起来去取，相当于两个表inner join，相当于一次性查询到\n     # 如果外键存在多个的话用逗号分隔，比如select_related(\'fk1\',\'fk2\')\n     # 避免发起多次查询请求。\n     # select * from tb1 inner join tb2 on ……\n     # 有Foreign Key数据较少的时候，联表性能下降也不是很大，就可以使用这个\n     model.tb.objects.all().select_related(\'外键字段\')\n     model.tb.objects.all().select_related(\'外键字段__外键字段\')\n\ndef prefetch_related(self, *lookups)\n    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。\n    # 不做联表，多次查询\n    # 获取所有用户表\n    # 获取用户类型表where id in (用户表中的查到的所有用户ID)\n    # select * from UserInfo;\n    # Django内部：把这张表的所有\"外键字段_id\"去重，然后取到\n    # 第二次查询：select * from user_type where id in 上面取到的外键字段的id。\n    # Django会将这两个结果集整合到一起\n    # 有外键，数据很多，查询次数频繁就可以用这个。进行单表查询提高性能。\n    models.UserInfo.objects.prefetch_related(\'外键字段\')\n\n\n\n    from django.db.models import Count, Case, When, IntegerField\n    Article.objects.annotate(\n        numviews=Count(Case(\n            When(readership__what_time__lt=treshold, then=1),\n            output_field=CharField(),\n        ))\n    )\n\n    students = Student.objects.all().annotate(num_excused_absences=models.Sum(\n                models.Case(\n                    models.When(absence__type=\'Excused\', then=1),\n                default=0,\n                output_field=models.IntegerField()\n            )))\n\ndef annotate(self, *args, **kwargs)\n    # 用于实现聚合group by查询\n\n    from django.db.models import Count, Avg, Max, Min, Sum\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\'))\n    # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\')).filter(uid__gt=1)\n    # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1\n\n    v = models.UserInfo.objects.values(\'u_id\').annotate(uid=Count(\'u_id\',distinct=True)).filter(uid__gt=1)\n    # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1\n\ndef distinct(self, *field_names)\n    # 用于distinct去重，在不同的数据源上用法不一样\n    # 比如mysql或者sqlite是不能传递参数的。\n    # 如果使用的是PG(PostGreSQL)就要这么写：\n    # models.UserInfo.objects.distinct(\'nid\')\n    \n    models.UserInfo.objects.values(\'nid\').distinct()\n    # select distinct nid from userinfo\n\n    注：只有在PostgreSQL中才能使用distinct进行去重\n\ndef order_by(self, *field_names)\n    # 用于排序\n    models.UserInfo.objects.all().order_by(\'-id\',\'age\')\n\ndef extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)\n    # 构造额外的查询条件或者映射，如：子查询\n\n    Entry.objects.extra(select={\'new_id\': \"select col from sometable where othercol > %s\"}, select_params=(1,))\n    Entry.objects.extra(where=[\'headline=%s\'], params=[\'Lennon\'])\n    Entry.objects.extra(where=[\"foo=\'a\' OR bar = \'a\'\", \"baz = \'a\'\"])\n    Entry.objects.extra(select={\'new_id\': \"select id from tb where id > %s\"}, select_params=(1,), order_by=[\'-nid\'])\n\n def reverse(self):\n    # 倒序，只有前面有order_by的时候，reverse才有用。reverse会反转order_by的所有条件\n    # 比如order_by(\'-col1\',\'col2\')，反转以后就是order_by(\'col1\',\'-col2\')\n    models.UserInfo.objects.all().order_by(\'-nid\').reverse()\n    # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序\n\n\n def defer(self, *fields):\n    models.UserInfo.objects.defer(\'username\',\'id\')\n    或\n    models.UserInfo.objects.filter(...).defer(\'username\',\'id\')\n    #映射中排除某列数据，如上即取除了username和id以外的数据。主键一定会取的。所以写不写无所谓\n\n def only(self, *fields):\n    #仅取某个表中的数据\n     models.UserInfo.objects.only(\'username\',\'id\')\n     或\n     models.UserInfo.objects.filter(...).only(\'username\',\'id\')\n     等价于：\n\t models.UserInfo.objects.filter(...).values(\'username\',\'id\')\n     # 只不过返回的依然是一个对象而不是一个元组，这个是和values不一样的地方\n     # 当然返回的obj依然可以用“.”去访问我们取的之外的字段，但是会引发新的sql查询\n     # 因此当使用only的时候你取谁了，就用谁，不要多余的去访问其他的字段属性，会造成额外查询降低sql的性能。不要多拿，要是多拿还不如不写，或者你干脆多取就的了。\n       \n def using(self, alias):\n     # 指定使用的数据库，参数为别名（setting中的设置，事先得有这个表。\n     models.UserInfo.objects().all.using(\'db2\')\n\n\n##################################################\n# PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #\n##################################################\n\ndef raw(self, raw_query, params=None, translations=None, using=None):\n    # 执行原生SQL，返回的内容是userinfo的对象\n    models.UserInfo.objects.raw(\'select * from userinfo\')\n\n    # 如果SQL是其他表时，必须将列名字设置为当前UserInfo对象的主键列名\n    models.UserInfo.objects.raw(\'select id as nid from 其他表\')\n\n    # 为原生SQL设置参数\n    models.UserInfo.objects.raw(\'select id as nid from userinfo where nid>%s\', params=[12,])\n\n    # 将获取的到列名转换为指定列名\n    name_map = {\'first\': \'first_name\', \'last\': \'last_name\', \'bd\': \'birth_date\', \'pk\': \'id\'}\n    # 相当于first as first_name;last as last_name\n    Person.objects.raw(\'SELECT * FROM some_other_table\', translations=name_map)\n\n    # 指定数据库\n    models.UserInfo.objects.raw(\'select * from userinfo\', using=\"default\")\n\n    ################### 原生SQL ###################\n    from django.db import connection, connections\n    cursor = connection.cursor()  # cursor = connections[\'default\'].cursor()\n    cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1])\n    row = cursor.fetchone() # fetchall()/fetchmany(..)\n\n\ndef values(self, *fields):\n    # 获取每行数据为字典格式\n\ndef values_list(self, *fields, **kwargs):\n    # 获取每行数据为元祖\n\ndef dates(self, field_name, kind, order=\'ASC\'):\n    # 根据时间进行某一部分进行去重查找并截取指定内容\n    # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日）\n    # order只能是：\"ASC\"  \"DESC\"\n    # 并获取转换后的时间\n        - year : 年-01-01\n        - month: 年-月-01\n        - day  : 年-月-日\n\t# ctime字段名，day上面的格式（只能写上面三个），desc倒序。\n    models.DatePlus.objects.dates(\'ctime\',\'day\',\'DESC\')\n\ndef datetimes(self, field_name, kind, order=\'ASC\', tzinfo=None):\n    # field name就是时间字段\n    # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间\n    # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"\n    # order只能是：\"ASC\"  \"DESC\"\n    # tzinfo时区对象\n    models.DDD.objects.datetimes(\'ctime\',\'hour\',tzinfo=pytz.UTC)\n    models.DDD.objects.datetimes(\'ctime\',\'hour\',tzinfo=pytz.timezone(\'Asia/Shanghai\'))\n\n    \"\"\"\n    # 时区的转换需要安装这个模块\n    pip3 install pytz\n    import pytz\n    pytz.all_timezones\n    pytz.timezone(‘Asia/Shanghai’)\n    \"\"\"\n\ndef none(self):\n    # 空QuerySet对象，什么都不取。\n\n\n####################################\n# METHODS THAT DO DATABASE QUERIES #\n####################################\n\ndef aggregate(self, *args, **kwargs):\n   # 聚合函数，获取字典类型聚合结果\n   # 计算整个表的聚合结果(分组)\n   from django.db.models import Count, Avg, Max, Min, Sum\n   # 如果包含distinct的话会先进行去重，然后再进行聚合\n   result = models.UserInfo.objects.aggregate(k=Count(\'ut_id\', distinct=True), n=Count(\'nid\'))\n   ===> {\'k\': 3, \'n\': 4}\n\ndef count(self):\n   # 获取个数\n\ndef get(self, *args, **kwargs):\n   # 获取单个对象\n   models.UserInfo.objects.get(id=1)\n\ndef create(self, **kwargs):\n   # 创建对象，会有一个返回值，这个返回值就是增加的这条数据\n   obj = models.UsetType.objects.create(title=\'xxx\')\n   obj = models.UsetType.objects.create(**dict_data)\n  \n   # 使用save提交\n   obj = models.UserType(title=\'xxx\')\n   obj.save()\n\ndef bulk_create(self, objs, batch_size=None):\n    # 批量插入\n    # batch_size表示一次插入的个数\n    objs = [\n        models.DDD(name=\'r11\'),\n        models.DDD(name=\'r22\')\n    ]\n    # 这里的10指的是一次最多提交10个对象，最多不要超过999\n    models.DDD.objects.bulk_create(objs, 10)\n\ndef get_or_create(self, defaults=None, **kwargs):\n    # 如果存在，则获取，否则，创建\n    # defaults 指定创建时，其他字段的值\n    # 如果能找到username=root1的，那么就直接返回对象，忽略后面的参数。\n    # 否则就创建，并按照defaults中的内容填充其他字段数据。\n    # obj返回查询的对象，created返回创建的结果，返回true或者false\n    obj, created = models.UserInfo.objects.get_or_create(username=\'root1\', defaults={\'email\': \'1111111\',\'u_id\': 2, \'t_id\': 2})\n\ndef update_or_create(self, defaults=None, **kwargs):\n    # 如果存在，则更新，否则，创建\n    # defaults 指定创建时或更新时的其他字段\n    obj, created = models.UserInfo.objects.update_or_create(username=\'root1\', defaults={\'email\': \'1111111\',\'u_id\': 2, \'t_id\': 1})\n\ndef first(self):\n   # 获取第一个\n\ndef last(self):\n   # 获取最后一个\n\ndef in_bulk(self, id_list=None):\n   # 根据主键ID进行查找，相当于in操作。不同于__in的就是是根据主键查找\n   id_list = [11,21,31]\n   models.DDD.objects.in_bulk(id_list)\n\ndef delete(self):\n   # 删除\n\ndef update(self, **kwargs):\n    # 更新\n\ndef exists(self):\n   # 是否有结果\n```\n\n## 总结\n\nDjango执行原生sql的三种方法：\n\n- 原生sql\n- extra\n- raw","timestamp":1523930994994},{"name":"04-Django 中间件.md","path":"06-Django/04-Django 中间件.md","content":"","timestamp":1523930994994},{"name":"01-01-Form组件.md","path":"06-Django/05-Django Form/01-01-Form组件.md","content":"# Form组件\n\n>Form组件能为我们做什么呢？\n>\n>- 根据用户请求对数据做验证\n>- 根据用户的输入还可以输出对应的错误信息\n>- 获取到数据然后进行验证，验证通过后对正确的信息进行打包并提交。\n>- 保留上一次的输入内容\n>- Form组件还可以创建HTML标签，通过挂件指定样式。\n>\n>在数据库操作之前进行一些规则的验证。\n\n问题：\n\n- 无法记住上次提交的内容，因此页面刷新数据消失\n- 重复的进行用户数据的校验：正则，长度，是否为空。\n\n## Form组件的简单实用\n\n### 定义组件\n\n```python\n# 首先简单定义一个Form组件，用于登录验证\n# 我们在app下新建一个form.py文件用于我们定义的Form验证规则\nfrom django.forms import fields, Form\n\nclass LoginForm(Form):\n    username = fields.CharField(\n        max_length=18,\n        min_length=6,\n        required=True,\n    )\n    password = fields.CharField(\n        max_length=16,\n        min_length=6,\n        required=True\n    )\n```\n\n### 组件的应用\n\n```python\n# 在views视图中直接调用，直接添加一个url路由用于匹配\nform main import form\n\ndef login(request):\n    if request.method == \'GET\':\n        # 当我直接访问的时候就直接返回登录页面\n        return render(request, \'login.html\')\n    else:\n        # 生成一个LoginForm的对象，要将用户在前端输入的账号密码传入\n        obj = form.LoginForm(request.POST)\n        # 调用对象的is_vaild方法进行规则的校验\n        # 返回值为True or False，因此直接调用is_valid()就可以\n        # 这个是由Django内部提供的一个验证机制。\n        if obj.is_valid():\n            # obj.cleaned_data是一个字典，就是验证通过后，用户提交的数据\n            # 这样如果遇到注册的时候创建用户直接使用create(**kwargs)就行了\n            print(obj.cleaned_data)\n            # 我们先让他说验证规则通过以后重定向到百度\n            return redirect(\'https://www.baidu.com\')\n        else:\n            # 如果验证不通过应该打印错误信息，Django内部也为我们提供了这种机制。\n            # obj.errors是所有的错误信息\n            # 这是一个对象，但是内部有一个__str__方法因此我们看到的是一大串html字符串\n            print(obj.errors)\n            print(obj.errors[\'username\'])\n            # 错误可以是存在多个的\n            # 拿多个错误信息的第一个，只要错误信息没满足就有问题，我们永远拿第一个就行了\n            print(obj.errors[\'password\'][0])\n            return render(request, \'login.html\', {\n                \'obj\': obj\n            })\n```\n\n假如说没有满足验证规则的话就会进行报错，报错的内容如下：\n\n```html\n# 这个是obj.errors的内容，这里包含了所有的错误信息。\n# 本身这是一个对象，但是因为实现了__str__方法因此我们可以看到一大堆的字符串。\n<ul class=\"errorlist\">\n    <li>\n        username\n        <ul class=\"errorlist\">\n            <li>Ensure this value has at least 6 characters (it has 1).</li>\t\t</ul>\n    </li>\n    <li>password\n        <ul class=\"errorlist\">\n            <li>Ensure this value has at least 6 characters (it has 2).</li>\t\t</ul>\n    </li>\n</ul>\n```\n\n同样我们可以使用`obj.errors[\'username\']`单独拿某一个name属性的报错。\n\n```html\n<ul class=\"errorlist\">\n    <li>Ensure this value has at least 6 characters (it has 1).</li>\n</ul>\n```\n\n对应的前端界面如下：\n\n```html\n<form  method=\"post\">\n    {% csrf_token %}\n    <p>用户名：<input type=\"text\" name=\"username\" />{{ obj.errors.username }}</p>\n    <p>密码：<input type=\"password\" name=\"password\" />{{ obj.errors.password }}</p>\n    <p><input type=\"submit\" value=\"提交\"></p>\n</form>\n```\n\n效果如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-26/5961066.jpg)\n\n#### 自定义错误信息\n\n通过上图可以发现，这个报错是英文的，那么可不可以进行自定义呢？当然是可以的。\n\n```python\n# 修改我们的form文件\nclass LoginForm(Form):\n    username = fields.CharField(\n        max_length=18,\n        min_length=6,\n        required=True,\n        error_messages={\n            \'required\': \'不能为空\',\n            \'min_length\': \'太短了！\',\n            \'max_length\': \'太长了！！！！\',\n        }\n    )\n    password = fields.CharField(\n        max_length=16,\n        required=True,\n        min_length=6,\n    )\n```\n\n添加上error_message参数就可以了，error_message对应的是一个字典，key是对应的我们添加的约束项目，比如min_length最小长度，max_length最大长度啊，required是否必填不能为空什么的，对应的value就是要报错的值，这样的话就可以将原来的内容替换成我们想写的内容了。\n\n一般来说，如果格式不对的话对应的error_message的key是`invalid`，针对其他的fields还有其他的属性，比如数字Integer属性，有数字的最大值`max_value`，最小值`min_value`等一些特殊的属于自己的属性。具体的可以参考下面的Django Form字段属性。\n\n\n\n\n\n### Django Form字段属性\n\n> 针对Django Form中不同的类型都有什么属性，比如Integer和CharField都是继承fields，因此它们都可以使用fields中的属性，emailField继承自CharField，那么它也可以把CharField中的属性继承下来，我们知道EmailField本质其实就是CharField。IntegerField会主动的调用父类的构造方法，CharField也是。如下，可以看到IntegerField主动的去调用父类的Field了，父类的构造方法还有一堆参数。\n>\n> ```python\n> def __init__(self, *, max_value=None, min_value=None, **kwargs):\n>     self.max_value, self.min_value = max_value, min_value\n>     if kwargs.get(\'localize\') and self.widget == NumberInput:\n>         # Localized number input is not well supported on most browsers\n>         kwargs.setdefault(\'widget\', super().widget)\n>     super().__init__(**kwargs)\n> ```\n>\n> 具体都有什么属性可以查看下面的内容\n\n- fields\n\n  ```python\n  required=True,               是否允许为空，默认的都是True，可以不用写\n  widget=None,                 HTML插件\n  label=None,                  用于生成Label标签或显示内容\n  initial=None,                初始值\n  help_text=\'\',                帮助信息(在标签旁边显示)\n  error_messages=None,         错误信息 {\'required\': \'不能为空\', \'invalid\': \'格式错误\'}\n  show_hidden_initial=False,   是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直）\n  validators=[],               自定义验证规则，在原有的规则上继续添加正则\n  localize=False,              是否支持本地化，比如时间的时区。\n  disabled=False,              是否可以编辑\n  label_suffix=None            Label内容后缀\n\n\n\n  ---------------------------------------\n  URLField(Field)\n  BooleanField(Field)  \n  NullBooleanField(BooleanField)\n  ```\n\n- charfield\n\n  ```python\n  max_length=None,             最大长度\n  min_length=None,             最小长度\n  strip=True                   是否移除用户输入空白，strip属性是默认的，默认为true。\n\n\n  ---------------------------------------\n  UUIDField(CharField)           uuid类型\n  SlugField(CharField)           数字，字母，下划线，减号（连字符）\n  ```\n\n- IntegerField\n\n  ```python\n  max_value=None,              最大值\n  min_value=None,              最小值\n\n  # FloatField(IntegerField)\n  ```\n\n- DecimalField(IntegerField)\n\n  ```python\n  max_value=None,              最大值\n  min_value=None,              最小值\n  max_digits=None,             总长度\n  decimal_places=None,         小数位长度\n  ```\n\n- BaseTemporalField(Field)\n\n  ```python\n  input_formats=None          时间格式化\n\n  ---------------------------------------\n  DateField(BaseTemporalField)    格式：2015-09-01\n  TimeField(BaseTemporalField)    格式：11:12\n  DateTimeField(BaseTemporalField)格式：2015-09-01 11:12\n  ```\n\n- DurationField(Field)            时间间隔：%d %H:%M:%S.%f\n\n- RegexField(CharField)    如果提供的不够用，支持自己书写正则表达式\n\n  ```python\n  regex,                      自定制正则表达式\n  max_length=None,            最大长度\n  min_length=None,            最小长度\n  error_message=None,         忽略，错误信息使用 error_messages={\'invalid\': \'...\'}\n\n  举例子：\n  # regexfield继承charfield，可以使用是否为空，最长最短，还有自己写的，一共4种\n  t = fields.RegexField(\'139\\d+\', error_messages={\'invalid\': \'格式错误\'})\n  ```\n\n- EmailField(CharField)\n\n- FileField(Field)              \n\n  ```python\n  allow_empty_file=False     是否允许空文件\n  ```\n\n- ImageField(FileField) \n\n  ```python\n  注：需要PIL模块，pip3 install Pillow\n  以上两个字典使用时，需要注意两点：\n      - form表单中 enctype=\"multipart/form-data\"\n      - view函数中 obj = MyForm(request.POST, request.FILES)\n  ```\n\n- ChoiceField(Field)\n\n  ```python\n  choices=(),                选项，如：choices = ((0,\'上海\'),(1,\'北京\'),)\n  required=True,             是否必填\n  widget=None,               插件，默认select插件\n  label=None,                Label内容\n  initial=None,              初始值\n  help_text=\'\',              帮助提示\n\n\n  ---------------------------------------\n  MultipleChoiceField(ChoiceField)\n  ```\n\n- ModelChoiceField(ChoiceField)\n\n  ```python\n  ...                        django.forms.models.ModelChoiceField\n  queryset,                  # 查询数据库中的数据\n  empty_label=\"---------\",   # 默认空显示内容\n  to_field_name=None,        # HTML中value的值对应的字段\n  limit_choices_to=None      # ModelForm中对queryset二次筛选\n  ```\n\n- ModelMultipleChoiceField(ModelChoiceField)\n\n  ```python\n  ...                        django.forms.models.ModelMultipleChoiceField\n  ```\n\n- TypedChoiceField(ChoiceField)\n\n  ```python\n  coerce = lambda val: val   对选中的值进行一次转换\n  empty_value= \'\'            空值的默认值\n  ```\n\n- TypedMultipleChoiceField(MultipleChoiceField)\n\n  ```python\n  coerce = lambda val: val   对选中的每一个值进行一次转换\n  empty_value= \'\'            空值的默认值\n  ```\n\n- ComboField(Field)，多个验证规则组合\n\n  ```python\n  fields=()                  \n  # 使用多个验证，如下：即验证最大长度20，又验证邮箱格式\n  fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])\n  ```\n\n- MultiValueField(Field)\n\n  ```python\n  PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用\n  ```\n\n- SplitDateTimeField(MultiValueField)\n\n  ```python\n  input_date_formats=None,   格式列表：[\'%Y--%m--%d\', \'%m%d/%Y\', \'%m/%d/%y\']\n  input_time_formats=None    格式列表：[\'%H:%M:%S\', \'%H:%M:%S.%f\', \'%H:%M\']\n  ```\n\n- FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中\n\n  ```python\n  path,                      文件夹路径\n  match=None,                正则匹配\n  recursive=False,           递归下面的文件夹\n  allow_files=True,          允许文件\n  allow_folders=False,       允许文件夹\n  required=True,\n  widget=None,\n  label=None,\n  initial=None,\n  help_text=\'\'\n  ```\n\n- GenericIPAddressField\n\n  ```python\n  protocol=\'both\',           both,ipv4,ipv6支持的IP格式\n  unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，\n              \t\t\t   可解析为192.0.2.1， PS：protocol必须为both才能启用\n  ```\n\n### 数据的提交\n\n#### Form提交\n\n> Form表单自身会刷新页面，因此提交的信息如果有误的话是不会被保留的\n\n#### Ajax提交\n\n> 页面不会刷新，偷偷的给服务器传递数据。上次内容自动保留，可以手动js刷新\n\n这里把提交按钮替换成一个a标签，然后出发一个onclick事件去提交：\n\n```html\n<form id=\"f1\" method=\"post\">\n    {% csrf_token %}\n    <p>用户名：<input type=\"text\" name=\"username\" />{{ obj.errors.username }}</p>\n    <p>密码：<input type=\"password\" name=\"password\" />{{ obj.errors.password }}</p>\n    <p><a onclick=\"submitForm();\">提交</a></p>\n</form>\n```\n\n对应的Js方法：\n\n```javascript\n# 引入Jquery\n<script src=\"/static/js/jquery-3.2.1.min.js\"></script>\n<script>\n    function submitForm() {\n    \t# 在执行这个方法开始将标签的样式还原\n        $(\'.c1\').remove();\n        $.ajax({\n            # 提交的地址，这个要在django的路由中加上\n            url: \"/ajax_login/\",\n            # 提交方式为POST\n            type: \'POST\',\n            # 通过上面的表单可以看到我们提交的内容有三个，用户名，密码，还有csrf_token\n            # 通过serialize方法可以获取打包后的数据将我们要提交的数据一起打包\n            # 打包后的格式为：“user=xxx&pwd=xxx&csrf_token=xxx”的字符串\n            data: $(\'#f1\').serialize(), \n            # 预期服务器返回的数据类型，我们返回类型为JSON\n            dataType: \"JSON\",\n            success: function (arg) {\n                if(arg.status){\n\n                }else{\n                    # 如果说验证失败其实是会返回错误的，如果username和password都有问题\n                    # 那么就是返回两个，如果其中有一个有问题就是返回一个，因此一个两个不确定\n                    # 为了处理这个问题，我们对返回的数据进行遍历\n                    $.each(arg.msg, function(index, value){\n                        console.log(index, value);\n            \t\t\t# 创建一个span标签\n                        var tag = document.createElement(\'span\');\n                        # 设置span标签的值为对应的报错信息\n                        tag.innerHTML = value[0];\n            \t\t\t# 在设置的时候设置一个类，用于重置显示内容\n                        # 因为页面没刷新，如果不做这个操作，每次触发onclick事件\n                        # 会不断的在后面添加内容。\n                        tag.className = \'c1\';\n            \t\t\t# 在form中找到属性name为对应的“index”属性的标签，在它后面加上tag\n                        # 这里用到了字符串的拼接。拼接结果为\"input[name=\"username\"]\"样\n                        $(\'#f1\').find(\'input[name=\"\' + index + \'\"]\').after(tag)\n                    })\n                }\n            }\n\n        })\n    }\n</script>\n```\n\n后端处理视图函数：\n\n```python\ndef ajax_login(request):\n    ret = {\n        \'status\': True,\n        \'msg\': None\n    }\n    if request.method == \"POST\":\n        obj = form.LoginForm(request.POST)\n        if obj.is_valid():\n            print(obj.cleaned_data)\n        else:\n            print(obj.errors)\n            ret[\'status\'] = False\n            ret[\'msg\'] = obj.errors\n    # 记得导入json模块\n    v = json.dumps(ret)\n    # return render(request, )\n    return HttpResponse(v)\n```\n\n#### 到底使用哪一种？\n\n> 今后两个一般只会用到一个\n\n- Ajax：仅用作验证功能（get+ajax）\n- Form：验证功能，生成HTML标签（get+post）。\n\n## 使用Form生成HTML\n\n#### 简单实现\n\n> widget,label,disabled,label_suffix,initial,help_text其实是放在一起使用的，他可以帮你自动生成html标签。\n\n先写一个测试的form类：\n\n```python\n# 实质就是返回fields.CharField内部的__str__方法返回一串html代码字符串\nclass TestForm(Form):\n    t1 = fields.CharField(\n        max_length=10,\n        required=True,\n        label=\"用户名\",\n        help_text=\"我是这个输入框的帮助信息\",\n        initial=\'666\',\n    )\n```\n\n然后在视图函数中调用\n\n```python\ndef testform(request):\n    if request.method == \"GET\":\n        obj = form.TestForm()\n        return render(request, \'testform.html\', {\n            \'obj\': obj,\n        })\n    else:\n        pass\n```\n\n在前端视图模板中进行调用：\n\n```html\n<form method=\"post\" id=\"f1\">\n    {% csrf_token %}\n    {{ obj.t1.label }}\n    {{ obj.t1 }}\n    {{ obj.t1.help_text }}\n    <input type=\"submit\">\n</form>\n```\n\n在前端界面就会生成如下的input输入框，这个就是form为我们生成的。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-3-27/6070256.jpg)\n\n其实比起上面的这种调用方式还有一种更为简单的调用方式：\n\n```python\n# 这种方式的实现原理是去对象把所有的字段找到，然后生成html标签。这种方法其实不太灵活\n{{ obj.as_p }}\n{{ obj.as_ul }}\n{{ obj.as_table }}\n\n使用ul的时候记得在外层套一个ul标签，生成table的时候在外面套一个table标签\n这俩内容只生成标签内部的东西。\n```\n\n两种方法都可以使用，一个简单，一个控制灵活，因此如果真要用的话建议使用控制更为灵活的。范例如下\n\n```python\nlabel = \'xxxxx\'\n\n<form method=\"POST\" enctype=\"multipart/form-data\">\n    {% csrf_token %}\n    \n        {{ form.xxoo.label }} # 可以把class中定义的label内容显示出来\n        {{ form.xxoo.id_for_label }}\n        {{ form.xxoo.label_tag }}\n        {{ form.xxoo.errors }}\n        <p>{{ form.user }} {{ form.user.errors }}</p>\n        <input type=\"submit\" />\n</form>\n```\n\n#### 保存用户上次生成的数据\n\n```python\ndef testform(request):\n    if request.method == \"GET\":\n        # 在这里生成的是一个不带value值的input标签\n        obj = form.TestForm()\n        return render(request, \'testform.html\', {\'obj\': obj,})\n    else:\n        # 先别管用户数据对不对，用户提交的数据肯定是过来了\n        # 那么就会生成一个input标签带着value值，值为用户输入的值。\n        obj = form.TestForm(request.POST)\n        if obj.is_valid():\n            # 数据验证部分\n            print(obj.cleaned_data)\n        else:\n            print(obj.errors)\n        return render(request, \'testform.html\', {\'obj\': obj})\n```\n\nForm生成html标签，单独使用意义不大，结合POST请求生成HTML标签更有意义。会携带value属性，带着数据。解决Form上次输入内容。\n\n#### widget挂件\n\n> 上面说了这么多，又有label，又有什么help_text，其实这一堆东西都是不建议使用，当然除了widget\n\n\n\n## Form表单内部实现原理\n\n### 简单实现原理\n\nfields本质就是验证规则，说验证规则实质就是正则表达式验证。可以说我们写的这个Form类似一个校验的模板。下面来看一下内部是如何实现验证的（is_valid的实现过程）。\n\n1. 每一次实例化Form组件类的时候，会先执行一个操作，就是把当前定义的字段放到self.fields中来。\n\n   ```python\n   # 实例化的时候：obj = LoginForm(request.POST)找到对应的Form组件类中的所有字段\n   # 把这些字段放到self.fields中\n   self.fields = {\n       \'username\': fields.CharField(xxxxx) # 正则表达式,\n       \'password\': 正则2\n   }\n   ```\n\n2. 循环self.fields：\n\n   ```python\n   flag = True\n   for k, v in self.fields.items():\n     # k就是每个name属性字段，比如username，password，v就是对应的正则表达式\n     # 获取到用户输入的内容\n     input_value = request.POST.get(k)\n     # 通过正则表达式和用户输入的内容按照正则表达式进行匹配。\n     # 如果说校验成功，就返回True的flag并发成功的数据放入到cleaned_data\n     # 如果说校验失败了，返回一个False的flag，并把数据放到errors\n     if not 正则校验，用re.match(xxxxx):\n    \tflag = False\n     return flag标志位\n   ```\n\n### 从源码角度看is_valid()的实现过程\n\n\n\n\n\n## 实际应用\n\n","timestamp":1523930994994},{"name":"07-Django模板.md","path":"06-Django/07-Django模板.md","content":"# Django中的模板\n\n> 为什么会有模板技术，即使没有模板我们也可以以字符串的形式将html代码嵌入到Python代码中去，但是考虑一下，这个明显是一个很麻烦的操作\n>\n> - 当改动的时候需要对Python代码进行改动\n> - Python和HTML前端是两种技术领域，应该有专业的技术去完成。耦合在一起明显加大了维护的难度。各司其职才是效率更高的体现。\n>\n> 也是因为如此，存在Django模版的技术，如下讲对Django的模板做简单的使用说明。\n\n## 1、特殊标记语言\n\n假如说我们在后台给前台render一段模板内容，第一个参数是request，第二个参数就是模板文件，第三个就是一个字典它可以结合模板语言去替换模板中的特殊标记的字符串。\n\n```python\nrender(request, \'login.html\', {\n    \'name\': \'lamber\',\n    # 在模板中取的时候用{{ users.1 }}这种形式，1表示索引值\n    \'users\': [\'user1\',\'user2\'],\n    # 取的时候直接{{ user_dict.k1 }}\n    \'user_dict\': {\'k1\':\'v1\',\'k2\':\'v2\'},\n    \'user_list_dict\': [\n        {\'id\':1, \'name\':\'alex\', \'email\':\'22222@q.com\'},\n        {\'id\':2, \'name\':\'alex2\', \'email\':\'22222@q.com\'},\n    ]\n})\n```\n\n那么现在我想要在前端把users这个key中的内容取出来应该使用什么方式去获取呢？\n\n```python\n# 在模板中使用for循环去取用users这个key的数据\n{% for item in users %}\n\t<h3>{{ item }}</h3>\n{% endfor %}\n这样的话在前段模板中就会显示两个html标签，分别为：\n<h3>user1</h3>\n<h3>user2</h3>\n\n# 或者嵌套进别的html标签中去写也是可以的。\n<ul>\n\t{% for item in users %}\n    <li>{{ item }}</li>\n    {% endfor %}\n</ul>\n\n# 针对这个列表形式的我们还可以使用索引去取数据，只不过取的时候形式和python的不太一样\n# 索引也是从0开始的\n<h1>{{ users.0 }}</h1>\n<h2>{{ users.1 }}</h2>\n\n# 直接调用字典里的内容。\n{% for i in userinfo.items %} # userinfo.keys,userinfo.values\nprint something\n{% endfor %}\n```\n\n上文中的这个item是一个变量，通过for循环去users中取出来的一个临时变量，想要使用变量的话可以使用双花括号的形式去调用，比如`{{ item }}`。值得注意的这个特殊标记有开始有结束，比如for循环，那么最后要有一个endfor标签作为结束，如果是if标签，要有一个endif作为结束。\n\n```python\n# 循环user_list_dict，直接使用\".\"去取嵌套字典中的每一个数据，这个也python也不一样。\n<table>\n\t{% for row in user_list_dict %}\n    <tr>\n    \t<td>{{ row.id }}</td>\n        <td>{{ row.name }}</td>\n        <td>{{ row.email }}</td>\n    </tr>\n    {% endfor %}\n</table>\n```\n\n我们在模板中还可以进行if判断\n\n```python\n{% if status %}\n    <h1>{{ users.0 }}</h1>\n{% else %}\n    <h1>{{ users.1 }}</h1>\n{% endif %}\n```\n\n**关于Request**\n\n其实我们在render一个界面的时候，会隐式的去传递一个request供我们去调用部分信息。比如我有一个界面我要登录，那么登录以后显示“您好，xxx”，这个xxx其实是保存在session中的一个字段，我们就可以这样去取用。\n\n```python\ndef login(request):\n    if request.method == \'GET\':\n        return render(request, \'login.html\')\n    else:\n        username = request.POST.get(\'username\')\n        password = request.POST.get(\'password\')\n        if username == \'lamber\' and password == \'12345\':\n            # 走到这里代表认证成功\n            request.session[\'username\'] = username\n            request.session[\'password\'] = password\n            return redirect(\'/admin/main/\')\n        else:\n            return render(request, \'login.html\', {\n                \'msg\': \'账号或者密码错误\',\n            })\n```\n\n模板对应的部分：\n\n```html\n<div id=\"header\">\n    欢迎您：{{ request.session.username }}\n</div>\n```\n\n## 2、母版\n\n其实就是把通用的部分写一遍就够了，其他地方在调用的时候直接继承一下就行了。比如我们说的后台里面有顶部导航栏，侧边栏，底部栏，但是内容区域的内容可能是不同的页面经常变化的，我们并不用每一次都把侧边栏，导航栏，底部栏重写一遍。\n\n**注意：一个子板只能有一个母版**\n\n```django\n# 我们设置一个通用页面，然后把变化的部分以一个block来封闭起来。\n{% block xx %}\n\t……………………各种变化的内容\n{% endblock %}\n```\n\n需要调用的时候直接使用\n\n```django\n# 先继承，在渲染的时候会先把公共部分extends过来，然后直接放到一起进行渲染\n{% extends \'layout.html\' %}\n\n{% block xx %}\n# 自己写模块，然后这个叫xx的block会集成到你的模板指定的位置。这个block也可以多加几个\n{% endblock %}\n```\n\n一般来讲会写三个block\n\n```html\n# 在head部分\n写一个block叫css\n\n# 内容部分\n写一个content是用来替换变化的内容的。\n\n# JS部分\n写一个block叫js模块，用来独立的调用某个页面的JS\n```\n\n目的是为了针对不同的部分做不同的css和js的区分，因为并不是一个css适用于所有的页面。母版里面应该放的内容是所有页面都要用的东西。\n\n## 3、模板中的函数\n\n在模板里面写上一个函数名是自动执行的，但是这个函数不能加参数，要加参数需要其他的操作去执行的。\n\n```jinja2\n# 这个upper实质上是一个带装饰器的函数，这个是由模板提供的函数\n{{ name|upper }}\n```\n\n这个当然是可以由我们自己来定义的，其中一种就叫simple_filter，另外一种叫做simple_tag。\n\n**自定义simple_filter**\n\n1. 在app中创建一个叫templatetags的模块（Python Package），名字必须是这个。\n\n2. 随便创建一个py文件，名字叫xx.py，自定义函数就放在这里。\n\n3. 写自定义函数\n\n   ```python\n   from django import template\n   register = template.Library()  # 这个是Django固定好的格式，必须这么写\n\n   @register.filter      # 只有加上这个装饰器才能在模板中使用\n   def my_upper(value):\n       return value.upper()\n   ```\n\n4. 在模板中使用\n\n   ```html\n   # 在页面顶部导入咱们自定义的内容\n   {% load xx %}\n   ```\n\n   模板中调用\n\n   ```python\n   {{ name|my_upper }}\n   ```\n\n5. settings中需要注册这个app才能够使用，不然无法使用。\n\n**如何给模板函数传递参数？**\n\n如果要给函数给传递多个参数的话要在函数后面用冒号接参数：\n\n```python\n{{ name|my_upper:\"666\" }}\n最多只支持两个参数，函数前面一个，后面一个，而且冒号不能有空格。不然会报错。\n```\n\n如果装饰器是simple_tag的话使用方法还不一样：\n\n```python\n@register.simple_tag      \ndef my_upper(value):\n    return value.upper()\n\n# 调用，这个是没有参数限制的。\n{% my_upper \"ALEX\" \"x\" \"SB\" \"V\" %}\n```\n\nfilter可以作为if的条件，但是simple_tag是无法作为if的条件语句\n\n```python\n{% if name|my_bool %}\n   <h3>hahah</h3>\n{% else %}\n   <h3>hehehehehe</h3>\n{% endif %}\n```\n\n反向生成URL就是使用的simple_tag的方法，因为参数无限制。一般情况下，filter用不到，所以作为了解就可以了。\n\n## 4、模板之Include\n\n> 模板之include，include单独的小组件。\n\n```python\n{% include \'pub.html\' %}\n```\n\n小组件和母版功能类似，但是又不一致。母版是用来继承的，而include是用来导入小组件的。同时小组件也是支持书写模板语言的。\n\ninclude会找到小组件把小组件的内容读取过来然后替换掉。因此这些模板语言也是支持的。比如我写了一个小模块，我在很多页面都用到了，那么我就可以直接把这个小页面或者说小模块单独拿过来在页面中引用。\n\n## 5、模板的简单实现原理：\n\n1. 创建一个 Template 对象，将模板代码放入一个 string 中作为参数。\n2. 调用模板(template)对象的 render() 方法，把一组变量作为上下文(context)传入。这么做将会把模板(template)展开，将所有变量(variables)和标签(tags)都赋予相应的值，并作为 string 返回。\n\n```python\n# 终端切换到项目目录下，在终端运行如下命令：\npython3 manage.py shell\n# 这个不要在终端直接引入，要通过manage.py，不然配置文件等相关内容不会被加载直接报错。\n# 或者直接在.bash_profile中手动添加 DJANGO_SETTINGS_MODULE这个环境变量，设为mysite.settings，前提是这个mysite的路径在环境变量里。\n>>> from django import template\n# 通过实例化创建一个Template的对象，构造函数接收一个参数，初始化模板代码\n>>> t = template.Template(\'My name is {{name}}\')\n>>> c = template.Context({\'name\':\'lamber\'})\n>>> print(t.render(c))\nMy name is lamber\n```","timestamp":1523930994994},{"name":"08-Cookie和Session.md","path":"06-Django/08-Cookie和Session.md","content":"# Cookie & Session\n\n## Cookie\n\n- cookie是保存在浏览器上的键值对。可以放多对，敏感信息不放在这里。\n- 服务端可以向用户浏览器端写cookie\n- 客户端每次发送请求的时候，会携带cookie去。Cookie是携带在请求头中的。\n- Cookie一般情况下是用来做用户登录的。\n- 在发送HTTP请求的时候，在请求中携带当前所有可访问的cookie\n\n首先去请求的cookie中获取凭证：tk\n\n```python\ntk = request.COOKIES.get(\'ticket\')\nif not tk:\n    return render(xxxxx)\n\n\n# 登录成功之后\n判断密码正确以后：\nobj = redirect(\'classes\')\n# obj = render(\'xxxxx\')\n# obj = HttpResponse(\'xxx\')\n# max_age 超时时间是10s,expires是具体的超时日期，和max_age二者择其一就可以\n# 推荐使用max_age\nfrom datetime import datatime, timedelta\nct = datetime.utcnow()\ninterval = timedelta(seconds=10)\nnew_time = ct + v\nobj.set_cookie(\'ticket\', \'xxxxxxx\', max_age = 10，expires=new_time, path=\'/\', domain=None, secure=False, httponly=\'False\')\n# path 可以指定cookie在某个指定url下使用，某些url下不使用。比如指定/classses/，那么其他的路径下就获取不到这个cookie了。默认是/也就是所有的url都能读取到。\n# domain表示指的是在访问某个域名的时候才能获取到这个cookie。默认就是当前域名，一般多用于SSO单点登录。\n# secure是给https提供的功能。如果是https网站要改为true\n# httponly表示只能自http请求中传入，js代码无法获取到。\nreturn obj\n\n在检查元素中的network 找到cookie就可以查看cookie的内容了\n\n\n```\n\nDjango扩展签名cookie\n\n```django\nobj.set_signed_cookie(\'ticket\', \'xxxx\', salt=\'jjjj\')\n\n# 读取的时候要按照如下的方式，下面获取到的内容是去掉签名的字符串\nrequest.get_signed_cookie(\'ticket\', salt=\'jjjj\')\n\n自定义加密方法，django默认不是走的md5：\nSIGNING_BACKEND = \'模块.定义类\'\n```\n\n\n\n装饰器实现cookie的判断\n\n```python\ndef get_cookie(*args, **kwargs):\n    def wrapper(func)\n    \n \n```\n\n作业：\n\n- 布局+代码\n- 登录cookie+装饰器实现登录\n- 布局页面的HTML+CSS\n\nCookie是什么？\n\n```\n保存在客户端浏览器上的键值对\n```\n\nSession\n\n```shell\n保存在服务器端的数据，本质也是键值对。\n应用：依赖cookie，因为给客户端的字符串是保存在cookie中的\n作用：会话保持(Web网站)\n好处：敏感信息不会直接给客户。\n\n用户信息保存在服务器端，以键值对形式，key为随机字符串，value为用户数据，仅给客户端发随机字符串。以后谁拉着随机字符串来，那么对应的值就可以取到。\n\n# 登录设置session\n1.生成随机字符串\n2.通过cookie发送给客户端\n3.服务端保存[随机字符串：{当前用户字典信息}]\nrequest.session[\'username\'] = \'alex\'  # 这一句话就上面三件事全做了。\nrequest.session[\'email\'] = \'1020561033@qq.com\'\n# 下面的这种写法可以针对不同种类的键值对进行分类\nrequest.session[\'userinfo\'] = {\n  \'user_id\': obj.id,\n  \'gender\': gender,\n  ……\n}\n对应的用户字典信息就生成了。\n\n那么程序里对应的内容放在哪里呢？\n在Django里默认没放在字典里，而是放在数据库表里，放到django_session这张表里了。\n对应的key就是生成的随机字符串，session_data就是键值对的value\nDjango内部针对这个value做了一个加密\n\n# 登录页判断(敏感信息不给用户，只给字符串，我再服务器想存什么就存什么)\n1、获取客户端cookie中的随机字符串  #Django内部帮你去cookie中取值了。\n2、去session中查找有没有对应的随机字符串\n3、去session对应的key的value中看看有没有对应的username\n\ndef index(request):\n\tv = request.session.get(\'username\')\n\tif v:\n\t\treturn HttpResponse(\'登录成功：%s\' %v)\n\telse:\n\t\treturn redirect(\'/login/\')\n```\n\n```\ndel request.session[\'k1\']\n这个删除的k1是cookie的随机字符串对应的session_data中的k1，而不是删除随机字符串。\n\ndef index(request):\n        # 获取、设置、删除Session中数据\n        request.session[\'k1\']\n        request.session.get(\'k1\',None)\n        request.session[\'k1\'] = 123\n        request.session.setdefault(\'k1\',123) # 存在则不设置\n        del request.session[\'k1\']\n \n        # 所有 键、值、键值对\n        request.session.keys()\n        request.session.values()\n        request.session.items()\n        request.session.iterkeys()\n        request.session.itervalues()\n        request.session.iteritems()\n \n \n        # 用户session的随机字符串\n        request.session.session_key\n \n        # 将所有Session失效日期小于当前日期的数据删除\n        request.session.clear_expired()\n \n        # 检查 用户session的随机字符串 在数据库中是否\n        request.session.exists(request.session.session_key)\n \n        # 删除当前用户的所有Session数据\n        request.session.delete(request.session.session_key)\n \n        request.session.set_expiry(value)\n            * 如果value是个整数，session会在些秒数后失效。\n            * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n            * 如果value是0,用户关闭浏览器session就会失效。\n            * 如果value是None,session会依赖全局session失效策略。\n```\n\n根据Django的规定，默认的情况下cookie会在浏览器保存两周\n\n```\na. 配置 settings.py\n \n    SESSION_ENGINE = \'django.contrib.sessions.backends.cache\'  # 引擎\n    SESSION_ENGINE = \'django.contrib.sessions.backends.db\'\n    SESSION_CACHE_ALIAS = \'default\'                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置\n \n \n    SESSION_COOKIE_NAME ＝ \"sessionid\"                        # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\n    SESSION_COOKIE_PATH ＝ \"/\"                                # Session的cookie保存的路径\n    SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名\n    SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie\n    SESSION_COOKIE_HTTPONLY = True                            \n    # 是否Session的cookie只支持http传输\n    \n    SESSION_COOKIE_AGE = 1209600                              \n    # Session的cookie失效日期（2周）\n    \n    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   \n    # 是否关闭浏览器使得Session过期\n    \n    SESSION_SAVE_EVERY_REQUEST = False                        \n    # 是否每次请求都保存Session，默认修改之后才保存\n    # False从一开始，这个时间段后超时。\n    # True每次请求都会计算，规定时间以内就不会超时。最好设置成True，让他每次都更新。\n    \n    \n    \n    \nSESSION_FILE_PATH = None\n# 如果缓存文件路径为None，那么就使用tempfile模块获取一个临时地址\n# tempfile.gettempdir()\n\nSESSION_ENGINE = \'django.crotrib.sessions.backends.signed_cookies\'\n这个不要用，这相当于给cookies加了个签名，相当于不用session了。\n\n\n```\n\nDjango指定session存放的位置，默认是存放在数据库。\n\n\n\n装饰器判断session存在不存在\n\n\n\n前端模板默认能拿到request这个模板变量\n\n比如：request.session.userinfo.nickname\n\n\n\n# 开工第一天\n\n```python\nfrom django.db import models\n\n\n# Create your models here.\nclass Boy(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n\n\nclass Girl(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n\n\nclass B2G(models.Model):\n    \"\"\"\n    默认情况下这个to是省略的，默认就是对应的表\n    默认情况下这个to_field也是省略的，默认就是id字段。\n    \"\"\"\n    b = models.ForeignKey(to=\'Boy\', to_field=\'id\', on_delete=models.CASCADE)\n    g = models.ForeignKey(to=\'Girl\', to_field=\'id\', on_delete=models.CASCADE)\n    \n当然这个是可以进行进一步优化的，男孩和女孩本质来讲其实都是用户，不需要拆开来看，只要构建一个新的用户表，加一个字段来控制性别就可以了。\ngender_choices = (\n\t(1, \'男\'),\n    (2, \'女\'),\n)\ngender = models.IntegerField(choices=gender_choices)\n\n比如：\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    gender_choices = (\n\t\t(1, \'男\'),\n    \t(2, \'女\'),\n\t)\n\tgender = models.IntegerField(choices=gender_choices)\n    \n    \nclass U2U(models.Model):\n  # related_query_name可以让对象在反向查找的时候不用表名而是使用a或者b。相当于a_set.all()\n  # 如果不带query，反向查找就不带set了，就是直接a.all()，b.all()\n  g = models.ForeignKey(\'Userinfo\', related_query_name=\'a\')\n  b = models.ForeignKey(\'UserInfo\', related_query_name=\'b\')\n  \n这个在添加数据的时候又两种写法\n1、在能获取明确的id的值的时候就可以这么用。\nmodels.U2U.objects.create(b_id=2, g_id=6)\n2、如果可以拿到对象的化django也是可以支持插入对象的。\nboy = models.UserInfo.objects.filter(xxxx)\ngirl = models.UserInfo.objects.filter(xxx)\nmodels.U2U.objects.create(b=boy, g=girl)\n\n或者：\nclass UserInfo(models.Model):\n    nickname = models.CharField(max_length=32)\n    username = models.CharField(max_length=32)\n    password = models.CharField(max_length=64)\n    gender_choices = (\n\t\t(1, \'男\'),\n    \t(2, \'女\'),\n\t)\n\tgender = models.IntegerField(choices=gender_choices)\n    m = models.ManyToManyField(\'UserInfo\')\n    \n如果设定的是manytomany的方式的话那么取数据的时候先后也有区别。\n上面的这个m在数据库中生成的字段名是from_userinfo_id和to_userinfo_id\n我们定前面的是男生的，后面的是女生的。那么取数据的时候就应该做如下修改：\n# 男生对象\nobj = models.UserInfo.objects.filter(id=1).first()\n# 根据男生id=1查找关联的所有女生\nobj.m.all()\n\n# 女生对象\nobj = models.UserInfo.objects.filter(id=4).first()\n# 根据女生id=4查找关联的所有男生\nobj.userinfo_set.all()\n```\n\n用户的注销：\n\n```python\n# 删除服务端的session数据，用户带着cookie来的话查不到数据\nrequest.session.delete(request.session.session_key)\n或者\n# 设置cookie超时\nrequest.session.clear()\n```\n\nForeign自关联\n\n```python\nclass Comment(models.Model):\n    \"\"\"评论表\"\"\"\n    news_id = models.IntegerField() # 新闻id\n    content = models.CharField(max_length=32) # 评论的内容\n    user = models.CharField(max_length=32)   # 评论用户的id\n    # 首先这个评论的新闻是要存在的，这个要在已经存在的数据中去确认。\n    # 因此ForeignKey关联的表是自己。这个叫做ForeignKey的自关联\n    reply = models.ForeignKey(\'Comment\', null=True, blank=True, related_name=\'xxxxx\') # 评论回复\n```\n\n一般情况下的自关联是用不到的。\n\n## 中间件\n\n用户请求到达视图函数之前还隔着一层中间件：\n\n```python\n# Django的Settings文件。\nMIDDLEWARE = [\n    \'django.middleware.security.SecurityMiddleware\',\n    \'django.contrib.sessions.middleware.SessionMiddleware\',\n    \'django.middleware.common.CommonMiddleware\',\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n    \'django.contrib.auth.middleware.AuthenticationMiddleware\',\n    \'django.contrib.messages.middleware.MessageMiddleware\',\n    \'django.middleware.clickjacking.XFrameOptionsMiddleware\',\n]\n```\n\n对应到Django中其实就是一个个的类，请求进来是一套方法，请求返回又是一套方法。在每一层中间件的时候如果遇到了错误，就不会继续执行了而是直接返回，根本到达不了视图函数。比如我们在这里做一个黑名单的功能，拦下一些ip地址。\n\n```python\n# 自定义中间件\nfrom django.utils.deprecation import MiddlewareMixin\n\n\nclass M1(MiddlewareMixin):\n    def process_request(self, request):\n \t\tpass\n    \n    def process_response(self, request, response):\n        # 在response的时候要返回给下一个中间件\n        # request不用return，因为django内部帮忙操作了。添上反而有问题。\n        # 你如果在request部分返回值，中间件就不继续往下执行了。\n        return response\n```\n\n在配置文件中，中间件是一个有序列表，因此中间件也是按照顺序进行执行的。\n\nDjango:\n\n- 路由\n  - 单一路由\n  - 正则\n  - 可命名（反向生成）\n  - include分发\n- 视图\n  - CBV\n    - request\n    - render\n    - HttpResponse\n    - methodDecrators\n  - FBV\n- 数据库\n  - 基本数据库操作（增删改查）\n  - ​\n- 模板\n- 其他：\n  - CSRF\n  - Cookie\n  - Session\n  - 分页\n\nDjango请求的生命周期：\n\ndjango默认使用的wsgi是wsgiref\n\n\n\nmvc & mtv(models（模型类）, templates（模板）,views（业务逻辑）)\n\n\n\n\n\n中间件：\n\n- 类\n  - process_request：django为你做了返回，如果自己添加的话中间件不会进一步运行\n  - process_response：需要有一个返回值\n- 注册中间件\n\n旧版本的1.10之前的Django，如果request我们人工返回了值会从中间件的最后一个response返回而不是从当前的中间件的response返回：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-22/64902081.jpg)\n\n不过最新的已经不是这么个流程了。\n\n中间件除了request和response外还有一个process_view方法\n\n```python\ndef process_view(self, request, callback, callback_args, callback_kwargs):\n    pass\n\ncallback是路由匹配对应的url函数的函数名。\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-22/30380835.jpg)\n\n因此在这个折返的过程中就允许我主动调用视图函数了。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-22/14622746.jpg)\n\nprocess_view中如果有返回值的话，会跳过视图函数把所有的response执行一遍返回去，和request多少有一点不一样。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-22/189029.jpg)\n\n- process_exception\n\n这个方法会捕获视图函数中的错误，执行流程如下：\n\n![](http://omk1n04i8.bkt.clouddn.com/18-2-22/10960222.jpg)\n\n就像一个鸡爪或者两个闪电~\n\nexception一旦有了返回值就不会往下继续执行了，也就是谁把错误处理了以后就不会继续往下执行了。\n\n- process_template_response(self, request, response)\n\n针对视图函数的返回值做一个要求，如果有render方法才会被调用。\n\n\n\n到底什么时候开始应用中间件：\n\n- 适用于对所有请求或者一部分请求做批量处理。\n- 可以应用于请求做判断进行缓存应用的处理。","timestamp":1523930994994},{"name":"09-Django安全.md","path":"06-Django/09-Django安全.md","content":"# Django安全\n\n## XSS跨站脚本攻击\n\n> Django在内部已经屏蔽了xss，如果说手贱给内容加了一个 \" content | safe\"就会进行解析，这样就不是字符串了。所以一般情况下不要加safe，如果一定要加safe要记得对特殊字符做过滤。\n>\n> 或者我们也可以在后台逻辑将用户传递过来的字符串进行判断是否有违规内容。\n>\n> 当然在django后台也可以标记，但是需要单独导入模块\n>\n> ```python\n> from django.utils.safestring import mark_safe\n> temp = \"<a>test</a>\"\n> # 把newtemp传递到前端模板的时候就会标记为安全的了。\n> # 因此标记为安全有前台和后台两种方式\n> newtemp = mark_safe(temp)\n> ```\n\n**要点**：\n\n- 慎用safe和mark_safe\n- 非要用，那务必过滤关键字。\n\n## CSRF（跨站请求的伪造）【需要视频复盘】\n\n> django为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。\n>\n> 更多：https://docs.djangoproject.com/en/dev/ref/csrf/#ajax\n\n配置文件中应该打开，默认也是打开的：\n\n```python\nMIDDLEWARE = [\n    \'django.middleware.csrf.CsrfViewMiddleware\',\n]\n```\n\n在这个选项打开的时候，如果没有传递token字符串的话怎么提交也是不生效的。\n\n全局：\n\n　　中间件 django.middleware.csrf.CsrfViewMiddleware\n\n局部（为函数添加如下的特殊装饰器就可以了）：\n\n```python\nfrom django.views.decorator import csrf_exempt或者csrf_protect\n```\n\n- @csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。\n- @csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。\n\n当然直接加装饰器我们这是针对FBV，如果说是针对CBV的时候我们还要做特殊处理：\n\n```python\nfrom django.views.decorator import csrf_protect\nfrom django.utils.decorators import method_decorator\nfrom django.views import View\n\n# 装饰器是CBV中是不可以直接使用的，要调用Django提供的方法才行。\n@method_decorator(csrf_protect) # 给类下的所有绑定方法加装饰器\n# @method_decorator(csrf_protect, name=\'post\') # 给类下的post方法加装饰器，name是谁就是给谁装饰\nclass Foo(View):\n    def get(self, request):\n        pass\n    \n    def post(self, request):\n        pass\n    \n    def dispatch(self,request,*args,**kwargs):\n        return xxx\n    \n# 如果是给dispatch加这个装饰器的话也相当于给所有的加了，因为dispatch是一个入口函数，有dispatch的时候是优先找到dispatch然后通过反射找的POST或者GET方法。\n@method_decorator(csrf_protect, name=\'dispatch\')\n\n# 针对CSRF的装饰器只能给CBV的类加，不能给类下的方法加，我们自己自定义的装饰器应该是ok的\n```\n\n### 应用\n\n普通表单\n\n```python\nveiw中设置返回值：\n　　return render_to_response(\'Account/Login.html\',data,context_instance=RequestContext(request))　　\n     或者\n     return render(request, \'xxx.html\', data)\n  \n# html中设置Token:\n# 会在页面生成一个隐藏的input的标签\n# 同时也会在cookie中插入csrftoken\n　　{% csrf_token %}\n```\n\nAjax\n\n```python\n# 对于传统的form，可以通过表单的方式将token再次发送到服务端，而对于ajax的话，使用如下方式。\n\n#view.py\nfrom django.template.context import RequestContext\n# Create your views here.\n  \n  \ndef test(request):\n  \n    if request.method == \'POST\':\n        print request.POST\n        return HttpResponse(\'ok\')\n    return  render_to_response(\'app01/test.html\',context_instance=RequestContext(request))\n```\n\ntext.html\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n    {% csrf_token %}\n  \n    <input type=\"button\" onclick=\"Do();\"  value=\"Do it\"/>\n  \n    <script src=\"/static/plugin/jquery/jquery-1.8.0.js\"></script>\n    <script src=\"/static/plugin/jquery/jquery.cookie.js\"></script>\n    <script type=\"text/javascript\">\n        var csrftoken = $.cookie(\'csrftoken\');\n  \n        function csrfSafeMethod(method) {\n            // these HTTP methods do not require CSRF protection\n            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n        }\n        $.ajaxSetup({\n            beforeSend: function(xhr, settings) {\n                if (!csrfSafeMethod(settings.type) && !this.crossDomain) {\n                    xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n                }\n            }\n        });\n        function Do(){\n  \n            $.ajax({\n                url:\"/app01/test/\",\n                data:{id:1},\n                type:\'POST\',\n                success:function(data){\n                    console.log(data);\n                }\n            });\n  \n        }\n    </script>\n</body>\n</html>\n```\n\n","timestamp":1523930994994},{"name":"01-需求分析&DB设计.md","path":"06-Django/98-Django Blog/01-需求分析&DB设计.md","content":"","timestamp":1523930994994},{"name":"02-首页.md","path":"06-Django/98-Django Blog/02-首页.md","content":"","timestamp":1523930994994},{"name":"08-文件的上传.md","path":"06-Django/98-Django Blog/08-文件的上传.md","content":"# 文件上传\n\n## 基于Form表单的上传\n\n> 基于Form表单的上传一个典型的特点就是提交就会刷新\n\n文件上传其实就是一个input的type为file的input框，在文件上传的时候值得注意的一点就是要指定form的`enctype=multipart/form-data`，否则后台拿不到对应的文件对象的。\n\n```python\nimport os\nfrom django.forms import Form\n\nclass F1Form(Form):\n    user = fields.CharField()\n    fafafa = fields.FileField()\n    \n    \ndef f1(request):\n    if request.method == \'GET\':\n        obj = F1Form()\n        return render(request, \'f2.html\',{\'obj\':obj})\n    else:\n        # 当发送POST请求的时候，我们就可以获取到用户提交的数据了。\n        # 这里拿到的也是一个文件对象，有name和size等其他属性，可以直接用file_obj.name获取\n        file_obj = request.FILE.get(\'fafafa\')\n        # 把文件一点一点的获取到，一块一块的。那么就可以像迭代器一样一块一块的去取\n        # 使用os.path.join拼一个路径出来，放到对应的目录下\n        f = open(os.path.join(\'static\',file_obj.name), \'wb\')\n        # chunk的size可以自定义，默认chunk_size为64*2**10，DEFAULT_CHUNK_SIZE\n        # chunk_size直接定义值就可以了。在调用的时候直接传参\n        for chunk in file_obj.chunks():\n           f.write(chunk)\n        f.close()\n        return render(request, \'f2.html\')\n\n# 这个enctype=\"multipart/form-data\"是要加的，否则后台获取到的数据字典是空的。\n# 这个和上传协议有关，加上以后会按照文件的编码进行上传。\n<form method=\"POST\" action=\'/xxx/\' enctype=\"multipart/form-data\">\n\t………………\n</form>\n```\n\n结合Form表单使用：\n\n```python\nfrom django.forms import Form\nfrom django.forms import fields, widgets\n\nclass F2Form(Form):\n    user = fields.CharField()\n    fafafa = fields.FileField()\n    \n    \ndef f2(request):\n    if request.method == \'GET\':\n        obj = F2Form()\n        return render(request, \'f2.html\',{\'obj\':obj})\n    else:\n        # 文本用data接收，文件用files接收。类型不一样\n        obj = F2Form(data=request.POST, files=request.FILES)\n        if obj.is_vaild():\n            # 文件获取到的是一个文件对象，有文件名啊，文件大小啊等各种属性\n            obj.cleaned_data.get(\'fafafa\')\n        return render(request, \'f2.html\', {\'obj\': obj})\n```\n\n","timestamp":1523930994994},{"name":"09-验证码.md","path":"06-Django/98-Django Blog/09-验证码.md","content":"# 验证码\n\n> 如何使用python来处理登录或者注册界面的验证码\n>\n> 武Sir博客参考：http://www.cnblogs.com/wupeiqi/articles/5812291.html\n\n环境准备：\n\n```python\n# 依托于PIL库，因此首先要去安装，就和php用gd库一样\npip install pillow\n```\n\n## 基本使用\n\n### 创建图片\n\n```python\nfrom PIL import Image\n# 创建一张画布图片，模式为RGB，大小宽高，颜色为这三个颜色\nimg = Image.new(mode=\'RGB\', size=(120, 30), color=(255, 255, 255))\n \n# 在图片查看器中打开\n# img.show() \n \n# 保存在本地\nwith open(\'code.png\',\'wb\') as f:\n    img.save(f,format=\'png\')\n```\n\n### 创建画笔在图片上绘画\n\n```python\n# 使用ImageDraw.Draw创建一只画笔用来绘画\nimg = Image.new(mode=\'RGB\', size=(120, 30), color=(255, 255, 255))\ndraw = ImageDraw.Draw(img, mode=\'RGB\')\n\n# 画点，第一个参数：表示坐标；第二个参数：表示颜色，颜色可以使用单词，可以使用rgb颜色\ndraw.point([100, 100], fill=\"red\")\ndraw.point([300, 300], fill=(255, 255, 255))\n\n# 画线，两个点确定一个线\n# 第一个参数：表示起始坐标和结束坐标\n# 第二个参数：表示颜色\ndraw.line((10, 10, 100, 20), fill=\'red\')\ndraw.line((10, 10, 100, 30), fill=(255, 255, 255))\n\n# 画圆，与其说画圆不如说是画扇形，确定两个坐标点，然后以这两个坐标点为对角线画出一个长方形，在这个长方形里面画圈。\n# 第一个参数：表示起始坐标和结束坐标（圆要画在其中间）\n# 第二个参数：表示开始角度\n# 第三个参数：表示结束角度\n# 第四个参数：表示颜色\ndraw.arc((10,10,30,30),0,90,fill=\"red\")\n\n# 写字\n# 第一个参数：表示起始坐标\n# 第二个参数：表示写入内容\n# 第三个参数：表示颜色\ndraw.text([0,0],\'python\',\"red\")\n\n# 写入特殊字体的文字\n# 第一个参数：表示字体文件路径\n# 第二个参数：表示字体大小\nfrom PIL import ImageFont\nfont = ImageFont.truetype(\"kumo.ttf\", 28)\n# 第一个参数：表示起始坐标\n# 第二个参数：表示写入内容\n# 第三个参数：表示颜色\n# 第四个参数：表示颜色\ndraw.text([0, 0], \'python\', \"red\", font=font)\n```\n\n## 通过PIL制作图片验证码\n\n> Httpresponse可以返回字符串也可以返回自己留，因此可以动态的去生成图片去显示。\n>\n> 直接返回内容为：`return HttpResponse(data)`其中data为字节流，那么生成的验证码图片应该放到什么位置呢？首先不能放到磁盘中。我们可以直接在内存中开辟一块空间用来保存这个内容。\n\n### 随机字符串\n\n首先要写字，如何生成随机字符串呢？\n\n```python\n# 文件名：random_check_code.py\n# 生成随机字符串，可以使用列表生成式的形式生成随机字符串，但是为了可以对每一个\n# 字符做单独的处理，因此不这么处理\n# char_list = \'\'.join([chr(random.randint(65, 90)) for i in range(5)])\nimport random\nchar_list = []\nfor i in range(5):\n    char = chr(random.randint(65, 90))\n    char_list.append(char)\n    font = ImageFont.truetype(\'static/font/kumo.ttf\', 28)\n    draw.text([i * 24, 0], char, (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)), font=font)\ncode = \'\'.join(char_list)\n```\n\n### 保存位置\n\n上面说到图片是不能保存到服务器的存储中的，所以可以临时在内存开辟一块空间去保存这个临时的验证码，需要引用的包如下：\n\n```python\nfrom io import BytesIO\n# 这个其实和打开文件很相似，创建一个文件句柄stream\nsteam = BytesIO()\n# 将图片内容保存到文件句柄中(字节流)，这里format可以省略，直接写成png\nimg.save(stream, format=\'png\')\n# 读取写到内存的内容\ndata = steam.getvalue()\n\n\n/---------Py3和py2写入内存的方式不太一样---------------/\n1. 写入内存(Python3)\nfrom io import BytesIO\nstream = BytesIO()\nimg.save(stream, \'png\')\nstream.getvalue()\n\n2. 写入内存（Python2）\nimport StringIO\nstream = StringIO.StringIO()\nimg.save(stream, \'png\')\nstream.getvalue()\n```\n\n### 封装成一个组件工具\n\n```python\nimport random\n# ImageFilter加滤镜，让色差更强一点\nfrom PIL import Image, ImageDraw, ImageFont, ImageFilter\n\n\ndef rd_check_code(width=120, height=30, char_length=5, font_file=\'static/font/kumo.ttf\', font_size=28):\n    \"\"\"\n    图片宽高，字符长度，字体路径，字体大小。\n    \"\"\"\n    code = []\n    img = Image.new(mode=\'RGB\', size=(width, height), color=(255, 255, 255))\n    draw = ImageDraw.Draw(img, mode=\'RGB\')\n\n    def rndchar():\n        \"\"\"\n        生成随机字母\n        :return:\n        \"\"\"\n        return chr(random.randint(65, 90))\n\n    def rndColor():\n        \"\"\"\n        生成随机颜色\n        :return:\n        \"\"\"\n        return (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255))\n\n    # 写文字\n    font = ImageFont.truetype(font_file, font_size)\n    for i in range(char_length):\n        char = rndchar()\n        code.append(char)\n        h = random.randint(0, 4)\n        draw.text([i * width / char_length, h], char, font=font, fill=rndColor())\n\n    # 写干扰点\n    for i in range(40):\n        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())\n\n    # 写干扰圆圈\n    for i in range(40):\n        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())\n        x = random.randint(0, width)\n        y = random.randint(0, height)\n        draw.arc((x, y, x + 4, y + 4), 0, 90, fill=rndColor())\n\n    # 画干扰线\n    for i in range(5):\n        x1 = random.randint(0, width)\n        y1 = random.randint(0, height)\n        x2 = random.randint(0, width)\n        y2 = random.randint(0, height)\n\n        draw.line((x1, y1, x2, y2), fill=rndColor())\n    # 设置色差\n    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)\n    return img, \'\'.join(code)\n```\n\n这样我们就可以把这个工具类放到一个工具目录下，用到的时候直接调用就可以了，比如说放到utils目录下\n\n```python\n# views.py\nfrom io import BytesIO\nfrom utils.random_check_code import rd_check_code\n\ndef check_code(request):\n    img, code = rd_check_code()\n    stream = BytesIO()\n    img.save(stream, \'png\')\n    request.session[\'code\'] = code\n    # 把内存中读取到的图片内容返回就可以了。\n    return HttpResponse(stream.getvalue())\n```\n\n那么在前端我们可以如何去使用呢？\n\n```html\n# src的实质其实也是把图片读取后放到内存中然后再呈现给用户\n# 那么我们可以直接把放到内存中的内容放到这里显示就可以了。\n<div class=\"col-sm-5\">\n    <img id=\'i1\' title=\'点击更新\' onclick=\"changeCode(this);\" src=\"/check_code\" alt=\"\" style=\"width: 120px;height: 30px;\">\n</div>\n```\n\n路由配置：\n\n```python\npath(\'check_code/\', views.check_code),\n```\n\n","timestamp":1523930994994},{"name":"10-上传头像.md","path":"06-Django/98-Django Blog/10-上传头像.md","content":"# 头像的上传\n\n> 用户在注册的时候或者注册以后允许用户上传自己的头像并且允许头像的实时预览，目前有两种方案：\n>\n> - 将图片上传到服务端通过ajax将图片的内容返回给前端\n> - 直接在浏览器预览，没问题后上传\n>\n> 第一种存在一种明显的问题就是上传以后服务器其实就有这个内容了，假如我只是上传了但是我不修改了或者页面被关掉了那么其实更新内容并没有更新上去，但是图片已经保存在服务器了。针对这个问题可以将图片放到一个临时的位置定期删除。\n>\n> 第二种问题相对来说要优秀很多，但是也存在一个浏览器兼容性的问题，也就是很多新版浏览器都是支持的，但是遇到ie这个老祖宗基本就会出现不兼容的情况。因此针对这个问题可以多方面的去做处理。根据条件去判断到底该使用什么办法从而达到一个全方面兼容的效果。\n\n","timestamp":1523930994994},{"name":"99-Django常见小问题.md","path":"06-Django/99-Django常见小问题.md","content":"# Django常见小问题汇总\n\n","timestamp":1523930994994}]