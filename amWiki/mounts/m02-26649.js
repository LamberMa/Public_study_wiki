if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m02']=[{"name":"01-Docker介绍.md","path":"02-Docker/01-Docker介绍.md","content":"# Docker\n\n> Docker是Docker.Inc公司开源的一个基于LXC技术之上构建的Container容器引擎，源代码托管在github上，基于Go语言并遵循Apache2.0协议开源。\n>\n> Docker是通过内核虚拟化技术（namespaces以及cgroups等）来提供容器的资源隔离与安全保证等。由于Docker通过系统层的虚拟化实现隔离，所以Docker容器在运行的时候不需要类似虚拟机额外的操作系统的开销（经验来看一般一个完整的系统大概会消耗一个物理主机6%左右的性能），提高资源利用率。\n\n**docker的核心理念**\n\n- 构建（Build）\n- 运输（Ship）\n- 运行（Run）\n\n## Docker介绍\n\n### 容器VS虚拟化\n\n![](http://omk1n04i8.bkt.clouddn.com/18-5-11/23003726.jpg)\n\n虚拟机是完整的资源隔离。容器是隔离不是虚拟，它不需要虚拟出来操作系统环境。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-5-11/3645079.jpg)\n\n### Docker可以做什么\n\n![](http://omk1n04i8.bkt.clouddn.com/18-5-11/87167288.jpg)\n\n1. 简化配置\n2. 代码流水线的管理，让开发，测试生产都跑在同样一个环境，保证开发环境的一致性。\n3. 提高开发效率\n4. 应用的隔离（虚拟机也可以做到）\n5. 整合服务器，通过docker的隔离能力整合多个服务器降低成本。\n6. 调试能力\n7. 多租户环境\n8. 快速部署\n\n### Docker改变了什么？\n\n- 面向产品：产品交付\n- 面向开发：简化环境配置\n- 面向测试：多版本测试\n- 面向运维：环境一致性，可以环境和代码一起发布，回滚的时候也可以做到一起回滚。\n- 面向架构：自动化扩容（微服务）\n\n## Docker的安装\n\n> 最新的安装信息请以官方文档的安装信息为准，[官方Doc文档地址](https://docs.docker.com/install/linux/docker-ce/centos/#set-up-the-repository)\n\n以下是一个简单的安装步骤：\n\n```shell\nyum install -y yum-utils device-mapper-persistent-data lvm2\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\nyum install docker-ce\nsystemctl start docker\n```\n\n查看docker启动状态：\n\n```shell\n[root@localhost ~]# ps -ef | grep docker\nroot     31551     1  2 00:43 ?        00:00:00 /usr/bin/dockerd\nroot     31555 31551  0 00:43 ?        00:00:00 docker-containerd --config /var/run/docker/containerd/containerd.toml\nroot     31667 31082  0 00:43 pts/0    00:00:00 grep --color=auto docker\n```\n\n拉取docker镜像，这里如果直接拉的话可能会因为网速慢导致拉不下来，因此我们可以配置一下国内的docker镜像源\n\n### 配置国内docker镜像源\n\n> 国内的Docker镜像源有很多可以选择，[参考原文](https://www.cnblogs.com/anliven/p/6218741.html)\n>\n> - [DaoCloud - Docker加速器](https://dashboard.daocloud.io/)\n> - [阿里云 - 开发者平台](https://dev.aliyun.com/)\n> - [微镜像 - 希云cSphere](https://csphere.cn/hub)\n> - [镜像广场 - 时速云](https://hub.tenxcloud.com/)\n> - [灵雀云](https://hub.alauda.cn/)\n> - [网易蜂巢](https://c.163.com/)\n\n这里以阿里云的Docker加速器为例，注册并登陆[阿里云 - 开发者平台](https://dev.aliyun.com/)之后，在首页点击“创建我的容器镜像”，然后就会来到阿里云的服务面板。点击加速器标签。根据提示输入Docker登录时需要使用的密码（后期可更改），用户名就是登录阿里云的用户名。在出现的页面中，可以得到一个专属的镜像加速地址，类似于“[https://1234abcd.mirror.aliyuncs.com](https://1234abcd.mirror.aliyuncs.com/)”。根据页面中的“操作文档”信息，配置自己的Docker加速器。\n\n或者，登录[阿里云 - 容器Hub服务控制台](https://cr.console.aliyun.com/)之后，点击加速器标签，也会出现相应信息。\n\n![](http://omk1n04i8.bkt.clouddn.com/18-5-11/49585375.jpg)\n\n**其他国内Docker镜像的配置方法**\n\n国内其他Docker加速器配置方法和阿里云的差不多：\n\n- 注册账号，获取专属的镜像加速地址\n- 根据提示和系统类型，升级，并配置Docker，然后重启。\n- 验证操作结果\n\n**手动配置Docker加速器**\n\n配置Docker加速器的本质就是把Docker配置文件中的镜像下载地址由默认的Docker Hub地址变为国内镜像的加速地址。\n\n```shell\n/lib/systemd/system/docker.service\n/etc/systemd/system/docker.service\n\n# 比如centos7中\n将 OPTIONS=--registry-mirror=http://abcd1234.m.daocloud.io加入到docker的配置文件/etc/sysconfig/docker中，然后重启Docker\n```\n\n## Docker镜像\n\n### 镜像搜索\n\n```shell\n# docker有一个docker hub仓库，这个其实和github很相似。仓库中存了很多已经构建好的镜像。\n# 大多数情况我们可以直接下载一个现成的镜像而不需要我们自己构建\nCOMAND:\n\n$ sudo docker search TERM\n\nOPTIONS:\n\n--automated=false     是否仅显示自动创建的镜像  \n--no-trunc=false      是否截断输出  \n-s, --stars=0         仅显示至少有x颗星的镜像  \n\n示例:\n\n[root@maxiaoyu ~]# docker search nginx\nINDEX       NAME                    DESCRIPTION               STARS     OFFICIAL   AUTOMATED\ndocker.io   docker.io/nginx    Official build of Nginx.       7127        [OK]\n```\n\n我这里截取了搜索出结果的第一行，当然如果你实际搜索的话会有很多行的内容的，其中包含了官方的以及各种自制的。\n\n- NAME：镜像名称\n\n\n- DESCRIPTION：也就是镜像的描述，\n\n\n- STARS类似于github里面的stars，表示点赞和热度。\n\n\n- OFFICIAL：指docker标准库, 由docker 官方建立. 用户建立的image则会有userid的prefix.\n\n\n- automated builds ：则是通过代码版本管理网站结合docker hub提供的接口生成的, 例如github, bitbucket, 你需要注册docker hub, 然后使用github或bitbucket的在账户链接到docker hub, 然后就可以选择在github或bitbucket里面的项目自动build docker image, 这样的话只要代码版本管理网站的项目有更新, 就会触发自动创建image.对于的image属于什么版本，下面的“[OK]”就会打在什么地方\n\n### 获取镜像\n\n获取镜像的方式有两种，一种是直接去pull我们刚才用docker search搜索到的镜像：\n\n```shell\n[root@maxiaoyu ~]# docker pull docker.io/nginx   \nUsing default tag: latest\nTrying to pull repository docker.io/library/nginx ... \nlatest: Pulling from docker.io/library/nginx\nbc95e04b23c0: Pull complete \n110767c6efff: Pull complete \nf081e0c4df75: Pull complete \nDigest: sha256:004ac1d5e791e705f12a17c80d7bb1e8f7f01aa7dca7deee6e65a03465392072\n[root@maxiaoyu ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/nginx     latest              1e5ab59102ce        2 weeks ago         108.3 MB\ndocker.io/centos    latest              328edcd84f1b        12 weeks ago        192.5 MB\n```\n\n导入本地的docker包：\n\n```shell\ndocker load --input centos.tar\n或者\ndocker load < nginx.tar\n```\n\n我们也可以通过docker的导出功能将我们pull下来的image导出成一个tar包，生成的tar包会保存在当前的目录：\n\n```shell\ndocker save -o centos.tar centos\n```\n\n使用docker inspect去查看image的内容：\n\n```shell\ndocker inspect docker.io/nginx:latest   \n```\n\n列出当前下载的所有的镜像：\n\n```shell\n[root@localhost ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              ae513a47849c        10 days ago         109MB\ncentos              latest              e934aafc2206        4 weeks ago         199MB\n```\n\n如果我们在docker pull的时候不加额外的参数，那么下载的就是最新的，可以在tag中看到是latest的。但是我们可以指定版本，比如：\n\n```shell\n# 参考示例\ndocker pull centos:v1.0\n```\n\n### 删除镜像\n\n```shell\ndocker rmi 镜像ID，比如：\n[root@maxiaoyu ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/nginx     latest              1e5ab59102ce        2 weeks ago         108.3 MB\ndocker.io/centos    latest              328edcd84f1b        12 weeks ago        192.5 MB\n[root@maxiaoyu ~]# docker rmi 1e5ab59102ce\nUntagged: docker.io/nginx:latest\nUntagged: docker.io/nginx@sha256:004ac1d5e791e705f12a17c80d7bb1e8f7f01aa7dca7deee6e65a03465392072\nDeleted: sha256:1e5ab59102ce46c277eda5ed77affaa4e3b06a59fe209fe0b05200606db3aa7a\nDeleted: sha256:182a54bd28aa918a440f7edd3066ea838825c3d6a08cc73858ba070dc4f27211\nDeleted: sha256:a527b2a06e67cab4b15e0fd831882f9e6a6485c24f3c56f870ac550b81938771\nDeleted: sha256:cec7521cdf36a6d4ad8f2e92e41e3ac1b6fa6e05be07fa53cc84a63503bc5700\n```\n\n实际上是按照image的id去删除的，当然如果你的image属于被其他容器引用的情况下的话是无法删除的。会收到如下的报错信息：\n\n```shell\n[root@maxiaoyu ~]# docker rmi 328edcd84f1b\nError response from daemon: conflict: unable to delete 328edcd84f1b (must be forced) - image is being used by stopped container 1284da16efeb\n```\n\n## Docker容器\n\n### 创建一个容器\n\n```shell\n[root@maxiaoyu ~]# docker run --name myfirstdocker -i -t centos /bin/bash\n[root@2ce82d7a275e /]# uname -a\nLinux 2ce82d7a275e 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n[root@2ce82d7a275e /]# ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.1  11764  1888 ?        Ss   09:40   0:00 /bin/bash\nroot        14  0.0  0.0  47436  1676 ?        R+   09:44   0:00 ps aux\n```\n\n这样就新建了一个容器，我们也随之会进入到容器的界面。docker容器的启动，即使没有把镜像pull下来，在执行如上的命令的时候依然可以执行，因为docker发现你没有这个镜像的时候会帮你把镜像pull下来。容器的主机名就是容器的container id。接下来看看如上的几个参数都代表什么意思：\n\n- --name:指定这个生成的容器的名字，当然如果不指定的话name也会自动生成，我们指定名字只不过是为了更方便的去管理我们的容器。\n- -i：允许标准输入 ，即确保容器的STDIN是开启的。可以看到，运行命令以后我们进入到了容器中，进程为PID的是/bin/bash，也就是刚才我们指定要运行的命令。因此docker其实是为进程执行隔离作用的，虚拟机是给操作系统做隔离的。\n- -t：开启一个tty伪终端。\n- -d：如果需要容器在后台运行的话，可以加上-d参数。范围值为容器的id\n\n>以上操作其实是经历了这样一个过程：\n>\n>1. 执行上面操作首先会在系统本地去找有没有对应的这样一个image，如果没有的话那么就会去Docker Hub Registry去找，一旦找到以后就回去下载然后保存到本地宿主机器。\n>2. Docker利用这个image创建了一个容器，这个容器拥有自己的网络，ip，以及桥接外部网络的接口。\n>3. 我们告诉这个容器要去执行什么命令（/bin/bash），当然这个命令是可以在容器中指定的，指定容器起来的时候自动执行某个命令，那这里就可以不写了。\n\n当前我们是在容器的内部，通过`ps aux`我们可以得知，pid的大树根并不是init（centos7的树根并不是init），而是我们运行的/bin/bash，如果此时我们使用exit退出容器的话，那么此时的容器就会被关掉，它就完成了它的使命。\n\n```shell\n[root@2ce82d7a275e /]# exit\nexit\n[root@maxiaoyu ~]# docker ps -a\nCONTAINER ID  IMAGE    COMMAND      CREATED         STATUS                   PORTS     NAMES     \n2ce82d7a275e  centos  \"/bin/bash\"  10 minutes ago  Exited (0) 5 seconds ago       myfirstdocker\n```\n\nDocker其实是单进程的，他需要一个进程在前台跑着，因此如果这个程序执行完了，那么整个容器也就退出了，就像我们刚才执行/bin/bash后进入到容器，当exit退出的时候这个进程结束以后整个容器也就跟着一起退出了。所以说不是所有的应用都适合docker。\n\n### 启动并进入一个容器\n\n那么如何启动已经关闭的容器呢？\n\n**方法一**\n\n```\ndocker start docker_name\n\n比如（这样就一直跑起来了）：\n[root@maxiaoyu ~]# docker start myfirstdocker\nmyfirstdocker\n```\n\n**方法二**\n\n```\n[root@maxiaoyu ~]# docker attach myfirstdocker\n[root@2ce82d7a275e /]# \n# 这样就是直接进到容器里面去了，不过exit以后容器还是会停止，因此一般不会去这么操作的\n# 而且多人同时进入到这个容器这个命令显示是同步的。\n```\n\n**方法三**\n\n```shell\n# 生产中建议使用的方法\n[root@maxiaoyu ~]# yum -y install util-linux\n[root@maxiaoyu ~]# docker start mydocker\nmydocker\n# 获取当前的docker的pid，如果获取到的pid=0，说明你这个容器没起来，后面可以接容器id也可以接容器名称。\n[root@maxiaoyu ~]# docker inspect -f \"{{ .State.Pid }}\" mydocker\n13500\n[root@maxiaoyu ~]# nsenter -t 13500 -m -u -i -n -p \n# 使用这种方法进入容器，即使退出的话仍然可以保证容器是开启的，进程并不会结束，docker ps能看到\n[root@1284da16efeb /]# exit\nlogout\n# 那么为什么即使exit出去也不会退出容器呢？\n[root@1284da16efeb /]# ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.0  11764  1676 ?        Ss+  10:01   0:00 /bin/bash\nroot        26  0.0  0.1  15192  1996 ?        S    10:05   0:00 -bash\nroot        39  0.0  0.0  50868  1816 ?        R+   10:05   0:00 ps aux\n# 主要原因是因为多了一个-bash的进程，因此退出当前的进程这个docker不会退出，因为仍然还有一个/bin/bash的进程正在运行，因此整个容器是并不会退出的。\n```\n\n查看一下nsenter的帮助信息：\n\n```\n[root@maxiaoyu ~]# nsenter --help\n\nUsage:\n nsenter [options] <program> [<argument>...]\n\nRun a program with namespaces of other processes.\n\nOptions:\n -t, --target <pid>     target process to get namespaces from\n -m, --mount[=<file>]   enter mount namespace\n -u, --uts[=<file>]     enter UTS namespace (hostname etc)\n -i, --ipc[=<file>]     enter System V IPC namespace\n -n, --net[=<file>]     enter network namespace\n -p, --pid[=<file>]     enter pid namespace\n -U, --user[=<file>]    enter user namespace\n -S, --setuid <uid>     set uid in entered namespace\n -G, --setgid <gid>     set gid in entered namespace\n     --preserve-credentials do not touch uids or gids\n -r, --root[=<dir>]     set the root directory\n -w, --wd[=<dir>]       set the working directory\n -F, --no-fork          do not fork before exec\'ing <program>\n -Z, --follow-context   set SELinux context according to --target PID\n\n -h, --help     display this help and exit\n -V, --version  output version information and exit\n\nFor more details see nsenter(1).\n```\n\n因此我们可以针对第三种生产中使用的方法去写一个小脚本然后通过批量部署分发后使用：\n\n```shell\n# $1可以是容器的名称，或者容器的id\n[root@maxiaoyu ~]# cat docker_in.sh \n#!/bin/bash\n\n# Use nsenter to access docker \n\ndocker_in (){\n   NAME_ID=$1\n   PID=$(docker inspect -f \"{{ .State.Pid }}\" $NAME_ID)\n   nsenter -t $PID -m -u -i -n -p\n}\n\ndocker_in $1\n[root@maxiaoyu ~]# chmod +x docker_in.sh\n```\n\n**方法四**\n\n```shell\n[root@localhost ~]# docker exec mydocker uptime\n 06:38:47 up  3:51,  0 users,  load average: 0.00, 0.03, 0.05\n```\n\n我不想真的进入容器，但是我还想让这个容器给我执行个命令，就可以使用exec，这个是exec命令的用途本意。不过通过exec也能进入容器，比如：\n\n```shell\n[root@linux-node1 ~]# docker exec -it mydocker /bin/bash\n[root@e95a62d6770f /]# ps aux\nUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot          1  0.0  0.0  11768  1676 ?        Ss+  02:28   0:00 /bin/bash\nroot         50  0.5  0.0  11768  1884 ?        Ss   02:41   0:00 /bin/bash\nroot         62  0.0  0.0  47440  1676 ?        R+   02:41   0:00 ps aux\n###有两个/bin/bash，因此这个容器技术退出了仍然还在运行，他退出的是pid=50的/bin/bash\n\n[root@e95a62d6770f /]# exit\nexit\n[root@linux-node1 ~]# docker ps -a\nCONTAINER ID    IMAGE    COMMAND     CREATED         STATUS        PORTS         NAMES\ne95a62d6770f    centos  \"/bin/bash\" 33 minutes ago  Up 12 minutes              mydocker\n78fc36ba1e5a    centos  \"/bin/echo xx\" 39 minutes ago  Exited (0) 39 minutes ago                       compassionate_rosalind\n```\n\n### 删除容器\n\n```shell\ndocker rm 容器id\n```\n\n如果容器在使用的话那是不允许你删除的，不过你可以使用-f强制干掉。当然一般不建议这么做。一般来讲都是先把容器停掉以后再把容器干掉。\n\n运行玩意后直接删除容器\n\n```shell\n## --rm参数可以使得一个容器运行完成以后就直接删除了。下面的内容执行完成以后再docker ps就看不到了\n[root@linux-node1 ~]# docker run --rm centos /bin/echo \"hello lamber\"\nhello lamber\n```\n\n### 停止容器\n\n```shell\ndocker stop 容器ID\n```\n\n\n\n","timestamp":1526281685638},{"name":"02-Docker数据存储和网络访问.md","path":"02-Docker/02-Docker数据存储和网络访问.md","content":"# Docker数据存储&网络访问\n\n## Docker的网络应用\n\n### 通过端口映射的方式访问Docker\n\n我们安装了docker后会多了一个桥接网卡docker0：\n\n```shell\n[root@localhost ~]# ifconfig docker0\ndocker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255\n        inet6 fe80::42:baff:fea1:dfa8  prefixlen 64  scopeid 0x20<link>\n        ether 02:42:ba:a1:df:a8  txqueuelen 0  (Ethernet)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 10  bytes 1876 (1.8 KiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n[root@localhost ~]# yum install bridge-utils\n\n[root@localhost ~]# brctl show\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\ndocker0\t\t8000.0242baa1dfa8\tno\t\tveth92ad03f\n```\n\n那么现在启动一个容器并映射端口，端口的映射分为随机映射和指定映射：\n\n- 随机映射\n  - docker run -P\n- 指定映射\n  - -p hostPort:containerPort       # 映射所有ip的指定端口到容器ip的指定端口\n  - -p ip:hostPort:containerPort   # 如果物理机有多个ip地址，我们也可以指定一个ip\n  - -p ip::containerPort   # 映射到指定地址的任意端口\n  - -p hostPort:containerPort:udp # 默认是tcp的，可以指定协议为udp\n  - -p 80:81 -p 443:443 ##同时映射多个端口\n\n#### 随机端口映射\n\n由于之前下载了一个nginx的镜像，那么我们就直接先来启用一个nginx容器：\n\n```shell\n[root@localhost ~]# docker run -d -P --name nginx-test1 nginx\nWARNING: IPv4 forwarding is disabled. Networking will not work.\n0b3299999a96eb216b05f2a5c68f32a2775751a49d240034a2f89305bb7bd236\n\n# 可以看到容器启动，返回了容器的id的，但是报了一个警报说如果不打开ipv4转发的话那么网络将不会有效。那么我们就先把系统的网络转发打开\necho 1 > /proc/sys/net/ipv4/ip_forward\n\n# 查看容器的状态\n[root@localhost ~]# docker ps\nCONTAINER ID IMAGE   COMMAND              CREATED             STATUS              PORTS                   NAMES\n0b3299999a96 nginx \"nginx -g \'daemon of…\"   3 minutes ago       Up 3 minutes        0.0.0.0:32768->80/tcp   nginx-test1\n```\n\n从上面可以看到将nginx容器的80端口映射到了宿主机的32768端口。此时我们就可以通过访问宿主机的32768端口来访问docker了，具体我还可以通过iptables来查看，`iptables -t nat nvL`。可以通过docker logs查看日志：\n\n```shell\n[root@localhost ~]# docker logs nginx-test1\n192.168.56.1 - - [11/May/2018:07:32:23 +0000] \"GET / HTTP/1.1\" 200 612 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" \"-\"\n2018/05/11 07:32:24 [error] 5#5: *1 open() \"/usr/share/nginx/html/favicon.ico\" failed (2: No such file or directory), client: 192.168.56.1, server: localhost, request: \"GET /favicon.ico HTTP/1.1\", host: \"192.168.56.101:32768\", referrer: \"http://192.168.56.101:32768/\"\n192.168.56.1 - - [11/May/2018:07:32:24 +0000] \"GET /favicon.ico HTTP/1.1\" 404 572 \"http://192.168.56.101:32768/\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\" \"-\"\n```\n\n随机映射是非常简单的，但是管理起来也不是很方便的，因为我们需要知道每个容器的端口的映射关系，好处就是端口不会重复，启用很方便。\n\n#### 指定映射\n\n```shell\n[root@localhost ~]# docker run -d -p 192.168.56.101:88:80 --name nginx-test2 nginx\n\nf2eccbad48a94111e7844562ce8750584bced374894cd4dad0af7b201eef8ffc\n[root@localhost ~]# curl 192.168.56.101:88 -I\nHTTP/1.1 200 OK\nServer: nginx/1.13.12\nDate: Fri, 11 May 2018 07:45:34 GMT\nContent-Type: text/html\nContent-Length: 612\nLast-Modified: Mon, 09 Apr 2018 16:01:09 GMT\nConnection: keep-alive\nETag: \"5acb8e45-264\"\nAccept-Ranges: bytes\n```\n\n查看容器映射：\n\n```shell\n# -l参数指的是查看最后一个最新创建的容器\n[root@localhost ~]# docker ps -l\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                       NAMES\nf2eccbad48a9        nginx               \"nginx -g \'daemon of…\"   2 minutes ago       Up 2 minutes        192.168.56.101:88->80/tcp   nginx-test2\n```\n\n查看一下iptables的nat规则：\n\n```shell\nChain DOCKER (2 references)\n pkts bytes target     prot opt in     out     source               destination         \n    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           \n    2   128 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:32768 to:172.17.0.3:80\n    1    60 DNAT       tcp  --  !docker0 *       0.0.0.0/0            192.168.56.101       tcp dpt:88 to:172.17.0.4:80\n```\n\n经过NAT转换所以对于吞吐量比较大的业务还是多少有一些影响的。\n\n## Docker数据存储\n\n> 生产中不建议直接在docker容器中去写数据，建议使用数据卷或者数据卷容器写入\n\n### 数据卷\n\n我们新建一个容器，并把物理机的一个区域给它mount到容器中的data目录下，使用-v参数：\n\n```shell\n[root@localhost ~]# docker run -d --name nginx-volume-test1 -v /data nginx\n7cb33525f1027208402a86c95d0deedc4bf592264d113ddb47901d46797daa94\n```\n\n为了方便测试，我们直接去容器内的data目录下新建了一个hehe文件。那么这个文件被映射到物理机的什么地方呢？\n\n```shell\n[root@localhost ~]# docker inspect -f {{.Mounts}} nginx-volume-test1\n[{volume c2316666b28d0875aa66ec90ef511e61c0e044e531d56a54e835789ac9792229 /var/lib/docker/volumes/c2316666b28d0875aa66ec90ef511e61c0e044e531d56a54e835789ac9792229/_data /data local  true }]\n[root@localhost ~]# cd /var/lib/docker/volumes/c2316666b28d0875aa66ec90ef511e61c0e044e531d56a54e835789ac9792229/_data\n[root@localhost _data]# ll\n总用量 0\n-rw-r--r--. 1 root root 0 5月  11 04:14 hehe\n```\n\n另外一种挂载方式，指定我们的映射目录，一个源一个目的：\n\n```shell\n# 源是物理机的，目的是docker容器的。注意对应关系\nmkdir /data/docker-volume-nginx -p\ndocker run -d --name nginx-volume-test2 -v /data/docker-volume-nginx/:/data nginx\n6b739fc4d20f1064abf5c2fb619a394772f445f15636b303b0527bb148bd2818\n\ntouch /data/docker-volume-nginx/hehehe\ndocker_in.sh nginx-volume-test2\n# 进入容器\nroot@6b739fc4d20f:/# ls -l /data/\ntotal 0\n-rw-r--r-- 1 root root 0 Mar 31 08:20 hehehe\n```\n\n但是上面的这种方法在dockerfile中就是不支持的，试想如果这样操作了，那么可移植性就下降了，你要确保移植的位置也有你这个物理机的目录和数据。\n\n其他的几个选项：\n\n```shell\ndocker run -d --name nginx-volume-test2 -v /data/docker-volume-nginx/:/data:ro  只读\n```\n\n挂载文件：\n\n```shell\n[root@linux-node1 ~]# docker run --rm -it -v /root/docker_in.sh:/root/ nginx /bin/bash\nroot@239820f3e6bd:/# ls /root/ -l --color\ntotal 4\n-rwxr-xr-x 1 root root 179 Mar 31 07:48 docker_in.sh\n\n###记得前后文件名要对应\n```\n\n### 数据卷容器\n\n实现数据在多个容器之间共享\n\n```shell\n[root@linux-node1 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n6b739fc4d20f        nginx               \"nginx -g \'daemon off\"   11 minutes ago      Up 11 minutes       80/tcp, 443/tcp                     nginx-volume-test2\n925564d95872        nginx               \"nginx -g \'daemon off\"   20 minutes ago      Up 20 minutes       80/tcp, 443/tcp                     nginx-volumn-test1\ndce2e78b22be        nginx               \"nginx -g \'daemon off\"   36 minutes ago      Up 36 minutes       443/tcp, 192.168.56.11:81->80/tcp   nginx2\n[root@linux-node1 ~]# docker run -it --name volume-test3 --volumes-from nginx-volume-test2 centos /bin/bash\n[root@034018de2dc4 /]# ls /data/\nhehehe\n```\n\n即使把nginx-volume-test2给停掉了仍然不影响volume-test3的访问，因为这个数据卷是mount上去的。而且我们这个时候占用的这个共享卷的时候，这个nginx-volume-test2你是删除不掉的。\n\n**实际应用**\n\n比如创建一个容器挂载数据卷，然后其他容器都共享它的。比如可以用到日志统一管理，多个容器挂载一个日志数据卷，然后用logstash统一收集管理。\n\n```shell\n[root@linux-node1 ~]# docker run -d --name nfs-test -v /data/nfs-data/:/data nginx\n[root@linux-node1 ~]# docker run --rm -it --volumes-from nfs-test centos /bin/bash\n[root@ac637a64910f /]# cd /data/\n[root@ac637a64910f data]# ls -l\ntotal 0\n-rw-r--r-- 1 root root 0 Mar 31 08:41 iamatest\n此时我们在物理机上创建的测试文件就显示出来了。\n```\n\n","timestamp":1526281685638},{"name":"03-手动构建镜像.md","path":"02-Docker/03-手动构建镜像.md","content":"# Docker手动构建\n\n杀死所有正在运行的容器并删除它\n\n```shell\n[root@linux-node1 ~]# docker ps -a -q\n319cc917e421\n00c801224fed\n9af1e1593e1c\n034018de2dc4\n6b739fc4d20f\n925564d95872\ndce2e78b22be\n35e9b3386c8a\ndfff10104bae\ne95a62d6770f\n78fc36ba1e5a\n[root@linux-node1 ~]# docker kill $(docker ps -a -q)\n[root@linux-node1 ~]# docker rm $(docker ps -a -q)\n```\n\n然后我们重新创建一个新的centos的容器，安装nginx：\n\n```shell\n[root@linux-node1 ~]# docker run --name mynginx -it centos \n\n# 进入容器，安装扩展源\n[root@c7426bc61497 /]# rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm\n\n# 安装nginx，这里测试用就直接yum了，生产中一般都是编译安装：\n[root@c7426bc61497 /]# yum install -y nginx\n\n# 前面说到容器的运行需要前台进程的支撑，因此如果nginx在后台跑的话这个docker容器是起不来的，因此我们需要对nginx做一些修改，让它在前台运行.\n[root@c7426bc61497 /]# grep -v \'^#\' /etc/nginx/nginx.conf | head -1\ndaemon off;\n配置文件中添加一行deamon off，然后退出容器\n[root@linux-node1 ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES\nc7426bc61497        centos              \"/bin/bash\"         12 minutes ago      Exited (0) 4 seconds ago                       mynginx\n```\n\n对容器修改完以后接下来我们需要提交，其实这个操作很类似于Git，其中-m指的是comment，就是一个描述，后面跟container id，然后nginx是库名称。\n\n```shell\n[root@linux-node1 ~]# docker commit -m \"My nginx\" c7426bc61497 nginx/mynginx:v1\nsha256:81f1607bb8a07d4874a68e1cffa369707f243e935f381373d8482cde6ee6a6ed\n[root@linux-node1 ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx/mynginx       v1                  81f1607bb8a0        About a minute ago   355 MB\ndocker.io/nginx     latest              5e69fe4b3c31        3 days ago           182.5 MB\ndocker.io/centos    latest              98d35105a391        2 weeks ago          192.5 MB\n```\n\n运行测试：\n\n```shell\n[root@linux-node1 ~]# docker run --name mynginxv1 -d -p 81:80 nginx/mynginx:v1 nginx\n这个名称要写全了，如果不写全的话，它会使用别的版本的最后这一个nginx是执行的命令。\n```\n\n![](http://omk1n04i8.bkt.clouddn.com/17-3-31/84755152-file_1490951666292_e7.jpg)\n\n","timestamp":1526281685638},{"name":"04-DockerFile.md","path":"02-Docker/04-DockerFile.md","content":"# DockerFile\n\n> Dockerfile是为快速构建docker image而设计的，当你使用dockerbuild 命令的时候，docker 会读取当前目录下的命名为Dockerfile(首字母大写)的纯文本文件并执行里面的指令构建出一个docker image。这比SaltStack的配置管理要简单的多，不过还是要掌握一些简单的指令。 Dockerfile 由一行行命令语句组成，并且支持以#开头的注释行。指令是不区分大小写的，但是通常我们都大写。\n\n下面我们通过构建一个Nginx的镜像来学习Dockerfile. 首先实现创建好目录，我这在opt下创建目录dockerfile，然后在dockerfile目录下创建nginx目录，在nginx目录下新建一个Dockerfile文件。Dcockerfile这个文件的首字母要大写，不然有可能不会被识别。\n\n```shell\n[root@linux-node1 ~]# cd /opt/\n[root@linux-node1 opt]# cd dockerfile/\n[root@linux-node1 dockerfile]# cd nginx/\n[root@linux-node1 nginx]# echo \"nginx in Docker ,hahahah\" >index.html\n[root@linux-node1 nginx]# cat Dockerfile \n# This Dockerfile is used to practice \n# Version: 1.0\n# Author: lamber\n\n# Base Image\nFROM centos\n\n# Who will take care of this image\nMAINTAINER lamber 1020561033@qq.com\n\n# Prepare Epel\nRUN rpm -ivh https://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm\n\n# Install Nginx and deal with the config file\nRUN yum -y install nginx && yum clean all\nRUN echo \"daemon off;\" >> /etc/nginx/nginx.conf\nADD index.html /usr/share/nginx/html/index.html\n\n# Run\nEXPOSE 80\nCMD [\"nginx\"]\n```\n\n说明：\n\n- FROM：这个镜像的妈是谁，指定基础镜像，除了注释外的第一行必须是他。如果本地没有这个镜像，它会给你pull下来。\n- MAINTAINER：告诉别人谁负责养他，指定维护者的信息\n- RUN：你想让他干啥，在命令前面加上RUN就可以了。\n- ADD：给它点创业资金，copy文件进去，会自动解压\n- WORKDIR：我是cd，今天刚化了妆（设置当前的工作目录）\n- VOLUME：给它一个存放行李的地方，设置卷，挂载主机目录\n- EXPOSE：它要打开的门是啥，指定对外的端口\n- CMD：奔跑吧，兄弟，指定容器启动后要干的事情\n\n构建docker镜像（后面那个点就是在当前目录，意思是告诉docker去哪里找这个dockerfile，一个点就是在当前目录找dockerfile，这个你也可以写绝对路径也是ok的），然后创建容器：\n\n```shell\n[root@linux-node1 nginx]# docker build -t mynginx:v2 .\n[root@linux-node1 nginx]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmynginx             v2                  5104f2ed9887        5 seconds ago       280.7 MB\nnginx/mynginx       v1                  81f1607bb8a0        32 minutes ago      355 MB\ndocker.io/nginx     latest              5e69fe4b3c31        3 days ago          182.5 MB\ndocker.io/centos    latest              98d35105a391        2 weeks ago         192.5 MB\n[root@linux-node1 nginx]# docker run --name mynginxv2 -d -p 82:80 mynginx:v2 nginx\na1efc632ba6d2412c3bc9fded592ca289c0f6c14dd1832118fc52539a2c1123f\n```\n\n起来以后我们就可以在网页端进行测试了！\n\n## 附录：Dockerfile指令详解\n\n下面我们来分别介绍下上面使用到的命令：\n\n#### FROM\n\n- 格式：FROM `<image>` 或FROM `<image>:<tag>`。\n- 解释：FROM是Dockerfile里的第一条指令（必须是），后面跟有效的镜像名（如果该镜像你的本地仓库没有则会从远程仓库Pull取）。然后后面的其它指令FROM的镜像中执行。\n\n#### MAINTAINER\n\n- 格式：MAINTAINER  `<name>`\n- 解释：指定维护者信息。\n\n#### RUN\n\n格式：RUN `<command>` 或 RUN [\"executable\", \"param1\", \"param2\"]。 解释：运行命令，命令较长使可以使用\\来换行。推荐使用上面数组的格式\n\n#### CMD\n\n```\n格式：\n   CMD [\"executable\",\"param1\",\"param2\"] 使用 exec 执行，推荐方式；\n   CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；\n   CMD [\"param1\",\"param2\"] 提供给ENTRYPOINT的默认参数；\n```\n\n解释： CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令。\n\n#### ENTRYPOINT\n\n```\n格式：\n   ENTRYPOINT [\"executable\", \"param1\",\"param2\"]\n   ENTRYPOINT command param1 param2（shell中执行）。\n```\n\n解释：和CMD类似都是配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。 每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。ENTRYPOINT没有CMD的可替换特性，也就是你启动容器的时候增加运行的命令不会覆盖ENTRYPOINT指定的命令。\n\n所以生产实践中我们可以同时使用ENTRYPOINT和CMD，例如：\n\n```\nENTRYPOINT [\"/usr/bin/rethinkdb\"]\nCMD [\"--help\"]\n```\n\n#### USER\n\n- 格式：USER daemon\n- 解释：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户。\n\n#### EXPOSE\n\n- 格式：EXPOSE `<port> [<port>…]`\n- 解释：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。\n\n#### ENV\n\n```\n格式：\nENV <key> <value>\nENV <key>=<value> ...\n```\n\n解释：设置环境变量，可以在RUN之前使用，然后RUN命令时调用，容器启动时这些环境变量都会被指定\n\n#### ADD\n\n```\n格式：\n   ADD <src>... <dest>\n   ADD [\"<src>\",... \"<dest>\"]\n```\n\n解释：将指定的<src>复制到容器文件系统中的<dest> 所有拷贝到container中的文件和文件夹权限为0755,uid和gid为0 如果文件是可识别的压缩格式，则docker会帮忙解压缩\n\n#### VOLUME\n\n- 格式：VOLUME [\"/data\"]\n- 解释：可以将本地文件夹或者其他container的文件夹挂载到container中。\n\n#### WORKDIR\n\n- 格式：WORKDIR/path/to/workdir\n- 解释：切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。\n\n可以多次切换(相当于cd命令)， 也可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\n\n```\n例如\nWORKDIR /a\nWORKDIR b\nWORKDIR c\nRUN pwd\n则最终路径为 /a/b/c。\n```\n\n#### ONBUILD\n\nONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行\n\n#### ARG\n\n- 格式：ARG `<name>[=<default value>]`\n- 解释：ARG指定了一个变量在docker build的时候使用，可以使用--build-arg  `<varname>=<value>`来指定参数的值，不过如果构建的时候不指定就会报错。\n\n参考自运维社区：https://mp.weixin.qq.com/s/A8KSp3zmpL_u9a2aYv8WYw","timestamp":1526281685638},{"name":"05-Docker镜像生产实战.md","path":"02-Docker/05-Docker镜像生产实战.md","content":"","timestamp":1526281685638},{"name":"06-Docker-registetry.md","path":"02-Docker/06-Docker-registetry.md","content":"","timestamp":1526281685638}]