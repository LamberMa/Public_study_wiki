# 持久化

> 将数据从掉电容易失去的内存放到可以永久存储的设备上，保证了数据的安全性，并且也可以让服务器在重启的时候载入持久化文件来还原服务器在关闭之前的数据键数据，或者使用持久化文件来进行数据备份和数据迁移的工作。redis的持久化功能可以将服务器包含的所有数据库以二进制文件的形式保存到硬盘里，一定程度上节省了空间。
>
> **redis为什么需要持久化**
>
> - Redis是基于内存的
> - 缓存服务器，作为缓存，数据丢失可能损失并不是很大
> - 内存数据库，数据丢失影响就很大了。
> - 消息队列

## redis持久化方式

### RDB（Redis DB）

#### 创建RDB三种最常见的方式

1. 服务器执行客户端发送save命令

   ```shell
   # 在手动执行save命令的过程中，也是rdb文件的创建过程中，redis服务器将被阻塞，无法处理客户端发送的命令请求，只有save命令执行完毕之后，rdb文件生成之后，服务器才会重新开始处理客户端发送的命令请求。如果说rdb文件已经存在，服务器将自动使用心得rdb文件替代就的rdb文件。

   # 我们可以写一个定时的任务，定期的去把dump.rdb转移走。相当于一个备份，防止有人flushdb然后save。给自己留一个后路，同时保存固定的数量个，然后用对应的时间命名。这样操作同样也是为了防止机房出现硬件级别的问题。
   ```

2. 服务器执行客户端发送bgsave命令

   ```shell
   # bgsave也会创建一个新的rdb文件，和save不同的地方在于，bgsave不会造成redis服务的阻塞，在执行bgsave的时候，服务器仍然可以接受用户的请求的。

   # 不会造成则色的原因有以下三个
   # 1、redis在接收到一个bgsave命令的时候它不是自己创建rdb文件，而是fork出来一个子进程去处理rdb文件的创建工作，自己继续去处理用户的请求
   # 2、当子进程创建好rdb文件并退出的时候会向父进程(也就是负责处理命令处理的redis服务器)发送一个讯号，告知它这个rdb文件已经创建完毕了。
   # 3、redis服务器(父进程)接收子进程创建的rdb文件bgsave执行完毕

   # bgsave本身是一个异步的过程，发送命令客户端会立即得到回复，但是实际操作在回复之后才会开始。

   # 创建子进程，会消耗额外的内存，所以save创建会比bgsave稍微快一些，这两种没有好坏之分，而是哪一种更适合你，比如数据库在线上跑着，那肯定要用bgsave，如果停机维护那就save，因为即使被阻塞也没有什么影响，停机期间，没有用户请求的。
   ```

   ![](http://omk1n04i8.bkt.clouddn.com/18-5-2/21724319.jpg)

   ![](http://omk1n04i8.bkt.clouddn.com/18-5-2/28727078.jpg)

3. 使用save配置选项设置自动保存，服务器自动执行bgsave

   - save 300 10：表示距离上一次创建rdb文件过去了300s，并且服务器的所有数据库总共发生了不少于10次的修改，那么就执行bgsave命令。
   - save 60 10000：距离上一次创建rdb文件过去了60s，并且服务器的所有数据库总共发生了不少于10000次修改，那么就执行bgsave命令
   - 另外，用户还可以通过设置多个save选项来设置多个启动保存的条件，当任意一个条件被满足的时候就会执行这个bgsave的命令。每一次创建rdb文件后，服务器为实现自动持久化而设置的时间计数器和次数计数器就会被清零并开始重新技术，所以说多个保存条件效果是不会互相叠加的。

#### 配置项

在配置文件中设置rdb文件的文件名和文件位置

```shell
# The filename where to dump the DB
dbfilename dump.rdb
```

自动保存的配置

```shell
# 这个你可以写多条
save 900 1
save 300 10
save 60 10000
```

#### RDB文件内容

![](http://omk1n04i8.bkt.clouddn.com/18-5-2/88585687.jpg)

rdb文件是一个二进制文件，它保存了redis服务器创建rdb文件的时候所有数据库的数据。

#### 问题

- rdb是单文件，如果库很大的话文件也会很大，查询起来，速度也会受到影响。
- rdb文件操作也不能太过频繁，过于频繁会严重影响服务器的性能。
- 重启以后redis会自己读取rdb文件加载到内存中。从配置中的dir获取目录
- 可以通过lastsave查看最后一次备份成功的时间
- 执行flushdb命令也会产生dump.rdb文件，但里面是空的，没有意义。

### AOF（AppendOnlyFile）

> RBD持久化还是存在一些问题的，一个是频繁操作可能存在性能的损耗，再有就是在配置文件中体现的那些自动执行bgsave的触发条件，随便拿一个`save 60 10000`来讲，即使一分钟内修改超过了1w次，那么要等一分钟以后才会重新生成一个文件，这期间其实就存在说突然宕机的可能。那这个时间段内的数据就极有可能丢失。针对那些对数据的一致性要求很高的环境，rdb就存在一定的缺陷，因此针对这个问题，还有一种持久化方式，那么就是AOF的持久化方式。

AOF持久化有一个很大的优势那就是，用户可以根据自己的需要对AOF持久化进行调整，让redis在遭遇意外宕机或者停机的时候不丢失数据，或者丢失的数据很少很少，比如丢失前1s的数据。这个可以把损失降到最低。

#### AOF原理

AOF持久化的操作原理是被当有**<u>修改数据库的命令</u>**被执行的时候，服务器就会将执行的命令写入到AOF文件的末尾。和RDB不一样，AOF保存的是执行的操作，而不是数据本身。因为AOF文件里储存了服务器执行过的所有数据库修改的命令，所以给定一个AOF文件，服务器只要重新执行一遍AOF文件里面包含的所有命令，就可以达到还原数据库的目的。

![](http://omk1n04i8.bkt.clouddn.com/18-5-2/39781256.jpg)

举一个AOF文件记录的内容的例子，比如：

```shell
SELECT 0
SET msg "hello"
INCR counter
SADD alphabets "a" "b" "c"
INCR counter
```

#### 安全性问题

虽然服务器执行一个修改数据库的命令，就会把执行的命令记录到AOF文件中，但这个并不意味着AOF持久化一点数据也不会丢，在目前常见的操作系统中，执行系统调用函数write函数，将一些内容写到某个文件里面的时候为了提高效率，系统通常不会直接将内容写入到硬盘里，而是先放到一个内存的缓冲区（buffer）里面，缓冲区满了，或者用户手动执行fsync调用和fdatasync调用的时候才会将缓冲区的内容写到硬盘里。

因此对于AOF来说，当一条命令真正的被写到硬盘里后才是真正意义上的保存住了。因此AOF持久化在遭遇停机时丢失命令的数量，取决于命令被写入到硬盘的时间，越早的将命令写到硬盘，发生意外丢失的数据就越少，反之丢失的就越多。

##### appendfsync

```shell
# appendfsync always
appendfsync everysec
# appendfsync no
```

为了控制redis服务器遇到意外停机而导致数据丢失，redis的aof持久化提供了一个appendfsync选项，这个选项的值可以是always，everysec或者是no。

- no：就是服务器不主动调用fdatasync，这个操作让操作系统自行去决定写入硬盘的时机，这个在遭遇问题的时候丢失的数据量其实是不可控的。
- Always：服务器的每写入一个命令，就调用一次fdatasync，将修改写入到应硬盘，这种模式下，即使遭遇意外停机，也不会丢失任何已经成功操作的命令数据。
- Everysec：一秒执行一次fdatasync，较always频率要低，如果遭遇了宕机也就是丢失一秒钟内的执行的命令数据。

因为always是执行一个就写一次，所以这个其实是运行速度最慢的，其他的两个都很快。建议使用的是everysec，同时默认值也是everysec。

#### AOF中的冗余命令

随着服务器的运行，不断的记录数据库的变化，AOF文件的体积是不断增加的。所以针对AOF文件的大小要进行合理的控制，针对这个问题redis提供了一个aof重写的功能，通过这个功能，服务器可以生成一个新的aof文件。

- 新的aof文件记录的数据库数据和原有的aof文件记录的数据库数据完全一样。
- 新的aof文件会使用极可能少的命令来记录数据库数据，因此新的aof文件的体积通常会比原有的aof文件体积小很多。
- aof重写期间，服务器不会被阻塞，可以正常处理客户端发送的命令请求。

简单来讲就是在保证数据一致性完整性的前提下将命令进行一定程度的精简从而达到节省空间的目的，比如：

![AOF缩减](http://omk1n04i8.bkt.clouddn.com/18-5-2/75273038.jpg)

**控制AOF重写的方式**

1. 客户端向服务器发送`BGREWRITEAOF`命令
2. 通知配置选项来让服务器自动执行`bgwriteaof`，命令。
   - auto-aof-rewrite-min-size：触发aof重写需要的最小的体积，只要aof文件的体积大于等于这个size的时候服务器才会考虑是否需要进行aof重写，这个选项用于避免对体积过小的aof文件重写
   - auto-aof-rewrite-percentage：指定触发重写所需要的aof体积的百分比，当aof的文件体积大于`auto-aof-rewrite-min-size`指定的体积的时候，并且超过上一次重写之后的aof文件体积的`percent%`，就会触发重新。如果服务器刚重启，还没有进行过aof重写，那么使用服务器启动时载入的aof文件的体积来作为基准值，如果将这个值设置为0的时候表示关闭aof的重写。（怎么理解这个例子，比如设置的最小大小，如果这个百分比设置为100，也就是AOF文件的增量大于100%以后才会触发重写。）

#### AOF配置

```shell
appendonly no
appendfilename "appendonly.aof"
appendfsync everysec
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

#### Tip

由于aof记录的是操作命令，所以说如果有人手贱执行了flushdb的话那么在aof的文件中也会有这个内容，紧急情况下，也可以手动编辑aof的备份文件，把最后执行的flushdb这条记录的内容手动删掉。所以说AOF文件里有FLUSHALL这个其实挺坑的。

假如说aof的备份文件有问题的话，比如我手动给aof文件的末尾加了一堆乱起八糟的字符。会导致aof备份文件无法成功加载，进而导致redis服务根本起不来。如果说aof文件有问题可以使用自带的修复软件进行修复

```shel
redis-check-aof --fix appendonly.aof
```

## 小结

![](http://omk1n04i8.bkt.clouddn.com/18-5-2/29823792.jpg)

一般来说为了数据的安全性，可以两种持久化都开启。然后还原数据的时候优先使用aof的数据进行还原。rdb适合大规模的数据恢复，但是对数据的一致性和完整性要求不高。RDB更适合备份数据库，所以以后在做主从的时候slave上可以只开rdb持久化，15min备一次就够。只保留save 900 1.当然这个只是一个建议值，具体还是要结合实际环境来。

如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。


如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构