# Mysql

**delete和truncate的区别是什么？**

```
1、truncate和delete只删除表数据不删除表的定义，但是drop会删除掉表的结构被依赖的约束，触发器，索引；依赖这个表的存储过程和函数将会被保留，但是会变为invalid的状态。
2、delete语句是数据库操作语言(DML)，这个操作会翻到rollback segement中，事物提交之后才生效；如果有相应的trigger，执行的时候将被处罚。
3、truncate和drop的操作是立即生效的，原数据不放到rollback segement中，不能回滚，操作不触发trigger。
4、delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动；drop 语句将表所占用的空间全部释放。truncate 语句缺省情况下将空间释放到 minextents个extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。
5、速度来讲，drop最快，其次是truncate，最后是delete。
6、安全性上来讲，小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及；使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.想删除表,当然用 drop；想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。
7、delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。
8、TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同：二者均删除表中的全部行。但TRUNCATE TABLE   比DELETE速度快，且使用的系统和事务日志资源少。DELETE语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 这是truncate比delete速度快的原因。
9、TRUNCATE TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用DROP TABLE语句。 
10、对于由外键约束引用的表，不能使用TRUNCATE TABLE，而应使用不带WHERE子句的DELETE语句。由于   TRUNCATE TABLE不记录在日志中，所以它不能激活触发器。  
11、TRUNCATE   TABLE   不能用于参与了索引视图的表。
```

**加索引的逻辑**

```
什么情况下需要家索引？是开发和你说加哪个字段就加哪个字段么？需要给所有用的字段加索引么？
1、首先索引不是加的越多就越好的，首先索引是要占用空间的。
2、一个表的主键一般要建立索引。
3、where子句中经常会用到的筛选条件应该添加索引，适用的还有group by，order by等；
4、更新频繁的字段不适合创建索引。不会出现在where子句中的字段也不适合创建索引。
5、当表数据过大的时候就应该加索引了，比如超过300条后加索引。
6、索引应该建立在小字段上，占用空间小，而不应该建立在text字段等超长文本字段，索引效率会大大降低。
7、复合索引的建立需要进行仔细分析，尽量考虑使用单字段索引代替：
   ① 正确选择复合索引中的主列字段，一般是选择性较好的字段
   ② 复合索引的字段是否经常同时以AND方式出现在where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
   ③ 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
   ④ 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
   ⑤ 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
```

