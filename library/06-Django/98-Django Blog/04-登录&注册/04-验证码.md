# 验证码

> 如何使用python来处理登录或者注册界面的验证码

环境准备：

```python
# 依托于PIL库，因此首先要去安装，就和php用gd库一样
pip install pillow
```

## 基本使用

### 创建图片

```python
from PIL import Image
# 创建一张画布图片，模式为RGB，大小宽高，颜色为这三个颜色
img = Image.new(mode='RGB', size=(120, 30), color=(255, 255, 255))
 
# 在图片查看器中打开
# img.show() 
 
# 保存在本地
with open('code.png','wb') as f:
    img.save(f,format='png')
```

### 创建画笔在图片上绘画

```python
# 使用ImageDraw.Draw创建一只画笔用来绘画
img = Image.new(mode='RGB', size=(120, 30), color=(255, 255, 255))
draw = ImageDraw.Draw(img, mode='RGB')

# 画点，第一个参数：表示坐标；第二个参数：表示颜色，颜色可以使用单词，可以使用rgb颜色
draw.point([100, 100], fill="red")
draw.point([300, 300], fill=(255, 255, 255))

# 画线，两个点确定一个线
# 第一个参数：表示起始坐标和结束坐标
# 第二个参数：表示颜色
draw.line((10, 10, 100, 20), fill='red')
draw.line((10, 10, 100, 30), fill=(255, 255, 255))

# 画圆，与其说画圆不如说是画扇形，确定两个坐标点，然后以这两个坐标点为对角线画出一个长方形，在这个长方形里面画圈。
# 第一个参数：表示起始坐标和结束坐标（圆要画在其中间）
# 第二个参数：表示开始角度
# 第三个参数：表示结束角度
# 第四个参数：表示颜色
draw.arc((10,10,30,30),0,90,fill="red")

# 写字
# 第一个参数：表示起始坐标
# 第二个参数：表示写入内容
# 第三个参数：表示颜色
draw.text([0,0],'python',"red")

# 写入特殊字体的文字
# 第一个参数：表示字体文件路径
# 第二个参数：表示字体大小
from PIL import ImageFont
font = ImageFont.truetype("kumo.ttf", 28)
# 第一个参数：表示起始坐标
# 第二个参数：表示写入内容
# 第三个参数：表示颜色
# 第四个参数：表示颜色
draw.text([0, 0], 'python', "red", font=font)
```

## 通过PIL制作图片验证码

> Httpresponse可以返回字符串也可以返回自己留，因此可以动态的去生成图片去显示。
>
> 直接返回内容为：`return HttpResponse(data)`其中data为字节流，那么生成的验证码图片应该放到什么位置呢？首先不能放到磁盘中。我们可以直接在内存中开辟一块空间用来保存这个内容。

### 随机字符串

首先要写字，如何生成随机字符串呢？

```python
# 文件名：random_check_code.py
# 生成随机字符串，可以使用列表生成式的形式生成随机字符串，但是为了可以对每一个
# 字符做单独的处理，因此不这么处理
# char_list = ''.join([chr(random.randint(65, 90)) for i in range(5)])
import random
char_list = []
for i in range(5):
    char = chr(random.randint(65, 90))
    char_list.append(char)
    font = ImageFont.truetype('static/font/kumo.ttf', 28)
    draw.text([i * 24, 0], char, (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)), font=font)
code = ''.join(char_list)
```

### 保存位置

上面说到图片是不能保存到服务器的存储中的，所以可以临时在内存开辟一块空间去保存这个临时的验证码，需要引用的包如下：

```python
from io import BytesIO
# 这个其实和打开文件很相似，创建一个文件句柄stream
steam = BytesIO()
# 将图片内容保存到文件句柄中(字节流)，这里format可以省略，直接写成png
img.save(stream, format='png')
# 读取写到内存的内容
data = steam.getvalue()


/---------Py3和py2写入内存的方式不太一样---------------/
1. 写入内存(Python3)
from io import BytesIO
stream = BytesIO()
img.save(stream, 'png')
stream.getvalue()

2. 写入内存（Python2）
import StringIO
stream = StringIO.StringIO()
img.save(stream, 'png')
stream.getvalue()
```

### 封装成一个组件工具

```python
import random
# ImageFilter加滤镜，让色差更强一点
from PIL import Image, ImageDraw, ImageFont, ImageFilter


def rd_check_code(width=120, height=30, char_length=5, font_file='static/font/kumo.ttf', font_size=28):
    """
    图片宽高，字符长度，字体路径，字体大小。
    """
    code = []
    img = Image.new(mode='RGB', size=(width, height), color=(255, 255, 255))
    draw = ImageDraw.Draw(img, mode='RGB')

    def rndchar():
        """
        生成随机字母
        :return:
        """
        return chr(random.randint(65, 90))

    def rndColor():
        """
        生成随机颜色
        :return:
        """
        return (random.randint(0, 255), random.randint(10, 255), random.randint(64, 255))

    # 写文字
    font = ImageFont.truetype(font_file, font_size)
    for i in range(char_length):
        char = rndchar()
        code.append(char)
        h = random.randint(0, 4)
        draw.text([i * width / char_length, h], char, font=font, fill=rndColor())

    # 写干扰点
    for i in range(40):
        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())

    # 写干扰圆圈
    for i in range(40):
        draw.point([random.randint(0, width), random.randint(0, height)], fill=rndColor())
        x = random.randint(0, width)
        y = random.randint(0, height)
        draw.arc((x, y, x + 4, y + 4), 0, 90, fill=rndColor())

    # 画干扰线
    for i in range(5):
        x1 = random.randint(0, width)
        y1 = random.randint(0, height)
        x2 = random.randint(0, width)
        y2 = random.randint(0, height)

        draw.line((x1, y1, x2, y2), fill=rndColor())
    # 设置色差
    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)
    return img, ''.join(code)
```

这样我们就可以把这个工具类放到一个工具目录下，用到的时候直接调用就可以了，比如说放到utils目录下

```python
# views.py
from io import BytesIO
from utils.random_check_code import rd_check_code

def check_code(request):
    img, code = rd_check_code()
    stream = BytesIO()
    img.save(stream, 'png')
    request.session['code'] = code
    # 把内存中读取到的图片内容返回就可以了。
    return HttpResponse(stream.getvalue())
```

那么在前端我们可以如何去使用呢？

```html
# src的实质其实也是把图片读取后放到内存中然后再呈现给用户
# 那么我们可以直接把放到内存中的内容放到这里显示就可以了。
<div class="col-sm-5">
    <img id='i1' title='点击更新' onclick="changeCode(this);" src="/check_code" alt="" style="width: 120px;height: 30px;">
</div>
```

路由配置：

```python
path('check_code/', views.check_code),
```

