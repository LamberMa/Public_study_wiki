# Form组件内部实现原理

### Form验证执行流程以及钩子

1. 验证字段is_vaild→self.is_bound and not self.errors如果self.is_bound是true就做绑定元整，否则就返回false。当实例化Form对象的时候为data就是绑定数据会做校验，如果是initial那么is_bound就是false。不做验证。

   ```python
   def is_valid(self):
       """Return True if the form has no errors, or False otherwise."""
       return self.is_bound and not self.errors
   ```

2. 

self.errors→self.full_clean()开始验证→self.cleaned_data是空的—self._clean_fields—遍历fields中的所有字段；value = fields.clean(value) 把值按照正则做校验。验证成功后：

self.cleaned_data[name] = value

对象中含有‘clean_属性名’，并且可以执行相对应的函数名的函数。也就是说：

```python
# 有如下的代码
class TestForm(Form):
    user = fields.CharField()  # 执行顺序1
    pwd = fileds.CharField()   # 执行顺序3
    
    # 这个函数会在内部被调用，如果有这个方法就执行没有就不执行，内部通过反射去判断的。
    # 上面只能是正则判断，在方法中就可以进行进一步的高级验证了，比如数据库判断
    # 如果正则表达式都没有通过，那么这里的函数就不会执行了。所以在正则没有验证成功后
    # 会抛出一个异常ValidationError然后，假如一个错误
    # self.add_error(name, e)
    # 所以这个扩展函数没有通过的时候我们也可以抛出一个异常添加到error中
    def clean_user(self):   # 执行顺序2
        # clean_user中不能取pwd的值，因为这回pwd的值还不在字典里呢
        # 因此最好只取自己的值，除非在你执行这一部分的时候其他的值已经加进去了。
        v = self.cleand_data['user']
        from django.core.exceptions import ValidationError
        if models.Student.objects.filter(name=v).count():
            # 这里的code就是之前定制的error_message的key
            # 默认不写就是invalid
            raise ValidationError('User exists', code='invalid')
        # 一定要返回一个值，因为django内部要重新赋值，否则会赋值为None
        return xxx
    
    def clean_pwd(self):   # 执行顺序4
        return self.cleaned_data['pwd']
```

验证通过后走下一句self._clean_form(self)，此时self_cleaned_data有值了，否则就是一个空字典→cleaned_data = self.clean()→找到这个self.clean()方法，可以看到注释说明这是一个钩子，用户扩展的。这个我们自己也可以进行自定义:

```python
# 有如下的代码
class TestForm(Form):
    user = fields.CharField()  # 执行顺序1
    pwd = fileds.CharField()   # 执行顺序3

    def clean_user(self):   
        v = self.cleand_data['user']
        from django.core.exceptions import ValidationError
        if models.Student.objects.filter(name=v).count():
            raise ValidationError('User exists', code='invalid')
        return xxx
    
    def clean_pwd(self):   # 执行顺序4
        return self.cleaned_data['pwd']
    
    def clean(self):
        # 举例子做一个联合唯一的判断，对用户和密码做整体判断
        user = self.cleaned_data.get('user')
        email = self.cleaned_data.get('email')
        # 数据库验证
        if models.Student.objects.filter(user=user,email=email).count():
            # 整体存在就别添加了。
            raise ValidationErrors('用户名已经存在')
        return self.cleaned_data
```

最后一个self._post_clean(self)也是用来自定义的。

```python
# 有如下的代码
class TestForm(Form):
    user = fields.CharField()  # 执行顺序1
    pwd = fileds.CharField()   # 执行顺序3

    def clean_user(self):   
        v = self.cleand_data['user']
        from django.core.exceptions import ValidationError
        if models.Student.objects.filter(name=v).count():
            raise ValidationError('User exists', code='invalid')
        return xxx
    
    def clean_pwd(self):   # 执行顺序4
        return self.cleaned_data['pwd']
    
    def clean(self):
        pass
    
    def _post_clean(self):
        """
        也是自定制的内容，一般用不到这个内容
        如果要用到的话记得自己加异常处理。
        """
        pass
```

自定义验证规则



