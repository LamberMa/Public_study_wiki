# 小结

TCP和UDP之间的区别：

```
1 TCP是流式的，UDP发送的是报文，udp会封装消息报头。
2 tcp是可靠的，udp是不可靠的，因为tcp是面向链接的，udp是不面向链接的
```

多线程多进程应用

```
首先说进程和线程，进程是一个资源单位，线程是一个调度单位，进程的资源是独立的，而线程的资源是可以共享的，那么多进程就有一个问题就是多进程势必户进行资源的占用。

CPython中有一个问题就是GIL锁，GIL锁在同一时刻只可以允许一个进程中的一个线程出去去使用cpu，因此即使使用多线程，但是同一时刻，一个进程中还是只能有一个线程去使用cpu。那么多进程是可以并行处理问题的，所以说多进程的一个有段就是可以利用多核。

二者的适用范围：
- 多进程：适用于计算密集型，处理器使用频繁但是IO操作少。比如金融分析
- 多线程：适用于IO密集型，处理器使用不是那么频繁的操作
```

黏包问题怎么解决

````
# 起因
因为tcp的数据是流式的，因此多张图发送从用户空间转到系统空间所有的内容都连在一起了，在另一端接收的时候只会接收指定的长度receive(length)，因此有可能接收的长度有一个数据和另外一个数据黏在一起了。
# 解决办法
避免黏包的问题，主要还是要知道一个完整的数据的头和尾，以及文件的长度，我知道文件长度是多少了，我就可以指定接收多少的长度把这个长度接收完了那么这就是这个文件。方法其一就是已知长度接收长度，另外一种方法就是封装一个报头，其中包含文件的长度，以及其他信息，然后将报头压缩，在接收端接收的时候先把报头读取出来，然后就知道文件该接受多少了。
````

线程与协程（切换机制）

```
首先从切换执行者的角度说明：
线程的切换者：处理器（CPU）
协程的切换者：程序开发人员，人为的去控制

线程切换的时机：
- 达到了规定的使用时间片
- 遇到了IO操作

协程首先就是一个线程，所以不涉及到切换的问题。这个是用户态的，协程拥有自己的寄存器上下文和栈，在切换的时候可以将上下文保存到其他的位置，切换回来的时候可以进行状态的恢复，可以进行人为的控制。
```

四个IO机制

```
1.阻塞性IO
一个同步的过程，如果没接收到对应的数据的话，用户态的数据会一直卡住持续等待。
2.非阻塞性IO
将一直等待给换成多次轮训去询问是否有数据，如果没有数据就返回一个error，也就是将一个持续的等待分成了多次的系统调用。这个调用期间cpu的使用权限是在进程手里的，因此还可以处理其他的内容，就好比排队办业务和叫号办业务的区别。
3.IO多路复用
将IO数据传输的整个过程拆为两部分，其中一个部分是由select去监听数据，select可以监听多个链接。
4.异步IO
用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。因此，异步IO的特点就是全程无阻塞。
```

锁的问题：

```
一般遇到有锁的问题大多是因为有资源数据共享的问题。要保证数据的一致性，一般会在处理数据的线程上加一把锁，加锁期间其他人需要进行锁等待，待处理完成以后进行锁释放，其他人才可以正常使用。
这个就是说到的互斥锁。当然锁是会出现死锁问题的，比如一个资源在请求一个资源的时候对已经获得的资源并不进行释放。这就可能产生死锁的问题。
```

