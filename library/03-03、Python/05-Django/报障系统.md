# 报障系统

> 背景：解决内外运维人员工作数字化
>
> 需求分析：
>
> - 报障
> - 知识库

## 1、数据库设计

- 用户，文章，点赞，评论
- 用户之间互粉，文章标签
- 个人博客主题定制

```python
class UserInfo(models.Model):
    """用户表"""
    nid = models.BigAutoField(primary_key=True)
    username = models.CharField(verbose_name='用户名', max_length=32, unique=True)
    password = models.CharField(verbose_name='密码', max_length=64)
    nickname = models.CharField(verbose_name='昵称', max_length=32)
    email = models.EmailField(verbose_name='邮箱', unique=True)
    avatar = models.ImageField(verbose_name='头像')
    create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True)
    fans = models.ManyToManyField(
        verbose_name='粉丝',
        to='UserInfo',
        # 自定义的关联
        through='UserFans',
        through_fields=('user', 'follower')
        related_name='f',
    )
    
    
class UserFans(models.Model):
    """互粉关系表"""
    user = models.ForeignKey(verbose_name='博主', to='UserInfo', to_field='nid', related_name='users')
    follower = models.ForeignKey(verbose_name='粉丝', to='UserInfo', to_field='nid', related_name='followers')
    
    class Meta:
        unique_together = [
            ('user', 'follower'),
        ]
    
    
class Blog(models.Model):
    """博客信息"""
    nid = models.BigAutoField(primary_key=True)
    title = models.CharField(verbose_name='个人博客标题', max_length=64)
    site = models.CharField(verbose_name='个人博客前缀', max_length=32, unique=True)
    theme = models.CharField(verbose_name='博客主题', max_length=32)
    # 博客和用户是一对一的，要保证每个用户的博客是唯一的。
    # OneToOne其实就是一个ForeignKey+Unique
    user = models.OneToOneField(to='UserInfo', to_field='nid')
    
    
class Category(models.Model):
    """博主个人文章分类表"""
    nid = models.AutoField(primary_key=True)
    title = models.CharField(verbose_name='分类标题', max_length=32)
    blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid')
    

class Tag(models.Model):
    """标签表"""
    nid = models.AutoField(primary_key=True)
    title = models.CharField(verbose_name='标签名称', max_length=32)
    blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid')
    
 
class Article(models.Model):
    nid = models.BigAutoField(primary_key=True)
    title = models.CharField(verbose_name='文章标题', max_length=128)
    summary = models.CharField(verbose_name='文章简介', max_length=255)
    # 阅读个数，评论个数，赞的个数，踩的个数
    read_count = models.IntegerField(default=0)
    comment_count = modesl.IntegerField(default=0)
    up_count = modesl.IntegerField(default=0)
    down_count = modesl.IntegerField(default=0)
    create_time = models.DateTimeField(verboseA_name='创建时间', auto_now_add=True)
    # 所属博客和分类
    blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid')
    category = models.ForeignKey(verbose_name='文章类型', to='Category', to_field='nid', null=True)
     
    type_choices = [
        (1, "Python"),
        (2, "Linux"),
        (3, "OpenStack"),
        (4, "GoLang"),
    ]
    article_type_id = models.IntegerField(choices=type_choices, default=None)
    tags = models.ManyToManyField(
        to="Tag",
        through='Article2Tag',
        through_fields=('article', 'tag'),
    )

    
class Article2Tag(models.Model):
    article = models.ForeignKey(verbose_name='文章', to='Article', to_field='nid')
    tag = models.ForeignKey(verbose_name='标签', to='Tag', to_field='nid')
    
    class Meta:
        unique_together = [
            ('article', 'tag'),
        ]
    
    
class ArticleDetail(models.Model):
    """
    文章详细表
    1、文章标题，文章简洁，文章内容
    2、外键关联文章的发布者到用户的博客，因此要有一个博客id
    3、一个文章只能选择一个分类，但是允许一篇文章选择多个标签
    4、文章内容不要和文章表放在一起，拆开，然后再做一个一对一的关联
    """
    content = models.TextField(verbose_name='文章内容',)
    article = models.OneToOneField(verbose_name='所属文章', to='Article', to_field='nid')
    
    
class Comment(models.Model):
    """
    评论表：
    1、需要有用户id，而不是博客id，因为不注册博客也可以评论。
    """
    nid = models.BigAutoField(primary_key=True)
    content = models.CharField(verbose_name='评论内容', max_length=255)
    create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True)
    reply = models.ForeignKey(verbose_name='回复评论', to='self', related_name='back', )
    article = models.ForeignKey(verbose_name='评论文章', to='Article', to_field='nid')
    user = models.ForeignKey(verbose_name='评论用户', to='UserInfo', to_field='nid')
    
class UpDown(models.Model):
    """
    点赞表：
    1、文章id，用户id，赞还是踩
    """
    article = models.ForeignKey(verbose_name='文章', to='Article' to_field='nid')
    user = models.ForeignKey(verbose_name='赞或踩用户', to='UserInfo', to_field='nid')
    up = models.BooleanField(verbose_name='是否赞')
    class Meta:
        unique_together = [
            ('article', 'user'),
        ]
```

要点：

- ImageField依赖Pillow，因此需要安装pillow：`pip install Pillow`
- ​





主页筛选，分页，登录成功显示个人信息，登录，验证码，使用Django的Form组件

做注册页面，多加一个上传个人头像，

 **Blog功能概要**

`models.Article.objects.filter(blog__site='wupeiqi')`

主题定制：

```html
<link rel=xxx href='/static/xxx/theme/{{ blog.theme }}.css'>
```

其实就是定制多套css文件，根据不同的主题名称调用不同的css

上传完头像以后要有预览，是上传完了以后就要有预览，而不是点了提交以后有预览。

```shell
(blog1) ➜  django-blog-master > python manage.py makemigrations -h   
usage: manage.py makemigrations [-h] [--version] [-v {0,1,2,3}]
                                [--settings SETTINGS]
                                [--pythonpath PYTHONPATH] [--traceback]
                                [--no-color] [--dry-run] [--merge] [--empty]
                                [--noinput] [-n NAME] [-e] [--check]
                                [app_label [app_label ...]]

Creates new migration(s) for apps.

positional arguments:
  app_label             Specify the app label(s) to create migrations for.

optional arguments:
  -h, --help            show this help message and exit
  --version             show program's version number and exit
  -v {0,1,2,3}, --verbosity {0,1,2,3}
                        Verbosity level; 0=minimal output, 1=normal output,
                        2=verbose output, 3=very verbose output
  --settings SETTINGS   The Python path to a settings module, e.g.
                        "myproject.settings.main". If this isn't provided, the
                        DJANGO_SETTINGS_MODULE environment variable will be
                        used.
  --pythonpath PYTHONPATH
                        A directory to add to the Python path, e.g.
                        "/home/djangoprojects/myproject".
  --traceback           Raise on CommandError exceptions
  --no-color            Don't colorize the command output.
  --dry-run             Just show what migrations would be made; don't
                        actually write them.
  --merge               Enable fixing of migration conflicts.
  --empty               Create an empty migration.
  --noinput, --no-input
                        Tells Django to NOT prompt the user for input of any
                        kind.
  -n NAME, --name NAME  Use this name for migration file(s).
  -e, --exit            Exit with error code 1 if no changes needing
                        migrations are found. Deprecated, use the --check
                        option instead.
  --check               Exit with a non-zero status if model changes are
                        missing migrations.
```

赞或者踩

### 使用Django实现多级评论

#### 前戏

```python
In [5]: v1
Out[5]: [1, 2, 3]

In [6]: id(v1)
Out[6]: 4497008776

In [7]: v1.append(123)

In [8]: v1
Out[8]: [1, 2, 3, 123]

In [9]: id(v1)
Out[9]: 4497008776
    
In [10]: v1 = {'k1':'v1'}

In [11]: id(v1)
Out[11]: 4497937608

In [12]: v1['k2'] = 'v2'

In [13]: v1
Out[13]: {'k1': 'v1', 'k2': 'v2'}

In [14]: id(v1)
Out[14]: 4497937608
    
In [28]: data
Out[28]: [[11, 22, 33], [44, 55, 66]]

In [29]: data[0].append(data[1])

In [30]: data
Out[30]: [[11, 22, 33, [44, 55, 66]], [44, 55, 66]]

In [31]: id(data[1]) == id(data[0][3])
Out[31]: True

In [32]: data[1].append(77)

In [33]: data
Out[33]: [[11, 22, 33, [44, 55, 66, 77]], [44, 55, 66, 77]]
```





#### 模拟设计一个数据结构

假设现在从数据库取出来某一篇文章的结果是一个评论列表，其中每一个元素都是一个字典，每一个字典是一条评论的信息，其中包含信息的id和内容以及从属的父级评论的id。

```python
msg_list = [
            {'id': 1, 'content': '写的太好了', 'parent_id': None},
            {'id': 2, 'content': '你说得对', 'parent_id': None},
            {'id': 3, 'content': '顶楼上', 'parent_id': None},
            {'id': 4, 'content': '你眼瞎吗', 'parent_id': 1},
            {'id': 5, 'content': '我看是', 'parent_id': 4},
            {'id': 6, 'content': '鸡毛', 'parent_id': 2},
            {'id': 7, 'content': '你是没呀', 'parent_id': 5},
            {'id': 8, 'content': '惺惺惜惺惺想寻', 'parent_id': 3},
]
```

其实我们想要的功能就是把对应的评论的子评论附加到父级评论中去，因此要我们自己去定义一个数据结构。

```
# 带child的msg_list，注意列表生成式中不能写表达式，比如row['child'] = []是不行的
# v = [row.setdefault('child', []) for row in msg_list]
# print(msg_list)
msg_list_dict = {}

for item in msg_list:
    item['child'] = []
    msg_list_dict[item['id']] = item


result = []
for item in msg_list:
    if item['parent_id']:
        msg_list_dict[pid]['child'].append(item)
    else:
        result.append(item)
# 评论层数为两层   
###################################
"""
<div class='comment'>
	<div class='content'>asdasd</div>
	<div class='content'>asdasd</div>
	<div class='content'>asdasd</div>
	<div class='content'>asdasd</div>
</div>
"""
comment_str = """"""
comment_str += "<div class='comment'>"
for row in result:
    tpl = "<div class='content'>%s</div>" % (row['content'])
    if row['child']:
        comment_str += "<div class='comment'>"
        for jow in row['child']:
            tpl = "<div class='content'>%s</div>" % (jow['content'])
            comment_str += tpl
        comment_str += "</div>"
    comment_str += tpl
comment_str += "</div>"
# 把这个内容传递到前台


# 
```





为什么字典取值快？

msg_list是数据源，msg_list_dict用户查找。



![](http://omk1n04i8.bkt.clouddn.com/18-3-7/48996755.jpg)

记得前端的代码要加上`|safe`才行。因此在用户发布文章的时候要做特殊的过滤。避免用户发布有害的内容。

文章点赞：

```html
<a onclick="up(this, {{ obj.nid }}, 0)">
  <span>👍</span>
  <i>{{ obj.up_count }}</i>
</a>

<a>
  <span>踩</span>
  <i>{{ obj.down_count }}</i>
</a>


<script>
  function up(ths, nid){
    $.ajax({
      url:'/up.html',
      data:{'val':1,'nid':nid,'csrfmiddlewaretoken':{{ csrf_token }}},
      type:"POST",
      dataType:'JSON',
      success:function(arg){
      	if(arg.status){
        	// 显示赞的个数+1
        }else{
            // 显示错误信息
        }
      }
    })
  }

function down(ths, nid){
    $.ajax({
      url:'/up.html',
      data:{'val':0,'nid':nid,'csrfmiddlewaretoken':{{ csrf_token }}},
      type:"POST",
      dataType:'JSON',
      success:function(arg){
      	if(arg.status){
        	// 显示踩的个数+1
        }else{
            // 显示错误信息
        }
      }
    })
  }
  
function updown(ths, nid, val){
    $.ajax({
      url:'/up.html',
      data:{'val':val,'nid':nid,'csrfmiddlewaretoken':{{ csrf_token }}},
      type:"POST",
      dataType:'JSON',
      success:function(arg){
      	if(arg.status == xxxx){
        	// 给前段返回特殊的状态码
        }else{
            // 显示错误信息
        }
      }
    })
  }
</script>


是哪个用户，文章踩或者赞
是谁，当前登录用户
1是赞，0是踩。


```

python

```python
def up(request):
    userid = request.session.get('user_id')
    article_id = request.POST.get('nid')
    val = request.POST.get('val')

    # 仍然会存在报错，用于捕获报错
    try:
        # 这个是针对某一个用户的点赞记录，如果有点赞记录的话就可以去到一个对象
        obj = models.UpDown.objects.filter(user_id=userid, article_id=article_id).first()
        if obj:
            pass
        else:
            # 取不到对象就可以进行添加
            if val == "0":
                # 引入事物，所谓事物就是一个整体，将下面两个操作作为原子性的操作，要成功就两个一起成功，要不成功就都不成功
                # 第一个操作是，在点赞表里添加点赞记录，第二个是在文章表里添加点赞技术，二者相辅相成，要成功就都成功。
                # 事物的作用就是对下面两个操作做限制，如果有其中一个失败，那么整个操作会回滚
                with transaction.atomic():
                    # 但是仍然要捕获异常
                    models.UpDown.objects.create(user_id=userid, article_id=article_id, up=True)
                    models.Article.objects.filter(nid=article_id).update(up_count=F('up_count') + 1)
            else:
                with transaction.atomic():
                    models.UpDown.objects.create(user_id=userid, article_id=article_id, up=False)
                    models.Article.objects.filter(nid=article_id).update(up_count=F('up_count') - 1)
    except Exception as e:
        pass
```

组合筛选





### kindEditor

> http://www.cnblogs.com/wupeiqi/articles/6307554.html

下载下来是一个zip的压缩包，解压后里面可以删除掉一些内容，比如asp、asp.net、jsp、php这些都是针对这些语言写的一些实例，在这里使用不到，可以直接干掉。



编辑器初始化参数说明：http://kindeditor.net/doc3.php?cmd=config

```
item：设置工具项，接收一个数组
noDisableItems：配合designMode要为false，可以指定某些显示的工具不让你使用
htmlTags：一个字典，限制这里只允许出现哪些标签，这些标签仅有哪些属性，但是这个功能很鸡肋。这个只是在选的时候做限制，但是当纯html代码的时候，仍然是可以提交到后端的。
```

上传图片：

针对提交内容的过滤。比如提交的内容有script标签

使用BeautifulSoap过滤违规标签：

```python
pip3 install BeautifulSoup4
```

BeautifulSoap4会把一个html文本转换成一个对象

www.cnblogs.com/wupeiqi/article/6283017.html



## 使用JS实现一个多级评论













## 用户的权限管理

根据url划分权限，所以应该要搞上一个表，保存所有的url地址，用户和权限url是一个多对多的关系。给用户的功能就搞一个url，然后通过给url传的参数不一致区分不同的功能

```html
/users.html
/users.html?md=get
/users.html?md=post
/users.html?md=edit
/users.html?md=del
```

![](http://omk1n04i8.bkt.clouddn.com/18-3-12/33596170.jpg)

一般搞权限不会定位到人，而是定位一个角色，通过角色去控制一个人应该有什么权限。

easyUi_Tree

![](http://omk1n04i8.bkt.clouddn.com/18-3-12/44631724.jpg)



### RBAC

> Role Basic Access Control基于角色的用户访问的控制。



