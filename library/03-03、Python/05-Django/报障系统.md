# 报障系统

> 背景：解决内外运维人员工作数字化
>
> 需求分析：
>
> - 报障
> - 知识库

## 数据库设计

- 用户，文章，点赞，评论
- 用户之间互粉，文章标签
- 个人博客主题定制

```python
class UserInfo(models.Model):
    """用户表"""
    nid = models.BigAutoField(primary_key=True)
    username = models.CharField(verbose_name='用户名', max_length=32, unique=True)
    password = models.CharField(verbose_name='密码', max_length=64)
    nickname = models.CharField(verbose_name='昵称', max_length=32)
    email = models.EmailField(verbose_name='邮箱', unique=True)
    avatar = models.ImageField(verbose_name='头像')
    create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True)
    fans = models.ManyToManyField(
        verbose_name='粉丝',
        to='UserInfo',
        # 自定义的关联
        through='UserFans',
        through_fields=('user', 'follower')
        related_name='f',
    )
    
    
class UserFans(models.Model):
    """互粉关系表"""
    user = models.ForeignKey(verbose_name='博主', to='UserInfo', to_field='nid', related_name='users')
    follower = models.ForeignKey(verbose_name='粉丝', to='UserInfo', to_field='nid', related_name='followers')
    
    class Meta:
        unique_together = [
            ('user', 'follower'),
        ]
    
    
class Blog(models.Model):
    """博客信息"""
    nid = models.BigAutoField(primary_key=True)
    title = models.CharField(verbose_name='个人博客标题', max_length=64)
    site = models.CharField(verbose_name='个人博客前缀', max_length=32, unique=True)
    theme = models.CharField(verbose_name='博客主题', max_length=32)
    # 博客和用户是一对一的，要保证每个用户的博客是唯一的。
    # OneToOne其实就是一个ForeignKey+Unique
    user = models.OneToOneField(to='UserInfo', to_field='nid')
    
    
class Category(models.Model):
    """博主个人文章分类表"""
    nid = models.AutoField(primary_key=True)
    title = models.CharField(verbose_name='分类标题', max_length=32)
    blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid')
    

class Tag(models.Model):
    """标签表"""
    nid = models.AutoField(primary_key=True)
    title = models.CharField(verbose_name='标签名称', max_length=32)
    blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid')
    
 
class Article(models.Model):
    nid = models.BigAutoField(primary_key=True)
    title = models.CharField(verbose_name='文章标题', max_length=128)
    summary = models.CharField(verbose_name='文章简介', max_length=255)
    # 阅读个数，评论个数，赞的个数，踩的个数
    read_count = models.IntegerField(default=0)
    comment_count = modesl.IntegerField(default=0)
    up_count = modesl.IntegerField(default=0)
    down_count = modesl.IntegerField(default=0)
    create_time = models.DateTimeField(verboseA_name='创建时间', auto_now_add=True)
    # 所属博客和分类
    blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid')
    category = models.ForeignKey(verbose_name='文章类型', to='Category', to_field='nid', null=True)
     
    type_choices = [
        (1, "Python"),
        (2, "Linux"),
        (3, "OpenStack"),
        (4, "GoLang"),
    ]
    article_type_id = models.IntegerField(choices=type_choices, default=None)
    tags = models.ManyToManyField(
        to="Tag",
        through='Article2Tag',
        through_fields=('article', 'tag'),
    )

    
class Article2Tag(models.Model):
    article = models.ForeignKey(verbose_name='文章', to='Article', to_field='nid')
    tag = models.ForeignKey(verbose_name='标签', to='Tag', to_field='nid')
    
    class Meta:
        unique_together = [
            ('article', 'tag'),
        ]
    
    
class ArticleDetail(models.Model):
    """
    文章详细表
    1、文章标题，文章简洁，文章内容
    2、外键关联文章的发布者到用户的博客，因此要有一个博客id
    3、一个文章只能选择一个分类，但是允许一篇文章选择多个标签
    4、文章内容不要和文章表放在一起，拆开，然后再做一个一对一的关联
    """
    content = models.TextField(verbose_name='文章内容',)
    article = models.OneToOneField(verbose_name='所属文章', to='Article', to_field='nid')
    
    
class Comment(models.Model):
    """
    评论表：
    1、需要有用户id，而不是博客id，因为不注册博客也可以评论。
    """
    nid = models.BigAutoField(primary_key=True)
    content = models.CharField(verbose_name='评论内容', max_length=255)
    create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True)
    reply = models.ForeignKey(verbose_name='回复评论', to='self', related_name='back', )
    article = models.ForeignKey(verbose_name='评论文章', to='Article', to_field='nid')
    user = models.ForeignKey(verbose_name='评论用户', to='UserInfo', to_field='nid')
    
class UpDown(models.Model):
    """
    点赞表：
    1、文章id，用户id，赞还是踩
    """
    article = models.ForeignKey(verbose_name='文章', to='Article' to_field='nid')
    user = models.ForeignKey(verbose_name='赞或踩用户', to='UserInfo', to_field='nid')
    up = models.BooleanField(verbose_name='是否赞')
    class Meta:
        unique_together = [
            ('article', 'user'),
        ]
```

要点：

- ImageField依赖Pillow，因此需要安装pillow：`pip install Pillow`
- ​





主页筛选，分页，登录成功显示个人信息，登录，验证码，使用Django的Form组件

做注册页面，多加一个上传个人头像，

 **Blog功能概要**

`models.Article.objects.filter(blog__site='wupeiqi')`

主题定制：

```html
<link rel=xxx href='/static/xxx/theme/{{ blog.theme }}.css'>
```

其实就是定制多套css文件，根据不同的主题名称调用不同的css

上传完头像以后要有预览，是上传完了以后就要有预览，而不是点了提交以后有预览。

```shell
(blog1) ➜  django-blog-master > python manage.py makemigrations -h   
usage: manage.py makemigrations [-h] [--version] [-v {0,1,2,3}]
                                [--settings SETTINGS]
                                [--pythonpath PYTHONPATH] [--traceback]
                                [--no-color] [--dry-run] [--merge] [--empty]
                                [--noinput] [-n NAME] [-e] [--check]
                                [app_label [app_label ...]]

Creates new migration(s) for apps.

positional arguments:
  app_label             Specify the app label(s) to create migrations for.

optional arguments:
  -h, --help            show this help message and exit
  --version             show program's version number and exit
  -v {0,1,2,3}, --verbosity {0,1,2,3}
                        Verbosity level; 0=minimal output, 1=normal output,
                        2=verbose output, 3=very verbose output
  --settings SETTINGS   The Python path to a settings module, e.g.
                        "myproject.settings.main". If this isn't provided, the
                        DJANGO_SETTINGS_MODULE environment variable will be
                        used.
  --pythonpath PYTHONPATH
                        A directory to add to the Python path, e.g.
                        "/home/djangoprojects/myproject".
  --traceback           Raise on CommandError exceptions
  --no-color            Don't colorize the command output.
  --dry-run             Just show what migrations would be made; don't
                        actually write them.
  --merge               Enable fixing of migration conflicts.
  --empty               Create an empty migration.
  --noinput, --no-input
                        Tells Django to NOT prompt the user for input of any
                        kind.
  -n NAME, --name NAME  Use this name for migration file(s).
  -e, --exit            Exit with error code 1 if no changes needing
                        migrations are found. Deprecated, use the --check
                        option instead.
  --check               Exit with a non-zero status if model changes are
                        missing migrations.
```

赞或者踩

### 使用Django实现多级评论

#### 前戏

```python
In [5]: v1
Out[5]: [1, 2, 3]

In [6]: id(v1)
Out[6]: 4497008776

In [7]: v1.append(123)

In [8]: v1
Out[8]: [1, 2, 3, 123]

In [9]: id(v1)
Out[9]: 4497008776
    
In [10]: v1 = {'k1':'v1'}

In [11]: id(v1)
Out[11]: 4497937608

In [12]: v1['k2'] = 'v2'

In [13]: v1
Out[13]: {'k1': 'v1', 'k2': 'v2'}

In [14]: id(v1)
Out[14]: 4497937608
    
In [28]: data
Out[28]: [[11, 22, 33], [44, 55, 66]]

In [29]: data[0].append(data[1])

In [30]: data
Out[30]: [[11, 22, 33, [44, 55, 66]], [44, 55, 66]]

In [31]: id(data[1]) == id(data[0][3])
Out[31]: True

In [32]: data[1].append(77)

In [33]: data
Out[33]: [[11, 22, 33, [44, 55, 66, 77]], [44, 55, 66, 77]]
```





#### 模拟设计一个数据结构

假设现在从数据库取出来某一篇文章的结果是一个评论列表，其中每一个元素都是一个字典，每一个字典是一条评论的信息，其中包含信息的id和内容以及从属的父级评论的id。

```python
msg_list = [
            {'id': 1, 'content': '写的太好了', 'parent_id': None},
            {'id': 2, 'content': '你说得对', 'parent_id': None},
            {'id': 3, 'content': '顶楼上', 'parent_id': None},
            {'id': 4, 'content': '你眼瞎吗', 'parent_id': 1},
            {'id': 5, 'content': '我看是', 'parent_id': 4},
            {'id': 6, 'content': '鸡毛', 'parent_id': 2},
            {'id': 7, 'content': '你是没呀', 'parent_id': 5},
            {'id': 8, 'content': '惺惺惜惺惺想寻', 'parent_id': 3},
]
```

其实我们想要的功能就是把对应的评论的子评论附加到父级评论中去，因此要我们自己去定义一个数据结构。

```
# 带child的msg_list，注意列表生成式中不能写表达式，比如row['child'] = []是不行的
# v = [row.setdefault('child', []) for row in msg_list]
# print(msg_list)
msg_list_dict = {}

for item in msg_list:
    item['child'] = []
    msg_list_dict[item['id']] = item


result = []
for item in msg_list:
    if item['parent_id']:
        msg_list_dict[pid]['child'].append(item)
    else:
        result.append(item)
# 评论层数为两层   
###################################
"""
<div class='comment'>
	<div class='content'>asdasd</div>
	<div class='content'>asdasd</div>
	<div class='content'>asdasd</div>
	<div class='content'>asdasd</div>
</div>
"""
comment_str = """"""
comment_str += "<div class='comment'>"
for row in result:
    tpl = "<div class='content'>%s</div>" % (row['content'])
    if row['child']:
        comment_str += "<div class='comment'>"
        for jow in row['child']:
            tpl = "<div class='content'>%s</div>" % (jow['content'])
            comment_str += tpl
        comment_str += "</div>"
    comment_str += tpl
comment_str += "</div>"
# 把这个内容传递到前台


# 
```





为什么字典取值快？

msg_list是数据源，msg_list_dict用户查找。



![](http://omk1n04i8.bkt.clouddn.com/18-3-7/48996755.jpg)

记得前端的代码要加上`|safe`才行。因此在用户发布文章的时候要做特殊的过滤。避免用户发布有害的内容。

文章点赞：

```html
<a onclick="up(this, {{ obj.nid }}, 0)">
  <span>👍</span>
  <i>{{ obj.up_count }}</i>
</a>

<a>
  <span>踩</span>
  <i>{{ obj.down_count }}</i>
</a>


<script>
  function up(ths, nid){
    $.ajax({
      url:'/up.html',
      data:{'val':1,'nid':nid,'csrfmiddlewaretoken':{{ csrf_token }}},
      type:"POST",
      dataType:'JSON',
      success:function(arg){
      	if(arg.status){
        	// 显示赞的个数+1
        }else{
            // 显示错误信息
        }
      }
    })
  }

function down(ths, nid){
    $.ajax({
      url:'/up.html',
      data:{'val':0,'nid':nid,'csrfmiddlewaretoken':{{ csrf_token }}},
      type:"POST",
      dataType:'JSON',
      success:function(arg){
      	if(arg.status){
        	// 显示踩的个数+1
        }else{
            // 显示错误信息
        }
      }
    })
  }
  
function updown(ths, nid, val){
    $.ajax({
      url:'/up.html',
      data:{'val':val,'nid':nid,'csrfmiddlewaretoken':{{ csrf_token }}},
      type:"POST",
      dataType:'JSON',
      success:function(arg){
      	if(arg.status == xxxx){
        	// 给前段返回特殊的状态码
        }else{
            // 显示错误信息
        }
      }
    })
  }
</script>


是哪个用户，文章踩或者赞
是谁，当前登录用户
1是赞，0是踩。


```

python

```python
def up(request):
    userid = request.session.get('user_id')
    article_id = request.POST.get('nid')
    val = request.POST.get('val')

    # 仍然会存在报错，用于捕获报错
    try:
        # 这个是针对某一个用户的点赞记录，如果有点赞记录的话就可以去到一个对象
        obj = models.UpDown.objects.filter(user_id=userid, article_id=article_id).first()
        if obj:
            pass
        else:
            # 取不到对象就可以进行添加
            if val == "0":
                # 引入事物，所谓事物就是一个整体，将下面两个操作作为原子性的操作，要成功就两个一起成功，要不成功就都不成功
                # 第一个操作是，在点赞表里添加点赞记录，第二个是在文章表里添加点赞技术，二者相辅相成，要成功就都成功。
                # 事物的作用就是对下面两个操作做限制，如果有其中一个失败，那么整个操作会回滚
                with transaction.atomic():
                    # 但是仍然要捕获异常
                    models.UpDown.objects.create(user_id=userid, article_id=article_id, up=True)
                    models.Article.objects.filter(nid=article_id).update(up_count=F('up_count') + 1)
            else:
                with transaction.atomic():
                    models.UpDown.objects.create(user_id=userid, article_id=article_id, up=False)
                    models.Article.objects.filter(nid=article_id).update(up_count=F('up_count') - 1)
    except Exception as e:
        pass
```

组合筛选





### kindEditor

> http://www.cnblogs.com/wupeiqi/articles/6307554.html

下载下来是一个zip的压缩包，解压后里面可以删除掉一些内容，比如asp、asp.net、jsp、php这些都是针对这些语言写的一些实例，在这里使用不到，可以直接干掉。



编辑器初始化参数说明：http://kindeditor.net/doc3.php?cmd=config

```
item：设置工具项，接收一个数组
noDisableItems：配合designMode要为false，可以指定某些显示的工具不让你使用
htmlTags：一个字典，限制这里只允许出现哪些标签，这些标签仅有哪些属性，但是这个功能很鸡肋。这个只是在选的时候做限制，但是当纯html代码的时候，仍然是可以提交到后端的。
```

上传图片：

针对提交内容的过滤。比如提交的内容有script标签

使用BeautifulSoap过滤违规标签：

```python
pip3 install BeautifulSoup4
```

BeautifulSoap4会把一个html文本转换成一个对象

www.cnblogs.com/wupeiqi/article/6283017.html



## 使用JS实现一个多级评论



## 用户的权限管理

关于用户权限的管理，我们可以根据不同的角色去设计。比如常见的discuz论坛，或者其他的论坛，内部包括游客，普通用户，管理员，审核员，超级管理员等等。经过定制化的论坛还会出现诸如VIP等角色，其实说白了就是不同的角色对应到了不同的权限。为了保证权限的管理可以被延用，因此可以独立去开辟一个app去管理这一部分。

```python
python manage.py startapp app02
```

用户与角色进行对应，一个用户可以对应多个角色，一个角色也可以被多个用户所对应，那么这其实是一个多对多的关系，因此需要一个中间表将这两个关联起来。

![用户角色关系示例](http://omk1n04i8.bkt.clouddn.com/18-3-13/56728684.jpg)



用户角色对应起来了以后，不同的角色对应的也就是不同的权限。











根据url划分权限，所以应该要搞上一个表，保存所有的url地址，用户和权限url是一个多对多的关系。给用户的功能就搞一个url，然后通过给url传的参数不一致区分不同的功能

```html
/users.html
/users.html?md=get
/users.html?md=post
/users.html?md=edit
/users.html?md=del
```

![](http://omk1n04i8.bkt.clouddn.com/18-3-12/33596170.jpg)

一般搞权限不会定位到人，而是定位一个角色，通过角色去控制一个人应该有什么权限。

easyUi_Tree

![](http://omk1n04i8.bkt.clouddn.com/18-3-12/44631724.jpg)



### 用户权限菜单处理

处理用户的菜单权限，要获取到用户的用户名或者用户的id，这个是要传递过来的数据。

```python
# 首先获取到所有的菜单，只取id，caption，parent_id字段
all_menu_list = models.Menu.objects.all().values('id', 'caption', 'parent_id')

# 这个数据获取到的内容应该是一个列表（QuerySet）套字典。格式大概如下所示：
[
    {'id': 1, 'caption': '1.0', 'parent_id': None}
	{'id': 2, 'caption': '2.0', 'parent_id': None}
	{'id': 3, 'caption': '3.0', 'parent_id': None}
	{'id': 4, 'caption': '1.1', 'parent_id': 1}
	{'id': 5, 'caption': '2.1', 'parent_id': 2}
	{'id': 6, 'caption': '3.1', 'parent_id': 3}
	{'id': 7, 'caption': '1.1.1', 'parent_id': 4}
	{'id': 8, 'caption': '1.1.1.1', 'parent_id': 7}
	{'id': 9, 'caption': '1.1.2', 'parent_id': 4}
	{'id': 10, 'caption': '2.1.1', 'parent_id': 5}
	{'id': 11, 'caption': '2.1.2', 'parent_id': 5}
	{'id': 12, 'caption': '3.1.1', 'parent_id': 6}
	{'id': 13, 'caption': '3.1.2', 'parent_id': 6}
]
```

首先获取用户对象，这个对象应该是从访问连接传递过来的，现在先可以临时写死代替，最后再调整：

```python
# 根据传递过来的username拿到用户对象
user = models.User.objects.filter(username='mxy').first()
# 根据用户对象可以拿到用户的角色对象列表，用户不一定只有一个角色
role_list = models.Role.objects.filter(users__user=user)
# 通过角色列表，就可以知道这个用户实际可以操作的权限到底有哪些了
# 这里取到的有权限表中数据项的id，url，已经关联菜单的id，权限名称。
# 因为不同的角色可能有复合的权限，因此使用distinct去重，当然也可以使用annotate去重
# distinct就是没有多加那一列，但是性能要略低于annotate
permission_list = models.Permission2Action2Role.objects.filter(role__in=role_list).values(
    'permission__id',                                                                                    	 'permission__url',                                                                                           	  'permission__menu_id',                                                                                                 	 'permission__caption').distinct()           

# 取到的permission_list也是一个列表套字典，如下的一个形式。

[
    {
        'permission__id': 4, 
        'permission__url': '/create-group-(\\d+).html', 
        'permission__menu_id': 10, 
        'permission__caption': '组织创建'
    }
	{
        'permission__id': 1, 
        'permission__url': '/edit.html', 
        'permission__menu_id': 7, 
        'permission__caption': '文章编辑'
    }
	{
        'permission__id': 2, 
        'permission__url': '/edit-cat.html', 
        'permission__menu_id': 8, 
        'permission__caption': '分类编辑'
    }
	{
        'permission__id': 3, 
        'permission__url': '/create-cat.html', 
        'permission__menu_id': 9, 
        'permission__caption': '分类创建'
    }
]
```

现在权限都拿到了就应该把权限挂到对应的菜单上了。首先把菜单处理成父子形式的关系。

```python
# 定义一个menu_dict空字典
all_menu_dict = {}

# 为每一个菜单项添加一个child子选项，假如说菜单有子菜单的话可以挂在里面
# 定一个status的key，表示是否显示菜单，默认为False
# 定义opened的key，表示默认是否打开，默认为False
# 最后通过循环遍历把每一个菜单加到all_menu_dict这个字典里去。key为id，value为字典
for row in all_menu_list:
    row['child'] = []  
    row['status'] = False  
    row['opened'] = False  
    all_menu_dict[row['id']] = row

# 关联权限和对应的菜单
for per in permission_list:
	# 不在菜单上显示的权限，比如是否允许用户上传图片，上传文件等。这个是不需要挂靠到菜单的。
    if not per['permission__menu_id']:
        continue

    item = {
        'id': per['permission__id'],
        'caption': per['permission__caption'],
        'parent_id': per['permission__menu_id'],
        'url': per['permission__url'],
        # 是否显示菜单，如果这个用户对应的权限有这个菜单的话，那么这个菜单应该显示出来
        # 只有当前URL和用户请求的URL匹配上了才会变成True，所以默认False
        # 然后根据URL的正则去判断是否为True。
        'status': True,
        'opened': False
    }
    # 当用户访问过来的请求满足这个正则url的时候，才是允许打开的。
    if re.match(per['permission__url'],request.path_info):
        item['opened'] = True
    # 获取权限所属的父级菜单的id。
    pid = item['parent_id']
    # 操作完了所有的菜单都挂靠完毕了
    all_menu_dict[pid]['child'].append(item)
    
    # 将当前权限前辈status=True
    temp = pid  # 1.父亲ID
    # 当父级id=None的时候那么就证明找到头了。
    # 而且如果当前父级菜单的status为true的时候就不需要继续循环了，证明已经改过了
    while not all_menu_dict[temp]['status']:
        all_menu_dict[temp]['status'] = True
        temp = all_menu_dict[temp]['parent_id']
        if not temp:
            break

    # 将当前权限前辈opened=True
    if item['opened']:
        temp1 = pid  # 1.父亲ID
        while not all_menu_dict[temp1]['opened']:
            all_menu_dict[temp1]['opened'] = True
            temp1 = all_menu_dict[temp1]['parent_id']
            if not temp1:
                break

# 到目前为止，权限就算是挂靠完毕了，处理过后的all_menu_dict是一个字典套字典的形式
# 内部的menu的id为key
```

接下来就要开始处理菜单于菜单之间的关系了，因为菜单之间也是有父子关系的。

```python
result = []
for row in all_menu_list:
    pid = row['parent_id']
    if pid:
        all_menu_dict[pid]['child'].append(row)
    else:
        result.append(row)
```







### RBAC

> Role Basic Access Control基于角色的用户访问的控制。

改变Django Admin的密码：

```python
运行：python manage.py shell


>>> from django.contrib.auth.models import User

>>> u = User.objects.get(username__exact='john')
>>> u.set_password('new password')
>>> u.save()
```



