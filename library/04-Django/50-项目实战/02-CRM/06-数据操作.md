# 数据操作

## 数据的添加

### 添加按钮

接下来要开始进行数据操作了，首先在调用inclusion_tag的地方加一个a标签，用于添加数据。那么编辑也好，添加也好，都是需要一个跳转链接的，其实操作方式都很多元化，可以是弹出一个模态框，或者是直接跳转到一个新的页面，这里采用跳转到一个新的页面，但是跳转链接怎么拿到呢？这里采用通过后端统一返回的形式。

```html
<div class="container">
    <h1>数据列表</h1>
    <a href='{{ add_url }}' style="float: right;" class="btn btn-default">添加</a>

    <!--数据表格 开始-->
    {% func result_list list_display lamberadmin_obj %}
    <!--数据表格结束-->
</div>
```

当访问某一个模型类的数据的时候，肯定会走通用的changelist_view这个视图方法，我们就在这里返回。

```python
def changelist_view(self, request):
    # 生成页面上的添加按钮
    add_url = reverse("{0}:{1}_{2}_add".format(self.site.namespace, self.app_label, self.model_name))
   
    context = {
        'result_list': result_list,
        'list_display': self.list_display,
        'lamberadmin_obj': self,
        'add_url': add_url,
    }
    return render(request, 'checklist_view.html', context)
```

不过这样和编辑存在同样的问题，就是你添加完了以后跳转会哪里？和编辑一样，首先要能跳转回来，而且你从100页跳转过来的，你添加完了以后也要跳转回去。操作也基本和编辑的时候去拼接一个url是大同小异的。

```python
from django.http.request import QueryDict
def changelist_view(self, request):
    param_dict = QueryDict(mutable=True)
    add_url = reverse("{0}:{1}_{2}_add".format(self.site.namespace, self.app_label, self.model_name))
    if request.GET:
        # 判断一下有没有携带参数，如果带了参数再拼接，没带的话就不要拼接了。
        # 这个特殊封装可以简单看到，比如%3D就是等于号。
        # 结果_changelistfilter=page%3D10%26id%3D666
        param_dict['_changelistfilter'] = request.GET.urlencode()
        add_url = add_url + '?' + param_dict.urlencode()
```

### 基于ModelForm添加数据

点击添加按钮，那么就会进入到我们的BaseLamberAdmin的add_view视图中，应该存在一个添加页面的，但是每一个类字段不一样，属性不同，该如何显示不同的类的字段呢？

这里使用ModelForm的方案去实现，自动为我们生成对应的html表格。

**ModelForm由谁来创建？**

我们知道ModelForm中的内容是可以自定制的，比如，label，error_message，widgets等等。所以这个内容肯定不能写死了，而是应该像展示数据的时候展示列一样，当我不写的时候走默认的`list_display=__all__`，用户还可以自己定制展示的列。这里也是同理的，允许用户自己定制ModelForm，但是如果用户不定制的话就用程序原本默认的ModelForm。

```python
from django.forms import ModelForm
class BaseLamberAdmin(object):
    # 添加一个属性，用于表示模型类，默认为None，表示用程序内部的ModelForm，如果用户想自定制，对这个属性进行重写就可以了。
    add_or_edit_model_form = None
    
    def get_add_or_edit_model_form(self):
        if self.add_or_edit_model_form:
            # 如果自定制了，那么就优先返回用户的。
            return self.add_or_edit_model_form
        else:
            """
            否则返回系统内部的定制的默认modelform组件，这里使用type来创建
            第一个参数是类名，第二个是一个元组，表示继承自哪些类，第三个就是类的一些参数。
            先创建内层的Meta，然后再创建外层的MyModelForm
            常规创建方式参考：
            class MyModelForm(ModelForm):
                class Meta:
                    model = self.model_class
                    fields = '__all__'
            """
            _m = type('Meta', (object, ), {'model': self.model_class, 'fields': '__all__'})
            MyModelForm = type('MyModelForm', (ModelForm, ), {'Meta': _m})
            return MyModelForm
```

add_view

```python
# BaseLamberAdmin中的add_view方法。
def add_view(self, request):
    # GET请求展示数据
    if request.method == 'GET':
        model_form_obj = self.get_add_or_edit_model_form()()
    else:
        model_form_obj = self.get_add_or_edit_model_form()(data=request.POST, files=request.FILES)
        if model_form_obj.is_valid():
            model_form_obj.save()
            # 添加成功了以后要进行跳转
            base_list_url = reverse('{0}:{1}_{2}_changelist'.format(self.site.namespace, self.app_label, self.model_name))
            # 有参数我才给你拼接，没有参数的话不需要拼接，否则会拼一个None过去。
           if request.GET.get('_changelistfilter'):
               base_list_url = "{0}?{1}".format(base_list_url, request.GET.get('_changelistfilter'))
           return redirect(base_list_url)
    context = {
        'form': model_form_obj
    }

    return render(request, 'add.html', context )
```

add.html

```html
<!--action可以不写，默认就是往当前页面提交。-->
<form action="" method="post" novalidate>
    {% csrf_token %}
    {{ form.as_p }}
    <input type="submit" value="提交">
</form>
```



## 数据的编辑

在数据展示的时候，我们的连接其实已经拼接好了，如果带参数的话，也会给编辑的href跳转链接拼接上我们自定一的参数（_changelistfilter）；

当点击编辑页面的时候，会跳转到编辑页面。



