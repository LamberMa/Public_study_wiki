# 处理用户请求

## 数据展示

从展示页面change_list_view开始，比如现在用户想要访问的是app01下的userinfo，那么此时应该展示所有的userinfo的model class的信息。那么首先从取数据开始。

取数据要拿到对应的模型类，在之前注册的时候还记得_registry中存的是什么么？key为对应的模型类，而value是对应的BaseLamberAdmin的对象，在构造函数`__init__`我们传递了两个参数，一个是model class，第二个则是LamberAdmin的对象。因此我们可以通过构造函数中的model_class直接拿过来就可以了。

```python
# BaseLamberAdmin的changelist_view方法
def changelist_view(self, request):
    result_list = self.model_class.objects.all()
    context = {
        'result_list': result_list,
    }
    return render(request, 'checklist_view.html', context)
```

### 通用性问题

现在对应的数据我们已经拿到了，我们可以通过在前端页面去遍历result_list，然后输出每一条记录的对应字段，但是之前讲到的，我们这里的CURD是一个统一的方法，也就是说不管是你哪个模型类注册进来了，在访问changelist_view的时候我都要把字段给你展示出来，那么这就有问题了，我怎么知道应该展示哪个字段？用的模板也是一套，在前端界面这个是不能写死的，比如前端循环的每一条记录是item，我不能写成`{{ item.name }}`或者其他的，因为我不知道这个模型类里有没有name字段，因此我们这里就要对BaseLamberAdmin进行进一步扩展。

```python
# 定制一个BaseLamberAdmin，给它里面添加一个字段，list_display，默认是__all__也就是显示所有
class BaseLamberAdmin(object):
    # 定制可以展示的类，默认是__all__，在它的子类中继承它就可以进行个别列的扩展了。
    list_display = '__all__'
    
    def changelist_view(self, request):
    	result_list = self.model_class.objects.all()
    	context = {
        	'result_list': result_list,
            # 要展示的字段数据一起扔给前端
            'list_display': self.list_display,
            'lamberadmin_obj': self,
    	}
    	return render(request, 'checklist_view.html', context)
```

我可以新加一个字段list_display，通过这个我们就可以指定要显示的字段了。还记得我们的类是怎么注册的么？

```python
v1.site.register(models.UserInfo)
```

这种注册的时候我们的register方法默认为我们填写了一个xxx=BaseLamberAdmin的类，如果我们自己写呢？这样我们就可以实现我们自己的功能了。

```python
v1.site.register(models.UserInfo, LamberUserInfo)
```

同时这个LamberUserInfo继承BaseLamberAdmin，这样就达成了一个我们自定制有的，走我们的，没有的走BaseLamberAdmin默认的；这样我们就可以通过循环self.list_display来得知该显示什么字段了，不指定当然也是ok的，会去寻找父类BaseLamberAdmin的list_display。默认为`__all__`。为`__all__`的时候，就让它不显示具体字段而是把这一条数据对象打印出来，如果指定了具体要显示的字段的话那么就显示具体的字段就可以了。

```python
"""
这里按照admin的逻辑来讲，这里其实我就应该传入几个内容，要注册的类或者类的列表，admin源码中这里可以传入一个类或者一个可迭代对象;然后后面其实还有一个内容就是admin_class，在django的admin中，admin_class我们没传递，默认为None;在register的逻辑中，如果admin_class默认为None的话，那么admin_class就是ModelAdmin，
"""
class LamberUserInfo(v1.BaseLamberAdmin):

    # 如果我继承了，但是我什么也不做的话其实还是和原来的是一样的，现在继承了，只不过我新加了内容而已
    list_display = ['id', 'username', 'email']
```

### 额外字段的问题

最后的想法是要展示出来一个表格，有表头，数据体。不过这个表可能存在一些扩展字段，比如有一列选项，或者最后有一列操作，允许我们编辑啊，或者删除啊，等等操作，这些内容其实并不是我们的字段数据，在实际的表数据中也不存在这个字段，这个时候我们就可以继续扩展list_display的内容。

![](http://tuku.dcgamer.top/18-10-17/37634909.jpg)

在上面的扩展中，list_display我们填入的只是字符串形式的字段名，当然这里还可以填写方法名，

```python
from django.utils.safestring import mark_safe
class LamberUserInfo(v1.BaseLamberAdmin):
    
    def checkbox(self, obj=None, is_header=None):
            return mark_safe('<input name="pk" type="checkbox" value="{0}">'.format(obj.pk))

    list_display = [checkbox, 'id', 'username', 'email',]
```

这个方法return一个我们想要显示的内容就可以了。

### 数据展示问题

操作上来讲，如果可以拿到list_display那么就可以去遍历操作，通过反射去获取对应的每一个实例item中的对应字段。但是这个遍历的操作不能使用前端的模板语言去获取，因为默认的模版语言所能支持的操作是有限的，因此现在可以考虑使用inclusion_tag去实现。在lamber的app中创建一个目录为templatetags，在里面创建一个lamber_list.py用来展示视图逻辑，展示过程中涉及到如下几个问题：

- 如何展示字段的中文？

  ```
  关于展示中文的问题，我们在list_display中填写的一般都是字段名称，比如，id，name什么的，那么如何把这些字段名称和对应的中文名称结合起来显示在表头上呢？
  1、通过前端传递一个BaseLamberAdmin的对象，取到其中封装的models模型类
  2、我们在models定义的时候一般会给每个字段加上verbose_name用以标识字段的意义，值为中文。
  3、model class的每一个字段其实都是一个实例，verbose_name本身也是一个属性，那么它就可以取到。
  4、使用模型类._meta中的get_fields可以拿到对应的字段实例，调用实例的verbose_name方法即可取到。
     model_class._meta.get_fields('username').verbose_name
  5、使用getattr可以同样达到这样的效果。
  ```

- 如何过滤掉list_display中的function

  ```
  因为list_display中并不是每一个字段都是数据字段，也有我们自定义显示的内容，因此循环遍历的时候我们要判断一下循环的每一个item的类型，判断是否是方法，只要判断这个item是不是FunctionType的实例就可以了。
  for item in list_display:
      if isinstance(item, FunctionType):
          print('This is a function')
          header_list.append(item(lamberadmin_obj, is_header=True) )
      else:
          pass
  ```

- 如何展示方法列的中文表头？

  ```
  
  ```


```python
# lamber/templatetags/lamber_list.py
from django.template import Library

# 只能叫register
register = Library()

def table_header(list_display, lamberadmin_obj):
    header_list = []
    for item in list_display:
        if isinstance(item, FunctionType):
            # 可以通过__doc__函数的注释
            # 或者在函数中加一个选项，根据is_header的布尔值返回不同的内容就可以了。
            header_list.append(item(lamberadmin_obj, is_header=True) )
            # header_list.append(item.__name__.title())
        else:
header_list.append(lamberadmin_obj.models_class._meta.get_fields(item).verbose_name)
            
def table_body(result_list, list_display, lamberadmin_obj):
    # 针对上面的内容做修改，使用yield不是所有的一起全部都搜索出来；也就是默认不循环，调用的时候才拿一个
    for item in result_list:
        sub = []
        for name in list_display:
            val = getattr(item, name)
            sub.append(val)
            yield sub

# 这里注意inclusion_tag的逻辑，这个func中的返回值是给inclusion_tag中指定的模板md.html使用的。
# 最后会把经过渲染完成后的md.html的内容拿过来直接扔到调用这个inclusion_tag的模板的位置。
# 最终我们是要生成一个表格，表格分为表头和表体，这两个部分需要单独的去遍历抽取。
@register.inclusion_tag('md.html')
def func(result_list, list_display, lamberadmin_obj):
    # 把table body拿到
    v = table_body(result_list, list_display, lamberadmin_obj)
    # 拿到table head表头数据
    h = table_header(list_display, lamberadmin_obj)
    return {'xxxxx': v, 'header_list': h}
```





比如我们这里让inclusion_tag的逻辑函数名称为func，注意在使用的时候先load一下，然后把我们需要到的参数传递进去，至于为什么需要这几个参数这里就不赘述了；