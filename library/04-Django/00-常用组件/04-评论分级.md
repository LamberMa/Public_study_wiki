# 评论分级

先实现一种在后端进行分级过后传递给前端的方式

```python
# 我们不动态去，现在模拟一个假的数据
msg_list = [
    {'id': 1, 'content': '写的太好了', 'parent_id': None},
    {'id': 2, 'content': '你说得对', 'parent_id': None},
    {'id': 3, 'content': '顶楼上', 'parent_id': None},
    {'id': 4, 'content': '你眼瞎吗', 'parent_id': 1},
    {'id': 5, 'content': '我看是', 'parent_id': 4},
    {'id': 6, 'content': '鸡毛', 'parent_id': 2},
    {'id': 7, 'content': '你是没呀', 'parent_id': 5},
    {'id': 8, 'content': '惺惺惜惺惺想寻', 'parent_id': 3},
]

# 定义一个空字典，用来构造新的一个数据结构
msg_list_dict = {}

# 遍历评论列表，给每一个item加一个key，为child，value为一个空列表
# 这个child的目的是什么，其实是为了把所有的子评论放到child里
# child的每一个子元素其实都是一个单独的评论的dict
for item in msg_list:
    # [item.setdefault('child', []) for item in msg_list]
    item['child'] = []
    # 让评论的id作为key，item作为value，构造这样的一个形式（哈希）的话是很方便查找的。
    msg_list_dict[item['id']] = item
    
# #### msg_list_dict用于查找
result = []
for item in msg_list:
    # 开始完善我们的msg_list_dict，首先获取父级id
    pid = item['parent_id']
    # 如果父级id存在，那么证明当前这一条就不是顶级
    if pid:
        # 不是顶级的话就把这一条添加到它的上一级的item中的child的列表里。
        msg_list_dict[pid]['child'].append(item)
    else:
        # 如果pid为None，那么证明这个就是顶级评论，直接把顶级评论添加到result里面来。
        result.append(item)
        
# 那么最后我拿到的这个result就是所有的顶级评论。顶级评论中的child字段中有所有的子评论，子评论里面可能还套着子评论，这样一个有层级关系的内容我们就已经搞完了。接下来就是写一个函数来处理这个内容
def comment_tree(comment_list):
    """
    当然这里是使用后台来实现的，不过建议的方法是扔到前端去用JS去做。
    可以等页面加载完成以后重新发一次ajax请求去获取
    :param result: 处理好层级关系的列表
    :return:
    """
    comment_str = "<div class='comment'>"
    for row in comment_list:
        # 定义一个评论的html模板，每一个评论就是一个div，class为content
        tpl = "<div class='content'>%s</div>" % (row['content'])
        comment_str += tpl
        if row['child']:
            # 如果这个评论有自评论的话，子评论的html模板内容就可以进行递归调用获取。
            child_str = comment_tree(row['child'])
            comment_str += child_str
    comment_str += "</div>"

    return comment_str
```

最后返回的这个comment_str就是最后拼接成功的一个完整的html格式的字符串。